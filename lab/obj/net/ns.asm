
obj/net/ns:     file format elf32-i386


Disassembly of section .text:

00800020 <_start>:
// starts us running when we are initially loaded into a new environment.
.text
.globl _start
_start:
	// See if we were started with arguments on the stack
	cmpl $USTACKTOP, %esp
  800020:	81 fc 00 e0 bf ee    	cmp    $0xeebfe000,%esp
	jne args_exist
  800026:	75 04                	jne    80002c <args_exist>

	// If not, push dummy argc/argv arguments.
	// This happens when we are loaded by the kernel,
	// because the kernel does not know about passing arguments.
	pushl $0
  800028:	6a 00                	push   $0x0
	pushl $0
  80002a:	6a 00                	push   $0x0

0080002c <args_exist>:

args_exist:
	call libmain
  80002c:	e8 c2 e5 00 00       	call   80e5f3 <libmain>
1:	jmp 1b
  800031:	eb fe                	jmp    800031 <args_exist+0x5>

00800033 <tcpip_init_done>:
		panic("cannot create timer thread: %s", e2s(r));
}

static void
tcpip_init_done(void *arg)
{
  800033:	55                   	push   %ebp
  800034:	89 e5                	mov    %esp,%ebp
  800036:	83 ec 14             	sub    $0x14,%esp
  800039:	8b 45 08             	mov    0x8(%ebp),%eax
	uint32_t *done = arg;
	*done = 1;
  80003c:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	thread_wakeup(done);
  800042:	50                   	push   %eax
  800043:	e8 02 a6 00 00       	call   80a64a <thread_wakeup>
}
  800048:	83 c4 10             	add    $0x10,%esp
  80004b:	c9                   	leave  
  80004c:	c3                   	ret    

0080004d <start_timer>:
{
  80004d:	55                   	push   %ebp
  80004e:	89 e5                	mov    %esp,%ebp
  800050:	53                   	push   %ebx
  800051:	83 ec 04             	sub    $0x4,%esp
	t->msec = msec;
  800054:	8b 5d 08             	mov    0x8(%ebp),%ebx
  800057:	89 18                	mov    %ebx,(%eax)
	t->func = func;
  800059:	89 50 04             	mov    %edx,0x4(%eax)
	t->name = name;
  80005c:	89 48 08             	mov    %ecx,0x8(%eax)
	int r = thread_create(0, name, &net_timer, (uint32_t)t);
  80005f:	50                   	push   %eax
  800060:	68 94 00 80 00       	push   $0x800094
  800065:	51                   	push   %ecx
  800066:	6a 00                	push   $0x0
  800068:	e8 4b a6 00 00       	call   80a6b8 <thread_create>
	if (r < 0)
  80006d:	83 c4 10             	add    $0x10,%esp
  800070:	85 c0                	test   %eax,%eax
  800072:	78 05                	js     800079 <start_timer+0x2c>
}
  800074:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  800077:	c9                   	leave  
  800078:	c3                   	ret    
		panic("cannot create timer thread: %s", e2s(r));
  800079:	83 ec 0c             	sub    $0xc,%esp
  80007c:	50                   	push   %eax
  80007d:	e8 67 a9 00 00       	call   80a9e9 <e2s>
  800082:	50                   	push   %eax
  800083:	68 00 0f 81 00       	push   $0x810f00
  800088:	6a 7a                	push   $0x7a
  80008a:	68 35 10 81 00       	push   $0x811035
  80008f:	e8 bf e5 00 00       	call   80e653 <_panic>

00800094 <net_timer>:
{
  800094:	55                   	push   %ebp
  800095:	89 e5                	mov    %esp,%ebp
  800097:	56                   	push   %esi
  800098:	53                   	push   %ebx
	struct timer_thread *t = (struct timer_thread *) arg;
  800099:	8b 75 08             	mov    0x8(%ebp),%esi
		uint32_t cur = sys_time_msec();
  80009c:	e8 14 f3 00 00       	call   80f3b5 <sys_time_msec>
  8000a1:	89 c3                	mov    %eax,%ebx
		lwip_core_lock();
  8000a3:	e8 69 a5 00 00       	call   80a611 <lwip_core_lock>
		t->func();
  8000a8:	ff 56 04             	call   *0x4(%esi)
		lwip_core_unlock();
  8000ab:	e8 66 a5 00 00       	call   80a616 <lwip_core_unlock>
		thread_wait(0, 0, cur + t->msec);
  8000b0:	83 ec 04             	sub    $0x4,%esp
  8000b3:	03 1e                	add    (%esi),%ebx
  8000b5:	53                   	push   %ebx
  8000b6:	6a 00                	push   $0x0
  8000b8:	6a 00                	push   $0x0
  8000ba:	e8 a5 a7 00 00       	call   80a864 <thread_wait>
  8000bf:	83 c4 10             	add    $0x10,%esp
  8000c2:	eb d8                	jmp    80009c <net_timer+0x8>

008000c4 <serve_thread>:
	uint32_t whom;
	union Nsipc *req;
};

static void
serve_thread(uint32_t a) {
  8000c4:	55                   	push   %ebp
  8000c5:	89 e5                	mov    %esp,%ebp
  8000c7:	57                   	push   %edi
  8000c8:	56                   	push   %esi
  8000c9:	53                   	push   %ebx
  8000ca:	83 ec 7c             	sub    $0x7c,%esp
  8000cd:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct st_args *args = (struct st_args *)a;
	union Nsipc *req = args->req;
  8000d0:	8b 73 08             	mov    0x8(%ebx),%esi
	int r;

	switch (args->reqno) {
  8000d3:	83 3b 0a             	cmpl   $0xa,(%ebx)
  8000d6:	0f 87 5e 01 00 00    	ja     80023a <serve_thread+0x176>
  8000dc:	8b 03                	mov    (%ebx),%eax
  8000de:	ff 24 85 e0 10 81 00 	jmp    *0x8110e0(,%eax,4)
	case NSREQ_ACCEPT:
	{
		struct Nsret_accept ret;
		ret.ret_addrlen = req->accept.req_addrlen;
  8000e5:	8b 46 04             	mov    0x4(%esi),%eax
  8000e8:	89 45 94             	mov    %eax,-0x6c(%ebp)
		r = lwip_accept(req->accept.req_s, &ret.ret_addr,
  8000eb:	83 ec 04             	sub    $0x4,%esp
  8000ee:	8d 45 94             	lea    -0x6c(%ebp),%eax
  8000f1:	50                   	push   %eax
  8000f2:	8d 45 84             	lea    -0x7c(%ebp),%eax
  8000f5:	50                   	push   %eax
  8000f6:	ff 36                	pushl  (%esi)
  8000f8:	e8 20 0d 00 00       	call   800e1d <lwip_accept>
  8000fd:	89 c7                	mov    %eax,%edi
				&ret.ret_addrlen);
		memmove(req, &ret, sizeof ret);
  8000ff:	83 c4 0c             	add    $0xc,%esp
  800102:	6a 14                	push   $0x14
  800104:	8d 45 84             	lea    -0x7c(%ebp),%eax
  800107:	50                   	push   %eax
  800108:	56                   	push   %esi
  800109:	e8 4b ee 00 00       	call   80ef59 <memmove>
  80010e:	83 c4 10             	add    $0x10,%esp
		cprintf("Invalid request code %d from %08x\n", args->whom, args->req);
		r = -E_INVAL;
		break;
	}

	if (r == -1) {
  800111:	83 ff ff             	cmp    $0xffffffff,%edi
  800114:	0f 84 3e 01 00 00    	je     800258 <serve_thread+0x194>
		char buf[100];
		snprintf(buf, sizeof buf, "ns req type %d", args->reqno);
		perror(buf);
	}

	if (args->reqno != NSREQ_INPUT)
  80011a:	83 3b 0a             	cmpl   $0xa,(%ebx)
  80011d:	74 10                	je     80012f <serve_thread+0x6b>
		ipc_send(args->whom, r, 0, 0);
  80011f:	6a 00                	push   $0x0
  800121:	6a 00                	push   $0x0
  800123:	57                   	push   %edi
  800124:	ff 73 04             	pushl  0x4(%ebx)
  800127:	e8 3d f6 00 00       	call   80f769 <ipc_send>
  80012c:	83 c4 10             	add    $0x10,%esp

	put_buffer(args->req);
  80012f:	8b 53 08             	mov    0x8(%ebx),%edx
	int i = ((uint32_t)va - REQVA) / PGSIZE;
  800132:	8d 82 00 50 01 f0    	lea    -0xffeb000(%edx),%eax
  800138:	c1 e8 0c             	shr    $0xc,%eax
	buse[i] = 0;
  80013b:	c6 80 00 50 81 00 00 	movb   $0x0,0x815000(%eax)
	sys_page_unmap(0, (void*) args->req);
  800142:	83 ec 08             	sub    $0x8,%esp
  800145:	52                   	push   %edx
  800146:	6a 00                	push   $0x0
  800148:	e8 fc f0 00 00       	call   80f249 <sys_page_unmap>
	free(args);
  80014d:	89 1c 24             	mov    %ebx,(%esp)
  800150:	e8 88 06 01 00       	call   8107dd <free>
}
  800155:	83 c4 10             	add    $0x10,%esp
  800158:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80015b:	5b                   	pop    %ebx
  80015c:	5e                   	pop    %esi
  80015d:	5f                   	pop    %edi
  80015e:	5d                   	pop    %ebp
  80015f:	c3                   	ret    
		r = lwip_bind(req->bind.req_s, &req->bind.req_name,
  800160:	83 ec 04             	sub    $0x4,%esp
  800163:	ff 76 14             	pushl  0x14(%esi)
  800166:	8d 46 04             	lea    0x4(%esi),%eax
  800169:	50                   	push   %eax
  80016a:	ff 36                	pushl  (%esi)
  80016c:	e8 5e 0e 00 00       	call   800fcf <lwip_bind>
  800171:	89 c7                	mov    %eax,%edi
		break;
  800173:	83 c4 10             	add    $0x10,%esp
  800176:	eb 99                	jmp    800111 <serve_thread+0x4d>
		r = lwip_shutdown(req->shutdown.req_s, req->shutdown.req_how);
  800178:	83 ec 08             	sub    $0x8,%esp
  80017b:	ff 76 04             	pushl  0x4(%esi)
  80017e:	ff 36                	pushl  (%esi)
  800180:	e8 9d 19 00 00       	call   801b22 <lwip_shutdown>
  800185:	89 c7                	mov    %eax,%edi
		break;
  800187:	83 c4 10             	add    $0x10,%esp
  80018a:	eb 85                	jmp    800111 <serve_thread+0x4d>
		r = lwip_close(req->close.req_s);
  80018c:	83 ec 0c             	sub    $0xc,%esp
  80018f:	ff 36                	pushl  (%esi)
  800191:	e8 ef 0e 00 00       	call   801085 <lwip_close>
  800196:	89 c7                	mov    %eax,%edi
		break;
  800198:	83 c4 10             	add    $0x10,%esp
  80019b:	e9 71 ff ff ff       	jmp    800111 <serve_thread+0x4d>
		r = lwip_connect(req->connect.req_s, &req->connect.req_name,
  8001a0:	83 ec 04             	sub    $0x4,%esp
  8001a3:	ff 76 14             	pushl  0x14(%esi)
  8001a6:	8d 46 04             	lea    0x4(%esi),%eax
  8001a9:	50                   	push   %eax
  8001aa:	ff 36                	pushl  (%esi)
  8001ac:	e8 5d 0f 00 00       	call   80110e <lwip_connect>
  8001b1:	89 c7                	mov    %eax,%edi
		break;
  8001b3:	83 c4 10             	add    $0x10,%esp
  8001b6:	e9 56 ff ff ff       	jmp    800111 <serve_thread+0x4d>
		r = lwip_listen(req->listen.req_s, req->listen.req_backlog);
  8001bb:	83 ec 08             	sub    $0x8,%esp
  8001be:	ff 76 04             	pushl  0x4(%esi)
  8001c1:	ff 36                	pushl  (%esi)
  8001c3:	e8 fc 0f 00 00       	call   8011c4 <lwip_listen>
  8001c8:	89 c7                	mov    %eax,%edi
		break;
  8001ca:	83 c4 10             	add    $0x10,%esp
  8001cd:	e9 3f ff ff ff       	jmp    800111 <serve_thread+0x4d>
		r = lwip_recv(req->recv.req_s, req->recvRet.ret_buf,
  8001d2:	ff 76 08             	pushl  0x8(%esi)
  8001d5:	ff 76 04             	pushl  0x4(%esi)
  8001d8:	56                   	push   %esi
  8001d9:	ff 36                	pushl  (%esi)
  8001db:	e8 e0 12 00 00       	call   8014c0 <lwip_recv>
  8001e0:	89 c7                	mov    %eax,%edi
		break;
  8001e2:	83 c4 10             	add    $0x10,%esp
  8001e5:	e9 27 ff ff ff       	jmp    800111 <serve_thread+0x4d>
		r = lwip_send(req->send.req_s, &req->send.req_buf,
  8001ea:	ff 76 08             	pushl  0x8(%esi)
  8001ed:	ff 76 04             	pushl  0x4(%esi)
  8001f0:	8d 46 0c             	lea    0xc(%esi),%eax
  8001f3:	50                   	push   %eax
  8001f4:	ff 36                	pushl  (%esi)
  8001f6:	e8 57 14 00 00       	call   801652 <lwip_send>
  8001fb:	89 c7                	mov    %eax,%edi
		break;
  8001fd:	83 c4 10             	add    $0x10,%esp
  800200:	e9 0c ff ff ff       	jmp    800111 <serve_thread+0x4d>
		r = lwip_socket(req->socket.req_domain, req->socket.req_type,
  800205:	83 ec 04             	sub    $0x4,%esp
  800208:	ff 76 08             	pushl  0x8(%esi)
  80020b:	ff 76 04             	pushl  0x4(%esi)
  80020e:	ff 36                	pushl  (%esi)
  800210:	e8 ce 14 00 00       	call   8016e3 <lwip_socket>
  800215:	89 c7                	mov    %eax,%edi
		break;
  800217:	83 c4 10             	add    $0x10,%esp
  80021a:	e9 f2 fe ff ff       	jmp    800111 <serve_thread+0x4d>
		jif_input(&nif, (void *)&req->pkt);
  80021f:	83 ec 08             	sub    $0x8,%esp
  800222:	56                   	push   %esi
  800223:	68 00 b2 b3 00       	push   $0xb3b200
  800228:	e8 ab a8 00 00       	call   80aad8 <jif_input>
  80022d:	83 c4 10             	add    $0x10,%esp
		r = 0;
  800230:	bf 00 00 00 00       	mov    $0x0,%edi
  800235:	e9 e0 fe ff ff       	jmp    80011a <serve_thread+0x56>
		cprintf("Invalid request code %d from %08x\n", args->whom, args->req);
  80023a:	83 ec 04             	sub    $0x4,%esp
  80023d:	56                   	push   %esi
  80023e:	ff 73 04             	pushl  0x4(%ebx)
  800241:	68 20 0f 81 00       	push   $0x810f20
  800246:	e8 e3 e4 00 00       	call   80e72e <cprintf>
  80024b:	83 c4 10             	add    $0x10,%esp
		r = -E_INVAL;
  80024e:	bf fd ff ff ff       	mov    $0xfffffffd,%edi
  800253:	e9 c2 fe ff ff       	jmp    80011a <serve_thread+0x56>
		snprintf(buf, sizeof buf, "ns req type %d", args->reqno);
  800258:	ff 33                	pushl  (%ebx)
  80025a:	68 40 10 81 00       	push   $0x811040
  80025f:	6a 64                	push   $0x64
  800261:	8d 75 84             	lea    -0x7c(%ebp),%esi
  800264:	56                   	push   %esi
  800265:	e8 10 eb 00 00       	call   80ed7a <snprintf>
		perror(buf);
  80026a:	89 34 24             	mov    %esi,(%esp)
  80026d:	e8 53 a7 00 00       	call   80a9c5 <perror>
  800272:	83 c4 10             	add    $0x10,%esp
  800275:	e9 a0 fe ff ff       	jmp    80011a <serve_thread+0x56>

0080027a <serve_init>:
{
  80027a:	55                   	push   %ebp
  80027b:	89 e5                	mov    %esp,%ebp
  80027d:	56                   	push   %esi
  80027e:	53                   	push   %ebx
  80027f:	83 ec 10             	sub    $0x10,%esp
  800282:	8b 75 08             	mov    0x8(%ebp),%esi
	lwip_core_lock();
  800285:	e8 87 a3 00 00       	call   80a611 <lwip_core_lock>
	uint32_t done = 0;
  80028a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	tcpip_init(&tcpip_init_done, &done);
  800291:	83 ec 08             	sub    $0x8,%esp
  800294:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  800297:	53                   	push   %ebx
  800298:	68 33 00 80 00       	push   $0x800033
  80029d:	e8 06 21 00 00       	call   8023a8 <tcpip_init>
	lwip_core_unlock();
  8002a2:	e8 6f a3 00 00       	call   80a616 <lwip_core_unlock>
	thread_wait(&done, 0, (uint32_t)~0);
  8002a7:	83 c4 0c             	add    $0xc,%esp
  8002aa:	6a ff                	push   $0xffffffff
  8002ac:	6a 00                	push   $0x0
  8002ae:	53                   	push   %ebx
  8002af:	e8 b0 a5 00 00       	call   80a864 <thread_wait>
	lwip_core_lock();
  8002b4:	e8 58 a3 00 00       	call   80a611 <lwip_core_lock>
	ipaddr.addr  = init_addr;
  8002b9:	89 75 e8             	mov    %esi,-0x18(%ebp)
	netmask.addr = init_mask;
  8002bc:	8b 45 0c             	mov    0xc(%ebp),%eax
  8002bf:	89 45 ec             	mov    %eax,-0x14(%ebp)
	gateway.addr = init_gw;
  8002c2:	8b 45 10             	mov    0x10(%ebp),%eax
  8002c5:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (0 == netif_add(nif, &ipaddr, &netmask, &gateway,
  8002c8:	83 c4 0c             	add    $0xc,%esp
  8002cb:	68 da 65 80 00       	push   $0x8065da
  8002d0:	68 c6 ab 80 00       	push   $0x80abc6
  8002d5:	68 14 50 81 00       	push   $0x815014
  8002da:	8d 45 f0             	lea    -0x10(%ebp),%eax
  8002dd:	50                   	push   %eax
  8002de:	8d 45 ec             	lea    -0x14(%ebp),%eax
  8002e1:	50                   	push   %eax
  8002e2:	8d 45 e8             	lea    -0x18(%ebp),%eax
  8002e5:	50                   	push   %eax
  8002e6:	68 00 b2 b3 00       	push   $0xb3b200
  8002eb:	e8 72 43 00 00       	call   804662 <netif_add>
  8002f0:	83 c4 20             	add    $0x20,%esp
  8002f3:	85 c0                	test   %eax,%eax
  8002f5:	0f 84 cc 00 00 00    	je     8003c7 <serve_init+0x14d>
	netif_set_default(nif);
  8002fb:	83 ec 0c             	sub    $0xc,%esp
  8002fe:	68 00 b2 b3 00       	push   $0xb3b200
  800303:	e8 0c 44 00 00       	call   804714 <netif_set_default>
	netif_set_up(nif);
  800308:	c7 04 24 00 b2 b3 00 	movl   $0xb3b200,(%esp)
  80030f:	e8 0d 44 00 00       	call   804721 <netif_set_up>
	start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
  800314:	c7 04 24 88 13 00 00 	movl   $0x1388,(%esp)
  80031b:	b9 4f 10 81 00       	mov    $0x81104f,%ecx
  800320:	ba 91 95 80 00       	mov    $0x809591,%edx
  800325:	b8 34 50 81 00       	mov    $0x815034,%eax
  80032a:	e8 1e fd ff ff       	call   80004d <start_timer>
	start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
  80032f:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  800336:	b9 59 10 81 00       	mov    $0x811059,%ecx
  80033b:	ba 46 57 80 00       	mov    $0x805746,%edx
  800340:	b8 28 50 81 00       	mov    $0x815028,%eax
  800345:	e8 03 fd ff ff       	call   80004d <start_timer>
	start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);
  80034a:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  800351:	b9 65 10 81 00       	mov    $0x811065,%ecx
  800356:	ba 27 5d 80 00       	mov    $0x805d27,%edx
  80035b:	b8 1c 50 81 00       	mov    $0x81501c,%eax
  800360:	e8 e8 fc ff ff       	call   80004d <start_timer>
	cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  800365:	89 34 24             	mov    %esi,(%esp)
  800368:	e8 7f 73 00 00       	call   8076ec <inet_ntoa>
  80036d:	50                   	push   %eax
  80036e:	0f b6 05 2a b2 b3 00 	movzbl 0xb3b22a,%eax
  800375:	50                   	push   %eax
  800376:	0f b6 05 29 b2 b3 00 	movzbl 0xb3b229,%eax
  80037d:	50                   	push   %eax
  80037e:	0f b6 05 28 b2 b3 00 	movzbl 0xb3b228,%eax
  800385:	50                   	push   %eax
  800386:	0f b6 05 27 b2 b3 00 	movzbl 0xb3b227,%eax
  80038d:	50                   	push   %eax
  80038e:	0f b6 05 26 b2 b3 00 	movzbl 0xb3b226,%eax
  800395:	50                   	push   %eax
  800396:	0f b6 05 25 b2 b3 00 	movzbl 0xb3b225,%eax
  80039d:	50                   	push   %eax
  80039e:	68 64 0f 81 00       	push   $0x810f64
  8003a3:	e8 86 e3 00 00       	call   80e72e <cprintf>
	lwip_core_unlock();
  8003a8:	83 c4 30             	add    $0x30,%esp
  8003ab:	e8 66 a2 00 00       	call   80a616 <lwip_core_unlock>
	cprintf("NS: TCP/IP initialized.\n");
  8003b0:	83 ec 0c             	sub    $0xc,%esp
  8003b3:	68 71 10 81 00       	push   $0x811071
  8003b8:	e8 71 e3 00 00       	call   80e72e <cprintf>
}
  8003bd:	83 c4 10             	add    $0x10,%esp
  8003c0:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8003c3:	5b                   	pop    %ebx
  8003c4:	5e                   	pop    %esi
  8003c5:	5d                   	pop    %ebp
  8003c6:	c3                   	ret    
		panic("lwip_init: error in netif_add\n");
  8003c7:	83 ec 04             	sub    $0x4,%esp
  8003ca:	68 44 0f 81 00       	push   $0x810f44
  8003cf:	6a 5c                	push   $0x5c
  8003d1:	68 35 10 81 00       	push   $0x811035
  8003d6:	e8 78 e2 00 00       	call   80e653 <_panic>

008003db <serve>:

void
serve(void) {
  8003db:	55                   	push   %ebp
  8003dc:	89 e5                	mov    %esp,%ebp
  8003de:	57                   	push   %edi
  8003df:	56                   	push   %esi
  8003e0:	53                   	push   %ebx
  8003e1:	83 ec 2c             	sub    $0x2c,%esp
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
			thread_yield();

		perm = 0;
		va = get_buffer();
		reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  8003e4:	8d 7d e0             	lea    -0x20(%ebp),%edi
  8003e7:	e9 b8 00 00 00       	jmp    8004a4 <serve+0xc9>
			thread_yield();
  8003ec:	e8 f0 a3 00 00       	call   80a7e1 <thread_yield>
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  8003f1:	83 c3 01             	add    $0x1,%ebx
  8003f4:	e8 72 a2 00 00       	call   80a66b <thread_wakeups_pending>
  8003f9:	85 c0                	test   %eax,%eax
  8003fb:	74 05                	je     800402 <serve+0x27>
  8003fd:	83 fb 1f             	cmp    $0x1f,%ebx
  800400:	7e ea                	jle    8003ec <serve+0x11>
		perm = 0;
  800402:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	for (i = 0; i < QUEUE_SIZE; i++)
  800409:	b8 00 00 00 00       	mov    $0x0,%eax
		if (!buse[i]) break;
  80040e:	80 b8 00 50 81 00 00 	cmpb   $0x0,0x815000(%eax)
  800415:	74 1c                	je     800433 <serve+0x58>
	for (i = 0; i < QUEUE_SIZE; i++)
  800417:	83 c0 01             	add    $0x1,%eax
  80041a:	83 f8 14             	cmp    $0x14,%eax
  80041d:	75 ef                	jne    80040e <serve+0x33>
		panic("NS: buffer overflow");
  80041f:	83 ec 04             	sub    $0x4,%esp
  800422:	68 8a 10 81 00       	push   $0x81108a
  800427:	6a 3f                	push   $0x3f
  800429:	68 35 10 81 00       	push   $0x811035
  80042e:	e8 20 e2 00 00       	call   80e653 <_panic>
	if (i == QUEUE_SIZE) {
  800433:	83 f8 14             	cmp    $0x14,%eax
  800436:	74 e7                	je     80041f <serve+0x44>
	va = (void *)(REQVA + i * PGSIZE);
  800438:	8d 98 eb ff 00 00    	lea    0xffeb(%eax),%ebx
  80043e:	c1 e3 0c             	shl    $0xc,%ebx
	buse[i] = 1;
  800441:	c6 80 00 50 81 00 01 	movb   $0x1,0x815000(%eax)
		reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  800448:	83 ec 04             	sub    $0x4,%esp
  80044b:	57                   	push   %edi
  80044c:	53                   	push   %ebx
  80044d:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  800450:	50                   	push   %eax
  800451:	e8 aa f2 00 00       	call   80f700 <ipc_recv>
  800456:	89 c6                	mov    %eax,%esi
		if (debug) {
			cprintf("ns req %d from %08x\n", reqno, whom);
		}

		// first take care of requests that do not contain an argument page
		if (reqno == NSREQ_TIMER) {
  800458:	83 c4 10             	add    $0x10,%esp
  80045b:	83 f8 0c             	cmp    $0xc,%eax
  80045e:	74 4e                	je     8004ae <serve+0xd3>
			put_buffer(va);
			continue;
		}

		// All remaining requests must contain an argument page
		if (!(perm & PTE_P)) {
  800460:	f6 45 e0 01          	testb  $0x1,-0x20(%ebp)
  800464:	0f 84 9f 00 00 00    	je     800509 <serve+0x12e>
			continue; // just leave it hanging...
		}

		// Since some lwIP socket calls will block, create a thread and
		// process the rest of the request in the thread.
		struct st_args *args = malloc(sizeof(struct st_args));
  80046a:	83 ec 0c             	sub    $0xc,%esp
  80046d:	6a 0c                	push   $0xc
  80046f:	e8 17 04 01 00       	call   81088b <malloc>
		if (!args)
  800474:	83 c4 10             	add    $0x10,%esp
  800477:	85 c0                	test   %eax,%eax
  800479:	0f 84 9f 00 00 00    	je     80051e <serve+0x143>
			panic("could not allocate thread args structure");

		args->reqno = reqno;
  80047f:	89 30                	mov    %esi,(%eax)
		args->whom = whom;
  800481:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  800484:	89 50 04             	mov    %edx,0x4(%eax)
		args->req = va;
  800487:	89 58 08             	mov    %ebx,0x8(%eax)

		thread_create(0, "serve_thread", serve_thread, (uint32_t)args);
  80048a:	50                   	push   %eax
  80048b:	68 c4 00 80 00       	push   $0x8000c4
  800490:	68 9e 10 81 00       	push   $0x81109e
  800495:	6a 00                	push   $0x0
  800497:	e8 1c a2 00 00       	call   80a6b8 <thread_create>
		thread_yield(); // let the thread created run
  80049c:	e8 40 a3 00 00       	call   80a7e1 <thread_yield>
  8004a1:	83 c4 10             	add    $0x10,%esp
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  8004a4:	bb 00 00 00 00       	mov    $0x0,%ebx
  8004a9:	e9 46 ff ff ff       	jmp    8003f4 <serve+0x19>
			process_timer(whom);
  8004ae:	8b 75 e4             	mov    -0x1c(%ebp),%esi
	if (envid != timer_envid) {
  8004b1:	3b 35 18 50 81 00    	cmp    0x815018,%esi
  8004b7:	74 23                	je     8004dc <serve+0x101>
		cprintf("NS: received timer interrupt from envid %x not timer env\n", envid);
  8004b9:	83 ec 08             	sub    $0x8,%esp
  8004bc:	56                   	push   %esi
  8004bd:	68 a0 0f 81 00       	push   $0x810fa0
  8004c2:	e8 67 e2 00 00       	call   80e72e <cprintf>
  8004c7:	83 c4 10             	add    $0x10,%esp
	int i = ((uint32_t)va - REQVA) / PGSIZE;
  8004ca:	81 eb 00 b0 fe 0f    	sub    $0xffeb000,%ebx
  8004d0:	c1 eb 0c             	shr    $0xc,%ebx
	buse[i] = 0;
  8004d3:	c6 83 00 50 81 00 00 	movb   $0x0,0x815000(%ebx)
			continue;
  8004da:	eb c8                	jmp    8004a4 <serve+0xc9>
	start = sys_time_msec();
  8004dc:	e8 d4 ee 00 00       	call   80f3b5 <sys_time_msec>
  8004e1:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	thread_yield();
  8004e4:	e8 f8 a2 00 00       	call   80a7e1 <thread_yield>
	now = sys_time_msec();
  8004e9:	e8 c7 ee 00 00       	call   80f3b5 <sys_time_msec>
	ipc_send(envid, to, 0, 0);
  8004ee:	6a 00                	push   $0x0
  8004f0:	6a 00                	push   $0x0
	to = TIMER_INTERVAL - (now - start);
  8004f2:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  8004f5:	81 c2 fa 00 00 00    	add    $0xfa,%edx
  8004fb:	29 c2                	sub    %eax,%edx
	ipc_send(envid, to, 0, 0);
  8004fd:	52                   	push   %edx
  8004fe:	56                   	push   %esi
  8004ff:	e8 65 f2 00 00       	call   80f769 <ipc_send>
  800504:	83 c4 10             	add    $0x10,%esp
  800507:	eb c1                	jmp    8004ca <serve+0xef>
			cprintf("Invalid request from %08x: no argument page\n", whom);
  800509:	83 ec 08             	sub    $0x8,%esp
  80050c:	ff 75 e4             	pushl  -0x1c(%ebp)
  80050f:	68 dc 0f 81 00       	push   $0x810fdc
  800514:	e8 15 e2 00 00       	call   80e72e <cprintf>
			continue; // just leave it hanging...
  800519:	83 c4 10             	add    $0x10,%esp
  80051c:	eb 86                	jmp    8004a4 <serve+0xc9>
			panic("could not allocate thread args structure");
  80051e:	83 ec 04             	sub    $0x4,%esp
  800521:	68 0c 10 81 00       	push   $0x81100c
  800526:	68 27 01 00 00       	push   $0x127
  80052b:	68 35 10 81 00       	push   $0x811035
  800530:	e8 1e e1 00 00       	call   80e653 <_panic>

00800535 <tmain>:
	}
}

static void
tmain(uint32_t arg) {
  800535:	55                   	push   %ebp
  800536:	89 e5                	mov    %esp,%ebp
  800538:	56                   	push   %esi
  800539:	53                   	push   %ebx
	serve_init(inet_addr(IP),
  80053a:	83 ec 0c             	sub    $0xc,%esp
  80053d:	68 ab 10 81 00       	push   $0x8110ab
  800542:	e8 51 74 00 00       	call   807998 <inet_addr>
  800547:	89 c6                	mov    %eax,%esi
  800549:	c7 04 24 b4 10 81 00 	movl   $0x8110b4,(%esp)
  800550:	e8 43 74 00 00       	call   807998 <inet_addr>
  800555:	89 c3                	mov    %eax,%ebx
  800557:	c7 04 24 c2 10 81 00 	movl   $0x8110c2,(%esp)
  80055e:	e8 35 74 00 00       	call   807998 <inet_addr>
  800563:	83 c4 0c             	add    $0xc,%esp
  800566:	56                   	push   %esi
  800567:	53                   	push   %ebx
  800568:	50                   	push   %eax
  800569:	e8 0c fd ff ff       	call   80027a <serve_init>
		   inet_addr(MASK),
		   inet_addr(DEFAULT));
	serve();
  80056e:	e8 68 fe ff ff       	call   8003db <serve>

00800573 <umain>:
}

void
umain(int argc, char **argv)
{
  800573:	55                   	push   %ebp
  800574:	89 e5                	mov    %esp,%ebp
  800576:	53                   	push   %ebx
  800577:	83 ec 04             	sub    $0x4,%esp
	envid_t ns_envid = sys_getenvid();
  80057a:	e8 07 ec 00 00       	call   80f186 <sys_getenvid>
  80057f:	89 c3                	mov    %eax,%ebx

	binaryname = "ns";
  800581:	c7 05 e8 42 81 00 1a 	movl   $0x813a1a,0x8142e8
  800588:	3a 81 00 

	// fork off the timer thread which will send us periodic messages
	timer_envid = fork();
  80058b:	e8 2e ef 00 00       	call   80f4be <fork>
  800590:	a3 18 50 81 00       	mov    %eax,0x815018
	if (timer_envid < 0)
  800595:	85 c0                	test   %eax,%eax
  800597:	78 49                	js     8005e2 <umain+0x6f>
		panic("error forking");
	else if (timer_envid == 0) {
  800599:	85 c0                	test   %eax,%eax
  80059b:	74 5c                	je     8005f9 <umain+0x86>
		return;
	}

	// fork off the input thread which will poll the NIC driver for input
	// packets
	input_envid = fork();
  80059d:	e8 1c ef 00 00       	call   80f4be <fork>
	if (input_envid < 0)
  8005a2:	85 c0                	test   %eax,%eax
  8005a4:	78 69                	js     80060f <umain+0x9c>
		panic("error forking");
	else if (input_envid == 0) {
  8005a6:	85 c0                	test   %eax,%eax
  8005a8:	74 7c                	je     800626 <umain+0xb3>
		return;
	}

	// fork off the output thread that will send the packets to the NIC
	// driver
	output_envid = fork();
  8005aa:	e8 0f ef 00 00       	call   80f4be <fork>
  8005af:	a3 14 50 81 00       	mov    %eax,0x815014
	if (output_envid < 0)
  8005b4:	85 c0                	test   %eax,%eax
  8005b6:	78 7c                	js     800634 <umain+0xc1>
		panic("error forking");
	else if (output_envid == 0) {
  8005b8:	85 c0                	test   %eax,%eax
  8005ba:	0f 84 8b 00 00 00    	je     80064b <umain+0xd8>
		return;
	}

	// lwIP requires a user threading library; start the library and jump
	// into a thread to continue initialization.
	thread_init();
  8005c0:	e8 56 a0 00 00       	call   80a61b <thread_init>
	thread_create(0, "main", tmain, 0);
  8005c5:	6a 00                	push   $0x0
  8005c7:	68 35 05 80 00       	push   $0x800535
  8005cc:	68 da 10 81 00       	push   $0x8110da
  8005d1:	6a 00                	push   $0x0
  8005d3:	e8 e0 a0 00 00       	call   80a6b8 <thread_create>
	thread_yield();
  8005d8:	e8 04 a2 00 00       	call   80a7e1 <thread_yield>
  8005dd:	83 c4 10             	add    $0x10,%esp
  8005e0:	eb 28                	jmp    80060a <umain+0x97>
		panic("error forking");
  8005e2:	83 ec 04             	sub    $0x4,%esp
  8005e5:	68 cc 10 81 00       	push   $0x8110cc
  8005ea:	68 44 01 00 00       	push   $0x144
  8005ef:	68 35 10 81 00       	push   $0x811035
  8005f4:	e8 5a e0 00 00       	call   80e653 <_panic>
		timer(ns_envid, TIMER_INTERVAL);
  8005f9:	83 ec 08             	sub    $0x8,%esp
  8005fc:	68 fa 00 00 00       	push   $0xfa
  800601:	53                   	push   %ebx
  800602:	e8 52 00 00 00       	call   800659 <timer>
		return;
  800607:	83 c4 10             	add    $0x10,%esp
	// never coming here!
}
  80060a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80060d:	c9                   	leave  
  80060e:	c3                   	ret    
		panic("error forking");
  80060f:	83 ec 04             	sub    $0x4,%esp
  800612:	68 cc 10 81 00       	push   $0x8110cc
  800617:	68 4e 01 00 00       	push   $0x14e
  80061c:	68 35 10 81 00       	push   $0x811035
  800621:	e8 2d e0 00 00       	call   80e653 <_panic>
		input(ns_envid);
  800626:	83 ec 0c             	sub    $0xc,%esp
  800629:	53                   	push   %ebx
  80062a:	e8 bd 00 00 00       	call   8006ec <input>
		return;
  80062f:	83 c4 10             	add    $0x10,%esp
  800632:	eb d6                	jmp    80060a <umain+0x97>
		panic("error forking");
  800634:	83 ec 04             	sub    $0x4,%esp
  800637:	68 cc 10 81 00       	push   $0x8110cc
  80063c:	68 58 01 00 00       	push   $0x158
  800641:	68 35 10 81 00       	push   $0x811035
  800646:	e8 08 e0 00 00       	call   80e653 <_panic>
		output(ns_envid);
  80064b:	83 ec 0c             	sub    $0xc,%esp
  80064e:	53                   	push   %ebx
  80064f:	e8 a7 00 00 00       	call   8006fb <output>
		return;
  800654:	83 c4 10             	add    $0x10,%esp
  800657:	eb b1                	jmp    80060a <umain+0x97>

00800659 <timer>:
#include "ns.h"

void
timer(envid_t ns_envid, uint32_t initial_to) {
  800659:	55                   	push   %ebp
  80065a:	89 e5                	mov    %esp,%ebp
  80065c:	57                   	push   %edi
  80065d:	56                   	push   %esi
  80065e:	53                   	push   %ebx
  80065f:	83 ec 1c             	sub    $0x1c,%esp
  800662:	8b 75 08             	mov    0x8(%ebp),%esi
	int r;
	uint32_t stop = sys_time_msec() + initial_to;
  800665:	e8 4b ed 00 00       	call   80f3b5 <sys_time_msec>
  80066a:	03 45 0c             	add    0xc(%ebp),%eax
  80066d:	89 c3                	mov    %eax,%ebx

	binaryname = "ns_timer";
  80066f:	c7 05 e8 42 81 00 0c 	movl   $0x81110c,0x8142e8
  800676:	11 81 00 

		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);

		while (1) {
			uint32_t to, whom;
			to = ipc_recv((int32_t *) &whom, 0, 0);
  800679:	8d 7d e4             	lea    -0x1c(%ebp),%edi
  80067c:	eb 33                	jmp    8006b1 <timer+0x58>
		if (r < 0)
  80067e:	85 c0                	test   %eax,%eax
  800680:	78 45                	js     8006c7 <timer+0x6e>
		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);
  800682:	6a 00                	push   $0x0
  800684:	6a 00                	push   $0x0
  800686:	6a 0c                	push   $0xc
  800688:	56                   	push   %esi
  800689:	e8 db f0 00 00       	call   80f769 <ipc_send>
  80068e:	83 c4 10             	add    $0x10,%esp
			to = ipc_recv((int32_t *) &whom, 0, 0);
  800691:	83 ec 04             	sub    $0x4,%esp
  800694:	6a 00                	push   $0x0
  800696:	6a 00                	push   $0x0
  800698:	57                   	push   %edi
  800699:	e8 62 f0 00 00       	call   80f700 <ipc_recv>
  80069e:	89 c3                	mov    %eax,%ebx

			if (whom != ns_envid) {
  8006a0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8006a3:	83 c4 10             	add    $0x10,%esp
  8006a6:	39 f0                	cmp    %esi,%eax
  8006a8:	75 2f                	jne    8006d9 <timer+0x80>
				cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
				continue;
			}

			stop = sys_time_msec() + to;
  8006aa:	e8 06 ed 00 00       	call   80f3b5 <sys_time_msec>
  8006af:	01 c3                	add    %eax,%ebx
		while((r = sys_time_msec()) < stop && r >= 0) {
  8006b1:	e8 ff ec 00 00       	call   80f3b5 <sys_time_msec>
  8006b6:	89 c2                	mov    %eax,%edx
  8006b8:	85 c0                	test   %eax,%eax
  8006ba:	78 c2                	js     80067e <timer+0x25>
  8006bc:	39 d8                	cmp    %ebx,%eax
  8006be:	73 be                	jae    80067e <timer+0x25>
			sys_yield();
  8006c0:	e8 e0 ea 00 00       	call   80f1a5 <sys_yield>
  8006c5:	eb ea                	jmp    8006b1 <timer+0x58>
			panic("sys_time_msec: %e", r);
  8006c7:	52                   	push   %edx
  8006c8:	68 15 11 81 00       	push   $0x811115
  8006cd:	6a 0f                	push   $0xf
  8006cf:	68 27 11 81 00       	push   $0x811127
  8006d4:	e8 7a df 00 00       	call   80e653 <_panic>
				cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
  8006d9:	83 ec 08             	sub    $0x8,%esp
  8006dc:	50                   	push   %eax
  8006dd:	68 34 11 81 00       	push   $0x811134
  8006e2:	e8 47 e0 00 00       	call   80e72e <cprintf>
				continue;
  8006e7:	83 c4 10             	add    $0x10,%esp
  8006ea:	eb a5                	jmp    800691 <timer+0x38>

008006ec <input>:

extern union Nsipc nsipcbuf;

void
input(envid_t ns_envid)
{
  8006ec:	55                   	push   %ebp
  8006ed:	89 e5                	mov    %esp,%ebp
	binaryname = "ns_input";
  8006ef:	c7 05 e8 42 81 00 6f 	movl   $0x81116f,0x8142e8
  8006f6:	11 81 00 
	// 	- read a packet from the device driver
	//	- send it to the network server
	// Hint: When you IPC a page to the network server, it will be
	// reading from it for a while, so don't immediately receive
	// another packet in to the same physical page.
}
  8006f9:	5d                   	pop    %ebp
  8006fa:	c3                   	ret    

008006fb <output>:

extern union Nsipc nsipcbuf;

void
output(envid_t ns_envid)
{
  8006fb:	55                   	push   %ebp
  8006fc:	89 e5                	mov    %esp,%ebp
	binaryname = "ns_output";
  8006fe:	c7 05 e8 42 81 00 78 	movl   $0x811178,0x8142e8
  800705:	11 81 00 

	// LAB 6: Your code here:
	// 	- read a packet from the network server
	//	- send the packet to the device driver
}
  800708:	5d                   	pop    %ebp
  800709:	c3                   	ret    

0080070a <get_socket>:
 * @param s externally used socket index
 * @return struct lwip_socket for the socket or NULL if not found
 */
static struct lwip_socket *
get_socket(int s)
{
  80070a:	55                   	push   %ebp
  80070b:	89 e5                	mov    %esp,%ebp
  struct lwip_socket *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
  80070d:	83 f8 1f             	cmp    $0x1f,%eax
  800710:	77 1b                	ja     80072d <get_socket+0x23>
  800712:	89 c2                	mov    %eax,%edx
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
    set_errno(EBADF);
    return NULL;
  }

  sock = &sockets[s];
  800714:	8d 04 80             	lea    (%eax,%eax,4),%eax
  800717:	8d 04 85 60 50 81 00 	lea    0x815060(,%eax,4),%eax

  if (!sock->conn) {
  80071e:	8d 14 92             	lea    (%edx,%edx,4),%edx
  800721:	83 3c 95 60 50 81 00 	cmpl   $0x0,0x815060(,%edx,4)
  800728:	00 
  800729:	74 13                	je     80073e <get_socket+0x34>
    set_errno(EBADF);
    return NULL;
  }

  return sock;
}
  80072b:	5d                   	pop    %ebp
  80072c:	c3                   	ret    
    set_errno(EBADF);
  80072d:	c7 05 e0 b1 b3 00 09 	movl   $0x9,0xb3b1e0
  800734:	00 00 00 
    return NULL;
  800737:	b8 00 00 00 00       	mov    $0x0,%eax
  80073c:	eb ed                	jmp    80072b <get_socket+0x21>
    set_errno(EBADF);
  80073e:	c7 05 e0 b1 b3 00 09 	movl   $0x9,0xb3b1e0
  800745:	00 00 00 
    return NULL;
  800748:	b8 00 00 00 00       	mov    $0x0,%eax
  80074d:	eb dc                	jmp    80072b <get_socket+0x21>

0080074f <lwip_selscan>:
 * @param exceptset not yet implemented
 * @return number of sockets that had events (read+write)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset)
{
  80074f:	55                   	push   %ebp
  800750:	89 e5                	mov    %esp,%ebp
  800752:	57                   	push   %edi
  800753:	56                   	push   %esi
  800754:	53                   	push   %ebx
  800755:	83 ec 40             	sub    $0x40,%esp
  800758:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  80075b:	89 55 d0             	mov    %edx,-0x30(%ebp)
  80075e:	89 4d cc             	mov    %ecx,-0x34(%ebp)
  int i, nready = 0;
  fd_set lreadset, lwriteset, lexceptset;
  struct lwip_socket *p_sock;
  
  FD_ZERO(&lreadset);
  800761:	6a 04                	push   $0x4
  800763:	6a 00                	push   $0x0
  800765:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  800768:	50                   	push   %eax
  800769:	e8 9e e7 00 00       	call   80ef0c <memset>
  FD_ZERO(&lwriteset);
  80076e:	83 c4 0c             	add    $0xc,%esp
  800771:	6a 04                	push   $0x4
  800773:	6a 00                	push   $0x0
  800775:	8d 45 e0             	lea    -0x20(%ebp),%eax
  800778:	50                   	push   %eax
  800779:	e8 8e e7 00 00       	call   80ef0c <memset>
  FD_ZERO(&lexceptset);
  80077e:	83 c4 0c             	add    $0xc,%esp
  800781:	6a 04                	push   $0x4
  800783:	6a 00                	push   $0x0
  800785:	8d 45 dc             	lea    -0x24(%ebp),%eax
  800788:	50                   	push   %eax
  800789:	e8 7e e7 00 00       	call   80ef0c <memset>
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  80078e:	83 c4 10             	add    $0x10,%esp
  int i, nready = 0;
  800791:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  for(i = 0; i < maxfdp1; i++) {
  800798:	bf 00 00 00 00       	mov    $0x0,%edi
  80079d:	eb 33                	jmp    8007d2 <lwip_selscan+0x83>
    if (FD_ISSET(i, readset)) {
      /* See if netconn of this socket is ready for read */
      p_sock = get_socket(i);
  80079f:	89 f8                	mov    %edi,%eax
  8007a1:	e8 64 ff ff ff       	call   80070a <get_socket>
      if (p_sock && (p_sock->lastdata || p_sock->rcvevent)) {
  8007a6:	85 c0                	test   %eax,%eax
  8007a8:	74 4c                	je     8007f6 <lwip_selscan+0xa7>
  8007aa:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  8007ae:	74 16                	je     8007c6 <lwip_selscan+0x77>
        FD_SET(i, &lreadset);
  8007b0:	b8 01 00 00 00       	mov    $0x1,%eax
  8007b5:	89 f1                	mov    %esi,%ecx
  8007b7:	d3 e0                	shl    %cl,%eax
  8007b9:	8b 55 c8             	mov    -0x38(%ebp),%edx
  8007bc:	08 44 15 e4          	or     %al,-0x1c(%ebp,%edx,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
        nready++;
  8007c0:	83 45 c4 01          	addl   $0x1,-0x3c(%ebp)
  8007c4:	eb 30                	jmp    8007f6 <lwip_selscan+0xa7>
      if (p_sock && (p_sock->lastdata || p_sock->rcvevent)) {
  8007c6:	66 83 78 0a 00       	cmpw   $0x0,0xa(%eax)
  8007cb:	74 29                	je     8007f6 <lwip_selscan+0xa7>
  8007cd:	eb e1                	jmp    8007b0 <lwip_selscan+0x61>
  for(i = 0; i < maxfdp1; i++) {
  8007cf:	83 c7 01             	add    $0x1,%edi
  8007d2:	3b 7d d4             	cmp    -0x2c(%ebp),%edi
  8007d5:	7d 53                	jge    80082a <lwip_selscan+0xdb>
    if (FD_ISSET(i, readset)) {
  8007d7:	8d 5f 07             	lea    0x7(%edi),%ebx
  8007da:	85 ff                	test   %edi,%edi
  8007dc:	0f 49 df             	cmovns %edi,%ebx
  8007df:	c1 fb 03             	sar    $0x3,%ebx
  8007e2:	89 5d c8             	mov    %ebx,-0x38(%ebp)
  8007e5:	89 fe                	mov    %edi,%esi
  8007e7:	83 e6 07             	and    $0x7,%esi
  8007ea:	8b 45 d0             	mov    -0x30(%ebp),%eax
  8007ed:	0f b6 04 18          	movzbl (%eax,%ebx,1),%eax
  8007f1:	0f a3 f0             	bt     %esi,%eax
  8007f4:	72 a9                	jb     80079f <lwip_selscan+0x50>
      }
    }
    if (FD_ISSET(i, writeset)) {
  8007f6:	8b 45 cc             	mov    -0x34(%ebp),%eax
  8007f9:	0f b6 04 18          	movzbl (%eax,%ebx,1),%eax
  8007fd:	0f a3 f0             	bt     %esi,%eax
  800800:	73 cd                	jae    8007cf <lwip_selscan+0x80>
      /* See if netconn of this socket is ready for write */
      p_sock = get_socket(i);
  800802:	89 f8                	mov    %edi,%eax
  800804:	e8 01 ff ff ff       	call   80070a <get_socket>
      if (p_sock && p_sock->sendevent) {
  800809:	85 c0                	test   %eax,%eax
  80080b:	74 c2                	je     8007cf <lwip_selscan+0x80>
  80080d:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  800812:	74 bb                	je     8007cf <lwip_selscan+0x80>
        FD_SET(i, &lwriteset);
  800814:	b8 01 00 00 00       	mov    $0x1,%eax
  800819:	89 f1                	mov    %esi,%ecx
  80081b:	d3 e0                	shl    %cl,%eax
  80081d:	8b 55 c8             	mov    -0x38(%ebp),%edx
  800820:	08 44 15 e0          	or     %al,-0x20(%ebp,%edx,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
  800824:	83 45 c4 01          	addl   $0x1,-0x3c(%ebp)
  800828:	eb a5                	jmp    8007cf <lwip_selscan+0x80>
      }
    }
  }
  *readset = lreadset;
  80082a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80082d:	8b 55 d0             	mov    -0x30(%ebp),%edx
  800830:	89 02                	mov    %eax,(%edx)
  *writeset = lwriteset;
  800832:	8b 45 e0             	mov    -0x20(%ebp),%eax
  800835:	8b 4d cc             	mov    -0x34(%ebp),%ecx
  800838:	89 01                	mov    %eax,(%ecx)
  FD_ZERO(exceptset);
  80083a:	83 ec 04             	sub    $0x4,%esp
  80083d:	6a 04                	push   $0x4
  80083f:	6a 00                	push   $0x0
  800841:	ff 75 08             	pushl  0x8(%ebp)
  800844:	e8 c3 e6 00 00       	call   80ef0c <memset>
  
  return nready;
}
  800849:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  80084c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80084f:	5b                   	pop    %ebx
  800850:	5e                   	pop    %esi
  800851:	5f                   	pop    %edi
  800852:	5d                   	pop    %ebp
  800853:	c3                   	ret    

00800854 <lwip_getaddrname>:
  return lwip_close(s); /* XXX temporary hack until proper implementation */
}

static int
lwip_getaddrname(int s, struct sockaddr *name, socklen_t *namelen, u8_t local)
{
  800854:	55                   	push   %ebp
  800855:	89 e5                	mov    %esp,%ebp
  800857:	57                   	push   %edi
  800858:	56                   	push   %esi
  800859:	53                   	push   %ebx
  80085a:	83 ec 3c             	sub    $0x3c,%esp
  80085d:	89 55 c4             	mov    %edx,-0x3c(%ebp)
  800860:	89 cf                	mov    %ecx,%edi
  800862:	8b 75 08             	mov    0x8(%ebp),%esi
  struct lwip_socket *sock;
  struct sockaddr_in sin;
  struct ip_addr naddr;

  sock = get_socket(s);
  800865:	e8 a0 fe ff ff       	call   80070a <get_socket>
  if (!sock)
  80086a:	85 c0                	test   %eax,%eax
  80086c:	0f 84 86 00 00 00    	je     8008f8 <lwip_getaddrname+0xa4>
  800872:	89 c3                	mov    %eax,%ebx
    return -1;

  memset(&sin, 0, sizeof(sin));
  800874:	83 ec 04             	sub    $0x4,%esp
  800877:	6a 10                	push   $0x10
  800879:	6a 00                	push   $0x0
  80087b:	8d 45 d8             	lea    -0x28(%ebp),%eax
  80087e:	50                   	push   %eax
  80087f:	e8 88 e6 00 00       	call   80ef0c <memset>
  sin.sin_len = sizeof(sin);
  800884:	c6 45 d8 10          	movb   $0x10,-0x28(%ebp)
  sin.sin_family = AF_INET;
  800888:	c6 45 d9 02          	movb   $0x2,-0x27(%ebp)

  /* get the IP address and port */
  netconn_getaddr(sock->conn, &naddr, &sin.sin_port, local);
  80088c:	89 f0                	mov    %esi,%eax
  80088e:	0f b6 f0             	movzbl %al,%esi
  800891:	56                   	push   %esi
  800892:	8d 45 da             	lea    -0x26(%ebp),%eax
  800895:	50                   	push   %eax
  800896:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  800899:	50                   	push   %eax
  80089a:	ff 33                	pushl  (%ebx)
  80089c:	e8 16 a5 00 00       	call   80adb7 <netconn_getaddr>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getaddrname(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%d)\n", sin.sin_port));

  sin.sin_port = htons(sin.sin_port);
  8008a1:	83 c4 14             	add    $0x14,%esp
  8008a4:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
  8008a8:	50                   	push   %eax
  8008a9:	e8 d4 6e 00 00       	call   807782 <htons>
  8008ae:	66 89 45 da          	mov    %ax,-0x26(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  8008b2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  8008b5:	89 45 dc             	mov    %eax,-0x24(%ebp)

  if (*namelen > sizeof(sin))
  8008b8:	83 c4 10             	add    $0x10,%esp
  8008bb:	83 3f 10             	cmpl   $0x10,(%edi)
  8008be:	76 06                	jbe    8008c6 <lwip_getaddrname+0x72>
    *namelen = sizeof(sin);
  8008c0:	c7 07 10 00 00 00    	movl   $0x10,(%edi)

  SMEMCPY(name, &sin, *namelen);
  8008c6:	83 ec 04             	sub    $0x4,%esp
  8008c9:	ff 37                	pushl  (%edi)
  8008cb:	8d 45 d8             	lea    -0x28(%ebp),%eax
  8008ce:	50                   	push   %eax
  8008cf:	ff 75 c4             	pushl  -0x3c(%ebp)
  8008d2:	e8 ea e6 00 00       	call   80efc1 <memcpy>
  sock_set_errno(sock, 0);
  8008d7:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  8008de:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  8008e5:	00 00 00 
  return 0;
  8008e8:	83 c4 10             	add    $0x10,%esp
  8008eb:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8008f0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8008f3:	5b                   	pop    %ebx
  8008f4:	5e                   	pop    %esi
  8008f5:	5f                   	pop    %edi
  8008f6:	5d                   	pop    %ebp
  8008f7:	c3                   	ret    
    return -1;
  8008f8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8008fd:	eb f1                	jmp    8008f0 <lwip_getaddrname+0x9c>

008008ff <event_callback>:
{
  8008ff:	55                   	push   %ebp
  800900:	89 e5                	mov    %esp,%ebp
  800902:	57                   	push   %edi
  800903:	56                   	push   %esi
  800904:	53                   	push   %ebx
  800905:	83 ec 1c             	sub    $0x1c,%esp
  800908:	8b 75 08             	mov    0x8(%ebp),%esi
  if (conn) {
  80090b:	85 f6                	test   %esi,%esi
  80090d:	0f 84 95 01 00 00    	je     800aa8 <event_callback+0x1a9>
    s = conn->socket;
  800913:	8b 5e 1c             	mov    0x1c(%esi),%ebx
    if (s < 0) {
  800916:	85 db                	test   %ebx,%ebx
  800918:	78 52                	js     80096c <event_callback+0x6d>
    sock = get_socket(s);
  80091a:	89 d8                	mov    %ebx,%eax
  80091c:	e8 e9 fd ff ff       	call   80070a <get_socket>
  800921:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (!sock) {
  800924:	85 c0                	test   %eax,%eax
  800926:	0f 84 7c 01 00 00    	je     800aa8 <event_callback+0x1a9>
  sys_sem_wait(selectsem);
  80092c:	83 ec 0c             	sub    $0xc,%esp
  80092f:	ff 35 40 50 81 00    	pushl  0x815040
  800935:	e8 01 48 00 00       	call   80513b <sys_sem_wait>
  switch (evt) {
  80093a:	83 c4 10             	add    $0x10,%esp
  80093d:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
  800941:	0f 84 aa 00 00 00    	je     8009f1 <event_callback+0xf2>
  800947:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
  80094b:	72 6f                	jb     8009bc <event_callback+0xbd>
  80094d:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
  800951:	0f 84 a4 00 00 00    	je     8009fb <event_callback+0xfc>
  800957:	83 7d 0c 03          	cmpl   $0x3,0xc(%ebp)
  80095b:	0f 85 a5 00 00 00    	jne    800a06 <event_callback+0x107>
      sock->sendevent = 0;
  800961:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800964:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
      break;
  80096a:	eb 58                	jmp    8009c4 <event_callback+0xc5>
      sys_sem_wait(socksem);
  80096c:	83 ec 0c             	sub    $0xc,%esp
  80096f:	ff 35 44 50 81 00    	pushl  0x815044
  800975:	e8 c1 47 00 00       	call   80513b <sys_sem_wait>
      if (conn->socket < 0) {
  80097a:	8b 46 1c             	mov    0x1c(%esi),%eax
  80097d:	83 c4 10             	add    $0x10,%esp
  800980:	85 c0                	test   %eax,%eax
  800982:	79 22                	jns    8009a6 <event_callback+0xa7>
        if (evt == NETCONN_EVT_RCVPLUS) {
  800984:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  800988:	75 06                	jne    800990 <event_callback+0x91>
          conn->socket--;
  80098a:	83 e8 01             	sub    $0x1,%eax
  80098d:	89 46 1c             	mov    %eax,0x1c(%esi)
        sys_sem_signal(socksem);
  800990:	83 ec 0c             	sub    $0xc,%esp
  800993:	ff 35 44 50 81 00    	pushl  0x815044
  800999:	e8 86 97 00 00       	call   80a124 <sys_sem_signal>
        return;
  80099e:	83 c4 10             	add    $0x10,%esp
  8009a1:	e9 02 01 00 00       	jmp    800aa8 <event_callback+0x1a9>
      sys_sem_signal(socksem);
  8009a6:	83 ec 0c             	sub    $0xc,%esp
  8009a9:	ff 35 44 50 81 00    	pushl  0x815044
  8009af:	e8 70 97 00 00       	call   80a124 <sys_sem_signal>
  8009b4:	83 c4 10             	add    $0x10,%esp
  8009b7:	e9 5e ff ff ff       	jmp    80091a <event_callback+0x1b>
      sock->rcvevent++;
  8009bc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8009bf:	66 83 40 0a 01       	addw   $0x1,0xa(%eax)
  sys_sem_signal(selectsem);
  8009c4:	83 ec 0c             	sub    $0xc,%esp
  8009c7:	ff 35 40 50 81 00    	pushl  0x815040
  8009cd:	e8 52 97 00 00       	call   80a124 <sys_sem_signal>
        if (scb->readset && FD_ISSET(s, scb->readset))
  8009d2:	8d 73 07             	lea    0x7(%ebx),%esi
  8009d5:	83 c4 10             	add    $0x10,%esp
  8009d8:	85 db                	test   %ebx,%ebx
  8009da:	0f 49 f3             	cmovns %ebx,%esi
  8009dd:	c1 fe 03             	sar    $0x3,%esi
  8009e0:	89 d9                	mov    %ebx,%ecx
  8009e2:	83 e1 07             	and    $0x7,%ecx
  8009e5:	bf 01 00 00 00       	mov    $0x1,%edi
  8009ea:	d3 e7                	shl    %cl,%edi
  8009ec:	e9 8d 00 00 00       	jmp    800a7e <event_callback+0x17f>
      sock->rcvevent--;
  8009f1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8009f4:	66 83 68 0a 01       	subw   $0x1,0xa(%eax)
      break;
  8009f9:	eb c9                	jmp    8009c4 <event_callback+0xc5>
      sock->sendevent = 1;
  8009fb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8009fe:	66 c7 40 0c 01 00    	movw   $0x1,0xc(%eax)
      break;
  800a04:	eb be                	jmp    8009c4 <event_callback+0xc5>
      LWIP_ASSERT("unknown event", 0);
  800a06:	83 ec 04             	sub    $0x4,%esp
  800a09:	68 82 11 81 00       	push   $0x811182
  800a0e:	68 17 04 00 00       	push   $0x417
  800a13:	68 90 11 81 00       	push   $0x811190
  800a18:	e8 36 dc 00 00       	call   80e653 <_panic>
    for (scb = select_cb_list; scb; scb = scb->next) {
  800a1d:	8b 1b                	mov    (%ebx),%ebx
  800a1f:	85 db                	test   %ebx,%ebx
  800a21:	74 74                	je     800a97 <event_callback+0x198>
      if (scb->sem_signalled == 0) {
  800a23:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  800a27:	75 f4                	jne    800a1d <event_callback+0x11e>
        if (scb->readset && FD_ISSET(s, scb->readset))
  800a29:	8b 43 04             	mov    0x4(%ebx),%eax
  800a2c:	85 c0                	test   %eax,%eax
  800a2e:	74 12                	je     800a42 <event_callback+0x143>
  800a30:	0f b6 04 30          	movzbl (%eax,%esi,1),%eax
  800a34:	85 f8                	test   %edi,%eax
  800a36:	74 0a                	je     800a42 <event_callback+0x143>
          if (sock->rcvevent)
  800a38:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800a3b:	66 83 78 0a 00       	cmpw   $0x0,0xa(%eax)
  800a40:	75 19                	jne    800a5b <event_callback+0x15c>
        if (scb->writeset && FD_ISSET(s, scb->writeset))
  800a42:	8b 43 08             	mov    0x8(%ebx),%eax
  800a45:	85 c0                	test   %eax,%eax
  800a47:	74 d4                	je     800a1d <event_callback+0x11e>
  800a49:	0f b6 04 30          	movzbl (%eax,%esi,1),%eax
  800a4d:	85 f8                	test   %edi,%eax
  800a4f:	74 cc                	je     800a1d <event_callback+0x11e>
          if (sock->sendevent)
  800a51:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800a54:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  800a59:	74 c2                	je     800a1d <event_callback+0x11e>
      scb->sem_signalled = 1;
  800a5b:	c7 43 10 01 00 00 00 	movl   $0x1,0x10(%ebx)
      sys_sem_signal(selectsem);
  800a62:	83 ec 0c             	sub    $0xc,%esp
  800a65:	ff 35 40 50 81 00    	pushl  0x815040
  800a6b:	e8 b4 96 00 00       	call   80a124 <sys_sem_signal>
      sys_sem_signal(scb->sem);
  800a70:	83 c4 04             	add    $0x4,%esp
  800a73:	ff 73 14             	pushl  0x14(%ebx)
  800a76:	e8 a9 96 00 00       	call   80a124 <sys_sem_signal>
    sys_sem_wait(selectsem);
  800a7b:	83 c4 10             	add    $0x10,%esp
  800a7e:	83 ec 0c             	sub    $0xc,%esp
  800a81:	ff 35 40 50 81 00    	pushl  0x815040
  800a87:	e8 af 46 00 00       	call   80513b <sys_sem_wait>
    for (scb = select_cb_list; scb; scb = scb->next) {
  800a8c:	8b 1d 48 50 81 00    	mov    0x815048,%ebx
  800a92:	83 c4 10             	add    $0x10,%esp
  800a95:	eb 88                	jmp    800a1f <event_callback+0x120>
      sys_sem_signal(selectsem);
  800a97:	83 ec 0c             	sub    $0xc,%esp
  800a9a:	ff 35 40 50 81 00    	pushl  0x815040
  800aa0:	e8 7f 96 00 00       	call   80a124 <sys_sem_signal>
      break;
  800aa5:	83 c4 10             	add    $0x10,%esp
}
  800aa8:	8d 65 f4             	lea    -0xc(%ebp),%esp
  800aab:	5b                   	pop    %ebx
  800aac:	5e                   	pop    %esi
  800aad:	5f                   	pop    %edi
  800aae:	5d                   	pop    %ebp
  800aaf:	c3                   	ret    

00800ab0 <alloc_socket>:
{
  800ab0:	55                   	push   %ebp
  800ab1:	89 e5                	mov    %esp,%ebp
  800ab3:	56                   	push   %esi
  800ab4:	53                   	push   %ebx
  800ab5:	89 c6                	mov    %eax,%esi
  sys_sem_wait(socksem);
  800ab7:	83 ec 0c             	sub    $0xc,%esp
  800aba:	ff 35 44 50 81 00    	pushl  0x815044
  800ac0:	e8 76 46 00 00       	call   80513b <sys_sem_wait>
  800ac5:	b8 60 50 81 00       	mov    $0x815060,%eax
  800aca:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < NUM_SOCKETS; ++i) {
  800acd:	bb 00 00 00 00       	mov    $0x0,%ebx
    if (!sockets[i].conn) {
  800ad2:	83 38 00             	cmpl   $0x0,(%eax)
  800ad5:	74 23                	je     800afa <alloc_socket+0x4a>
  for (i = 0; i < NUM_SOCKETS; ++i) {
  800ad7:	83 c3 01             	add    $0x1,%ebx
  800ada:	83 c0 14             	add    $0x14,%eax
  800add:	83 fb 20             	cmp    $0x20,%ebx
  800ae0:	75 f0                	jne    800ad2 <alloc_socket+0x22>
  sys_sem_signal(socksem);
  800ae2:	83 ec 0c             	sub    $0xc,%esp
  800ae5:	ff 35 44 50 81 00    	pushl  0x815044
  800aeb:	e8 34 96 00 00       	call   80a124 <sys_sem_signal>
  return -1;
  800af0:	83 c4 10             	add    $0x10,%esp
  800af3:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  800af8:	eb 55                	jmp    800b4f <alloc_socket+0x9f>
      sockets[i].conn       = newconn;
  800afa:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
  800afd:	c1 e2 02             	shl    $0x2,%edx
  800b00:	89 b2 60 50 81 00    	mov    %esi,0x815060(%edx)
      sockets[i].lastdata   = NULL;
  800b06:	c7 82 64 50 81 00 00 	movl   $0x0,0x815064(%edx)
  800b0d:	00 00 00 
      sockets[i].lastoffset = 0;
  800b10:	66 c7 82 68 50 81 00 	movw   $0x0,0x815068(%edx)
  800b17:	00 00 
      sockets[i].rcvevent   = 0;
  800b19:	66 c7 82 6a 50 81 00 	movw   $0x0,0x81506a(%edx)
  800b20:	00 00 
      sockets[i].sendevent  = 1; /* TCP send buf is empty */
  800b22:	66 c7 82 6c 50 81 00 	movw   $0x1,0x81506c(%edx)
  800b29:	01 00 
      sockets[i].flags      = 0;
  800b2b:	66 c7 82 6e 50 81 00 	movw   $0x0,0x81506e(%edx)
  800b32:	00 00 
      sockets[i].err        = 0;
  800b34:	c7 82 70 50 81 00 00 	movl   $0x0,0x815070(%edx)
  800b3b:	00 00 00 
      sys_sem_signal(socksem);
  800b3e:	83 ec 0c             	sub    $0xc,%esp
  800b41:	ff 35 44 50 81 00    	pushl  0x815044
  800b47:	e8 d8 95 00 00       	call   80a124 <sys_sem_signal>
      return i;
  800b4c:	83 c4 10             	add    $0x10,%esp
}
  800b4f:	89 d8                	mov    %ebx,%eax
  800b51:	8d 65 f8             	lea    -0x8(%ebp),%esp
  800b54:	5b                   	pop    %ebx
  800b55:	5e                   	pop    %esi
  800b56:	5d                   	pop    %ebp
  800b57:	c3                   	ret    

00800b58 <lwip_getsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_getsockopt_internal(void *arg)
{
  800b58:	55                   	push   %ebp
  800b59:	89 e5                	mov    %esp,%ebp
  800b5b:	53                   	push   %ebx
  800b5c:	83 ec 04             	sub    $0x4,%esp
  800b5f:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  800b62:	85 c0                	test   %eax,%eax
  800b64:	74 38                	je     800b9e <lwip_getsockopt_internal+0x46>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  800b66:	8b 08                	mov    (%eax),%ecx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  optname = data->optname;
  800b68:	8b 50 0c             	mov    0xc(%eax),%edx
  optval = data->optval;
  800b6b:	8b 58 10             	mov    0x10(%eax),%ebx

  switch (level) {
  800b6e:	8b 40 08             	mov    0x8(%eax),%eax
  800b71:	83 f8 06             	cmp    $0x6,%eax
  800b74:	0f 84 39 01 00 00    	je     800cb3 <lwip_getsockopt_internal+0x15b>
  800b7a:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  800b7f:	74 34                	je     800bb5 <lwip_getsockopt_internal+0x5d>
  800b81:	85 c0                	test   %eax,%eax
  800b83:	0f 84 fc 00 00 00    	je     800c85 <lwip_getsockopt_internal+0x12d>
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  } /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  800b89:	83 ec 0c             	sub    $0xc,%esp
  800b8c:	8b 01                	mov    (%ecx),%eax
  800b8e:	ff 70 10             	pushl  0x10(%eax)
  800b91:	e8 8e 95 00 00       	call   80a124 <sys_sem_signal>
}
  800b96:	83 c4 10             	add    $0x10,%esp
  800b99:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  800b9c:	c9                   	leave  
  800b9d:	c3                   	ret    
  LWIP_ASSERT("arg != NULL", arg != NULL);
  800b9e:	83 ec 04             	sub    $0x4,%esp
  800ba1:	68 a7 11 81 00       	push   $0x8111a7
  800ba6:	68 38 05 00 00       	push   $0x538
  800bab:	68 90 11 81 00       	push   $0x811190
  800bb0:	e8 9e da 00 00       	call   80e653 <_panic>
    switch (optname) {
  800bb5:	83 fa 20             	cmp    $0x20,%edx
  800bb8:	74 68                	je     800c22 <lwip_getsockopt_internal+0xca>
  800bba:	83 fa 20             	cmp    $0x20,%edx
  800bbd:	7e 55                	jle    800c14 <lwip_getsockopt_internal+0xbc>
  800bbf:	81 fa 08 10 00 00    	cmp    $0x1008,%edx
  800bc5:	74 6d                	je     800c34 <lwip_getsockopt_internal+0xdc>
  800bc7:	81 fa 0a 10 00 00    	cmp    $0x100a,%edx
  800bcd:	0f 84 9f 00 00 00    	je     800c72 <lwip_getsockopt_internal+0x11a>
  800bd3:	81 fa 07 10 00 00    	cmp    $0x1007,%edx
  800bd9:	75 ae                	jne    800b89 <lwip_getsockopt_internal+0x31>
      if (sock->err == 0) {
  800bdb:	83 79 10 00          	cmpl   $0x0,0x10(%ecx)
  800bdf:	75 22                	jne    800c03 <lwip_getsockopt_internal+0xab>
        sock_set_errno(sock, err_to_errno(sock->conn->err));
  800be1:	8b 01                	mov    (%ecx),%eax
  800be3:	0f be 40 0c          	movsbl 0xc(%eax),%eax
  800be7:	f7 d8                	neg    %eax
  800be9:	ba 05 00 00 00       	mov    $0x5,%edx
  800bee:	83 f8 0e             	cmp    $0xe,%eax
  800bf1:	77 07                	ja     800bfa <lwip_getsockopt_internal+0xa2>
  800bf3:	8b 14 85 60 12 81 00 	mov    0x811260(,%eax,4),%edx
  800bfa:	89 51 10             	mov    %edx,0x10(%ecx)
  800bfd:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
      *(int *)optval = sock->err;
  800c03:	8b 41 10             	mov    0x10(%ecx),%eax
  800c06:	89 03                	mov    %eax,(%ebx)
      sock->err = 0;
  800c08:	c7 41 10 00 00 00 00 	movl   $0x0,0x10(%ecx)
      break;
  800c0f:	e9 75 ff ff ff       	jmp    800b89 <lwip_getsockopt_internal+0x31>
    switch (optname) {
  800c14:	83 fa 02             	cmp    $0x2,%edx
  800c17:	74 09                	je     800c22 <lwip_getsockopt_internal+0xca>
  800c19:	83 fa 08             	cmp    $0x8,%edx
  800c1c:	0f 85 67 ff ff ff    	jne    800b89 <lwip_getsockopt_internal+0x31>
      *(int*)optval = sock->conn->pcb.ip->so_options & optname;
  800c22:	8b 01                	mov    (%ecx),%eax
  800c24:	8b 40 08             	mov    0x8(%eax),%eax
  800c27:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  800c2b:	21 c2                	and    %eax,%edx
  800c2d:	89 13                	mov    %edx,(%ebx)
      break;
  800c2f:	e9 55 ff ff ff       	jmp    800b89 <lwip_getsockopt_internal+0x31>
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
  800c34:	8b 01                	mov    (%ecx),%eax
  800c36:	8b 00                	mov    (%eax),%eax
  800c38:	89 c2                	mov    %eax,%edx
  800c3a:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  800c40:	83 fa 20             	cmp    $0x20,%edx
  800c43:	74 22                	je     800c67 <lwip_getsockopt_internal+0x10f>
  800c45:	83 fa 40             	cmp    $0x40,%edx
  800c48:	74 12                	je     800c5c <lwip_getsockopt_internal+0x104>
        *(int*)optval = sock->conn->type;
  800c4a:	83 fa 10             	cmp    $0x10,%edx
  800c4d:	ba 01 00 00 00       	mov    $0x1,%edx
  800c52:	0f 44 c2             	cmove  %edx,%eax
  800c55:	89 03                	mov    %eax,(%ebx)
  800c57:	e9 2d ff ff ff       	jmp    800b89 <lwip_getsockopt_internal+0x31>
        *(int*)optval = SOCK_RAW;
  800c5c:	c7 03 03 00 00 00    	movl   $0x3,(%ebx)
        break;
  800c62:	e9 22 ff ff ff       	jmp    800b89 <lwip_getsockopt_internal+0x31>
        *(int*)optval = SOCK_DGRAM;
  800c67:	c7 03 02 00 00 00    	movl   $0x2,(%ebx)
        break;
  800c6d:	e9 17 ff ff ff       	jmp    800b89 <lwip_getsockopt_internal+0x31>
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
  800c72:	8b 01                	mov    (%ecx),%eax
  800c74:	8b 40 08             	mov    0x8(%eax),%eax
  800c77:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  800c7b:	83 e0 01             	and    $0x1,%eax
  800c7e:	89 03                	mov    %eax,(%ebx)
      break;
  800c80:	e9 04 ff ff ff       	jmp    800b89 <lwip_getsockopt_internal+0x31>
    switch (optname) {
  800c85:	83 fa 01             	cmp    $0x1,%edx
  800c88:	74 19                	je     800ca3 <lwip_getsockopt_internal+0x14b>
  800c8a:	83 fa 02             	cmp    $0x2,%edx
  800c8d:	0f 85 f6 fe ff ff    	jne    800b89 <lwip_getsockopt_internal+0x31>
      *(int*)optval = sock->conn->pcb.ip->ttl;
  800c93:	8b 01                	mov    (%ecx),%eax
  800c95:	8b 40 08             	mov    0x8(%eax),%eax
  800c98:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
  800c9c:	89 03                	mov    %eax,(%ebx)
      break;
  800c9e:	e9 e6 fe ff ff       	jmp    800b89 <lwip_getsockopt_internal+0x31>
      *(int*)optval = sock->conn->pcb.ip->tos;
  800ca3:	8b 01                	mov    (%ecx),%eax
  800ca5:	8b 40 08             	mov    0x8(%eax),%eax
  800ca8:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
  800cac:	89 03                	mov    %eax,(%ebx)
      break;
  800cae:	e9 d6 fe ff ff       	jmp    800b89 <lwip_getsockopt_internal+0x31>
    switch (optname) {
  800cb3:	83 fa 01             	cmp    $0x1,%edx
  800cb6:	74 1b                	je     800cd3 <lwip_getsockopt_internal+0x17b>
  800cb8:	83 fa 02             	cmp    $0x2,%edx
  800cbb:	0f 85 c8 fe ff ff    	jne    800b89 <lwip_getsockopt_internal+0x31>
      *(int*)optval = (int)sock->conn->pcb.tcp->keep_idle;
  800cc1:	8b 01                	mov    (%ecx),%eax
  800cc3:	8b 40 08             	mov    0x8(%eax),%eax
  800cc6:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
  800ccc:	89 03                	mov    %eax,(%ebx)
      break;
  800cce:	e9 b6 fe ff ff       	jmp    800b89 <lwip_getsockopt_internal+0x31>
      *(int*)optval = (sock->conn->pcb.tcp->flags & TF_NODELAY);
  800cd3:	8b 01                	mov    (%ecx),%eax
  800cd5:	8b 40 08             	mov    0x8(%eax),%eax
  800cd8:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  800cdc:	83 e0 40             	and    $0x40,%eax
  800cdf:	0f b6 c0             	movzbl %al,%eax
  800ce2:	89 03                	mov    %eax,(%ebx)
      break;
  800ce4:	e9 a0 fe ff ff       	jmp    800b89 <lwip_getsockopt_internal+0x31>

00800ce9 <lwip_setsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_setsockopt_internal(void *arg)
{
  800ce9:	55                   	push   %ebp
  800cea:	89 e5                	mov    %esp,%ebp
  800cec:	53                   	push   %ebx
  800ced:	83 ec 04             	sub    $0x4,%esp
  800cf0:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  const void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  800cf3:	85 c0                	test   %eax,%eax
  800cf5:	74 34                	je     800d2b <lwip_setsockopt_internal+0x42>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  800cf7:	8b 08                	mov    (%eax),%ecx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  optname = data->optname;
  800cf9:	8b 50 0c             	mov    0xc(%eax),%edx
  optval = data->optval;
  800cfc:	8b 58 10             	mov    0x10(%eax),%ebx

  switch (level) {
  800cff:	8b 40 08             	mov    0x8(%eax),%eax
  800d02:	83 f8 06             	cmp    $0x6,%eax
  800d05:	0f 84 a9 00 00 00    	je     800db4 <lwip_setsockopt_internal+0xcb>
  800d0b:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  800d10:	74 30                	je     800d42 <lwip_setsockopt_internal+0x59>
  800d12:	85 c0                	test   %eax,%eax
  800d14:	74 76                	je     800d8c <lwip_setsockopt_internal+0xa3>
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  }  /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  800d16:	83 ec 0c             	sub    $0xc,%esp
  800d19:	8b 01                	mov    (%ecx),%eax
  800d1b:	ff 70 10             	pushl  0x10(%eax)
  800d1e:	e8 01 94 00 00       	call   80a124 <sys_sem_signal>
}
  800d23:	83 c4 10             	add    $0x10,%esp
  800d26:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  800d29:	c9                   	leave  
  800d2a:	c3                   	ret    
  LWIP_ASSERT("arg != NULL", arg != NULL);
  800d2b:	83 ec 04             	sub    $0x4,%esp
  800d2e:	68 a7 11 81 00       	push   $0x8111a7
  800d33:	68 ae 06 00 00       	push   $0x6ae
  800d38:	68 90 11 81 00       	push   $0x811190
  800d3d:	e8 11 d9 00 00       	call   80e653 <_panic>
    switch (optname) {
  800d42:	83 fa 20             	cmp    $0x20,%edx
  800d45:	74 0d                	je     800d54 <lwip_setsockopt_internal+0x6b>
  800d47:	81 fa 0a 10 00 00    	cmp    $0x100a,%edx
  800d4d:	74 22                	je     800d71 <lwip_setsockopt_internal+0x88>
  800d4f:	83 fa 08             	cmp    $0x8,%edx
  800d52:	75 c2                	jne    800d16 <lwip_setsockopt_internal+0x2d>
      if (*(int*)optval) {
  800d54:	83 3b 00             	cmpl   $0x0,(%ebx)
  800d57:	74 0b                	je     800d64 <lwip_setsockopt_internal+0x7b>
        sock->conn->pcb.ip->so_options |= optname;
  800d59:	8b 01                	mov    (%ecx),%eax
  800d5b:	8b 40 08             	mov    0x8(%eax),%eax
  800d5e:	66 09 50 08          	or     %dx,0x8(%eax)
  800d62:	eb b2                	jmp    800d16 <lwip_setsockopt_internal+0x2d>
        sock->conn->pcb.ip->so_options &= ~optname;
  800d64:	8b 01                	mov    (%ecx),%eax
  800d66:	8b 40 08             	mov    0x8(%eax),%eax
  800d69:	f7 d2                	not    %edx
  800d6b:	66 21 50 08          	and    %dx,0x8(%eax)
  800d6f:	eb a5                	jmp    800d16 <lwip_setsockopt_internal+0x2d>
      if (*(int*)optval) {
  800d71:	83 3b 00             	cmpl   $0x0,(%ebx)
  800d74:	74 0b                	je     800d81 <lwip_setsockopt_internal+0x98>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
  800d76:	8b 01                	mov    (%ecx),%eax
  800d78:	8b 40 08             	mov    0x8(%eax),%eax
  800d7b:	80 48 10 01          	orb    $0x1,0x10(%eax)
  800d7f:	eb 95                	jmp    800d16 <lwip_setsockopt_internal+0x2d>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
  800d81:	8b 01                	mov    (%ecx),%eax
  800d83:	8b 40 08             	mov    0x8(%eax),%eax
  800d86:	80 60 10 fe          	andb   $0xfe,0x10(%eax)
  800d8a:	eb 8a                	jmp    800d16 <lwip_setsockopt_internal+0x2d>
    switch (optname) {
  800d8c:	83 fa 01             	cmp    $0x1,%edx
  800d8f:	74 14                	je     800da5 <lwip_setsockopt_internal+0xbc>
  800d91:	83 fa 02             	cmp    $0x2,%edx
  800d94:	75 80                	jne    800d16 <lwip_setsockopt_internal+0x2d>
      sock->conn->pcb.ip->ttl = (u8_t)(*(int*)optval);
  800d96:	8b 01                	mov    (%ecx),%eax
  800d98:	8b 40 08             	mov    0x8(%eax),%eax
  800d9b:	8b 13                	mov    (%ebx),%edx
  800d9d:	88 50 0b             	mov    %dl,0xb(%eax)
      break;
  800da0:	e9 71 ff ff ff       	jmp    800d16 <lwip_setsockopt_internal+0x2d>
      sock->conn->pcb.ip->tos = (u8_t)(*(int*)optval);
  800da5:	8b 01                	mov    (%ecx),%eax
  800da7:	8b 40 08             	mov    0x8(%eax),%eax
  800daa:	8b 13                	mov    (%ebx),%edx
  800dac:	88 50 0a             	mov    %dl,0xa(%eax)
      break;
  800daf:	e9 62 ff ff ff       	jmp    800d16 <lwip_setsockopt_internal+0x2d>
    switch (optname) {
  800db4:	83 fa 01             	cmp    $0x1,%edx
  800db7:	74 1b                	je     800dd4 <lwip_setsockopt_internal+0xeb>
  800db9:	83 fa 02             	cmp    $0x2,%edx
  800dbc:	0f 85 54 ff ff ff    	jne    800d16 <lwip_setsockopt_internal+0x2d>
      sock->conn->pcb.tcp->keep_idle = (u32_t)(*(int*)optval);
  800dc2:	8b 01                	mov    (%ecx),%eax
  800dc4:	8b 40 08             	mov    0x8(%eax),%eax
  800dc7:	8b 13                	mov    (%ebx),%edx
  800dc9:	89 90 9c 00 00 00    	mov    %edx,0x9c(%eax)
      break;
  800dcf:	e9 42 ff ff ff       	jmp    800d16 <lwip_setsockopt_internal+0x2d>
      if (*(int*)optval) {
  800dd4:	83 3b 00             	cmpl   $0x0,(%ebx)
  800dd7:	74 0e                	je     800de7 <lwip_setsockopt_internal+0xfe>
        sock->conn->pcb.tcp->flags |= TF_NODELAY;
  800dd9:	8b 01                	mov    (%ecx),%eax
  800ddb:	8b 40 08             	mov    0x8(%eax),%eax
  800dde:	80 48 20 40          	orb    $0x40,0x20(%eax)
  800de2:	e9 2f ff ff ff       	jmp    800d16 <lwip_setsockopt_internal+0x2d>
        sock->conn->pcb.tcp->flags &= ~TF_NODELAY;
  800de7:	8b 01                	mov    (%ecx),%eax
  800de9:	8b 40 08             	mov    0x8(%eax),%eax
  800dec:	80 60 20 bf          	andb   $0xbf,0x20(%eax)
  800df0:	e9 21 ff ff ff       	jmp    800d16 <lwip_setsockopt_internal+0x2d>

00800df5 <lwip_socket_init>:
{
  800df5:	55                   	push   %ebp
  800df6:	89 e5                	mov    %esp,%ebp
  800df8:	83 ec 14             	sub    $0x14,%esp
  socksem   = sys_sem_new(1);
  800dfb:	6a 01                	push   $0x1
  800dfd:	e8 65 90 00 00       	call   809e67 <sys_sem_new>
  800e02:	a3 44 50 81 00       	mov    %eax,0x815044
  selectsem = sys_sem_new(1);
  800e07:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  800e0e:	e8 54 90 00 00       	call   809e67 <sys_sem_new>
  800e13:	a3 40 50 81 00       	mov    %eax,0x815040
}
  800e18:	83 c4 10             	add    $0x10,%esp
  800e1b:	c9                   	leave  
  800e1c:	c3                   	ret    

00800e1d <lwip_accept>:
{
  800e1d:	55                   	push   %ebp
  800e1e:	89 e5                	mov    %esp,%ebp
  800e20:	57                   	push   %edi
  800e21:	56                   	push   %esi
  800e22:	53                   	push   %ebx
  800e23:	83 ec 3c             	sub    $0x3c,%esp
  800e26:	8b 7d 10             	mov    0x10(%ebp),%edi
  sock = get_socket(s);
  800e29:	8b 45 08             	mov    0x8(%ebp),%eax
  800e2c:	e8 d9 f8 ff ff       	call   80070a <get_socket>
  if (!sock)
  800e31:	85 c0                	test   %eax,%eax
  800e33:	0f 84 8c 01 00 00    	je     800fc5 <lwip_accept+0x1a8>
  800e39:	89 c6                	mov    %eax,%esi
  newconn = netconn_accept(sock->conn);
  800e3b:	83 ec 0c             	sub    $0xc,%esp
  800e3e:	ff 30                	pushl  (%eax)
  800e40:	e8 28 a1 00 00       	call   80af6d <netconn_accept>
  800e45:	89 c3                	mov    %eax,%ebx
  if (!newconn) {
  800e47:	83 c4 10             	add    $0x10,%esp
  800e4a:	85 c0                	test   %eax,%eax
  800e4c:	0f 84 de 00 00 00    	je     800f30 <lwip_accept+0x113>
  err = netconn_peer(newconn, &naddr, &port);
  800e52:	6a 00                	push   $0x0
  800e54:	8d 45 e2             	lea    -0x1e(%ebp),%eax
  800e57:	50                   	push   %eax
  800e58:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  800e5b:	50                   	push   %eax
  800e5c:	53                   	push   %ebx
  800e5d:	e8 55 9f 00 00       	call   80adb7 <netconn_getaddr>
  800e62:	88 45 c7             	mov    %al,-0x39(%ebp)
  if (err != ERR_OK) {
  800e65:	83 c4 10             	add    $0x10,%esp
  800e68:	84 c0                	test   %al,%al
  800e6a:	0f 85 e9 00 00 00    	jne    800f59 <lwip_accept+0x13c>
  memset(&sin, 0, sizeof(sin));
  800e70:	83 ec 04             	sub    $0x4,%esp
  800e73:	6a 10                	push   $0x10
  800e75:	6a 00                	push   $0x0
  800e77:	8d 45 d0             	lea    -0x30(%ebp),%eax
  800e7a:	50                   	push   %eax
  800e7b:	e8 8c e0 00 00       	call   80ef0c <memset>
  sin.sin_len = sizeof(sin);
  800e80:	c6 45 d0 10          	movb   $0x10,-0x30(%ebp)
  sin.sin_family = AF_INET;
  800e84:	c6 45 d1 02          	movb   $0x2,-0x2f(%ebp)
  sin.sin_port = htons(port);
  800e88:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  800e8c:	89 04 24             	mov    %eax,(%esp)
  800e8f:	e8 ee 68 00 00       	call   807782 <htons>
  800e94:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  800e98:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800e9b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  if (*addrlen > sizeof(sin))
  800e9e:	83 c4 10             	add    $0x10,%esp
  800ea1:	83 3f 10             	cmpl   $0x10,(%edi)
  800ea4:	76 06                	jbe    800eac <lwip_accept+0x8f>
    *addrlen = sizeof(sin);
  800ea6:	c7 07 10 00 00 00    	movl   $0x10,(%edi)
  SMEMCPY(addr, &sin, *addrlen);
  800eac:	83 ec 04             	sub    $0x4,%esp
  800eaf:	ff 37                	pushl  (%edi)
  800eb1:	8d 45 d0             	lea    -0x30(%ebp),%eax
  800eb4:	50                   	push   %eax
  800eb5:	ff 75 0c             	pushl  0xc(%ebp)
  800eb8:	e8 04 e1 00 00       	call   80efc1 <memcpy>
  newsock = alloc_socket(newconn);
  800ebd:	89 d8                	mov    %ebx,%eax
  800ebf:	e8 ec fb ff ff       	call   800ab0 <alloc_socket>
  800ec4:	89 c7                	mov    %eax,%edi
  if (newsock == -1) {
  800ec6:	83 c4 10             	add    $0x10,%esp
  800ec9:	83 f8 ff             	cmp    $0xffffffff,%eax
  800ecc:	0f 84 ba 00 00 00    	je     800f8c <lwip_accept+0x16f>
  LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
  800ed2:	83 f8 1f             	cmp    $0x1f,%eax
  800ed5:	0f 87 d3 00 00 00    	ja     800fae <lwip_accept+0x191>
  newconn->callback = event_callback;
  800edb:	c7 43 2c ff 08 80 00 	movl   $0x8008ff,0x2c(%ebx)
  sys_sem_wait(socksem);
  800ee2:	83 ec 0c             	sub    $0xc,%esp
  800ee5:	ff 35 44 50 81 00    	pushl  0x815044
  800eeb:	e8 4b 42 00 00       	call   80513b <sys_sem_wait>
  nsock->rcvevent += -1 - newconn->socket;
  800ef0:	8d 04 bf             	lea    (%edi,%edi,4),%eax
  800ef3:	0f b7 53 1c          	movzwl 0x1c(%ebx),%edx
  800ef7:	f7 d2                	not    %edx
  800ef9:	66 01 14 85 6a 50 81 	add    %dx,0x81506a(,%eax,4)
  800f00:	00 
  newconn->socket = newsock;
  800f01:	89 7b 1c             	mov    %edi,0x1c(%ebx)
  sys_sem_signal(socksem);
  800f04:	83 c4 04             	add    $0x4,%esp
  800f07:	ff 35 44 50 81 00    	pushl  0x815044
  800f0d:	e8 12 92 00 00       	call   80a124 <sys_sem_signal>
  sock_set_errno(sock, 0);
  800f12:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
  800f19:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  800f20:	00 00 00 
  return newsock;
  800f23:	83 c4 10             	add    $0x10,%esp
}
  800f26:	89 f8                	mov    %edi,%eax
  800f28:	8d 65 f4             	lea    -0xc(%ebp),%esp
  800f2b:	5b                   	pop    %ebx
  800f2c:	5e                   	pop    %esi
  800f2d:	5f                   	pop    %edi
  800f2e:	5d                   	pop    %ebp
  800f2f:	c3                   	ret    
    sock_set_errno(sock, err_to_errno(sock->conn->err));
  800f30:	8b 06                	mov    (%esi),%eax
  800f32:	0f be 40 0c          	movsbl 0xc(%eax),%eax
  800f36:	f7 d8                	neg    %eax
  800f38:	ba 05 00 00 00       	mov    $0x5,%edx
  800f3d:	83 f8 0e             	cmp    $0xe,%eax
  800f40:	77 07                	ja     800f49 <lwip_accept+0x12c>
  800f42:	8b 14 85 60 12 81 00 	mov    0x811260(,%eax,4),%edx
  800f49:	89 56 10             	mov    %edx,0x10(%esi)
  800f4c:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
    return -1;
  800f52:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  800f57:	eb cd                	jmp    800f26 <lwip_accept+0x109>
    netconn_delete(newconn);
  800f59:	83 ec 0c             	sub    $0xc,%esp
  800f5c:	53                   	push   %ebx
  800f5d:	e8 ed 9d 00 00       	call   80ad4f <netconn_delete>
    sock_set_errno(sock, err_to_errno(err));
  800f62:	0f be 45 c7          	movsbl -0x39(%ebp),%eax
  800f66:	f7 d8                	neg    %eax
  800f68:	83 c4 10             	add    $0x10,%esp
  800f6b:	ba 05 00 00 00       	mov    $0x5,%edx
  800f70:	83 f8 0e             	cmp    $0xe,%eax
  800f73:	77 07                	ja     800f7c <lwip_accept+0x15f>
  800f75:	8b 14 85 60 12 81 00 	mov    0x811260(,%eax,4),%edx
  800f7c:	89 56 10             	mov    %edx,0x10(%esi)
  800f7f:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
    return -1;
  800f85:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  800f8a:	eb 9a                	jmp    800f26 <lwip_accept+0x109>
    netconn_delete(newconn);
  800f8c:	83 ec 0c             	sub    $0xc,%esp
  800f8f:	53                   	push   %ebx
  800f90:	e8 ba 9d 00 00       	call   80ad4f <netconn_delete>
    sock_set_errno(sock, ENFILE);
  800f95:	c7 46 10 17 00 00 00 	movl   $0x17,0x10(%esi)
  800f9c:	c7 05 e0 b1 b3 00 17 	movl   $0x17,0xb3b1e0
  800fa3:	00 00 00 
    return -1;
  800fa6:	83 c4 10             	add    $0x10,%esp
  800fa9:	e9 78 ff ff ff       	jmp    800f26 <lwip_accept+0x109>
  LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
  800fae:	83 ec 04             	sub    $0x4,%esp
  800fb1:	68 b3 11 81 00       	push   $0x8111b3
  800fb6:	68 25 01 00 00       	push   $0x125
  800fbb:	68 90 11 81 00       	push   $0x811190
  800fc0:	e8 8e d6 00 00       	call   80e653 <_panic>
    return -1;
  800fc5:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  800fca:	e9 57 ff ff ff       	jmp    800f26 <lwip_accept+0x109>

00800fcf <lwip_bind>:
{
  800fcf:	55                   	push   %ebp
  800fd0:	89 e5                	mov    %esp,%ebp
  800fd2:	56                   	push   %esi
  800fd3:	53                   	push   %ebx
  800fd4:	83 ec 10             	sub    $0x10,%esp
  800fd7:	8b 75 0c             	mov    0xc(%ebp),%esi
  sock = get_socket(s);
  800fda:	8b 45 08             	mov    0x8(%ebp),%eax
  800fdd:	e8 28 f7 ff ff       	call   80070a <get_socket>
  if (!sock)
  800fe2:	85 c0                	test   %eax,%eax
  800fe4:	0f 84 94 00 00 00    	je     80107e <lwip_bind+0xaf>
  800fea:	89 c3                	mov    %eax,%ebx
  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  800fec:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  800ff0:	75 4f                	jne    801041 <lwip_bind+0x72>
  800ff2:	80 7e 01 02          	cmpb   $0x2,0x1(%esi)
  800ff6:	75 49                	jne    801041 <lwip_bind+0x72>
  local_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  800ff8:	8b 46 04             	mov    0x4(%esi),%eax
  800ffb:	89 45 f4             	mov    %eax,-0xc(%ebp)
  err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
  800ffe:	83 ec 0c             	sub    $0xc,%esp
  801001:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  801005:	50                   	push   %eax
  801006:	e8 84 67 00 00       	call   80778f <ntohs>
  80100b:	83 c4 0c             	add    $0xc,%esp
  80100e:	0f b7 c0             	movzwl %ax,%eax
  801011:	50                   	push   %eax
  801012:	8d 45 f4             	lea    -0xc(%ebp),%eax
  801015:	50                   	push   %eax
  801016:	ff 33                	pushl  (%ebx)
  801018:	e8 26 9e 00 00       	call   80ae43 <netconn_bind>
  if (err != ERR_OK) {
  80101d:	83 c4 10             	add    $0x10,%esp
  801020:	84 c0                	test   %al,%al
  801022:	75 34                	jne    801058 <lwip_bind+0x89>
  sock_set_errno(sock, 0);
  801024:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  80102b:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801032:	00 00 00 
  return 0;
  801035:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80103a:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80103d:	5b                   	pop    %ebx
  80103e:	5e                   	pop    %esi
  80103f:	5d                   	pop    %ebp
  801040:	c3                   	ret    
  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  801041:	83 ec 04             	sub    $0x4,%esp
  801044:	68 c8 11 81 00       	push   $0x8111c8
  801049:	68 4a 01 00 00       	push   $0x14a
  80104e:	68 90 11 81 00       	push   $0x811190
  801053:	e8 fb d5 00 00       	call   80e653 <_panic>
    sock_set_errno(sock, err_to_errno(err));
  801058:	0f be c0             	movsbl %al,%eax
  80105b:	f7 d8                	neg    %eax
  80105d:	ba 05 00 00 00       	mov    $0x5,%edx
  801062:	83 f8 0e             	cmp    $0xe,%eax
  801065:	77 07                	ja     80106e <lwip_bind+0x9f>
  801067:	8b 14 85 60 12 81 00 	mov    0x811260(,%eax,4),%edx
  80106e:	89 53 10             	mov    %edx,0x10(%ebx)
  801071:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
    return -1;
  801077:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80107c:	eb bc                	jmp    80103a <lwip_bind+0x6b>
    return -1;
  80107e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801083:	eb b5                	jmp    80103a <lwip_bind+0x6b>

00801085 <lwip_close>:
{
  801085:	55                   	push   %ebp
  801086:	89 e5                	mov    %esp,%ebp
  801088:	53                   	push   %ebx
  801089:	83 ec 04             	sub    $0x4,%esp
  sock = get_socket(s);
  80108c:	8b 45 08             	mov    0x8(%ebp),%eax
  80108f:	e8 76 f6 ff ff       	call   80070a <get_socket>
  if (!sock) {
  801094:	85 c0                	test   %eax,%eax
  801096:	74 6f                	je     801107 <lwip_close+0x82>
  801098:	89 c3                	mov    %eax,%ebx
  netconn_delete(sock->conn);
  80109a:	83 ec 0c             	sub    $0xc,%esp
  80109d:	ff 30                	pushl  (%eax)
  80109f:	e8 ab 9c 00 00       	call   80ad4f <netconn_delete>
  sys_sem_wait(socksem);
  8010a4:	83 c4 04             	add    $0x4,%esp
  8010a7:	ff 35 44 50 81 00    	pushl  0x815044
  8010ad:	e8 89 40 00 00       	call   80513b <sys_sem_wait>
  if (sock->lastdata) {
  8010b2:	8b 43 04             	mov    0x4(%ebx),%eax
  8010b5:	83 c4 10             	add    $0x10,%esp
  8010b8:	85 c0                	test   %eax,%eax
  8010ba:	74 0c                	je     8010c8 <lwip_close+0x43>
    netbuf_delete(sock->lastdata);
  8010bc:	83 ec 0c             	sub    $0xc,%esp
  8010bf:	50                   	push   %eax
  8010c0:	e8 84 13 00 00       	call   802449 <netbuf_delete>
  8010c5:	83 c4 10             	add    $0x10,%esp
  sock->lastdata   = NULL;
  8010c8:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sock->lastoffset = 0;
  8010cf:	66 c7 43 08 00 00    	movw   $0x0,0x8(%ebx)
  sock->conn       = NULL;
  8010d5:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  sock_set_errno(sock, 0);
  8010db:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  8010e2:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  8010e9:	00 00 00 
  sys_sem_signal(socksem);
  8010ec:	83 ec 0c             	sub    $0xc,%esp
  8010ef:	ff 35 44 50 81 00    	pushl  0x815044
  8010f5:	e8 2a 90 00 00       	call   80a124 <sys_sem_signal>
  return 0;
  8010fa:	83 c4 10             	add    $0x10,%esp
  8010fd:	b8 00 00 00 00       	mov    $0x0,%eax
}
  801102:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  801105:	c9                   	leave  
  801106:	c3                   	ret    
    return -1;
  801107:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80110c:	eb f4                	jmp    801102 <lwip_close+0x7d>

0080110e <lwip_connect>:
{
  80110e:	55                   	push   %ebp
  80110f:	89 e5                	mov    %esp,%ebp
  801111:	56                   	push   %esi
  801112:	53                   	push   %ebx
  801113:	83 ec 10             	sub    $0x10,%esp
  801116:	8b 75 0c             	mov    0xc(%ebp),%esi
  sock = get_socket(s);
  801119:	8b 45 08             	mov    0x8(%ebp),%eax
  80111c:	e8 e9 f5 ff ff       	call   80070a <get_socket>
  if (!sock)
  801121:	85 c0                	test   %eax,%eax
  801123:	0f 84 94 00 00 00    	je     8011bd <lwip_connect+0xaf>
  801129:	89 c3                	mov    %eax,%ebx
  LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  80112b:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  80112f:	75 4f                	jne    801180 <lwip_connect+0x72>
  801131:	80 7e 01 02          	cmpb   $0x2,0x1(%esi)
  801135:	75 49                	jne    801180 <lwip_connect+0x72>
    remote_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  801137:	8b 46 04             	mov    0x4(%esi),%eax
  80113a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    err = netconn_connect(sock->conn, &remote_addr, ntohs(remote_port));
  80113d:	83 ec 0c             	sub    $0xc,%esp
  801140:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  801144:	50                   	push   %eax
  801145:	e8 45 66 00 00       	call   80778f <ntohs>
  80114a:	83 c4 0c             	add    $0xc,%esp
  80114d:	0f b7 c0             	movzwl %ax,%eax
  801150:	50                   	push   %eax
  801151:	8d 45 f4             	lea    -0xc(%ebp),%eax
  801154:	50                   	push   %eax
  801155:	ff 33                	pushl  (%ebx)
  801157:	e8 38 9d 00 00       	call   80ae94 <netconn_connect>
  if (err != ERR_OK) {
  80115c:	83 c4 10             	add    $0x10,%esp
  80115f:	84 c0                	test   %al,%al
  801161:	75 34                	jne    801197 <lwip_connect+0x89>
  sock_set_errno(sock, 0);
  801163:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  80116a:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801171:	00 00 00 
  return 0;
  801174:	b8 00 00 00 00       	mov    $0x0,%eax
}
  801179:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80117c:	5b                   	pop    %ebx
  80117d:	5e                   	pop    %esi
  80117e:	5d                   	pop    %ebp
  80117f:	c3                   	ret    
  LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  801180:	83 ec 04             	sub    $0x4,%esp
  801183:	68 e3 11 81 00       	push   $0x8111e3
  801188:	68 86 01 00 00       	push   $0x186
  80118d:	68 90 11 81 00       	push   $0x811190
  801192:	e8 bc d4 00 00       	call   80e653 <_panic>
    sock_set_errno(sock, err_to_errno(err));
  801197:	0f be c0             	movsbl %al,%eax
  80119a:	f7 d8                	neg    %eax
  80119c:	ba 05 00 00 00       	mov    $0x5,%edx
  8011a1:	83 f8 0e             	cmp    $0xe,%eax
  8011a4:	77 07                	ja     8011ad <lwip_connect+0x9f>
  8011a6:	8b 14 85 60 12 81 00 	mov    0x811260(,%eax,4),%edx
  8011ad:	89 53 10             	mov    %edx,0x10(%ebx)
  8011b0:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
    return -1;
  8011b6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8011bb:	eb bc                	jmp    801179 <lwip_connect+0x6b>
    return -1;
  8011bd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8011c2:	eb b5                	jmp    801179 <lwip_connect+0x6b>

008011c4 <lwip_listen>:
{
  8011c4:	55                   	push   %ebp
  8011c5:	89 e5                	mov    %esp,%ebp
  8011c7:	56                   	push   %esi
  8011c8:	53                   	push   %ebx
  8011c9:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  sock = get_socket(s);
  8011cc:	8b 45 08             	mov    0x8(%ebp),%eax
  8011cf:	e8 36 f5 ff ff       	call   80070a <get_socket>
  if (!sock)
  8011d4:	85 c0                	test   %eax,%eax
  8011d6:	74 72                	je     80124a <lwip_listen+0x86>
  8011d8:	89 c6                	mov    %eax,%esi
  8011da:	81 fb ff 00 00 00    	cmp    $0xff,%ebx
  8011e0:	b8 ff 00 00 00       	mov    $0xff,%eax
  8011e5:	0f 4f d8             	cmovg  %eax,%ebx
  err = netconn_listen_with_backlog(sock->conn, backlog);
  8011e8:	83 ec 08             	sub    $0x8,%esp
  8011eb:	85 db                	test   %ebx,%ebx
  8011ed:	b8 00 00 00 00       	mov    $0x0,%eax
  8011f2:	0f 48 d8             	cmovs  %eax,%ebx
  8011f5:	0f b6 db             	movzbl %bl,%ebx
  8011f8:	53                   	push   %ebx
  8011f9:	ff 36                	pushl  (%esi)
  8011fb:	e8 29 9d 00 00       	call   80af29 <netconn_listen_with_backlog>
  if (err != ERR_OK) {
  801200:	83 c4 10             	add    $0x10,%esp
  801203:	84 c0                	test   %al,%al
  801205:	75 1d                	jne    801224 <lwip_listen+0x60>
  sock_set_errno(sock, 0);
  801207:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
  80120e:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801215:	00 00 00 
  return 0;
  801218:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80121d:	8d 65 f8             	lea    -0x8(%ebp),%esp
  801220:	5b                   	pop    %ebx
  801221:	5e                   	pop    %esi
  801222:	5d                   	pop    %ebp
  801223:	c3                   	ret    
    sock_set_errno(sock, err_to_errno(err));
  801224:	0f be c0             	movsbl %al,%eax
  801227:	f7 d8                	neg    %eax
  801229:	ba 05 00 00 00       	mov    $0x5,%edx
  80122e:	83 f8 0e             	cmp    $0xe,%eax
  801231:	77 07                	ja     80123a <lwip_listen+0x76>
  801233:	8b 14 85 60 12 81 00 	mov    0x811260(,%eax,4),%edx
  80123a:	89 56 10             	mov    %edx,0x10(%esi)
  80123d:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
    return -1;
  801243:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801248:	eb d3                	jmp    80121d <lwip_listen+0x59>
    return -1;
  80124a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80124f:	eb cc                	jmp    80121d <lwip_listen+0x59>

00801251 <lwip_recvfrom>:
{
  801251:	55                   	push   %ebp
  801252:	89 e5                	mov    %esp,%ebp
  801254:	57                   	push   %edi
  801255:	56                   	push   %esi
  801256:	53                   	push   %ebx
  801257:	83 ec 3c             	sub    $0x3c,%esp
  sock = get_socket(s);
  80125a:	8b 45 08             	mov    0x8(%ebp),%eax
  80125d:	e8 a8 f4 ff ff       	call   80070a <get_socket>
  if (!sock)
  801262:	85 c0                	test   %eax,%eax
  801264:	0f 84 30 02 00 00    	je     80149a <lwip_recvfrom+0x249>
  80126a:	89 c7                	mov    %eax,%edi
  u16_t               buflen, copylen, off = 0;
  80126c:	66 c7 45 c0 00 00    	movw   $0x0,-0x40(%ebp)
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
  801272:	8b 45 14             	mov    0x14(%ebp),%eax
  801275:	83 e0 08             	and    $0x8,%eax
  801278:	89 45 b8             	mov    %eax,-0x48(%ebp)
  80127b:	e9 b9 00 00 00       	jmp    801339 <lwip_recvfrom+0xe8>
  801280:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
  801284:	75 06                	jne    80128c <lwip_recvfrom+0x3b>
  801286:	f6 47 0f 08          	testb  $0x8,0xf(%edi)
  80128a:	74 07                	je     801293 <lwip_recvfrom+0x42>
  80128c:	66 83 7f 0a 00       	cmpw   $0x0,0xa(%edi)
  801291:	74 56                	je     8012e9 <lwip_recvfrom+0x98>
      sock->lastdata = buf = netconn_recv(sock->conn);
  801293:	83 ec 0c             	sub    $0xc,%esp
  801296:	ff 37                	pushl  (%edi)
  801298:	e8 42 9d 00 00       	call   80afdf <netconn_recv>
  80129d:	89 c6                	mov    %eax,%esi
  80129f:	89 47 04             	mov    %eax,0x4(%edi)
      if (!buf) {
  8012a2:	83 c4 10             	add    $0x10,%esp
  8012a5:	85 c0                	test   %eax,%eax
  8012a7:	0f 85 97 00 00 00    	jne    801344 <lwip_recvfrom+0xf3>
        sock_set_errno(sock, (((sock->conn->pcb.ip!=NULL) && (sock->conn->err==ERR_OK))?ETIMEDOUT:err_to_errno(sock->conn->err)));
  8012ad:	8b 17                	mov    (%edi),%edx
  8012af:	83 7a 08 00          	cmpl   $0x0,0x8(%edx)
  8012b3:	74 0b                	je     8012c0 <lwip_recvfrom+0x6f>
  8012b5:	b8 6e 00 00 00       	mov    $0x6e,%eax
  8012ba:	80 7a 0c 00          	cmpb   $0x0,0xc(%edx)
  8012be:	74 17                	je     8012d7 <lwip_recvfrom+0x86>
  8012c0:	0f be 52 0c          	movsbl 0xc(%edx),%edx
  8012c4:	f7 da                	neg    %edx
  8012c6:	b8 05 00 00 00       	mov    $0x5,%eax
  8012cb:	83 fa 0e             	cmp    $0xe,%edx
  8012ce:	77 07                	ja     8012d7 <lwip_recvfrom+0x86>
  8012d0:	8b 04 95 60 12 81 00 	mov    0x811260(,%edx,4),%eax
  8012d7:	89 47 10             	mov    %eax,0x10(%edi)
  8012da:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
        return 0;
  8012df:	b8 00 00 00 00       	mov    $0x0,%eax
  8012e4:	e9 19 01 00 00       	jmp    801402 <lwip_recvfrom+0x1b1>
        sock_set_errno(sock, EWOULDBLOCK);
  8012e9:	c7 47 10 0b 00 00 00 	movl   $0xb,0x10(%edi)
  8012f0:	c7 05 e0 b1 b3 00 0b 	movl   $0xb,0xb3b1e0
  8012f7:	00 00 00 
        return -1;
  8012fa:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8012ff:	e9 fe 00 00 00       	jmp    801402 <lwip_recvfrom+0x1b1>
      done = 1;
  801304:	c6 45 c3 01          	movb   $0x1,-0x3d(%ebp)
  801308:	e9 a9 00 00 00       	jmp    8013b6 <lwip_recvfrom+0x165>
        done = 1;
  80130d:	c6 45 c3 01          	movb   $0x1,-0x3d(%ebp)
  801311:	e9 a0 00 00 00       	jmp    8013b6 <lwip_recvfrom+0x165>
        sock->lastdata = NULL;
  801316:	c7 47 04 00 00 00 00 	movl   $0x0,0x4(%edi)
        sock->lastoffset = 0;
  80131d:	66 c7 47 08 00 00    	movw   $0x0,0x8(%edi)
        netbuf_delete(buf);
  801323:	83 ec 0c             	sub    $0xc,%esp
  801326:	56                   	push   %esi
  801327:	e8 1d 11 00 00       	call   802449 <netbuf_delete>
  80132c:	83 c4 10             	add    $0x10,%esp
  } while (!done);
  80132f:	80 7d c3 00          	cmpb   $0x0,-0x3d(%ebp)
  801333:	0f 85 a8 00 00 00    	jne    8013e1 <lwip_recvfrom+0x190>
    if (sock->lastdata) {
  801339:	8b 77 04             	mov    0x4(%edi),%esi
  80133c:	85 f6                	test   %esi,%esi
  80133e:	0f 84 3c ff ff ff    	je     801280 <lwip_recvfrom+0x2f>
    buflen = netbuf_len(buf);
  801344:	8b 16                	mov    (%esi),%edx
    buflen -= sock->lastoffset;
  801346:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80134a:	0f b7 5a 08          	movzwl 0x8(%edx),%ebx
  80134e:	29 c3                	sub    %eax,%ebx
    if (len > buflen) {
  801350:	0f b7 cb             	movzwl %bx,%ecx
  801353:	89 4d bc             	mov    %ecx,-0x44(%ebp)
      copylen = len;
  801356:	3b 4d 10             	cmp    0x10(%ebp),%ecx
  801359:	66 0f 4d 5d 10       	cmovge 0x10(%ebp),%bx
    netbuf_copy_partial(buf, (u8_t*)mem + off, copylen, sock->lastoffset);
  80135e:	0f b7 cb             	movzwl %bx,%ecx
  801361:	0f b7 c0             	movzwl %ax,%eax
  801364:	50                   	push   %eax
  801365:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
  801368:	51                   	push   %ecx
  801369:	0f b7 45 c0          	movzwl -0x40(%ebp),%eax
  80136d:	03 45 0c             	add    0xc(%ebp),%eax
  801370:	50                   	push   %eax
  801371:	52                   	push   %edx
  801372:	e8 60 3c 00 00       	call   804fd7 <pbuf_copy_partial>
    off += copylen;
  801377:	66 01 5d c0          	add    %bx,-0x40(%ebp)
    if (netconn_type(sock->conn) == NETCONN_TCP) {
  80137b:	83 c4 04             	add    $0x4,%esp
  80137e:	ff 37                	pushl  (%edi)
  801380:	e8 0a 9a 00 00       	call   80ad8f <netconn_type>
  801385:	83 c4 10             	add    $0x10,%esp
  801388:	83 f8 10             	cmp    $0x10,%eax
  80138b:	0f 85 73 ff ff ff    	jne    801304 <lwip_recvfrom+0xb3>
      len -= copylen;
  801391:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
  801394:	29 4d 10             	sub    %ecx,0x10(%ebp)
      if ( (len <= 0) || (buf->p->flags & PBUF_FLAG_PUSH) || !sock->rcvevent) {
  801397:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  80139b:	0f 8e 6c ff ff ff    	jle    80130d <lwip_recvfrom+0xbc>
  8013a1:	8b 06                	mov    (%esi),%eax
        done = 1;
  8013a3:	c6 45 c3 01          	movb   $0x1,-0x3d(%ebp)
      if ( (len <= 0) || (buf->p->flags & PBUF_FLAG_PUSH) || !sock->rcvevent) {
  8013a7:	f6 40 0d 01          	testb  $0x1,0xd(%eax)
  8013ab:	75 09                	jne    8013b6 <lwip_recvfrom+0x165>
  8013ad:	66 83 7f 0a 00       	cmpw   $0x0,0xa(%edi)
  8013b2:	0f 94 45 c3          	sete   -0x3d(%ebp)
    if ((flags & MSG_PEEK)==0) {
  8013b6:	f6 45 14 01          	testb  $0x1,0x14(%ebp)
  8013ba:	75 25                	jne    8013e1 <lwip_recvfrom+0x190>
      if ((sock->conn->type == NETCONN_TCP) && (buflen - copylen > 0)) {
  8013bc:	8b 07                	mov    (%edi),%eax
  8013be:	83 38 10             	cmpl   $0x10,(%eax)
  8013c1:	0f 85 4f ff ff ff    	jne    801316 <lwip_recvfrom+0xc5>
  8013c7:	8b 45 bc             	mov    -0x44(%ebp),%eax
  8013ca:	2b 45 c4             	sub    -0x3c(%ebp),%eax
  8013cd:	85 c0                	test   %eax,%eax
  8013cf:	0f 8e 41 ff ff ff    	jle    801316 <lwip_recvfrom+0xc5>
        sock->lastdata = buf;
  8013d5:	89 77 04             	mov    %esi,0x4(%edi)
        sock->lastoffset += copylen;
  8013d8:	66 01 5f 08          	add    %bx,0x8(%edi)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: lastdata now netbuf=%p\n", (void*)buf));
  8013dc:	e9 4e ff ff ff       	jmp    80132f <lwip_recvfrom+0xde>
  if (from && fromlen) {
  8013e1:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  8013e5:	74 06                	je     8013ed <lwip_recvfrom+0x19c>
  8013e7:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  8013eb:	75 1d                	jne    80140a <lwip_recvfrom+0x1b9>
  sock_set_errno(sock, 0);
  8013ed:	c7 47 10 00 00 00 00 	movl   $0x0,0x10(%edi)
  8013f4:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  8013fb:	00 00 00 
  return off;
  8013fe:	0f b7 45 c0          	movzwl -0x40(%ebp),%eax
}
  801402:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801405:	5b                   	pop    %ebx
  801406:	5e                   	pop    %esi
  801407:	5f                   	pop    %edi
  801408:	5d                   	pop    %ebp
  801409:	c3                   	ret    
    if (netconn_type(sock->conn) == NETCONN_TCP) {
  80140a:	83 ec 0c             	sub    $0xc,%esp
  80140d:	ff 37                	pushl  (%edi)
  80140f:	e8 7b 99 00 00       	call   80ad8f <netconn_type>
  801414:	83 c4 10             	add    $0x10,%esp
  801417:	83 f8 10             	cmp    $0x10,%eax
  80141a:	74 65                	je     801481 <lwip_recvfrom+0x230>
      addr = netbuf_fromaddr(buf);
  80141c:	8b 5e 08             	mov    0x8(%esi),%ebx
      port = netbuf_fromport(buf);
  80141f:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  801423:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
    memset(&sin, 0, sizeof(sin));
  801427:	83 ec 04             	sub    $0x4,%esp
  80142a:	6a 10                	push   $0x10
  80142c:	6a 00                	push   $0x0
  80142e:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  801431:	50                   	push   %eax
  801432:	e8 d5 da 00 00       	call   80ef0c <memset>
    sin.sin_len = sizeof(sin);
  801437:	c6 45 d4 10          	movb   $0x10,-0x2c(%ebp)
    sin.sin_family = AF_INET;
  80143b:	c6 45 d5 02          	movb   $0x2,-0x2b(%ebp)
    sin.sin_port = htons(port);
  80143f:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  801443:	89 04 24             	mov    %eax,(%esp)
  801446:	e8 37 63 00 00       	call   807782 <htons>
  80144b:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
    sin.sin_addr.s_addr = addr->addr;
  80144f:	8b 03                	mov    (%ebx),%eax
  801451:	89 45 d8             	mov    %eax,-0x28(%ebp)
    if (*fromlen > sizeof(sin))
  801454:	83 c4 10             	add    $0x10,%esp
  801457:	8b 45 1c             	mov    0x1c(%ebp),%eax
  80145a:	83 38 10             	cmpl   $0x10,(%eax)
  80145d:	76 06                	jbe    801465 <lwip_recvfrom+0x214>
      *fromlen = sizeof(sin);
  80145f:	c7 00 10 00 00 00    	movl   $0x10,(%eax)
    SMEMCPY(from, &sin, *fromlen);
  801465:	83 ec 04             	sub    $0x4,%esp
  801468:	8b 45 1c             	mov    0x1c(%ebp),%eax
  80146b:	ff 30                	pushl  (%eax)
  80146d:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  801470:	50                   	push   %eax
  801471:	ff 75 18             	pushl  0x18(%ebp)
  801474:	e8 48 db 00 00       	call   80efc1 <memcpy>
  801479:	83 c4 10             	add    $0x10,%esp
  80147c:	e9 6c ff ff ff       	jmp    8013ed <lwip_recvfrom+0x19c>
      netconn_getaddr(sock->conn, addr, &port, 0);
  801481:	6a 00                	push   $0x0
  801483:	8d 45 e6             	lea    -0x1a(%ebp),%eax
  801486:	50                   	push   %eax
  801487:	8d 45 d8             	lea    -0x28(%ebp),%eax
  80148a:	50                   	push   %eax
  80148b:	ff 37                	pushl  (%edi)
  80148d:	e8 25 99 00 00       	call   80adb7 <netconn_getaddr>
  801492:	83 c4 10             	add    $0x10,%esp
      addr = (struct ip_addr*)&(sin.sin_addr.s_addr);
  801495:	8d 5d d8             	lea    -0x28(%ebp),%ebx
  801498:	eb 8d                	jmp    801427 <lwip_recvfrom+0x1d6>
    return -1;
  80149a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80149f:	e9 5e ff ff ff       	jmp    801402 <lwip_recvfrom+0x1b1>

008014a4 <lwip_read>:
{
  8014a4:	55                   	push   %ebp
  8014a5:	89 e5                	mov    %esp,%ebp
  8014a7:	83 ec 10             	sub    $0x10,%esp
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
  8014aa:	6a 00                	push   $0x0
  8014ac:	6a 00                	push   $0x0
  8014ae:	6a 00                	push   $0x0
  8014b0:	ff 75 10             	pushl  0x10(%ebp)
  8014b3:	ff 75 0c             	pushl  0xc(%ebp)
  8014b6:	ff 75 08             	pushl  0x8(%ebp)
  8014b9:	e8 93 fd ff ff       	call   801251 <lwip_recvfrom>
}
  8014be:	c9                   	leave  
  8014bf:	c3                   	ret    

008014c0 <lwip_recv>:
{
  8014c0:	55                   	push   %ebp
  8014c1:	89 e5                	mov    %esp,%ebp
  8014c3:	83 ec 10             	sub    $0x10,%esp
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
  8014c6:	6a 00                	push   $0x0
  8014c8:	6a 00                	push   $0x0
  8014ca:	ff 75 14             	pushl  0x14(%ebp)
  8014cd:	ff 75 10             	pushl  0x10(%ebp)
  8014d0:	ff 75 0c             	pushl  0xc(%ebp)
  8014d3:	ff 75 08             	pushl  0x8(%ebp)
  8014d6:	e8 76 fd ff ff       	call   801251 <lwip_recvfrom>
}
  8014db:	c9                   	leave  
  8014dc:	c3                   	ret    

008014dd <lwip_sendto>:
{
  8014dd:	55                   	push   %ebp
  8014de:	89 e5                	mov    %esp,%ebp
  8014e0:	57                   	push   %edi
  8014e1:	56                   	push   %esi
  8014e2:	53                   	push   %ebx
  8014e3:	83 ec 2c             	sub    $0x2c,%esp
  8014e6:	8b 75 10             	mov    0x10(%ebp),%esi
  8014e9:	8b 5d 18             	mov    0x18(%ebp),%ebx
  sock = get_socket(s);
  8014ec:	8b 45 08             	mov    0x8(%ebp),%eax
  8014ef:	e8 16 f2 ff ff       	call   80070a <get_socket>
  if (!sock)
  8014f4:	85 c0                	test   %eax,%eax
  8014f6:	0f 84 4c 01 00 00    	je     801648 <lwip_sendto+0x16b>
  8014fc:	89 c7                	mov    %eax,%edi
  if (sock->conn->type==NETCONN_TCP) {
  8014fe:	8b 00                	mov    (%eax),%eax
  801500:	83 38 10             	cmpl   $0x10,(%eax)
  801503:	0f 84 b9 00 00 00    	je     8015c2 <lwip_sendto+0xe5>
  LWIP_ASSERT("lwip_sendto: size must fit in u16_t",
  801509:	81 fe ff ff 00 00    	cmp    $0xffff,%esi
  80150f:	0f 87 c3 00 00 00    	ja     8015d8 <lwip_sendto+0xfb>
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
  801515:	85 db                	test   %ebx,%ebx
  801517:	0f 85 d2 00 00 00    	jne    8015ef <lwip_sendto+0x112>
  80151d:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  801521:	0f 85 c8 00 00 00    	jne    8015ef <lwip_sendto+0x112>
  buf.p = buf.ptr = NULL;
  801527:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  80152e:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  if (to) {
  801535:	85 db                	test   %ebx,%ebx
  801537:	0f 84 d9 00 00 00    	je     801616 <lwip_sendto+0x139>
    remote_addr.addr = ((struct sockaddr_in *)to)->sin_addr.s_addr;
  80153d:	8b 43 04             	mov    0x4(%ebx),%eax
  801540:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    remote_port      = ntohs(((struct sockaddr_in *)to)->sin_port);
  801543:	83 ec 0c             	sub    $0xc,%esp
  801546:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  80154a:	50                   	push   %eax
  80154b:	e8 3f 62 00 00       	call   80778f <ntohs>
    buf.addr         = &remote_addr;
  801550:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  801553:	89 55 dc             	mov    %edx,-0x24(%ebp)
    buf.port         = remote_port;
  801556:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  80155a:	83 c4 10             	add    $0x10,%esp
  if ((err = netbuf_ref(&buf, data, size)) == ERR_OK) {
  80155d:	83 ec 04             	sub    $0x4,%esp
  801560:	0f b7 c6             	movzwl %si,%eax
  801563:	50                   	push   %eax
  801564:	ff 75 0c             	pushl  0xc(%ebp)
  801567:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  80156a:	50                   	push   %eax
  80156b:	e8 db 0f 00 00       	call   80254b <netbuf_ref>
  801570:	0f be d8             	movsbl %al,%ebx
  801573:	83 c4 10             	add    $0x10,%esp
  801576:	85 db                	test   %ebx,%ebx
  801578:	0f 84 b1 00 00 00    	je     80162f <lwip_sendto+0x152>
  if (buf.p != NULL) {
  80157e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  801581:	85 c0                	test   %eax,%eax
  801583:	74 0c                	je     801591 <lwip_sendto+0xb4>
    pbuf_free(buf.p);
  801585:	83 ec 0c             	sub    $0xc,%esp
  801588:	50                   	push   %eax
  801589:	e8 bf 32 00 00       	call   80484d <pbuf_free>
  80158e:	83 c4 10             	add    $0x10,%esp
  sock_set_errno(sock, err_to_errno(err));
  801591:	89 da                	mov    %ebx,%edx
  801593:	f7 da                	neg    %edx
  801595:	b8 05 00 00 00       	mov    $0x5,%eax
  80159a:	83 fa 0e             	cmp    $0xe,%edx
  80159d:	77 07                	ja     8015a6 <lwip_sendto+0xc9>
  80159f:	8b 04 95 60 12 81 00 	mov    0x811260(,%edx,4),%eax
  8015a6:	89 47 10             	mov    %eax,0x10(%edi)
  8015a9:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
  return (err==ERR_OK?size:-1);
  8015ae:	85 db                	test   %ebx,%ebx
  8015b0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8015b5:	0f 45 f0             	cmovne %eax,%esi
}
  8015b8:	89 f0                	mov    %esi,%eax
  8015ba:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8015bd:	5b                   	pop    %ebx
  8015be:	5e                   	pop    %esi
  8015bf:	5f                   	pop    %edi
  8015c0:	5d                   	pop    %ebp
  8015c1:	c3                   	ret    
    return lwip_send(s, data, size, flags);
  8015c2:	ff 75 14             	pushl  0x14(%ebp)
  8015c5:	56                   	push   %esi
  8015c6:	ff 75 0c             	pushl  0xc(%ebp)
  8015c9:	ff 75 08             	pushl  0x8(%ebp)
  8015cc:	e8 81 00 00 00       	call   801652 <lwip_send>
  8015d1:	89 c6                	mov    %eax,%esi
  8015d3:	83 c4 10             	add    $0x10,%esp
  8015d6:	eb e0                	jmp    8015b8 <lwip_sendto+0xdb>
  LWIP_ASSERT("lwip_sendto: size must fit in u16_t",
  8015d8:	83 ec 04             	sub    $0x4,%esp
  8015db:	68 20 12 81 00       	push   $0x811220
  8015e0:	68 97 02 00 00       	push   $0x297
  8015e5:	68 90 11 81 00       	push   $0x811190
  8015ea:	e8 64 d0 00 00       	call   80e653 <_panic>
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
  8015ef:	83 7d 1c 10          	cmpl   $0x10,0x1c(%ebp)
  8015f3:	75 0a                	jne    8015ff <lwip_sendto+0x122>
  8015f5:	80 7b 01 02          	cmpb   $0x2,0x1(%ebx)
  8015f9:	0f 84 28 ff ff ff    	je     801527 <lwip_sendto+0x4a>
  8015ff:	83 ec 04             	sub    $0x4,%esp
  801602:	68 01 12 81 00       	push   $0x811201
  801607:	68 9b 02 00 00       	push   $0x29b
  80160c:	68 90 11 81 00       	push   $0x811190
  801611:	e8 3d d0 00 00       	call   80e653 <_panic>
    remote_addr.addr = 0;
  801616:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    buf.addr         = NULL;
  80161d:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
    buf.port         = 0;
  801624:	66 c7 45 e0 00 00    	movw   $0x0,-0x20(%ebp)
  80162a:	e9 2e ff ff ff       	jmp    80155d <lwip_sendto+0x80>
    err = netconn_send(sock->conn, &buf);
  80162f:	83 ec 08             	sub    $0x8,%esp
  801632:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  801635:	50                   	push   %eax
  801636:	ff 37                	pushl  (%edi)
  801638:	e8 46 9b 00 00       	call   80b183 <netconn_send>
  80163d:	0f be d8             	movsbl %al,%ebx
  801640:	83 c4 10             	add    $0x10,%esp
  801643:	e9 36 ff ff ff       	jmp    80157e <lwip_sendto+0xa1>
    return -1;
  801648:	be ff ff ff ff       	mov    $0xffffffff,%esi
  80164d:	e9 66 ff ff ff       	jmp    8015b8 <lwip_sendto+0xdb>

00801652 <lwip_send>:
{
  801652:	55                   	push   %ebp
  801653:	89 e5                	mov    %esp,%ebp
  801655:	57                   	push   %edi
  801656:	56                   	push   %esi
  801657:	53                   	push   %ebx
  801658:	83 ec 0c             	sub    $0xc,%esp
  80165b:	8b 7d 08             	mov    0x8(%ebp),%edi
  80165e:	8b 5d 10             	mov    0x10(%ebp),%ebx
  sock = get_socket(s);
  801661:	89 f8                	mov    %edi,%eax
  801663:	e8 a2 f0 ff ff       	call   80070a <get_socket>
  if (!sock)
  801668:	85 c0                	test   %eax,%eax
  80166a:	74 70                	je     8016dc <lwip_send+0x8a>
  80166c:	89 c6                	mov    %eax,%esi
  if (sock->conn->type!=NETCONN_TCP) {
  80166e:	8b 00                	mov    (%eax),%eax
  801670:	83 38 10             	cmpl   $0x10,(%eax)
  801673:	74 1f                	je     801694 <lwip_send+0x42>
    return lwip_sendto(s, data, size, flags, NULL, 0);
  801675:	83 ec 08             	sub    $0x8,%esp
  801678:	6a 00                	push   $0x0
  80167a:	6a 00                	push   $0x0
  80167c:	ff 75 14             	pushl  0x14(%ebp)
  80167f:	53                   	push   %ebx
  801680:	ff 75 0c             	pushl  0xc(%ebp)
  801683:	57                   	push   %edi
  801684:	e8 54 fe ff ff       	call   8014dd <lwip_sendto>
  801689:	83 c4 20             	add    $0x20,%esp
}
  80168c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80168f:	5b                   	pop    %ebx
  801690:	5e                   	pop    %esi
  801691:	5f                   	pop    %edi
  801692:	5d                   	pop    %ebp
  801693:	c3                   	ret    
  err = netconn_write(sock->conn, data, size, NETCONN_COPY | ((flags & MSG_MORE)?NETCONN_MORE:0));
  801694:	8b 55 14             	mov    0x14(%ebp),%edx
  801697:	c1 ea 03             	shr    $0x3,%edx
  80169a:	83 e2 02             	and    $0x2,%edx
  80169d:	83 ca 01             	or     $0x1,%edx
  8016a0:	0f b6 d2             	movzbl %dl,%edx
  8016a3:	52                   	push   %edx
  8016a4:	53                   	push   %ebx
  8016a5:	ff 75 0c             	pushl  0xc(%ebp)
  8016a8:	50                   	push   %eax
  8016a9:	e8 51 9b 00 00       	call   80b1ff <netconn_write>
  sock_set_errno(sock, err_to_errno(err));
  8016ae:	0f be d0             	movsbl %al,%edx
  8016b1:	f7 da                	neg    %edx
  8016b3:	83 c4 10             	add    $0x10,%esp
  8016b6:	b9 05 00 00 00       	mov    $0x5,%ecx
  8016bb:	83 fa 0e             	cmp    $0xe,%edx
  8016be:	77 07                	ja     8016c7 <lwip_send+0x75>
  8016c0:	8b 0c 95 60 12 81 00 	mov    0x811260(,%edx,4),%ecx
  8016c7:	89 4e 10             	mov    %ecx,0x10(%esi)
  8016ca:	89 0d e0 b1 b3 00    	mov    %ecx,0xb3b1e0
  return (err==ERR_OK?size:-1);
  8016d0:	84 c0                	test   %al,%al
  8016d2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8016d7:	0f 44 c3             	cmove  %ebx,%eax
  8016da:	eb b0                	jmp    80168c <lwip_send+0x3a>
    return -1;
  8016dc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8016e1:	eb a9                	jmp    80168c <lwip_send+0x3a>

008016e3 <lwip_socket>:
{
  8016e3:	55                   	push   %ebp
  8016e4:	89 e5                	mov    %esp,%ebp
  8016e6:	56                   	push   %esi
  8016e7:	53                   	push   %ebx
  8016e8:	8b 45 0c             	mov    0xc(%ebp),%eax
  switch (type) {
  8016eb:	83 f8 02             	cmp    $0x2,%eax
  8016ee:	74 5c                	je     80174c <lwip_socket+0x69>
  8016f0:	83 f8 03             	cmp    $0x3,%eax
  8016f3:	74 16                	je     80170b <lwip_socket+0x28>
  8016f5:	83 f8 01             	cmp    $0x1,%eax
  8016f8:	74 79                	je     801773 <lwip_socket+0x90>
    set_errno(EINVAL);
  8016fa:	c7 05 e0 b1 b3 00 16 	movl   $0x16,0xb3b1e0
  801701:	00 00 00 
    return -1;
  801704:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  801709:	eb 38                	jmp    801743 <lwip_socket+0x60>
    conn = netconn_new_with_proto_and_callback(NETCONN_RAW, (u8_t)protocol, event_callback);
  80170b:	83 ec 04             	sub    $0x4,%esp
  80170e:	68 ff 08 80 00       	push   $0x8008ff
  801713:	0f b6 45 10          	movzbl 0x10(%ebp),%eax
  801717:	50                   	push   %eax
  801718:	6a 40                	push   $0x40
  80171a:	e8 53 95 00 00       	call   80ac72 <netconn_new_with_proto_and_callback>
  80171f:	89 c6                	mov    %eax,%esi
    break;
  801721:	83 c4 10             	add    $0x10,%esp
  if (!conn) {
  801724:	85 f6                	test   %esi,%esi
  801726:	74 63                	je     80178b <lwip_socket+0xa8>
  i = alloc_socket(conn);
  801728:	89 f0                	mov    %esi,%eax
  80172a:	e8 81 f3 ff ff       	call   800ab0 <alloc_socket>
  80172f:	89 c3                	mov    %eax,%ebx
  if (i == -1) {
  801731:	83 f8 ff             	cmp    $0xffffffff,%eax
  801734:	74 66                	je     80179c <lwip_socket+0xb9>
  conn->socket = i;
  801736:	89 46 1c             	mov    %eax,0x1c(%esi)
  set_errno(0);
  801739:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801740:	00 00 00 
}
  801743:	89 d8                	mov    %ebx,%eax
  801745:	8d 65 f8             	lea    -0x8(%ebp),%esp
  801748:	5b                   	pop    %ebx
  801749:	5e                   	pop    %esi
  80174a:	5d                   	pop    %ebp
  80174b:	c3                   	ret    
    conn = netconn_new_with_callback( (protocol == IPPROTO_UDPLITE) ?
  80174c:	81 7d 10 88 00 00 00 	cmpl   $0x88,0x10(%ebp)
  801753:	0f 94 c0             	sete   %al
  801756:	0f b6 c0             	movzbl %al,%eax
  801759:	83 c0 20             	add    $0x20,%eax
  80175c:	83 ec 04             	sub    $0x4,%esp
  80175f:	68 ff 08 80 00       	push   $0x8008ff
  801764:	6a 00                	push   $0x0
  801766:	50                   	push   %eax
  801767:	e8 06 95 00 00       	call   80ac72 <netconn_new_with_proto_and_callback>
  80176c:	89 c6                	mov    %eax,%esi
    break;
  80176e:	83 c4 10             	add    $0x10,%esp
  801771:	eb b1                	jmp    801724 <lwip_socket+0x41>
    conn = netconn_new_with_callback(NETCONN_TCP, event_callback);
  801773:	83 ec 04             	sub    $0x4,%esp
  801776:	68 ff 08 80 00       	push   $0x8008ff
  80177b:	6a 00                	push   $0x0
  80177d:	6a 10                	push   $0x10
  80177f:	e8 ee 94 00 00       	call   80ac72 <netconn_new_with_proto_and_callback>
  801784:	89 c6                	mov    %eax,%esi
    break;
  801786:	83 c4 10             	add    $0x10,%esp
  801789:	eb 99                	jmp    801724 <lwip_socket+0x41>
    set_errno(ENOBUFS);
  80178b:	c7 05 e0 b1 b3 00 69 	movl   $0x69,0xb3b1e0
  801792:	00 00 00 
    return -1;
  801795:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  80179a:	eb a7                	jmp    801743 <lwip_socket+0x60>
    netconn_delete(conn);
  80179c:	83 ec 0c             	sub    $0xc,%esp
  80179f:	56                   	push   %esi
  8017a0:	e8 aa 95 00 00       	call   80ad4f <netconn_delete>
    set_errno(ENFILE);
  8017a5:	c7 05 e0 b1 b3 00 17 	movl   $0x17,0xb3b1e0
  8017ac:	00 00 00 
    return -1;
  8017af:	83 c4 10             	add    $0x10,%esp
  8017b2:	eb 8f                	jmp    801743 <lwip_socket+0x60>

008017b4 <lwip_write>:
{
  8017b4:	55                   	push   %ebp
  8017b5:	89 e5                	mov    %esp,%ebp
  8017b7:	83 ec 08             	sub    $0x8,%esp
  return lwip_send(s, data, size, 0);
  8017ba:	6a 00                	push   $0x0
  8017bc:	ff 75 10             	pushl  0x10(%ebp)
  8017bf:	ff 75 0c             	pushl  0xc(%ebp)
  8017c2:	ff 75 08             	pushl  0x8(%ebp)
  8017c5:	e8 88 fe ff ff       	call   801652 <lwip_send>
}
  8017ca:	c9                   	leave  
  8017cb:	c3                   	ret    

008017cc <lwip_select>:
{
  8017cc:	55                   	push   %ebp
  8017cd:	89 e5                	mov    %esp,%ebp
  8017cf:	57                   	push   %edi
  8017d0:	56                   	push   %esi
  8017d1:	53                   	push   %ebx
  8017d2:	83 ec 58             	sub    $0x58,%esp
  8017d5:	8b 7d 0c             	mov    0xc(%ebp),%edi
  8017d8:	8b 75 10             	mov    0x10(%ebp),%esi
  8017db:	8b 5d 14             	mov    0x14(%ebp),%ebx
  select_cb.next = 0;
  8017de:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  select_cb.readset = readset;
  8017e5:	89 7d c8             	mov    %edi,-0x38(%ebp)
  select_cb.writeset = writeset;
  8017e8:	89 75 cc             	mov    %esi,-0x34(%ebp)
  select_cb.exceptset = exceptset;
  8017eb:	89 5d d0             	mov    %ebx,-0x30(%ebp)
  select_cb.sem_signalled = 0;
  8017ee:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  sys_sem_wait(selectsem);
  8017f5:	ff 35 40 50 81 00    	pushl  0x815040
  8017fb:	e8 3b 39 00 00       	call   80513b <sys_sem_wait>
  if (readset)
  801800:	83 c4 10             	add    $0x10,%esp
  801803:	85 ff                	test   %edi,%edi
  801805:	0f 84 07 01 00 00    	je     801912 <lwip_select+0x146>
    lreadset = *readset;
  80180b:	8b 07                	mov    (%edi),%eax
  80180d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if (writeset)
  801810:	85 f6                	test   %esi,%esi
  801812:	0f 84 12 01 00 00    	je     80192a <lwip_select+0x15e>
    lwriteset = *writeset;
  801818:	8b 06                	mov    (%esi),%eax
  80181a:	89 45 e0             	mov    %eax,-0x20(%ebp)
  if (exceptset)
  80181d:	85 db                	test   %ebx,%ebx
  80181f:	0f 84 1d 01 00 00    	je     801942 <lwip_select+0x176>
    lexceptset = *exceptset;
  801825:	8b 03                	mov    (%ebx),%eax
  801827:	89 45 dc             	mov    %eax,-0x24(%ebp)
  nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  80182a:	83 ec 0c             	sub    $0xc,%esp
  80182d:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801830:	50                   	push   %eax
  801831:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  801834:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  801837:	8b 45 08             	mov    0x8(%ebp),%eax
  80183a:	e8 10 ef ff ff       	call   80074f <lwip_selscan>
  80183f:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  if (!nready) {
  801842:	83 c4 10             	add    $0x10,%esp
  801845:	85 c0                	test   %eax,%eax
  801847:	0f 85 5c 02 00 00    	jne    801aa9 <lwip_select+0x2dd>
    if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
  80184d:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  801851:	0f 84 93 02 00 00    	je     801aea <lwip_select+0x31e>
  801857:	8b 45 18             	mov    0x18(%ebp),%eax
  80185a:	83 38 00             	cmpl   $0x0,(%eax)
  80185d:	75 0a                	jne    801869 <lwip_select+0x9d>
  80185f:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  801863:	0f 84 f1 00 00 00    	je     80195a <lwip_select+0x18e>
    select_cb.sem = sys_sem_new(0);
  801869:	83 ec 0c             	sub    $0xc,%esp
  80186c:	6a 00                	push   $0x0
  80186e:	e8 f4 85 00 00       	call   809e67 <sys_sem_new>
  801873:	89 45 d8             	mov    %eax,-0x28(%ebp)
    select_cb.next = select_cb_list;
  801876:	a1 48 50 81 00       	mov    0x815048,%eax
  80187b:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    select_cb_list = &select_cb;
  80187e:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  801881:	a3 48 50 81 00       	mov    %eax,0x815048
    sys_sem_signal(selectsem);
  801886:	83 c4 04             	add    $0x4,%esp
  801889:	ff 35 40 50 81 00    	pushl  0x815040
  80188f:	e8 90 88 00 00       	call   80a124 <sys_sem_signal>
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
  801894:	8b 45 18             	mov    0x18(%ebp),%eax
  801897:	8b 40 04             	mov    0x4(%eax),%eax
  80189a:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  80189d:	8d 88 f4 01 00 00    	lea    0x1f4(%eax),%ecx
  8018a3:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  8018a8:	89 c8                	mov    %ecx,%eax
  8018aa:	f7 ea                	imul   %edx
  8018ac:	c1 fa 06             	sar    $0x6,%edx
  8018af:	c1 f9 1f             	sar    $0x1f,%ecx
  8018b2:	29 ca                	sub    %ecx,%edx
  8018b4:	8b 45 18             	mov    0x18(%ebp),%eax
  8018b7:	69 00 e8 03 00 00    	imul   $0x3e8,(%eax),%eax
      if(msectimeout == 0)
  8018bd:	83 c4 10             	add    $0x10,%esp
  8018c0:	01 d0                	add    %edx,%eax
        msectimeout = 1;
  8018c2:	ba 01 00 00 00       	mov    $0x1,%edx
  8018c7:	0f 44 c2             	cmove  %edx,%eax
    i = sys_sem_wait_timeout(select_cb.sem, msectimeout);
  8018ca:	83 ec 08             	sub    $0x8,%esp
  8018cd:	50                   	push   %eax
  8018ce:	ff 75 d8             	pushl  -0x28(%ebp)
  8018d1:	e8 23 3a 00 00       	call   8052f9 <sys_sem_wait_timeout>
  8018d6:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    sys_sem_wait(selectsem);
  8018d9:	83 c4 04             	add    $0x4,%esp
  8018dc:	ff 35 40 50 81 00    	pushl  0x815040
  8018e2:	e8 54 38 00 00       	call   80513b <sys_sem_wait>
    if (select_cb_list == &select_cb)
  8018e7:	a1 48 50 81 00       	mov    0x815048,%eax
  8018ec:	8d 55 c4             	lea    -0x3c(%ebp),%edx
  8018ef:	83 c4 10             	add    $0x10,%esp
        if (p_selcb->next == &select_cb) {
  8018f2:	89 d1                	mov    %edx,%ecx
    if (select_cb_list == &select_cb)
  8018f4:	39 d0                	cmp    %edx,%eax
  8018f6:	0f 84 ba 00 00 00    	je     8019b6 <lwip_select+0x1ea>
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  8018fc:	85 c0                	test   %eax,%eax
  8018fe:	0f 84 c1 00 00 00    	je     8019c5 <lwip_select+0x1f9>
        if (p_selcb->next == &select_cb) {
  801904:	8b 10                	mov    (%eax),%edx
  801906:	39 ca                	cmp    %ecx,%edx
  801908:	0f 84 b2 00 00 00    	je     8019c0 <lwip_select+0x1f4>
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  80190e:	89 d0                	mov    %edx,%eax
  801910:	eb ea                	jmp    8018fc <lwip_select+0x130>
    FD_ZERO(&lreadset);
  801912:	83 ec 04             	sub    $0x4,%esp
  801915:	6a 04                	push   $0x4
  801917:	6a 00                	push   $0x0
  801919:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80191c:	50                   	push   %eax
  80191d:	e8 ea d5 00 00       	call   80ef0c <memset>
  801922:	83 c4 10             	add    $0x10,%esp
  801925:	e9 e6 fe ff ff       	jmp    801810 <lwip_select+0x44>
    FD_ZERO(&lwriteset);
  80192a:	83 ec 04             	sub    $0x4,%esp
  80192d:	6a 04                	push   $0x4
  80192f:	6a 00                	push   $0x0
  801931:	8d 45 e0             	lea    -0x20(%ebp),%eax
  801934:	50                   	push   %eax
  801935:	e8 d2 d5 00 00       	call   80ef0c <memset>
  80193a:	83 c4 10             	add    $0x10,%esp
  80193d:	e9 db fe ff ff       	jmp    80181d <lwip_select+0x51>
    FD_ZERO(&lexceptset);
  801942:	83 ec 04             	sub    $0x4,%esp
  801945:	6a 04                	push   $0x4
  801947:	6a 00                	push   $0x0
  801949:	8d 45 dc             	lea    -0x24(%ebp),%eax
  80194c:	50                   	push   %eax
  80194d:	e8 ba d5 00 00       	call   80ef0c <memset>
  801952:	83 c4 10             	add    $0x10,%esp
  801955:	e9 d0 fe ff ff       	jmp    80182a <lwip_select+0x5e>
      sys_sem_signal(selectsem);
  80195a:	83 ec 0c             	sub    $0xc,%esp
  80195d:	ff 35 40 50 81 00    	pushl  0x815040
  801963:	e8 bc 87 00 00       	call   80a124 <sys_sem_signal>
      if (readset)
  801968:	83 c4 10             	add    $0x10,%esp
  80196b:	85 ff                	test   %edi,%edi
  80196d:	74 10                	je     80197f <lwip_select+0x1b3>
        FD_ZERO(readset);
  80196f:	83 ec 04             	sub    $0x4,%esp
  801972:	6a 04                	push   $0x4
  801974:	6a 00                	push   $0x0
  801976:	57                   	push   %edi
  801977:	e8 90 d5 00 00       	call   80ef0c <memset>
  80197c:	83 c4 10             	add    $0x10,%esp
      if (writeset)
  80197f:	85 f6                	test   %esi,%esi
  801981:	74 10                	je     801993 <lwip_select+0x1c7>
        FD_ZERO(writeset);
  801983:	83 ec 04             	sub    $0x4,%esp
  801986:	6a 04                	push   $0x4
  801988:	6a 00                	push   $0x0
  80198a:	56                   	push   %esi
  80198b:	e8 7c d5 00 00       	call   80ef0c <memset>
  801990:	83 c4 10             	add    $0x10,%esp
      if (exceptset)
  801993:	85 db                	test   %ebx,%ebx
  801995:	74 10                	je     8019a7 <lwip_select+0x1db>
        FD_ZERO(exceptset);
  801997:	83 ec 04             	sub    $0x4,%esp
  80199a:	6a 04                	push   $0x4
  80199c:	6a 00                	push   $0x0
  80199e:	53                   	push   %ebx
  80199f:	e8 68 d5 00 00       	call   80ef0c <memset>
  8019a4:	83 c4 10             	add    $0x10,%esp
      set_errno(0);
  8019a7:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  8019ae:	00 00 00 
      return 0;
  8019b1:	e9 29 01 00 00       	jmp    801adf <lwip_select+0x313>
      select_cb_list = select_cb.next;
  8019b6:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  8019b9:	a3 48 50 81 00       	mov    %eax,0x815048
  8019be:	eb 05                	jmp    8019c5 <lwip_select+0x1f9>
          p_selcb->next = select_cb.next;
  8019c0:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  8019c3:	89 10                	mov    %edx,(%eax)
    sys_sem_signal(selectsem);
  8019c5:	83 ec 0c             	sub    $0xc,%esp
  8019c8:	ff 35 40 50 81 00    	pushl  0x815040
  8019ce:	e8 51 87 00 00       	call   80a124 <sys_sem_signal>
    sys_sem_free(select_cb.sem);
  8019d3:	83 c4 04             	add    $0x4,%esp
  8019d6:	ff 75 d8             	pushl  -0x28(%ebp)
  8019d9:	e8 0a 85 00 00       	call   809ee8 <sys_sem_free>
    if (i == 0)  {
  8019de:	83 c4 10             	add    $0x10,%esp
  8019e1:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
  8019e5:	75 4b                	jne    801a32 <lwip_select+0x266>
      if (readset)
  8019e7:	85 ff                	test   %edi,%edi
  8019e9:	74 10                	je     8019fb <lwip_select+0x22f>
        FD_ZERO(readset);
  8019eb:	83 ec 04             	sub    $0x4,%esp
  8019ee:	6a 04                	push   $0x4
  8019f0:	6a 00                	push   $0x0
  8019f2:	57                   	push   %edi
  8019f3:	e8 14 d5 00 00       	call   80ef0c <memset>
  8019f8:	83 c4 10             	add    $0x10,%esp
      if (writeset)
  8019fb:	85 f6                	test   %esi,%esi
  8019fd:	74 10                	je     801a0f <lwip_select+0x243>
        FD_ZERO(writeset);
  8019ff:	83 ec 04             	sub    $0x4,%esp
  801a02:	6a 04                	push   $0x4
  801a04:	6a 00                	push   $0x0
  801a06:	56                   	push   %esi
  801a07:	e8 00 d5 00 00       	call   80ef0c <memset>
  801a0c:	83 c4 10             	add    $0x10,%esp
      if (exceptset)
  801a0f:	85 db                	test   %ebx,%ebx
  801a11:	74 10                	je     801a23 <lwip_select+0x257>
        FD_ZERO(exceptset);
  801a13:	83 ec 04             	sub    $0x4,%esp
  801a16:	6a 04                	push   $0x4
  801a18:	6a 00                	push   $0x0
  801a1a:	53                   	push   %ebx
  801a1b:	e8 ec d4 00 00       	call   80ef0c <memset>
  801a20:	83 c4 10             	add    $0x10,%esp
      set_errno(0);
  801a23:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801a2a:	00 00 00 
      return 0;
  801a2d:	e9 ad 00 00 00       	jmp    801adf <lwip_select+0x313>
    if (readset)
  801a32:	85 ff                	test   %edi,%edi
  801a34:	74 34                	je     801a6a <lwip_select+0x29e>
      lreadset = *readset;
  801a36:	8b 07                	mov    (%edi),%eax
  801a38:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (writeset)
  801a3b:	85 f6                	test   %esi,%esi
  801a3d:	74 40                	je     801a7f <lwip_select+0x2b3>
      lwriteset = *writeset;
  801a3f:	8b 06                	mov    (%esi),%eax
  801a41:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if (exceptset)
  801a44:	85 db                	test   %ebx,%ebx
  801a46:	74 4c                	je     801a94 <lwip_select+0x2c8>
      lexceptset = *exceptset;
  801a48:	8b 03                	mov    (%ebx),%eax
  801a4a:	89 45 dc             	mov    %eax,-0x24(%ebp)
    nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  801a4d:	83 ec 0c             	sub    $0xc,%esp
  801a50:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801a53:	50                   	push   %eax
  801a54:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  801a57:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  801a5a:	8b 45 08             	mov    0x8(%ebp),%eax
  801a5d:	e8 ed ec ff ff       	call   80074f <lwip_selscan>
  801a62:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  801a65:	83 c4 10             	add    $0x10,%esp
  801a68:	eb 50                	jmp    801aba <lwip_select+0x2ee>
      FD_ZERO(&lreadset);
  801a6a:	83 ec 04             	sub    $0x4,%esp
  801a6d:	6a 04                	push   $0x4
  801a6f:	6a 00                	push   $0x0
  801a71:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  801a74:	50                   	push   %eax
  801a75:	e8 92 d4 00 00       	call   80ef0c <memset>
  801a7a:	83 c4 10             	add    $0x10,%esp
  801a7d:	eb bc                	jmp    801a3b <lwip_select+0x26f>
      FD_ZERO(&lwriteset);
  801a7f:	83 ec 04             	sub    $0x4,%esp
  801a82:	6a 04                	push   $0x4
  801a84:	6a 00                	push   $0x0
  801a86:	8d 45 e0             	lea    -0x20(%ebp),%eax
  801a89:	50                   	push   %eax
  801a8a:	e8 7d d4 00 00       	call   80ef0c <memset>
  801a8f:	83 c4 10             	add    $0x10,%esp
  801a92:	eb b0                	jmp    801a44 <lwip_select+0x278>
      FD_ZERO(&lexceptset);
  801a94:	83 ec 04             	sub    $0x4,%esp
  801a97:	6a 04                	push   $0x4
  801a99:	6a 00                	push   $0x0
  801a9b:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801a9e:	50                   	push   %eax
  801a9f:	e8 68 d4 00 00       	call   80ef0c <memset>
  801aa4:	83 c4 10             	add    $0x10,%esp
  801aa7:	eb a4                	jmp    801a4d <lwip_select+0x281>
    sys_sem_signal(selectsem);
  801aa9:	83 ec 0c             	sub    $0xc,%esp
  801aac:	ff 35 40 50 81 00    	pushl  0x815040
  801ab2:	e8 6d 86 00 00       	call   80a124 <sys_sem_signal>
  801ab7:	83 c4 10             	add    $0x10,%esp
  if (readset)
  801aba:	85 ff                	test   %edi,%edi
  801abc:	74 05                	je     801ac3 <lwip_select+0x2f7>
    *readset = lreadset;
  801abe:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  801ac1:	89 07                	mov    %eax,(%edi)
  if (writeset)
  801ac3:	85 f6                	test   %esi,%esi
  801ac5:	74 05                	je     801acc <lwip_select+0x300>
    *writeset = lwriteset;
  801ac7:	8b 45 e0             	mov    -0x20(%ebp),%eax
  801aca:	89 06                	mov    %eax,(%esi)
  if (exceptset)
  801acc:	85 db                	test   %ebx,%ebx
  801ace:	74 05                	je     801ad5 <lwip_select+0x309>
    *exceptset = lexceptset;
  801ad0:	8b 45 dc             	mov    -0x24(%ebp),%eax
  801ad3:	89 03                	mov    %eax,(%ebx)
  set_errno(0);
  801ad5:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801adc:	00 00 00 
}
  801adf:	8b 45 b4             	mov    -0x4c(%ebp),%eax
  801ae2:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801ae5:	5b                   	pop    %ebx
  801ae6:	5e                   	pop    %esi
  801ae7:	5f                   	pop    %edi
  801ae8:	5d                   	pop    %ebp
  801ae9:	c3                   	ret    
    select_cb.sem = sys_sem_new(0);
  801aea:	83 ec 0c             	sub    $0xc,%esp
  801aed:	6a 00                	push   $0x0
  801aef:	e8 73 83 00 00       	call   809e67 <sys_sem_new>
  801af4:	89 45 d8             	mov    %eax,-0x28(%ebp)
    select_cb.next = select_cb_list;
  801af7:	a1 48 50 81 00       	mov    0x815048,%eax
  801afc:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    select_cb_list = &select_cb;
  801aff:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  801b02:	a3 48 50 81 00       	mov    %eax,0x815048
    sys_sem_signal(selectsem);
  801b07:	83 c4 04             	add    $0x4,%esp
  801b0a:	ff 35 40 50 81 00    	pushl  0x815040
  801b10:	e8 0f 86 00 00       	call   80a124 <sys_sem_signal>
  801b15:	83 c4 10             	add    $0x10,%esp
      msectimeout = 0;
  801b18:	b8 00 00 00 00       	mov    $0x0,%eax
  801b1d:	e9 a8 fd ff ff       	jmp    8018ca <lwip_select+0xfe>

00801b22 <lwip_shutdown>:
{
  801b22:	55                   	push   %ebp
  801b23:	89 e5                	mov    %esp,%ebp
  801b25:	83 ec 14             	sub    $0x14,%esp
  return lwip_close(s); /* XXX temporary hack until proper implementation */
  801b28:	ff 75 08             	pushl  0x8(%ebp)
  801b2b:	e8 55 f5 ff ff       	call   801085 <lwip_close>
}
  801b30:	c9                   	leave  
  801b31:	c3                   	ret    

00801b32 <lwip_getpeername>:
{
  801b32:	55                   	push   %ebp
  801b33:	89 e5                	mov    %esp,%ebp
  801b35:	83 ec 14             	sub    $0x14,%esp
  return lwip_getaddrname(s, name, namelen, 0);
  801b38:	6a 00                	push   $0x0
  801b3a:	8b 4d 10             	mov    0x10(%ebp),%ecx
  801b3d:	8b 55 0c             	mov    0xc(%ebp),%edx
  801b40:	8b 45 08             	mov    0x8(%ebp),%eax
  801b43:	e8 0c ed ff ff       	call   800854 <lwip_getaddrname>
}
  801b48:	c9                   	leave  
  801b49:	c3                   	ret    

00801b4a <lwip_getsockname>:
{
  801b4a:	55                   	push   %ebp
  801b4b:	89 e5                	mov    %esp,%ebp
  801b4d:	83 ec 14             	sub    $0x14,%esp
  return lwip_getaddrname(s, name, namelen, 1);
  801b50:	6a 01                	push   $0x1
  801b52:	8b 4d 10             	mov    0x10(%ebp),%ecx
  801b55:	8b 55 0c             	mov    0xc(%ebp),%edx
  801b58:	8b 45 08             	mov    0x8(%ebp),%eax
  801b5b:	e8 f4 ec ff ff       	call   800854 <lwip_getaddrname>
}
  801b60:	c9                   	leave  
  801b61:	c3                   	ret    

00801b62 <lwip_getsockopt>:
{
  801b62:	55                   	push   %ebp
  801b63:	89 e5                	mov    %esp,%ebp
  801b65:	57                   	push   %edi
  801b66:	56                   	push   %esi
  801b67:	53                   	push   %ebx
  801b68:	83 ec 2c             	sub    $0x2c,%esp
  801b6b:	8b 75 0c             	mov    0xc(%ebp),%esi
  801b6e:	8b 7d 18             	mov    0x18(%ebp),%edi
  struct lwip_socket *sock = get_socket(s);
  801b71:	8b 45 08             	mov    0x8(%ebp),%eax
  801b74:	e8 91 eb ff ff       	call   80070a <get_socket>
  if (!sock)
  801b79:	85 c0                	test   %eax,%eax
  801b7b:	0f 84 9c 01 00 00    	je     801d1d <lwip_getsockopt+0x1bb>
  801b81:	89 c3                	mov    %eax,%ebx
  if ((NULL == optval) || (NULL == optlen)) {
  801b83:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  801b87:	74 37                	je     801bc0 <lwip_getsockopt+0x5e>
  801b89:	85 ff                	test   %edi,%edi
  801b8b:	74 33                	je     801bc0 <lwip_getsockopt+0x5e>
  switch (level) {
  801b8d:	83 fe 06             	cmp    $0x6,%esi
  801b90:	0f 84 2f 01 00 00    	je     801cc5 <lwip_getsockopt+0x163>
  801b96:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
  801b9c:	74 3d                	je     801bdb <lwip_getsockopt+0x79>
      err = ENOPROTOOPT;
  801b9e:	b8 5c 00 00 00       	mov    $0x5c,%eax
  switch (level) {
  801ba3:	85 f6                	test   %esi,%esi
  801ba5:	0f 84 a2 00 00 00    	je     801c4d <lwip_getsockopt+0xeb>
    sock_set_errno(sock, err);
  801bab:	0f be c0             	movsbl %al,%eax
  801bae:	89 43 10             	mov    %eax,0x10(%ebx)
  801bb1:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
    return -1;
  801bb6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801bbb:	e9 fd 00 00 00       	jmp    801cbd <lwip_getsockopt+0x15b>
    sock_set_errno(sock, EFAULT);
  801bc0:	c7 43 10 0e 00 00 00 	movl   $0xe,0x10(%ebx)
  801bc7:	c7 05 e0 b1 b3 00 0e 	movl   $0xe,0xb3b1e0
  801bce:	00 00 00 
    return -1;
  801bd1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801bd6:	e9 e2 00 00 00       	jmp    801cbd <lwip_getsockopt+0x15b>
    switch (optname) {
  801bdb:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  801bdf:	74 5d                	je     801c3e <lwip_getsockopt+0xdc>
  801be1:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  801be5:	7e 41                	jle    801c28 <lwip_getsockopt+0xc6>
  801be7:	81 7d 10 07 10 00 00 	cmpl   $0x1007,0x10(%ebp)
  801bee:	7c 44                	jl     801c34 <lwip_getsockopt+0xd2>
  801bf0:	81 7d 10 08 10 00 00 	cmpl   $0x1008,0x10(%ebp)
  801bf7:	7e 45                	jle    801c3e <lwip_getsockopt+0xdc>
  801bf9:	81 7d 10 0a 10 00 00 	cmpl   $0x100a,0x10(%ebp)
  801c00:	75 32                	jne    801c34 <lwip_getsockopt+0xd2>
        err = EINVAL;
  801c02:	83 3f 04             	cmpl   $0x4,(%edi)
  801c05:	19 c0                	sbb    %eax,%eax
  801c07:	83 e0 16             	and    $0x16,%eax
      if ((sock->conn->type != NETCONN_UDP) ||
  801c0a:	8b 13                	mov    (%ebx),%edx
  801c0c:	83 3a 20             	cmpl   $0x20,(%edx)
  801c0f:	0f 85 d6 00 00 00    	jne    801ceb <lwip_getsockopt+0x189>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  801c15:	8b 52 08             	mov    0x8(%edx),%edx
      if ((sock->conn->type != NETCONN_UDP) ||
  801c18:	f6 42 10 02          	testb  $0x2,0x10(%edx)
  801c1c:	0f 85 d3 00 00 00    	jne    801cf5 <lwip_getsockopt+0x193>
  if (err != ERR_OK) {
  801c22:	84 c0                	test   %al,%al
  801c24:	74 3f                	je     801c65 <lwip_getsockopt+0x103>
  801c26:	eb 83                	jmp    801bab <lwip_getsockopt+0x49>
    switch (optname) {
  801c28:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
  801c2c:	74 10                	je     801c3e <lwip_getsockopt+0xdc>
  801c2e:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
  801c32:	74 0a                	je     801c3e <lwip_getsockopt+0xdc>
      err = ENOPROTOOPT;
  801c34:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801c39:	e9 6d ff ff ff       	jmp    801bab <lwip_getsockopt+0x49>
      if (*optlen < sizeof(int)) {
  801c3e:	83 3f 03             	cmpl   $0x3,(%edi)
  801c41:	77 22                	ja     801c65 <lwip_getsockopt+0x103>
        err = EINVAL;
  801c43:	b8 16 00 00 00       	mov    $0x16,%eax
  801c48:	e9 5e ff ff ff       	jmp    801bab <lwip_getsockopt+0x49>
    switch (optname) {
  801c4d:	8b 45 10             	mov    0x10(%ebp),%eax
  801c50:	83 e8 01             	sub    $0x1,%eax
  801c53:	83 f8 01             	cmp    $0x1,%eax
  801c56:	0f 87 a3 00 00 00    	ja     801cff <lwip_getsockopt+0x19d>
      if (*optlen < sizeof(int)) {
  801c5c:	83 3f 03             	cmpl   $0x3,(%edi)
  801c5f:	0f 86 a4 00 00 00    	jbe    801d09 <lwip_getsockopt+0x1a7>
  data.sock = sock;
  801c65:	89 5d cc             	mov    %ebx,-0x34(%ebp)
  data.level = level;
  801c68:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  data.optname = optname;
  801c6b:	8b 45 10             	mov    0x10(%ebp),%eax
  801c6e:	89 45 d8             	mov    %eax,-0x28(%ebp)
  data.optval = optval;
  801c71:	8b 45 14             	mov    0x14(%ebp),%eax
  801c74:	89 45 dc             	mov    %eax,-0x24(%ebp)
  data.optlen = optlen;
  801c77:	89 7d e0             	mov    %edi,-0x20(%ebp)
  data.err = err;
  801c7a:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  tcpip_callback(lwip_getsockopt_internal, &data);
  801c7e:	83 ec 04             	sub    $0x4,%esp
  801c81:	6a 01                	push   $0x1
  801c83:	8d 45 cc             	lea    -0x34(%ebp),%eax
  801c86:	50                   	push   %eax
  801c87:	68 58 0b 80 00       	push   $0x800b58
  801c8c:	e8 d8 05 00 00       	call   802269 <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  801c91:	83 c4 08             	add    $0x8,%esp
  801c94:	6a 00                	push   $0x0
  801c96:	8b 03                	mov    (%ebx),%eax
  801c98:	ff 70 10             	pushl  0x10(%eax)
  801c9b:	e8 f4 84 00 00       	call   80a194 <sys_arch_sem_wait>
  err = data.err;
  801ca0:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  sock_set_errno(sock, err);
  801ca4:	0f be d0             	movsbl %al,%edx
  801ca7:	89 53 10             	mov    %edx,0x10(%ebx)
  801caa:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
  return err ? -1 : 0;
  801cb0:	83 c4 10             	add    $0x10,%esp
  801cb3:	84 c0                	test   %al,%al
  801cb5:	0f 95 c0             	setne  %al
  801cb8:	0f b6 c0             	movzbl %al,%eax
  801cbb:	f7 d8                	neg    %eax
}
  801cbd:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801cc0:	5b                   	pop    %ebx
  801cc1:	5e                   	pop    %esi
  801cc2:	5f                   	pop    %edi
  801cc3:	5d                   	pop    %ebp
  801cc4:	c3                   	ret    
    if (*optlen < sizeof(int)) {
  801cc5:	83 3f 03             	cmpl   $0x3,(%edi)
  801cc8:	76 49                	jbe    801d13 <lwip_getsockopt+0x1b1>
    if (sock->conn->type != NETCONN_TCP)
  801cca:	8b 10                	mov    (%eax),%edx
      return 0;
  801ccc:	b8 00 00 00 00       	mov    $0x0,%eax
    if (sock->conn->type != NETCONN_TCP)
  801cd1:	83 3a 10             	cmpl   $0x10,(%edx)
  801cd4:	75 e7                	jne    801cbd <lwip_getsockopt+0x15b>
    switch (optname) {
  801cd6:	8b 45 10             	mov    0x10(%ebp),%eax
  801cd9:	83 e8 01             	sub    $0x1,%eax
  801cdc:	83 f8 01             	cmp    $0x1,%eax
  801cdf:	76 84                	jbe    801c65 <lwip_getsockopt+0x103>
      err = ENOPROTOOPT;
  801ce1:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801ce6:	e9 c0 fe ff ff       	jmp    801bab <lwip_getsockopt+0x49>
  801ceb:	b8 61 00 00 00       	mov    $0x61,%eax
  801cf0:	e9 b6 fe ff ff       	jmp    801bab <lwip_getsockopt+0x49>
  801cf5:	b8 61 00 00 00       	mov    $0x61,%eax
  801cfa:	e9 ac fe ff ff       	jmp    801bab <lwip_getsockopt+0x49>
      err = ENOPROTOOPT;
  801cff:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801d04:	e9 a2 fe ff ff       	jmp    801bab <lwip_getsockopt+0x49>
        err = EINVAL;
  801d09:	b8 16 00 00 00       	mov    $0x16,%eax
  801d0e:	e9 98 fe ff ff       	jmp    801bab <lwip_getsockopt+0x49>
      err = EINVAL;
  801d13:	b8 16 00 00 00       	mov    $0x16,%eax
  801d18:	e9 8e fe ff ff       	jmp    801bab <lwip_getsockopt+0x49>
    return -1;
  801d1d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801d22:	eb 99                	jmp    801cbd <lwip_getsockopt+0x15b>

00801d24 <lwip_setsockopt>:
{
  801d24:	55                   	push   %ebp
  801d25:	89 e5                	mov    %esp,%ebp
  801d27:	57                   	push   %edi
  801d28:	56                   	push   %esi
  801d29:	53                   	push   %ebx
  801d2a:	83 ec 2c             	sub    $0x2c,%esp
  801d2d:	8b 75 0c             	mov    0xc(%ebp),%esi
  801d30:	8b 7d 14             	mov    0x14(%ebp),%edi
  struct lwip_socket *sock = get_socket(s);
  801d33:	8b 45 08             	mov    0x8(%ebp),%eax
  801d36:	e8 cf e9 ff ff       	call   80070a <get_socket>
  if (!sock)
  801d3b:	85 c0                	test   %eax,%eax
  801d3d:	0f 84 69 01 00 00    	je     801eac <lwip_setsockopt+0x188>
  801d43:	89 c3                	mov    %eax,%ebx
  if (NULL == optval) {
  801d45:	85 ff                	test   %edi,%edi
  801d47:	74 2c                	je     801d75 <lwip_setsockopt+0x51>
  switch (level) {
  801d49:	83 fe 06             	cmp    $0x6,%esi
  801d4c:	0f 84 01 01 00 00    	je     801e53 <lwip_setsockopt+0x12f>
  801d52:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
  801d58:	74 36                	je     801d90 <lwip_setsockopt+0x6c>
    err = ENOPROTOOPT;
  801d5a:	b8 5c 00 00 00       	mov    $0x5c,%eax
  switch (level) {
  801d5f:	85 f6                	test   %esi,%esi
  801d61:	74 7b                	je     801dde <lwip_setsockopt+0xba>
    sock_set_errno(sock, err);
  801d63:	89 43 10             	mov    %eax,0x10(%ebx)
  801d66:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
    return -1;
  801d6b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801d70:	e9 d6 00 00 00       	jmp    801e4b <lwip_setsockopt+0x127>
    sock_set_errno(sock, EFAULT);
  801d75:	c7 40 10 0e 00 00 00 	movl   $0xe,0x10(%eax)
  801d7c:	c7 05 e0 b1 b3 00 0e 	movl   $0xe,0xb3b1e0
  801d83:	00 00 00 
    return -1;
  801d86:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801d8b:	e9 bb 00 00 00       	jmp    801e4b <lwip_setsockopt+0x127>
    switch (optname) {
  801d90:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  801d94:	74 14                	je     801daa <lwip_setsockopt+0x86>
  801d96:	81 7d 10 0a 10 00 00 	cmpl   $0x100a,0x10(%ebp)
  801d9d:	74 18                	je     801db7 <lwip_setsockopt+0x93>
      err = ENOPROTOOPT;
  801d9f:	b8 5c 00 00 00       	mov    $0x5c,%eax
    switch (optname) {
  801da4:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
  801da8:	75 b9                	jne    801d63 <lwip_setsockopt+0x3f>
      if (optlen < sizeof(int)) {
  801daa:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  801dae:	77 47                	ja     801df7 <lwip_setsockopt+0xd3>
        err = EINVAL;
  801db0:	b8 16 00 00 00       	mov    $0x16,%eax
  801db5:	eb ac                	jmp    801d63 <lwip_setsockopt+0x3f>
        err = EINVAL;
  801db7:	83 7d 18 04          	cmpl   $0x4,0x18(%ebp)
  801dbb:	19 c0                	sbb    %eax,%eax
  801dbd:	83 e0 16             	and    $0x16,%eax
      if ((sock->conn->type != NETCONN_UDP) ||
  801dc0:	8b 13                	mov    (%ebx),%edx
  801dc2:	83 3a 20             	cmpl   $0x20,(%edx)
  801dc5:	0f 85 af 00 00 00    	jne    801e7a <lwip_setsockopt+0x156>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  801dcb:	8b 52 08             	mov    0x8(%edx),%edx
      if ((sock->conn->type != NETCONN_UDP) ||
  801dce:	f6 42 10 02          	testb  $0x2,0x10(%edx)
  801dd2:	0f 85 ac 00 00 00    	jne    801e84 <lwip_setsockopt+0x160>
  if (err != ERR_OK) {
  801dd8:	85 c0                	test   %eax,%eax
  801dda:	74 1b                	je     801df7 <lwip_setsockopt+0xd3>
  801ddc:	eb 85                	jmp    801d63 <lwip_setsockopt+0x3f>
    switch (optname) {
  801dde:	8b 45 10             	mov    0x10(%ebp),%eax
  801de1:	83 e8 01             	sub    $0x1,%eax
  801de4:	83 f8 01             	cmp    $0x1,%eax
  801de7:	0f 87 a1 00 00 00    	ja     801e8e <lwip_setsockopt+0x16a>
      if (optlen < sizeof(int)) {
  801ded:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  801df1:	0f 86 a1 00 00 00    	jbe    801e98 <lwip_setsockopt+0x174>
  data.sock = sock;
  801df7:	89 5d cc             	mov    %ebx,-0x34(%ebp)
  data.level = level;
  801dfa:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  data.optname = optname;
  801dfd:	8b 45 10             	mov    0x10(%ebp),%eax
  801e00:	89 45 d8             	mov    %eax,-0x28(%ebp)
  data.optval = (void*)optval;
  801e03:	89 7d dc             	mov    %edi,-0x24(%ebp)
  data.optlen = &optlen;
  801e06:	8d 45 18             	lea    0x18(%ebp),%eax
  801e09:	89 45 e0             	mov    %eax,-0x20(%ebp)
  data.err = err;
  801e0c:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  tcpip_callback(lwip_setsockopt_internal, &data);
  801e10:	83 ec 04             	sub    $0x4,%esp
  801e13:	6a 01                	push   $0x1
  801e15:	8d 45 cc             	lea    -0x34(%ebp),%eax
  801e18:	50                   	push   %eax
  801e19:	68 e9 0c 80 00       	push   $0x800ce9
  801e1e:	e8 46 04 00 00       	call   802269 <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  801e23:	83 c4 08             	add    $0x8,%esp
  801e26:	6a 00                	push   $0x0
  801e28:	8b 03                	mov    (%ebx),%eax
  801e2a:	ff 70 10             	pushl  0x10(%eax)
  801e2d:	e8 62 83 00 00       	call   80a194 <sys_arch_sem_wait>
  err = data.err;
  801e32:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
  sock_set_errno(sock, err);
  801e36:	89 43 10             	mov    %eax,0x10(%ebx)
  801e39:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
  return err ? -1 : 0;
  801e3e:	83 c4 10             	add    $0x10,%esp
  801e41:	85 c0                	test   %eax,%eax
  801e43:	0f 95 c0             	setne  %al
  801e46:	0f b6 c0             	movzbl %al,%eax
  801e49:	f7 d8                	neg    %eax
}
  801e4b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801e4e:	5b                   	pop    %ebx
  801e4f:	5e                   	pop    %esi
  801e50:	5f                   	pop    %edi
  801e51:	5d                   	pop    %ebp
  801e52:	c3                   	ret    
    if (optlen < sizeof(int)) {
  801e53:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  801e57:	76 49                	jbe    801ea2 <lwip_setsockopt+0x17e>
    if (sock->conn->type != NETCONN_TCP)
  801e59:	8b 10                	mov    (%eax),%edx
      return 0;
  801e5b:	b8 00 00 00 00       	mov    $0x0,%eax
    if (sock->conn->type != NETCONN_TCP)
  801e60:	83 3a 10             	cmpl   $0x10,(%edx)
  801e63:	75 e6                	jne    801e4b <lwip_setsockopt+0x127>
    switch (optname) {
  801e65:	8b 45 10             	mov    0x10(%ebp),%eax
  801e68:	83 e8 01             	sub    $0x1,%eax
  801e6b:	83 f8 01             	cmp    $0x1,%eax
  801e6e:	76 87                	jbe    801df7 <lwip_setsockopt+0xd3>
      err = ENOPROTOOPT;
  801e70:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801e75:	e9 e9 fe ff ff       	jmp    801d63 <lwip_setsockopt+0x3f>
  801e7a:	b8 61 00 00 00       	mov    $0x61,%eax
  801e7f:	e9 df fe ff ff       	jmp    801d63 <lwip_setsockopt+0x3f>
  801e84:	b8 61 00 00 00       	mov    $0x61,%eax
  801e89:	e9 d5 fe ff ff       	jmp    801d63 <lwip_setsockopt+0x3f>
        err = ENOPROTOOPT;
  801e8e:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801e93:	e9 cb fe ff ff       	jmp    801d63 <lwip_setsockopt+0x3f>
        err = EINVAL;
  801e98:	b8 16 00 00 00       	mov    $0x16,%eax
  801e9d:	e9 c1 fe ff ff       	jmp    801d63 <lwip_setsockopt+0x3f>
      err = EINVAL;
  801ea2:	b8 16 00 00 00       	mov    $0x16,%eax
  801ea7:	e9 b7 fe ff ff       	jmp    801d63 <lwip_setsockopt+0x3f>
    return -1;
  801eac:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801eb1:	eb 98                	jmp    801e4b <lwip_setsockopt+0x127>

00801eb3 <lwip_ioctl>:

int
lwip_ioctl(int s, long cmd, void *argp)
{
  801eb3:	55                   	push   %ebp
  801eb4:	89 e5                	mov    %esp,%ebp
  801eb6:	56                   	push   %esi
  801eb7:	53                   	push   %ebx
  801eb8:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  801ebb:	8b 75 10             	mov    0x10(%ebp),%esi
  struct lwip_socket *sock = get_socket(s);
  801ebe:	8b 45 08             	mov    0x8(%ebp),%eax
  801ec1:	e8 44 e8 ff ff       	call   80070a <get_socket>
  u16_t buflen = 0;

  if (!sock)
  801ec6:	85 c0                	test   %eax,%eax
  801ec8:	0f 84 ae 00 00 00    	je     801f7c <lwip_ioctl+0xc9>
    return -1;

  switch (cmd) {
  801ece:	81 fb 7e 66 04 80    	cmp    $0x8004667e,%ebx
  801ed4:	74 5d                	je     801f33 <lwip_ioctl+0x80>
  801ed6:	81 fb 7f 66 04 40    	cmp    $0x4004667f,%ebx
  801edc:	0f 85 82 00 00 00    	jne    801f64 <lwip_ioctl+0xb1>
  case FIONREAD:
    if (!argp) {
  801ee2:	85 f6                	test   %esi,%esi
  801ee4:	74 35                	je     801f1b <lwip_ioctl+0x68>
      sock_set_errno(sock, EINVAL);
      return -1;
    }

    SYS_ARCH_GET(sock->conn->recv_avail, *((u16_t*)argp));
  801ee6:	8b 10                	mov    (%eax),%edx
  801ee8:	0f b7 52 20          	movzwl 0x20(%edx),%edx
  801eec:	66 89 16             	mov    %dx,(%esi)

    /* Check if there is data left from the last recv operation. /maq 041215 */
    if (sock->lastdata) {
  801eef:	8b 48 04             	mov    0x4(%eax),%ecx
  801ef2:	85 c9                	test   %ecx,%ecx
  801ef4:	74 0d                	je     801f03 <lwip_ioctl+0x50>
      buflen = netbuf_len(sock->lastdata);
  801ef6:	8b 09                	mov    (%ecx),%ecx
      buflen -= sock->lastoffset;

      *((u16_t*)argp) += buflen;
  801ef8:	66 2b 50 08          	sub    0x8(%eax),%dx
  801efc:	66 03 51 08          	add    0x8(%ecx),%dx
  801f00:	66 89 16             	mov    %dx,(%esi)
    }

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONREAD, %p) = %u\n", s, argp, *((u16_t*)argp)));
    sock_set_errno(sock, 0);
  801f03:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  801f0a:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801f11:	00 00 00 
    return 0;
  801f14:	b8 00 00 00 00       	mov    $0x0,%eax
  801f19:	eb 45                	jmp    801f60 <lwip_ioctl+0xad>
      sock_set_errno(sock, EINVAL);
  801f1b:	c7 40 10 16 00 00 00 	movl   $0x16,0x10(%eax)
  801f22:	c7 05 e0 b1 b3 00 16 	movl   $0x16,0xb3b1e0
  801f29:	00 00 00 
      return -1;
  801f2c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801f31:	eb 2d                	jmp    801f60 <lwip_ioctl+0xad>

  case FIONBIO:
    if (argp && *(u32_t*)argp)
  801f33:	85 f6                	test   %esi,%esi
  801f35:	74 0d                	je     801f44 <lwip_ioctl+0x91>
  801f37:	83 3e 00             	cmpl   $0x0,(%esi)
  801f3a:	74 08                	je     801f44 <lwip_ioctl+0x91>
      sock->flags |= O_NONBLOCK;
  801f3c:	66 81 48 0e 00 08    	orw    $0x800,0xe(%eax)
  801f42:	eb 06                	jmp    801f4a <lwip_ioctl+0x97>
    else
      sock->flags &= ~O_NONBLOCK;
  801f44:	66 81 60 0e ff f7    	andw   $0xf7ff,0xe(%eax)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONBIO, %d)\n", s, !!(sock->flags & O_NONBLOCK)));
    sock_set_errno(sock, 0);
  801f4a:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  801f51:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801f58:	00 00 00 
    return 0;
  801f5b:	b8 00 00 00 00       	mov    $0x0,%eax
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
    return -1;
  } /* switch (cmd) */
}
  801f60:	5b                   	pop    %ebx
  801f61:	5e                   	pop    %esi
  801f62:	5d                   	pop    %ebp
  801f63:	c3                   	ret    
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
  801f64:	c7 40 10 26 00 00 00 	movl   $0x26,0x10(%eax)
  801f6b:	c7 05 e0 b1 b3 00 26 	movl   $0x26,0xb3b1e0
  801f72:	00 00 00 
    return -1;
  801f75:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801f7a:	eb e4                	jmp    801f60 <lwip_ioctl+0xad>
    return -1;
  801f7c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801f81:	eb dd                	jmp    801f60 <lwip_ioctl+0xad>

00801f83 <tcpip_tcp_timer>:
 *
 * @param arg unused argument
 */
static void
tcpip_tcp_timer(void *arg)
{
  801f83:	55                   	push   %ebp
  801f84:	89 e5                	mov    %esp,%ebp
  801f86:	83 ec 08             	sub    $0x8,%esp
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
  801f89:	e8 0a 42 00 00       	call   806198 <tcp_tmr>
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
  801f8e:	83 3d 3c b2 b3 00 00 	cmpl   $0x0,0xb3b23c
  801f95:	75 09                	jne    801fa0 <tcpip_tcp_timer+0x1d>
  801f97:	83 3d 50 b2 b3 00 00 	cmpl   $0x0,0xb3b250
  801f9e:	74 19                	je     801fb9 <tcpip_tcp_timer+0x36>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  801fa0:	83 ec 04             	sub    $0x4,%esp
  801fa3:	6a 00                	push   $0x0
  801fa5:	68 83 1f 80 00       	push   $0x801f83
  801faa:	68 fa 00 00 00       	push   $0xfa
  801faf:	e8 16 32 00 00       	call   8051ca <sys_timeout>
  801fb4:	83 c4 10             	add    $0x10,%esp
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
  }
}
  801fb7:	c9                   	leave  
  801fb8:	c3                   	ret    
    tcpip_tcp_timer_active = 0;
  801fb9:	c7 05 e0 52 81 00 00 	movl   $0x0,0x8152e0
  801fc0:	00 00 00 
}
  801fc3:	eb f2                	jmp    801fb7 <tcpip_tcp_timer+0x34>

00801fc5 <tcpip_thread>:
 *
 * @param arg unused argument
 */
static void
tcpip_thread(void *arg)
{
  801fc5:	55                   	push   %ebp
  801fc6:	89 e5                	mov    %esp,%ebp
  801fc8:	53                   	push   %ebx
  801fc9:	83 ec 18             	sub    $0x18,%esp
  struct tcpip_msg *msg;
  LWIP_UNUSED_ARG(arg);

#if IP_REASSEMBLY
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  801fcc:	6a 00                	push   $0x0
  801fce:	68 80 21 80 00       	push   $0x802180
  801fd3:	68 e8 03 00 00       	push   $0x3e8
  801fd8:	e8 ed 31 00 00       	call   8051ca <sys_timeout>
#endif /* IP_REASSEMBLY */
#if LWIP_ARP
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  801fdd:	83 c4 0c             	add    $0xc,%esp
  801fe0:	6a 00                	push   $0x0
  801fe2:	68 5c 21 80 00       	push   $0x80215c
  801fe7:	68 88 13 00 00       	push   $0x1388
  801fec:	e8 d9 31 00 00       	call   8051ca <sys_timeout>
#endif /* LWIP_ARP */
#if LWIP_DHCP
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  801ff1:	83 c4 0c             	add    $0xc,%esp
  801ff4:	6a 00                	push   $0x0
  801ff6:	68 38 21 80 00       	push   $0x802138
  801ffb:	68 60 ea 00 00       	push   $0xea60
  802000:	e8 c5 31 00 00       	call   8051ca <sys_timeout>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  802005:	83 c4 0c             	add    $0xc,%esp
  802008:	6a 00                	push   $0x0
  80200a:	68 14 21 80 00       	push   $0x802114
  80200f:	68 f4 01 00 00       	push   $0x1f4
  802014:	e8 b1 31 00 00       	call   8051ca <sys_timeout>
#endif /* LWIP_IGMP */
#if LWIP_DNS
  sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);
#endif /* LWIP_DNS */

  if (tcpip_init_done != NULL) {
  802019:	a1 e8 52 81 00       	mov    0x8152e8,%eax
  80201e:	83 c4 10             	add    $0x10,%esp
  802021:	85 c0                	test   %eax,%eax
  802023:	74 0e                	je     802033 <tcpip_thread+0x6e>
    tcpip_init_done(tcpip_init_done_arg);
  802025:	83 ec 0c             	sub    $0xc,%esp
  802028:	ff 35 e4 52 81 00    	pushl  0x8152e4
  80202e:	ff d0                	call   *%eax
  802030:	83 c4 10             	add    $0x10,%esp
  }

  LOCK_TCPIP_CORE();
  while (1) {                          /* MAIN Loop */
    sys_mbox_fetch(mbox, (void *)&msg);
  802033:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  802036:	eb 0f                	jmp    802047 <tcpip_thread+0x82>
    switch (msg->type) {
#if LWIP_NETCONN
    case TCPIP_MSG_API:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: API message %p\n", (void *)msg));
      msg->msg.apimsg->function(&(msg->msg.apimsg->msg));
  802038:	8b 42 08             	mov    0x8(%edx),%eax
  80203b:	83 ec 0c             	sub    $0xc,%esp
  80203e:	8d 50 04             	lea    0x4(%eax),%edx
  802041:	52                   	push   %edx
  802042:	ff 10                	call   *(%eax)
      break;
  802044:	83 c4 10             	add    $0x10,%esp
    sys_mbox_fetch(mbox, (void *)&msg);
  802047:	83 ec 08             	sub    $0x8,%esp
  80204a:	53                   	push   %ebx
  80204b:	ff 35 00 40 81 00    	pushl  0x814000
  802051:	e8 50 30 00 00       	call   8050a6 <sys_mbox_fetch>
    switch (msg->type) {
  802056:	8b 55 f4             	mov    -0xc(%ebp),%edx
  802059:	83 c4 10             	add    $0x10,%esp
  80205c:	8b 02                	mov    (%edx),%eax
  80205e:	83 f8 01             	cmp    $0x1,%eax
  802061:	74 3f                	je     8020a2 <tcpip_thread+0xdd>
  802063:	83 f8 01             	cmp    $0x1,%eax
  802066:	72 d0                	jb     802038 <tcpip_thread+0x73>
  802068:	83 f8 02             	cmp    $0x2,%eax
  80206b:	74 73                	je     8020e0 <tcpip_thread+0x11b>
  80206d:	83 f8 03             	cmp    $0x3,%eax
  802070:	75 d5                	jne    802047 <tcpip_thread+0x82>
      break;

    case TCPIP_MSG_TIMEOUT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: TIMEOUT %p\n", (void *)msg));

      if(msg->msg.tmo.msecs != 0xffffffff)
  802072:	8b 42 08             	mov    0x8(%edx),%eax
  802075:	83 f8 ff             	cmp    $0xffffffff,%eax
  802078:	0f 84 80 00 00 00    	je     8020fe <tcpip_thread+0x139>
        sys_timeout (msg->msg.tmo.msecs, msg->msg.tmo.h, msg->msg.tmo.arg);
  80207e:	83 ec 04             	sub    $0x4,%esp
  802081:	ff 72 10             	pushl  0x10(%edx)
  802084:	ff 72 0c             	pushl  0xc(%edx)
  802087:	50                   	push   %eax
  802088:	e8 3d 31 00 00       	call   8051ca <sys_timeout>
  80208d:	83 c4 10             	add    $0x10,%esp
      else
        sys_untimeout (msg->msg.tmo.h, msg->msg.tmo.arg);
      memp_free(MEMP_TCPIP_MSG_API, msg);
  802090:	83 ec 08             	sub    $0x8,%esp
  802093:	ff 75 f4             	pushl  -0xc(%ebp)
  802096:	6a 08                	push   $0x8
  802098:	e8 41 24 00 00       	call   8044de <memp_free>
      break;
  80209d:	83 c4 10             	add    $0x10,%esp
  8020a0:	eb a5                	jmp    802047 <tcpip_thread+0x82>
      if (msg->msg.inp.netif->flags & NETIF_FLAG_ETHARP) {
  8020a2:	8b 42 0c             	mov    0xc(%edx),%eax
  8020a5:	f6 40 2e 20          	testb  $0x20,0x2e(%eax)
  8020a9:	74 24                	je     8020cf <tcpip_thread+0x10a>
        ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
  8020ab:	83 ec 08             	sub    $0x8,%esp
  8020ae:	50                   	push   %eax
  8020af:	ff 72 08             	pushl  0x8(%edx)
  8020b2:	e8 06 7c 00 00       	call   809cbd <ethernet_input>
  8020b7:	83 c4 10             	add    $0x10,%esp
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  8020ba:	83 ec 08             	sub    $0x8,%esp
  8020bd:	ff 75 f4             	pushl  -0xc(%ebp)
  8020c0:	6a 09                	push   $0x9
  8020c2:	e8 17 24 00 00       	call   8044de <memp_free>
      break;
  8020c7:	83 c4 10             	add    $0x10,%esp
  8020ca:	e9 78 ff ff ff       	jmp    802047 <tcpip_thread+0x82>
      { ip_input(msg->msg.inp.p, msg->msg.inp.netif);
  8020cf:	83 ec 08             	sub    $0x8,%esp
  8020d2:	50                   	push   %eax
  8020d3:	ff 72 08             	pushl  0x8(%edx)
  8020d6:	e8 ff 44 00 00       	call   8065da <ip_input>
  8020db:	83 c4 10             	add    $0x10,%esp
  8020de:	eb da                	jmp    8020ba <tcpip_thread+0xf5>
      msg->msg.cb.f(msg->msg.cb.ctx);
  8020e0:	83 ec 0c             	sub    $0xc,%esp
  8020e3:	ff 72 0c             	pushl  0xc(%edx)
  8020e6:	ff 52 08             	call   *0x8(%edx)
      memp_free(MEMP_TCPIP_MSG_API, msg);
  8020e9:	83 c4 08             	add    $0x8,%esp
  8020ec:	ff 75 f4             	pushl  -0xc(%ebp)
  8020ef:	6a 08                	push   $0x8
  8020f1:	e8 e8 23 00 00       	call   8044de <memp_free>
      break;
  8020f6:	83 c4 10             	add    $0x10,%esp
  8020f9:	e9 49 ff ff ff       	jmp    802047 <tcpip_thread+0x82>
        sys_untimeout (msg->msg.tmo.h, msg->msg.tmo.arg);
  8020fe:	83 ec 08             	sub    $0x8,%esp
  802101:	ff 72 10             	pushl  0x10(%edx)
  802104:	ff 72 0c             	pushl  0xc(%edx)
  802107:	e8 6d 31 00 00       	call   805279 <sys_untimeout>
  80210c:	83 c4 10             	add    $0x10,%esp
  80210f:	e9 7c ff ff ff       	jmp    802090 <tcpip_thread+0xcb>

00802114 <dhcp_timer_fine>:
{
  802114:	55                   	push   %ebp
  802115:	89 e5                	mov    %esp,%ebp
  802117:	83 ec 08             	sub    $0x8,%esp
  dhcp_fine_tmr();
  80211a:	e8 5a 1b 00 00       	call   803c79 <dhcp_fine_tmr>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  80211f:	83 ec 04             	sub    $0x4,%esp
  802122:	6a 00                	push   $0x0
  802124:	68 14 21 80 00       	push   $0x802114
  802129:	68 f4 01 00 00       	push   $0x1f4
  80212e:	e8 97 30 00 00       	call   8051ca <sys_timeout>
}
  802133:	83 c4 10             	add    $0x10,%esp
  802136:	c9                   	leave  
  802137:	c3                   	ret    

00802138 <dhcp_timer_coarse>:
{
  802138:	55                   	push   %ebp
  802139:	89 e5                	mov    %esp,%ebp
  80213b:	83 ec 08             	sub    $0x8,%esp
  dhcp_coarse_tmr();
  80213e:	e8 6a 19 00 00       	call   803aad <dhcp_coarse_tmr>
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  802143:	83 ec 04             	sub    $0x4,%esp
  802146:	6a 00                	push   $0x0
  802148:	68 38 21 80 00       	push   $0x802138
  80214d:	68 60 ea 00 00       	push   $0xea60
  802152:	e8 73 30 00 00       	call   8051ca <sys_timeout>
}
  802157:	83 c4 10             	add    $0x10,%esp
  80215a:	c9                   	leave  
  80215b:	c3                   	ret    

0080215c <arp_timer>:
{
  80215c:	55                   	push   %ebp
  80215d:	89 e5                	mov    %esp,%ebp
  80215f:	83 ec 08             	sub    $0x8,%esp
  etharp_tmr();
  802162:	e8 2a 74 00 00       	call   809591 <etharp_tmr>
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  802167:	83 ec 04             	sub    $0x4,%esp
  80216a:	6a 00                	push   $0x0
  80216c:	68 5c 21 80 00       	push   $0x80215c
  802171:	68 88 13 00 00       	push   $0x1388
  802176:	e8 4f 30 00 00       	call   8051ca <sys_timeout>
}
  80217b:	83 c4 10             	add    $0x10,%esp
  80217e:	c9                   	leave  
  80217f:	c3                   	ret    

00802180 <ip_reass_timer>:
{
  802180:	55                   	push   %ebp
  802181:	89 e5                	mov    %esp,%ebp
  802183:	83 ec 08             	sub    $0x8,%esp
  ip_reass_tmr();
  802186:	e8 38 4b 00 00       	call   806cc3 <ip_reass_tmr>
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  80218b:	83 ec 04             	sub    $0x4,%esp
  80218e:	6a 00                	push   $0x0
  802190:	68 80 21 80 00       	push   $0x802180
  802195:	68 e8 03 00 00       	push   $0x3e8
  80219a:	e8 2b 30 00 00       	call   8051ca <sys_timeout>
}
  80219f:	83 c4 10             	add    $0x10,%esp
  8021a2:	c9                   	leave  
  8021a3:	c3                   	ret    

008021a4 <pbuf_free_int>:
 *
 * @param p The pbuf (chain) to be dereferenced.
 */
static void
pbuf_free_int(void *p)
{
  8021a4:	55                   	push   %ebp
  8021a5:	89 e5                	mov    %esp,%ebp
  8021a7:	83 ec 14             	sub    $0x14,%esp
  struct pbuf *q = p;
  pbuf_free(q);
  8021aa:	ff 75 08             	pushl  0x8(%ebp)
  8021ad:	e8 9b 26 00 00       	call   80484d <pbuf_free>
}
  8021b2:	83 c4 10             	add    $0x10,%esp
  8021b5:	c9                   	leave  
  8021b6:	c3                   	ret    

008021b7 <tcp_timer_needed>:
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
  8021b7:	83 3d e0 52 81 00 00 	cmpl   $0x0,0x8152e0
  8021be:	75 38                	jne    8021f8 <tcp_timer_needed+0x41>
  8021c0:	83 3d 3c b2 b3 00 00 	cmpl   $0x0,0xb3b23c
  8021c7:	74 26                	je     8021ef <tcp_timer_needed+0x38>
{
  8021c9:	55                   	push   %ebp
  8021ca:	89 e5                	mov    %esp,%ebp
  8021cc:	83 ec 0c             	sub    $0xc,%esp
    tcpip_tcp_timer_active = 1;
  8021cf:	c7 05 e0 52 81 00 01 	movl   $0x1,0x8152e0
  8021d6:	00 00 00 
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  8021d9:	6a 00                	push   $0x0
  8021db:	68 83 1f 80 00       	push   $0x801f83
  8021e0:	68 fa 00 00 00       	push   $0xfa
  8021e5:	e8 e0 2f 00 00       	call   8051ca <sys_timeout>
  8021ea:	83 c4 10             	add    $0x10,%esp
}
  8021ed:	c9                   	leave  
  8021ee:	c3                   	ret    
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
  8021ef:	83 3d 50 b2 b3 00 00 	cmpl   $0x0,0xb3b250
  8021f6:	75 d1                	jne    8021c9 <tcp_timer_needed+0x12>
  8021f8:	f3 c3                	repz ret 

008021fa <tcpip_input>:
  if (mbox != SYS_MBOX_NULL) {
  8021fa:	83 3d 00 40 81 00 ff 	cmpl   $0xffffffff,0x814000
  802201:	74 59                	je     80225c <tcpip_input+0x62>
{
  802203:	55                   	push   %ebp
  802204:	89 e5                	mov    %esp,%ebp
  802206:	53                   	push   %ebx
  802207:	83 ec 10             	sub    $0x10,%esp
    msg = memp_malloc(MEMP_TCPIP_MSG_INPKT);
  80220a:	6a 09                	push   $0x9
  80220c:	e8 77 22 00 00       	call   804488 <memp_malloc>
  802211:	89 c3                	mov    %eax,%ebx
    if (msg == NULL) {
  802213:	83 c4 10             	add    $0x10,%esp
  802216:	85 c0                	test   %eax,%eax
  802218:	74 48                	je     802262 <tcpip_input+0x68>
    msg->type = TCPIP_MSG_INPKT;
  80221a:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    msg->msg.inp.p = p;
  802220:	8b 45 08             	mov    0x8(%ebp),%eax
  802223:	89 43 08             	mov    %eax,0x8(%ebx)
    msg->msg.inp.netif = inp;
  802226:	8b 45 0c             	mov    0xc(%ebp),%eax
  802229:	89 43 0c             	mov    %eax,0xc(%ebx)
    if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  80222c:	83 ec 08             	sub    $0x8,%esp
  80222f:	53                   	push   %ebx
  802230:	ff 35 00 40 81 00    	pushl  0x814000
  802236:	e8 69 80 00 00       	call   80a2a4 <sys_mbox_trypost>
  80223b:	83 c4 10             	add    $0x10,%esp
  80223e:	84 c0                	test   %al,%al
  802240:	75 05                	jne    802247 <tcpip_input+0x4d>
}
  802242:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802245:	c9                   	leave  
  802246:	c3                   	ret    
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  802247:	83 ec 08             	sub    $0x8,%esp
  80224a:	53                   	push   %ebx
  80224b:	6a 09                	push   $0x9
  80224d:	e8 8c 22 00 00       	call   8044de <memp_free>
      return ERR_MEM;
  802252:	83 c4 10             	add    $0x10,%esp
  802255:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80225a:	eb e6                	jmp    802242 <tcpip_input+0x48>
  return ERR_VAL;
  80225c:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  802261:	c3                   	ret    
      return ERR_MEM;
  802262:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802267:	eb d9                	jmp    802242 <tcpip_input+0x48>

00802269 <tcpip_callback_with_block>:
{
  802269:	55                   	push   %ebp
  80226a:	89 e5                	mov    %esp,%ebp
  80226c:	56                   	push   %esi
  80226d:	53                   	push   %ebx
  80226e:	8b 75 10             	mov    0x10(%ebp),%esi
  if (mbox != SYS_MBOX_NULL) {
  802271:	83 3d 00 40 81 00 ff 	cmpl   $0xffffffff,0x814000
  802278:	74 76                	je     8022f0 <tcpip_callback_with_block+0x87>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  80227a:	83 ec 0c             	sub    $0xc,%esp
  80227d:	6a 08                	push   $0x8
  80227f:	e8 04 22 00 00       	call   804488 <memp_malloc>
  802284:	89 c3                	mov    %eax,%ebx
    if (msg == NULL) {
  802286:	83 c4 10             	add    $0x10,%esp
  802289:	85 c0                	test   %eax,%eax
  80228b:	74 6a                	je     8022f7 <tcpip_callback_with_block+0x8e>
    msg->type = TCPIP_MSG_CALLBACK;
  80228d:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
    msg->msg.cb.f = f;
  802293:	8b 45 08             	mov    0x8(%ebp),%eax
  802296:	89 43 08             	mov    %eax,0x8(%ebx)
    msg->msg.cb.ctx = ctx;
  802299:	8b 45 0c             	mov    0xc(%ebp),%eax
  80229c:	89 43 0c             	mov    %eax,0xc(%ebx)
    if (block) {
  80229f:	89 f0                	mov    %esi,%eax
  8022a1:	84 c0                	test   %al,%al
  8022a3:	75 1d                	jne    8022c2 <tcpip_callback_with_block+0x59>
      if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  8022a5:	83 ec 08             	sub    $0x8,%esp
  8022a8:	53                   	push   %ebx
  8022a9:	ff 35 00 40 81 00    	pushl  0x814000
  8022af:	e8 f0 7f 00 00       	call   80a2a4 <sys_mbox_trypost>
  8022b4:	83 c4 10             	add    $0x10,%esp
  8022b7:	84 c0                	test   %al,%al
  8022b9:	75 20                	jne    8022db <tcpip_callback_with_block+0x72>
}
  8022bb:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8022be:	5b                   	pop    %ebx
  8022bf:	5e                   	pop    %esi
  8022c0:	5d                   	pop    %ebp
  8022c1:	c3                   	ret    
      sys_mbox_post(mbox, msg);
  8022c2:	83 ec 08             	sub    $0x8,%esp
  8022c5:	53                   	push   %ebx
  8022c6:	ff 35 00 40 81 00    	pushl  0x814000
  8022cc:	e8 98 80 00 00       	call   80a369 <sys_mbox_post>
  8022d1:	83 c4 10             	add    $0x10,%esp
    return ERR_OK;
  8022d4:	b8 00 00 00 00       	mov    $0x0,%eax
  8022d9:	eb e0                	jmp    8022bb <tcpip_callback_with_block+0x52>
        memp_free(MEMP_TCPIP_MSG_API, msg);
  8022db:	83 ec 08             	sub    $0x8,%esp
  8022de:	53                   	push   %ebx
  8022df:	6a 08                	push   $0x8
  8022e1:	e8 f8 21 00 00       	call   8044de <memp_free>
        return ERR_MEM;
  8022e6:	83 c4 10             	add    $0x10,%esp
  8022e9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8022ee:	eb cb                	jmp    8022bb <tcpip_callback_with_block+0x52>
  return ERR_VAL;
  8022f0:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  8022f5:	eb c4                	jmp    8022bb <tcpip_callback_with_block+0x52>
      return ERR_MEM;
  8022f7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8022fc:	eb bd                	jmp    8022bb <tcpip_callback_with_block+0x52>

008022fe <tcpip_timeout>:
  if (mbox != SYS_MBOX_NULL) {
  8022fe:	83 3d 00 40 81 00 ff 	cmpl   $0xffffffff,0x814000
  802305:	74 45                	je     80234c <tcpip_timeout+0x4e>
{
  802307:	55                   	push   %ebp
  802308:	89 e5                	mov    %esp,%ebp
  80230a:	83 ec 14             	sub    $0x14,%esp
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  80230d:	6a 08                	push   $0x8
  80230f:	e8 74 21 00 00       	call   804488 <memp_malloc>
    if (msg == NULL) {
  802314:	83 c4 10             	add    $0x10,%esp
  802317:	85 c0                	test   %eax,%eax
  802319:	74 37                	je     802352 <tcpip_timeout+0x54>
    msg->type = TCPIP_MSG_TIMEOUT;
  80231b:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
    msg->msg.tmo.msecs = msecs;
  802321:	8b 55 08             	mov    0x8(%ebp),%edx
  802324:	89 50 08             	mov    %edx,0x8(%eax)
    msg->msg.tmo.h = h;
  802327:	8b 55 0c             	mov    0xc(%ebp),%edx
  80232a:	89 50 0c             	mov    %edx,0xc(%eax)
    msg->msg.tmo.arg = arg;
  80232d:	8b 55 10             	mov    0x10(%ebp),%edx
  802330:	89 50 10             	mov    %edx,0x10(%eax)
    sys_mbox_post(mbox, msg);
  802333:	83 ec 08             	sub    $0x8,%esp
  802336:	50                   	push   %eax
  802337:	ff 35 00 40 81 00    	pushl  0x814000
  80233d:	e8 27 80 00 00       	call   80a369 <sys_mbox_post>
    return ERR_OK;
  802342:	83 c4 10             	add    $0x10,%esp
  802345:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80234a:	c9                   	leave  
  80234b:	c3                   	ret    
  return ERR_VAL;
  80234c:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  802351:	c3                   	ret    
      return ERR_MEM;
  802352:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802357:	eb f1                	jmp    80234a <tcpip_timeout+0x4c>

00802359 <tcpip_apimsg>:
{
  802359:	55                   	push   %ebp
  80235a:	89 e5                	mov    %esp,%ebp
  80235c:	53                   	push   %ebx
  80235d:	83 ec 24             	sub    $0x24,%esp
  802360:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (mbox != SYS_MBOX_NULL) {
  802363:	a1 00 40 81 00       	mov    0x814000,%eax
  802368:	83 f8 ff             	cmp    $0xffffffff,%eax
  80236b:	74 34                	je     8023a1 <tcpip_apimsg+0x48>
    msg.type = TCPIP_MSG_API;
  80236d:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    msg.msg.apimsg = apimsg;
  802374:	89 5d ec             	mov    %ebx,-0x14(%ebp)
    sys_mbox_post(mbox, &msg);
  802377:	83 ec 08             	sub    $0x8,%esp
  80237a:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  80237d:	52                   	push   %edx
  80237e:	50                   	push   %eax
  80237f:	e8 e5 7f 00 00       	call   80a369 <sys_mbox_post>
    sys_arch_sem_wait(apimsg->msg.conn->op_completed, 0);
  802384:	83 c4 08             	add    $0x8,%esp
  802387:	6a 00                	push   $0x0
  802389:	8b 43 04             	mov    0x4(%ebx),%eax
  80238c:	ff 70 10             	pushl  0x10(%eax)
  80238f:	e8 00 7e 00 00       	call   80a194 <sys_arch_sem_wait>
    return ERR_OK;
  802394:	83 c4 10             	add    $0x10,%esp
  802397:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80239c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80239f:	c9                   	leave  
  8023a0:	c3                   	ret    
  return ERR_VAL;
  8023a1:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  8023a6:	eb f4                	jmp    80239c <tcpip_apimsg+0x43>

008023a8 <tcpip_init>:
{
  8023a8:	55                   	push   %ebp
  8023a9:	89 e5                	mov    %esp,%ebp
  8023ab:	83 ec 08             	sub    $0x8,%esp
  lwip_init();
  8023ae:	e8 71 03 00 00       	call   802724 <lwip_init>
  tcpip_init_done = initfunc;
  8023b3:	8b 45 08             	mov    0x8(%ebp),%eax
  8023b6:	a3 e8 52 81 00       	mov    %eax,0x8152e8
  tcpip_init_done_arg = arg;
  8023bb:	8b 45 0c             	mov    0xc(%ebp),%eax
  8023be:	a3 e4 52 81 00       	mov    %eax,0x8152e4
  mbox = sys_mbox_new(TCPIP_MBOX_SIZE);
  8023c3:	83 ec 0c             	sub    $0xc,%esp
  8023c6:	6a 00                	push   $0x0
  8023c8:	e8 43 7c 00 00       	call   80a010 <sys_mbox_new>
  8023cd:	a3 00 40 81 00       	mov    %eax,0x814000
  sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
  8023d2:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  8023d9:	6a 00                	push   $0x0
  8023db:	6a 00                	push   $0x0
  8023dd:	68 c5 1f 80 00       	push   $0x801fc5
  8023e2:	68 9c 12 81 00       	push   $0x81129c
  8023e7:	e8 b0 80 00 00       	call   80a49c <sys_thread_new>
}
  8023ec:	83 c4 20             	add    $0x20,%esp
  8023ef:	c9                   	leave  
  8023f0:	c3                   	ret    

008023f1 <pbuf_free_callback>:
 * @param p The pbuf (chain) to be dereferenced.
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
pbuf_free_callback(struct pbuf *p)
{
  8023f1:	55                   	push   %ebp
  8023f2:	89 e5                	mov    %esp,%ebp
  8023f4:	83 ec 0c             	sub    $0xc,%esp
  return tcpip_callback_with_block(pbuf_free_int, p, 0);
  8023f7:	6a 00                	push   $0x0
  8023f9:	ff 75 08             	pushl  0x8(%ebp)
  8023fc:	68 a4 21 80 00       	push   $0x8021a4
  802401:	e8 63 fe ff ff       	call   802269 <tcpip_callback_with_block>
}
  802406:	c9                   	leave  
  802407:	c3                   	ret    

00802408 <mem_free_callback>:
 * @param m the heap memory to free
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
mem_free_callback(void *m)
{
  802408:	55                   	push   %ebp
  802409:	89 e5                	mov    %esp,%ebp
  80240b:	83 ec 0c             	sub    $0xc,%esp
  return tcpip_callback_with_block(mem_free, m, 0);
  80240e:	6a 00                	push   $0x0
  802410:	ff 75 08             	pushl  0x8(%ebp)
  802413:	68 2f 3f 80 00       	push   $0x803f2f
  802418:	e8 4c fe ff ff       	call   802269 <tcpip_callback_with_block>
}
  80241d:	c9                   	leave  
  80241e:	c3                   	ret    

0080241f <netbuf_new>:
 * @return a pointer to a new netbuf
 *         NULL on lack of memory
 */
struct
netbuf *netbuf_new(void)
{
  80241f:	55                   	push   %ebp
  802420:	89 e5                	mov    %esp,%ebp
  802422:	83 ec 14             	sub    $0x14,%esp
  struct netbuf *buf;

  buf = memp_malloc(MEMP_NETBUF);
  802425:	6a 06                	push   $0x6
  802427:	e8 5c 20 00 00       	call   804488 <memp_malloc>
  if (buf != NULL) {
  80242c:	83 c4 10             	add    $0x10,%esp
  80242f:	85 c0                	test   %eax,%eax
  802431:	74 14                	je     802447 <netbuf_new+0x28>
    buf->p = NULL;
  802433:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    buf->ptr = NULL;
  802439:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    buf->addr = NULL;
  802440:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    return buf;
  } else {
    return NULL;
  }
}
  802447:	c9                   	leave  
  802448:	c3                   	ret    

00802449 <netbuf_delete>:
 *
 * @param buf pointer to a netbuf allocated by netbuf_new()
 */
void
netbuf_delete(struct netbuf *buf)
{
  802449:	55                   	push   %ebp
  80244a:	89 e5                	mov    %esp,%ebp
  80244c:	53                   	push   %ebx
  80244d:	83 ec 04             	sub    $0x4,%esp
  802450:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (buf != NULL) {
  802453:	85 db                	test   %ebx,%ebx
  802455:	74 2d                	je     802484 <netbuf_delete+0x3b>
    if (buf->p != NULL) {
  802457:	8b 03                	mov    (%ebx),%eax
  802459:	85 c0                	test   %eax,%eax
  80245b:	74 19                	je     802476 <netbuf_delete+0x2d>
      pbuf_free(buf->p);
  80245d:	83 ec 0c             	sub    $0xc,%esp
  802460:	50                   	push   %eax
  802461:	e8 e7 23 00 00       	call   80484d <pbuf_free>
      buf->p = buf->ptr = NULL;
  802466:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  80246d:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  802473:	83 c4 10             	add    $0x10,%esp
    }
    memp_free(MEMP_NETBUF, buf);
  802476:	83 ec 08             	sub    $0x8,%esp
  802479:	53                   	push   %ebx
  80247a:	6a 06                	push   $0x6
  80247c:	e8 5d 20 00 00       	call   8044de <memp_free>
  802481:	83 c4 10             	add    $0x10,%esp
  }
}
  802484:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802487:	c9                   	leave  
  802488:	c3                   	ret    

00802489 <netbuf_alloc>:
 * @return pointer to the allocated memory
 *         NULL if no memory could be allocated
 */
void *
netbuf_alloc(struct netbuf *buf, u16_t size)
{
  802489:	55                   	push   %ebp
  80248a:	89 e5                	mov    %esp,%ebp
  80248c:	56                   	push   %esi
  80248d:	53                   	push   %ebx
  80248e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  802491:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
  802494:	85 db                	test   %ebx,%ebx
  802496:	74 3e                	je     8024d6 <netbuf_alloc+0x4d>

  /* Deallocate any previously allocated memory. */
  if (buf->p != NULL) {
  802498:	8b 03                	mov    (%ebx),%eax
  80249a:	85 c0                	test   %eax,%eax
  80249c:	74 0c                	je     8024aa <netbuf_alloc+0x21>
    pbuf_free(buf->p);
  80249e:	83 ec 0c             	sub    $0xc,%esp
  8024a1:	50                   	push   %eax
  8024a2:	e8 a6 23 00 00       	call   80484d <pbuf_free>
  8024a7:	83 c4 10             	add    $0x10,%esp
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
  8024aa:	83 ec 04             	sub    $0x4,%esp
  8024ad:	6a 00                	push   $0x0
  8024af:	0f b7 c6             	movzwl %si,%eax
  8024b2:	50                   	push   %eax
  8024b3:	6a 00                	push   $0x0
  8024b5:	e8 59 24 00 00       	call   804913 <pbuf_alloc>
  8024ba:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  8024bc:	83 c4 10             	add    $0x10,%esp
  8024bf:	85 c0                	test   %eax,%eax
  8024c1:	74 3b                	je     8024fe <netbuf_alloc+0x75>
     return NULL;
  }
  LWIP_ASSERT("check that first pbuf can hold size",
  8024c3:	66 39 70 0a          	cmp    %si,0xa(%eax)
  8024c7:	72 21                	jb     8024ea <netbuf_alloc+0x61>
             (buf->p->len >= size));
  buf->ptr = buf->p;
  8024c9:	89 43 04             	mov    %eax,0x4(%ebx)
  return buf->p->payload;
  8024cc:	8b 40 04             	mov    0x4(%eax),%eax
}
  8024cf:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8024d2:	5b                   	pop    %ebx
  8024d3:	5e                   	pop    %esi
  8024d4:	5d                   	pop    %ebp
  8024d5:	c3                   	ret    
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
  8024d6:	83 ec 04             	sub    $0x4,%esp
  8024d9:	68 a9 12 81 00       	push   $0x8112a9
  8024de:	6a 63                	push   $0x63
  8024e0:	68 c3 12 81 00       	push   $0x8112c3
  8024e5:	e8 69 c1 00 00       	call   80e653 <_panic>
  LWIP_ASSERT("check that first pbuf can hold size",
  8024ea:	83 ec 04             	sub    $0x4,%esp
  8024ed:	68 90 13 81 00       	push   $0x811390
  8024f2:	6a 6e                	push   $0x6e
  8024f4:	68 c3 12 81 00       	push   $0x8112c3
  8024f9:	e8 55 c1 00 00       	call   80e653 <_panic>
     return NULL;
  8024fe:	b8 00 00 00 00       	mov    $0x0,%eax
  802503:	eb ca                	jmp    8024cf <netbuf_alloc+0x46>

00802505 <netbuf_free>:
 *
 * @param buf pointer to the netbuf which contains the packet buffer to free
 */
void
netbuf_free(struct netbuf *buf)
{
  802505:	55                   	push   %ebp
  802506:	89 e5                	mov    %esp,%ebp
  802508:	53                   	push   %ebx
  802509:	83 ec 04             	sub    $0x4,%esp
  80250c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  80250f:	85 db                	test   %ebx,%ebx
  802511:	74 24                	je     802537 <netbuf_free+0x32>
  if (buf->p != NULL) {
  802513:	8b 03                	mov    (%ebx),%eax
  802515:	85 c0                	test   %eax,%eax
  802517:	74 0c                	je     802525 <netbuf_free+0x20>
    pbuf_free(buf->p);
  802519:	83 ec 0c             	sub    $0xc,%esp
  80251c:	50                   	push   %eax
  80251d:	e8 2b 23 00 00       	call   80484d <pbuf_free>
  802522:	83 c4 10             	add    $0x10,%esp
  }
  buf->p = buf->ptr = NULL;
  802525:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  80252c:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
}
  802532:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802535:	c9                   	leave  
  802536:	c3                   	ret    
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  802537:	83 ec 04             	sub    $0x4,%esp
  80253a:	68 d9 12 81 00       	push   $0x8112d9
  80253f:	6a 7b                	push   $0x7b
  802541:	68 c3 12 81 00       	push   $0x8112c3
  802546:	e8 08 c1 00 00       	call   80e653 <_panic>

0080254b <netbuf_ref>:
 * @return ERR_OK if data is referenced
 *         ERR_MEM if data couldn't be referenced due to lack of memory
 */
err_t
netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
{
  80254b:	55                   	push   %ebp
  80254c:	89 e5                	mov    %esp,%ebp
  80254e:	56                   	push   %esi
  80254f:	53                   	push   %ebx
  802550:	8b 5d 08             	mov    0x8(%ebp),%ebx
  802553:	8b 75 10             	mov    0x10(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
  802556:	85 db                	test   %ebx,%ebx
  802558:	74 4c                	je     8025a6 <netbuf_ref+0x5b>
  if (buf->p != NULL) {
  80255a:	8b 03                	mov    (%ebx),%eax
  80255c:	85 c0                	test   %eax,%eax
  80255e:	74 0c                	je     80256c <netbuf_ref+0x21>
    pbuf_free(buf->p);
  802560:	83 ec 0c             	sub    $0xc,%esp
  802563:	50                   	push   %eax
  802564:	e8 e4 22 00 00       	call   80484d <pbuf_free>
  802569:	83 c4 10             	add    $0x10,%esp
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
  80256c:	83 ec 04             	sub    $0x4,%esp
  80256f:	6a 02                	push   $0x2
  802571:	6a 00                	push   $0x0
  802573:	6a 00                	push   $0x0
  802575:	e8 99 23 00 00       	call   804913 <pbuf_alloc>
  80257a:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  80257c:	83 c4 10             	add    $0x10,%esp
  80257f:	85 c0                	test   %eax,%eax
  802581:	74 3a                	je     8025bd <netbuf_ref+0x72>
    buf->ptr = NULL;
    return ERR_MEM;
  }
  buf->p->payload = (void*)dataptr;
  802583:	8b 55 0c             	mov    0xc(%ebp),%edx
  802586:	89 50 04             	mov    %edx,0x4(%eax)
  buf->p->len = buf->p->tot_len = size;
  802589:	8b 03                	mov    (%ebx),%eax
  80258b:	66 89 70 08          	mov    %si,0x8(%eax)
  80258f:	8b 03                	mov    (%ebx),%eax
  802591:	66 89 70 0a          	mov    %si,0xa(%eax)
  buf->ptr = buf->p;
  802595:	8b 03                	mov    (%ebx),%eax
  802597:	89 43 04             	mov    %eax,0x4(%ebx)
  return ERR_OK;
  80259a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80259f:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8025a2:	5b                   	pop    %ebx
  8025a3:	5e                   	pop    %esi
  8025a4:	5d                   	pop    %ebp
  8025a5:	c3                   	ret    
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
  8025a6:	83 ec 04             	sub    $0x4,%esp
  8025a9:	68 f2 12 81 00       	push   $0x8112f2
  8025ae:	68 8e 00 00 00       	push   $0x8e
  8025b3:	68 c3 12 81 00       	push   $0x8112c3
  8025b8:	e8 96 c0 00 00       	call   80e653 <_panic>
    buf->ptr = NULL;
  8025bd:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    return ERR_MEM;
  8025c4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8025c9:	eb d4                	jmp    80259f <netbuf_ref+0x54>

008025cb <netbuf_chain>:
 * @param head the first netbuf
 * @param tail netbuf to chain after head
 */
void
netbuf_chain(struct netbuf *head, struct netbuf *tail)
{
  8025cb:	55                   	push   %ebp
  8025cc:	89 e5                	mov    %esp,%ebp
  8025ce:	56                   	push   %esi
  8025cf:	53                   	push   %ebx
  8025d0:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8025d3:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
  8025d6:	85 db                	test   %ebx,%ebx
  8025d8:	74 2a                	je     802604 <netbuf_chain+0x39>
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
  8025da:	85 f6                	test   %esi,%esi
  8025dc:	74 3d                	je     80261b <netbuf_chain+0x50>
  pbuf_chain(head->p, tail->p);
  8025de:	83 ec 08             	sub    $0x8,%esp
  8025e1:	ff 36                	pushl  (%esi)
  8025e3:	ff 33                	pushl  (%ebx)
  8025e5:	e8 3b 27 00 00       	call   804d25 <pbuf_chain>
  head->ptr = head->p;
  8025ea:	8b 03                	mov    (%ebx),%eax
  8025ec:	89 43 04             	mov    %eax,0x4(%ebx)
  memp_free(MEMP_NETBUF, tail);
  8025ef:	83 c4 08             	add    $0x8,%esp
  8025f2:	56                   	push   %esi
  8025f3:	6a 06                	push   $0x6
  8025f5:	e8 e4 1e 00 00       	call   8044de <memp_free>
}
  8025fa:	83 c4 10             	add    $0x10,%esp
  8025fd:	8d 65 f8             	lea    -0x8(%ebp),%esp
  802600:	5b                   	pop    %ebx
  802601:	5e                   	pop    %esi
  802602:	5d                   	pop    %ebp
  802603:	c3                   	ret    
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
  802604:	83 ec 04             	sub    $0x4,%esp
  802607:	68 0a 13 81 00       	push   $0x81130a
  80260c:	68 a6 00 00 00       	push   $0xa6
  802611:	68 c3 12 81 00       	push   $0x8112c3
  802616:	e8 38 c0 00 00       	call   80e653 <_panic>
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
  80261b:	83 ec 04             	sub    $0x4,%esp
  80261e:	68 23 13 81 00       	push   $0x811323
  802623:	68 a7 00 00 00       	push   $0xa7
  802628:	68 c3 12 81 00       	push   $0x8112c3
  80262d:	e8 21 c0 00 00       	call   80e653 <_panic>

00802632 <netbuf_data>:
 * @return ERR_OK if the information was retreived,
 *         ERR_BUF on error.
 */
err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
  802632:	55                   	push   %ebp
  802633:	89 e5                	mov    %esp,%ebp
  802635:	53                   	push   %ebx
  802636:	83 ec 04             	sub    $0x4,%esp
  802639:	8b 45 08             	mov    0x8(%ebp),%eax
  80263c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80263f:	8b 55 10             	mov    0x10(%ebp),%edx
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  802642:	85 c0                	test   %eax,%eax
  802644:	74 28                	je     80266e <netbuf_data+0x3c>
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  802646:	85 c9                	test   %ecx,%ecx
  802648:	74 3b                	je     802685 <netbuf_data+0x53>
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
  80264a:	85 d2                	test   %edx,%edx
  80264c:	74 4e                	je     80269c <netbuf_data+0x6a>

  if (buf->ptr == NULL) {
  80264e:	8b 58 04             	mov    0x4(%eax),%ebx
  802651:	85 db                	test   %ebx,%ebx
  802653:	74 5e                	je     8026b3 <netbuf_data+0x81>
    return ERR_BUF;
  }
  *dataptr = buf->ptr->payload;
  802655:	8b 5b 04             	mov    0x4(%ebx),%ebx
  802658:	89 19                	mov    %ebx,(%ecx)
  *len = buf->ptr->len;
  80265a:	8b 40 04             	mov    0x4(%eax),%eax
  80265d:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  802661:	66 89 02             	mov    %ax,(%edx)
  return ERR_OK;
  802664:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802669:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80266c:	c9                   	leave  
  80266d:	c3                   	ret    
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  80266e:	83 ec 04             	sub    $0x4,%esp
  802671:	68 3e 13 81 00       	push   $0x81133e
  802676:	68 b9 00 00 00       	push   $0xb9
  80267b:	68 c3 12 81 00       	push   $0x8112c3
  802680:	e8 ce bf 00 00       	call   80e653 <_panic>
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  802685:	83 ec 04             	sub    $0x4,%esp
  802688:	68 57 13 81 00       	push   $0x811357
  80268d:	68 ba 00 00 00       	push   $0xba
  802692:	68 c3 12 81 00       	push   $0x8112c3
  802697:	e8 b7 bf 00 00       	call   80e653 <_panic>
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
  80269c:	83 ec 04             	sub    $0x4,%esp
  80269f:	68 74 13 81 00       	push   $0x811374
  8026a4:	68 bb 00 00 00       	push   $0xbb
  8026a9:	68 c3 12 81 00       	push   $0x8112c3
  8026ae:	e8 a0 bf 00 00       	call   80e653 <_panic>
    return ERR_BUF;
  8026b3:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  8026b8:	eb af                	jmp    802669 <netbuf_data+0x37>

008026ba <netbuf_next>:
 *         1  if moved to the next part but now there is no next part
 *         0  if moved to the next part and there are still more parts
 */
s8_t
netbuf_next(struct netbuf *buf)
{
  8026ba:	55                   	push   %ebp
  8026bb:	89 e5                	mov    %esp,%ebp
  8026bd:	83 ec 08             	sub    $0x8,%esp
  8026c0:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  8026c3:	85 c0                	test   %eax,%eax
  8026c5:	74 14                	je     8026db <netbuf_next+0x21>
  if (buf->ptr->next == NULL) {
  8026c7:	8b 50 04             	mov    0x4(%eax),%edx
  8026ca:	8b 12                	mov    (%edx),%edx
  8026cc:	85 d2                	test   %edx,%edx
  8026ce:	74 22                	je     8026f2 <netbuf_next+0x38>
    return -1;
  }
  buf->ptr = buf->ptr->next;
  8026d0:	89 50 04             	mov    %edx,0x4(%eax)
  if (buf->ptr->next == NULL) {
  8026d3:	83 3a 00             	cmpl   $0x0,(%edx)
  8026d6:	0f 94 c0             	sete   %al
    return 1;
  }
  return 0;
}
  8026d9:	c9                   	leave  
  8026da:	c3                   	ret    
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  8026db:	83 ec 04             	sub    $0x4,%esp
  8026de:	68 d9 12 81 00       	push   $0x8112d9
  8026e3:	68 d2 00 00 00       	push   $0xd2
  8026e8:	68 c3 12 81 00       	push   $0x8112c3
  8026ed:	e8 61 bf 00 00       	call   80e653 <_panic>
    return -1;
  8026f2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8026f7:	eb e0                	jmp    8026d9 <netbuf_next+0x1f>

008026f9 <netbuf_first>:
 *
 * @param buf the netbuf to modify
 */
void
netbuf_first(struct netbuf *buf)
{
  8026f9:	55                   	push   %ebp
  8026fa:	89 e5                	mov    %esp,%ebp
  8026fc:	83 ec 08             	sub    $0x8,%esp
  8026ff:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  802702:	85 c0                	test   %eax,%eax
  802704:	74 07                	je     80270d <netbuf_first+0x14>
  buf->ptr = buf->p;
  802706:	8b 10                	mov    (%eax),%edx
  802708:	89 50 04             	mov    %edx,0x4(%eax)
}
  80270b:	c9                   	leave  
  80270c:	c3                   	ret    
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  80270d:	83 ec 04             	sub    $0x4,%esp
  802710:	68 d9 12 81 00       	push   $0x8112d9
  802715:	68 e7 00 00 00       	push   $0xe7
  80271a:	68 c3 12 81 00       	push   $0x8112c3
  80271f:	e8 2f bf 00 00       	call   80e653 <_panic>

00802724 <lwip_init>:
/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void
lwip_init(void)
{
  802724:	55                   	push   %ebp
  802725:	89 e5                	mov    %esp,%ebp
  802727:	83 ec 08             	sub    $0x8,%esp
  /* Sanity check user-configurable values */
  lwip_sanity_check();

  /* Modules initialization */
  stats_init();
  sys_init();
  80272a:	e8 9b 76 00 00       	call   809dca <sys_init>
  mem_init();
  80272f:	e8 95 17 00 00       	call   803ec9 <mem_init>
  memp_init();
  802734:	e8 e6 1c 00 00       	call   80441f <memp_init>
  pbuf_init();
  netif_init();
#if LWIP_SOCKET
  lwip_socket_init();
  802739:	e8 b7 e6 ff ff       	call   800df5 <lwip_socket_init>
  igmp_init();
#endif /* LWIP_IGMP */
#if LWIP_DNS
  dns_init();
#endif /* LWIP_DNS */
}
  80273e:	c9                   	leave  
  80273f:	c3                   	ret    

00802740 <dhcp_set_state>:
 *
 * TODO: we might also want to reset the timeout here?
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  802740:	55                   	push   %ebp
  802741:	89 e5                	mov    %esp,%ebp
  if (new_state != dhcp->state) {
  802743:	38 10                	cmp    %dl,(%eax)
  802745:	74 06                	je     80274d <dhcp_set_state+0xd>
    dhcp->state = new_state;
  802747:	88 10                	mov    %dl,(%eax)
    dhcp->tries = 0;
  802749:	c6 40 01 00          	movb   $0x0,0x1(%eax)
  }
}
  80274d:	5d                   	pop    %ebp
  80274e:	c3                   	ret    

0080274f <dhcp_get_option_ptr>:
 *
 * @return a byte offset into the UDP message where the option was found, or
 * zero if the given option was not found.
 */
static u8_t *dhcp_get_option_ptr(struct dhcp *dhcp, u8_t option_type)
{
  80274f:	55                   	push   %ebp
  802750:	89 e5                	mov    %esp,%ebp
  802752:	57                   	push   %edi
  802753:	56                   	push   %esi
  802754:	53                   	push   %ebx
  802755:	83 ec 08             	sub    $0x8,%esp
  802758:	89 45 ec             	mov    %eax,-0x14(%ebp)
  u8_t overload = DHCP_OVERLOAD_NONE;

  /* options available? */
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
  80275b:	8b 70 14             	mov    0x14(%eax),%esi
  80275e:	85 f6                	test   %esi,%esi
  802760:	0f 84 da 00 00 00    	je     802840 <dhcp_get_option_ptr+0xf1>
  802766:	0f b7 78 18          	movzwl 0x18(%eax),%edi
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
    u16_t offset = 0;
  80276a:	b9 00 00 00 00       	mov    $0x0,%ecx
  u8_t overload = DHCP_OVERLOAD_NONE;
  80276f:	c6 45 f0 00          	movb   $0x0,-0x10(%ebp)
          offset += 1 + options[offset];
        }
      }
    }
  }
  return NULL;
  802773:	b8 00 00 00 00       	mov    $0x0,%eax
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
  802778:	66 85 ff             	test   %di,%di
  80277b:	75 25                	jne    8027a2 <dhcp_get_option_ptr+0x53>
  80277d:	e9 d1 00 00 00       	jmp    802853 <dhcp_get_option_ptr+0x104>
        offset += 2;
  802782:	8d 41 02             	lea    0x2(%ecx),%eax
        overload = options[offset++];
  802785:	83 c1 03             	add    $0x3,%ecx
  802788:	0f b7 c0             	movzwl %ax,%eax
  80278b:	0f b6 04 06          	movzbl (%esi,%eax,1),%eax
  80278f:	88 45 f0             	mov    %al,-0x10(%ebp)
  802792:	eb 0e                	jmp    8027a2 <dhcp_get_option_ptr+0x53>
        offset++;
  802794:	8d 41 01             	lea    0x1(%ecx),%eax
        offset += 1 + options[offset];
  802797:	0f b7 c0             	movzwl %ax,%eax
  80279a:	0f b6 04 06          	movzbl (%esi,%eax,1),%eax
  80279e:	8d 4c 08 02          	lea    0x2(%eax,%ecx,1),%ecx
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  8027a2:	66 39 cf             	cmp    %cx,%di
  8027a5:	76 1b                	jbe    8027c2 <dhcp_get_option_ptr+0x73>
  8027a7:	0f b7 c1             	movzwl %cx,%eax
  8027aa:	01 f0                	add    %esi,%eax
  8027ac:	0f b6 18             	movzbl (%eax),%ebx
  8027af:	80 fb ff             	cmp    $0xff,%bl
  8027b2:	74 0e                	je     8027c2 <dhcp_get_option_ptr+0x73>
      if (options[offset] == DHCP_OPTION_OVERLOAD) {
  8027b4:	80 fb 34             	cmp    $0x34,%bl
  8027b7:	74 c9                	je     802782 <dhcp_get_option_ptr+0x33>
      else if (options[offset] == option_type) {
  8027b9:	38 d3                	cmp    %dl,%bl
  8027bb:	75 d7                	jne    802794 <dhcp_get_option_ptr+0x45>
  8027bd:	e9 91 00 00 00       	jmp    802853 <dhcp_get_option_ptr+0x104>
    if (overload != DHCP_OVERLOAD_NONE) {
  8027c2:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
  8027c6:	84 c0                	test   %al,%al
  8027c8:	74 7d                	je     802847 <dhcp_get_option_ptr+0xf8>
      if (overload == DHCP_OVERLOAD_FILE) {
  8027ca:	3c 01                	cmp    $0x1,%al
  8027cc:	74 1d                	je     8027eb <dhcp_get_option_ptr+0x9c>
      } else if (overload == DHCP_OVERLOAD_SNAME) {
  8027ce:	80 7d f0 02          	cmpb   $0x2,-0x10(%ebp)
  8027d2:	74 27                	je     8027fb <dhcp_get_option_ptr+0xac>
        options = (u8_t *)&dhcp->msg_in->sname;
  8027d4:	8b 45 ec             	mov    -0x14(%ebp),%eax
  8027d7:	8b 58 10             	mov    0x10(%eax),%ebx
  8027da:	83 c3 2c             	add    $0x2c,%ebx
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
  8027dd:	be c0 00 00 00       	mov    $0xc0,%esi
      offset = 0;
  8027e2:	b9 00 00 00 00       	mov    $0x0,%ecx
  8027e7:	89 d7                	mov    %edx,%edi
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  8027e9:	eb 2e                	jmp    802819 <dhcp_get_option_ptr+0xca>
        options = (u8_t *)&dhcp->msg_in->file;
  8027eb:	8b 45 ec             	mov    -0x14(%ebp),%eax
  8027ee:	8b 58 10             	mov    0x10(%eax),%ebx
  8027f1:	83 c3 6c             	add    $0x6c,%ebx
        field_len = DHCP_FILE_LEN;
  8027f4:	be 80 00 00 00       	mov    $0x80,%esi
  8027f9:	eb e7                	jmp    8027e2 <dhcp_get_option_ptr+0x93>
        options = (u8_t *)&dhcp->msg_in->sname;
  8027fb:	8b 45 ec             	mov    -0x14(%ebp),%eax
  8027fe:	8b 58 10             	mov    0x10(%eax),%ebx
  802801:	83 c3 2c             	add    $0x2c,%ebx
        field_len = DHCP_SNAME_LEN;
  802804:	be 40 00 00 00       	mov    $0x40,%esi
  802809:	eb d7                	jmp    8027e2 <dhcp_get_option_ptr+0x93>
          offset++;
  80280b:	8d 41 01             	lea    0x1(%ecx),%eax
          offset += 1 + options[offset];
  80280e:	0f b7 c0             	movzwl %ax,%eax
  802811:	0f b6 04 03          	movzbl (%ebx,%eax,1),%eax
  802815:	8d 4c 01 02          	lea    0x2(%ecx,%eax,1),%ecx
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  802819:	66 39 ce             	cmp    %cx,%si
  80281c:	76 30                	jbe    80284e <dhcp_get_option_ptr+0xff>
  80281e:	0f b7 c1             	movzwl %cx,%eax
  802821:	01 d8                	add    %ebx,%eax
  802823:	89 45 f0             	mov    %eax,-0x10(%ebp)
  802826:	0f b6 10             	movzbl (%eax),%edx
  802829:	80 fa ff             	cmp    $0xff,%dl
  80282c:	74 0b                	je     802839 <dhcp_get_option_ptr+0xea>
        if (options[offset] == option_type) {
  80282e:	89 f8                	mov    %edi,%eax
  802830:	38 c2                	cmp    %al,%dl
  802832:	75 d7                	jne    80280b <dhcp_get_option_ptr+0xbc>
  802834:	8b 45 f0             	mov    -0x10(%ebp),%eax
  802837:	eb 1a                	jmp    802853 <dhcp_get_option_ptr+0x104>
  return NULL;
  802839:	b8 00 00 00 00       	mov    $0x0,%eax
  80283e:	eb 13                	jmp    802853 <dhcp_get_option_ptr+0x104>
  802840:	b8 00 00 00 00       	mov    $0x0,%eax
  802845:	eb 0c                	jmp    802853 <dhcp_get_option_ptr+0x104>
  802847:	b8 00 00 00 00       	mov    $0x0,%eax
  80284c:	eb 05                	jmp    802853 <dhcp_get_option_ptr+0x104>
  80284e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802853:	83 c4 08             	add    $0x8,%esp
  802856:	5b                   	pop    %ebx
  802857:	5e                   	pop    %esi
  802858:	5f                   	pop    %edi
  802859:	5d                   	pop    %ebp
  80285a:	c3                   	ret    

0080285b <dhcp_get_option_long>:
 * @param ptr pointer obtained by dhcp_get_option_ptr().
 *
 * @return byte value at the given address.
 */
static u32_t dhcp_get_option_long(u8_t *ptr)
{
  80285b:	55                   	push   %ebp
  80285c:	89 e5                	mov    %esp,%ebp
  u32_t value;
  value = (u32_t)(*ptr++) << 24;
  80285e:	0f b6 10             	movzbl (%eax),%edx
  802861:	89 d1                	mov    %edx,%ecx
  802863:	c1 e1 18             	shl    $0x18,%ecx
  value |= (u32_t)(*ptr++) << 16;
  802866:	0f b6 50 01          	movzbl 0x1(%eax),%edx
  80286a:	c1 e2 10             	shl    $0x10,%edx
  80286d:	09 ca                	or     %ecx,%edx
  value |= (u32_t)(*ptr++) << 8;
  value |= (u32_t)(*ptr++);
  80286f:	0f b6 48 03          	movzbl 0x3(%eax),%ecx
  802873:	09 ca                	or     %ecx,%edx
  value |= (u32_t)(*ptr++) << 8;
  802875:	0f b6 40 02          	movzbl 0x2(%eax),%eax
  802879:	c1 e0 08             	shl    $0x8,%eax
  value |= (u32_t)(*ptr++);
  80287c:	09 d0                	or     %edx,%eax
  LWIP_DEBUGF(DHCP_DEBUG, ("option long value=%"U32_F"\n", value));
  return value;
}
  80287e:	5d                   	pop    %ebp
  80287f:	c3                   	ret    

00802880 <dhcp_option_byte>:
{
  802880:	55                   	push   %ebp
  802881:	89 e5                	mov    %esp,%ebp
  802883:	56                   	push   %esi
  802884:	53                   	push   %ebx
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802885:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802889:	66 83 f9 43          	cmp    $0x43,%cx
  80288d:	77 1b                	ja     8028aa <dhcp_option_byte+0x2a>
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
  80288f:	8b 58 20             	mov    0x20(%eax),%ebx
  802892:	8d 71 01             	lea    0x1(%ecx),%esi
  802895:	66 89 70 24          	mov    %si,0x24(%eax)
  802899:	0f b7 c9             	movzwl %cx,%ecx
  80289c:	88 94 0b f0 00 00 00 	mov    %dl,0xf0(%ebx,%ecx,1)
}
  8028a3:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8028a6:	5b                   	pop    %ebx
  8028a7:	5e                   	pop    %esi
  8028a8:	5d                   	pop    %ebp
  8028a9:	c3                   	ret    
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  8028aa:	83 ec 04             	sub    $0x4,%esp
  8028ad:	68 b4 13 81 00       	push   $0x8113b4
  8028b2:	68 65 04 00 00       	push   $0x465
  8028b7:	68 02 17 81 00       	push   $0x811702
  8028bc:	e8 92 bd 00 00       	call   80e653 <_panic>

008028c1 <dhcp_option>:
{
  8028c1:	55                   	push   %ebp
  8028c2:	89 e5                	mov    %esp,%ebp
  8028c4:	57                   	push   %edi
  8028c5:	56                   	push   %esi
  8028c6:	53                   	push   %ebx
  8028c7:	83 ec 0c             	sub    $0xc,%esp
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  8028ca:	0f b7 58 24          	movzwl 0x24(%eax),%ebx
  8028ce:	0f b6 f9             	movzbl %cl,%edi
  8028d1:	0f b7 f3             	movzwl %bx,%esi
  8028d4:	8d 74 37 02          	lea    0x2(%edi,%esi,1),%esi
  8028d8:	83 fe 44             	cmp    $0x44,%esi
  8028db:	77 34                	ja     802911 <dhcp_option+0x50>
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
  8028dd:	8b 70 20             	mov    0x20(%eax),%esi
  8028e0:	8d 7b 01             	lea    0x1(%ebx),%edi
  8028e3:	66 89 78 24          	mov    %di,0x24(%eax)
  8028e7:	0f b7 db             	movzwl %bx,%ebx
  8028ea:	88 94 1e f0 00 00 00 	mov    %dl,0xf0(%esi,%ebx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
  8028f1:	8b 58 20             	mov    0x20(%eax),%ebx
  8028f4:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  8028f8:	8d 72 01             	lea    0x1(%edx),%esi
  8028fb:	66 89 70 24          	mov    %si,0x24(%eax)
  8028ff:	0f b7 d2             	movzwl %dx,%edx
  802902:	88 8c 13 f0 00 00 00 	mov    %cl,0xf0(%ebx,%edx,1)
}
  802909:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80290c:	5b                   	pop    %ebx
  80290d:	5e                   	pop    %esi
  80290e:	5f                   	pop    %edi
  80290f:	5d                   	pop    %ebp
  802910:	c3                   	ret    
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  802911:	83 ec 04             	sub    $0x4,%esp
  802914:	68 f0 13 81 00       	push   $0x8113f0
  802919:	68 5a 04 00 00       	push   $0x45a
  80291e:	68 02 17 81 00       	push   $0x811702
  802923:	e8 2b bd 00 00       	call   80e653 <_panic>

00802928 <dhcp_option_short>:
{
  802928:	55                   	push   %ebp
  802929:	89 e5                	mov    %esp,%ebp
  80292b:	56                   	push   %esi
  80292c:	53                   	push   %ebx
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  80292d:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802931:	0f b7 d9             	movzwl %cx,%ebx
  802934:	83 c3 02             	add    $0x2,%ebx
  802937:	83 fb 44             	cmp    $0x44,%ebx
  80293a:	77 33                	ja     80296f <dhcp_option_short+0x47>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
  80293c:	8b 58 20             	mov    0x20(%eax),%ebx
  80293f:	8d 71 01             	lea    0x1(%ecx),%esi
  802942:	66 89 70 24          	mov    %si,0x24(%eax)
  802946:	0f b7 c9             	movzwl %cx,%ecx
  802949:	88 b4 0b f0 00 00 00 	mov    %dh,0xf0(%ebx,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
  802950:	8b 58 20             	mov    0x20(%eax),%ebx
  802953:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802957:	8d 71 01             	lea    0x1(%ecx),%esi
  80295a:	66 89 70 24          	mov    %si,0x24(%eax)
  80295e:	0f b7 c9             	movzwl %cx,%ecx
  802961:	88 94 0b f0 00 00 00 	mov    %dl,0xf0(%ebx,%ecx,1)
}
  802968:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80296b:	5b                   	pop    %ebx
  80296c:	5e                   	pop    %esi
  80296d:	5d                   	pop    %ebp
  80296e:	c3                   	ret    
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  80296f:	83 ec 04             	sub    $0x4,%esp
  802972:	68 38 14 81 00       	push   $0x811438
  802977:	68 6c 04 00 00       	push   $0x46c
  80297c:	68 02 17 81 00       	push   $0x811702
  802981:	e8 cd bc 00 00       	call   80e653 <_panic>

00802986 <dhcp_option_trailer>:
{
  802986:	55                   	push   %ebp
  802987:	89 e5                	mov    %esp,%ebp
  802989:	53                   	push   %ebx
  80298a:	83 ec 04             	sub    $0x4,%esp
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  80298d:	85 c0                	test   %eax,%eax
  80298f:	74 25                	je     8029b6 <dhcp_option_trailer+0x30>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  802991:	8b 48 20             	mov    0x20(%eax),%ecx
  802994:	85 c9                	test   %ecx,%ecx
  802996:	74 35                	je     8029cd <dhcp_option_trailer+0x47>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802998:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  80299c:	66 83 fa 43          	cmp    $0x43,%dx
  8029a0:	77 42                	ja     8029e4 <dhcp_option_trailer+0x5e>
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  8029a2:	8d 5a 01             	lea    0x1(%edx),%ebx
  8029a5:	66 89 58 24          	mov    %bx,0x24(%eax)
  8029a9:	0f b7 d2             	movzwl %dx,%edx
  8029ac:	c6 84 11 f0 00 00 00 	movb   $0xff,0xf0(%ecx,%edx,1)
  8029b3:	ff 
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  8029b4:	eb 5a                	jmp    802a10 <dhcp_option_trailer+0x8a>
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  8029b6:	83 ec 04             	sub    $0x4,%esp
  8029b9:	68 7c 14 81 00       	push   $0x81147c
  8029be:	68 80 05 00 00       	push   $0x580
  8029c3:	68 02 17 81 00       	push   $0x811702
  8029c8:	e8 86 bc 00 00       	call   80e653 <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  8029cd:	83 ec 04             	sub    $0x4,%esp
  8029d0:	68 a0 14 81 00       	push   $0x8114a0
  8029d5:	68 81 05 00 00       	push   $0x581
  8029da:	68 02 17 81 00       	push   $0x811702
  8029df:	e8 6f bc 00 00       	call   80e653 <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  8029e4:	83 ec 04             	sub    $0x4,%esp
  8029e7:	68 cc 14 81 00       	push   $0x8114cc
  8029ec:	68 82 05 00 00       	push   $0x582
  8029f1:	68 02 17 81 00       	push   $0x811702
  8029f6:	e8 58 bc 00 00       	call   80e653 <_panic>
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  8029fb:	8b 48 20             	mov    0x20(%eax),%ecx
  8029fe:	8d 5a 01             	lea    0x1(%edx),%ebx
  802a01:	66 89 58 24          	mov    %bx,0x24(%eax)
  802a05:	0f b7 d2             	movzwl %dx,%edx
  802a08:	c6 84 11 f0 00 00 00 	movb   $0x0,0xf0(%ecx,%edx,1)
  802a0f:	00 
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  802a10:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  802a14:	66 83 fa 43          	cmp    $0x43,%dx
  802a18:	76 e1                	jbe    8029fb <dhcp_option_trailer+0x75>
  802a1a:	f6 c2 03             	test   $0x3,%dl
  802a1d:	74 17                	je     802a36 <dhcp_option_trailer+0xb0>
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802a1f:	83 ec 04             	sub    $0x4,%esp
  802a22:	68 cc 14 81 00       	push   $0x8114cc
  802a27:	68 87 05 00 00       	push   $0x587
  802a2c:	68 02 17 81 00       	push   $0x811702
  802a31:	e8 1d bc 00 00       	call   80e653 <_panic>
}
  802a36:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802a39:	c9                   	leave  
  802a3a:	c3                   	ret    

00802a3b <dhcp_option_long>:
{
  802a3b:	55                   	push   %ebp
  802a3c:	89 e5                	mov    %esp,%ebp
  802a3e:	56                   	push   %esi
  802a3f:	53                   	push   %ebx
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  802a40:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802a44:	0f b7 d9             	movzwl %cx,%ebx
  802a47:	83 c3 04             	add    $0x4,%ebx
  802a4a:	83 fb 44             	cmp    $0x44,%ebx
  802a4d:	77 6d                	ja     802abc <dhcp_option_long+0x81>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
  802a4f:	8d 71 01             	lea    0x1(%ecx),%esi
  802a52:	66 89 70 24          	mov    %si,0x24(%eax)
  802a56:	0f b7 c9             	movzwl %cx,%ecx
  802a59:	89 d3                	mov    %edx,%ebx
  802a5b:	c1 eb 18             	shr    $0x18,%ebx
  802a5e:	8b 70 20             	mov    0x20(%eax),%esi
  802a61:	88 9c 0e f0 00 00 00 	mov    %bl,0xf0(%esi,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
  802a68:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802a6c:	8d 71 01             	lea    0x1(%ecx),%esi
  802a6f:	66 89 70 24          	mov    %si,0x24(%eax)
  802a73:	0f b7 c9             	movzwl %cx,%ecx
  802a76:	89 d3                	mov    %edx,%ebx
  802a78:	c1 eb 10             	shr    $0x10,%ebx
  802a7b:	8b 70 20             	mov    0x20(%eax),%esi
  802a7e:	88 9c 0e f0 00 00 00 	mov    %bl,0xf0(%esi,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
  802a85:	8b 58 20             	mov    0x20(%eax),%ebx
  802a88:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802a8c:	8d 71 01             	lea    0x1(%ecx),%esi
  802a8f:	66 89 70 24          	mov    %si,0x24(%eax)
  802a93:	0f b7 c9             	movzwl %cx,%ecx
  802a96:	88 b4 0b f0 00 00 00 	mov    %dh,0xf0(%ebx,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
  802a9d:	8b 58 20             	mov    0x20(%eax),%ebx
  802aa0:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802aa4:	8d 71 01             	lea    0x1(%ecx),%esi
  802aa7:	66 89 70 24          	mov    %si,0x24(%eax)
  802aab:	0f b7 c9             	movzwl %cx,%ecx
  802aae:	88 94 0b f0 00 00 00 	mov    %dl,0xf0(%ebx,%ecx,1)
}
  802ab5:	8d 65 f8             	lea    -0x8(%ebp),%esp
  802ab8:	5b                   	pop    %ebx
  802ab9:	5e                   	pop    %esi
  802aba:	5d                   	pop    %ebp
  802abb:	c3                   	ret    
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  802abc:	83 ec 04             	sub    $0x4,%esp
  802abf:	68 0c 15 81 00       	push   $0x81150c
  802ac4:	68 74 04 00 00       	push   $0x474
  802ac9:	68 02 17 81 00       	push   $0x811702
  802ace:	e8 80 bb 00 00       	call   80e653 <_panic>

00802ad3 <dhcp_create_request>:
{
  802ad3:	55                   	push   %ebp
  802ad4:	89 e5                	mov    %esp,%ebp
  802ad6:	57                   	push   %edi
  802ad7:	56                   	push   %esi
  802ad8:	53                   	push   %ebx
  802ad9:	83 ec 0c             	sub    $0xc,%esp
  LWIP_ERROR("dhcp_create_request: netif != NULL", (netif != NULL), return ERR_ARG;);
  802adc:	85 c0                	test   %eax,%eax
  802ade:	0f 84 d8 00 00 00    	je     802bbc <dhcp_create_request+0xe9>
  802ae4:	89 c6                	mov    %eax,%esi
  dhcp = netif->dhcp;
  802ae6:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_create_request: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  802ae9:	85 db                	test   %ebx,%ebx
  802aeb:	0f 84 e2 00 00 00    	je     802bd3 <dhcp_create_request+0x100>
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  802af1:	83 7b 1c 00          	cmpl   $0x0,0x1c(%ebx)
  802af5:	0f 85 ef 00 00 00    	jne    802bea <dhcp_create_request+0x117>
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  802afb:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  802aff:	0f 85 fc 00 00 00    	jne    802c01 <dhcp_create_request+0x12e>
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  802b05:	83 ec 04             	sub    $0x4,%esp
  802b08:	6a 00                	push   $0x0
  802b0a:	68 34 01 00 00       	push   $0x134
  802b0f:	6a 00                	push   $0x0
  802b11:	e8 fd 1d 00 00       	call   804913 <pbuf_alloc>
  802b16:	89 43 1c             	mov    %eax,0x1c(%ebx)
  if (dhcp->p_out == NULL) {
  802b19:	83 c4 10             	add    $0x10,%esp
  802b1c:	85 c0                	test   %eax,%eax
  802b1e:	0f 84 9b 01 00 00    	je     802cbf <dhcp_create_request+0x1ec>
  LWIP_ASSERT("dhcp_create_request: check that first pbuf can hold struct dhcp_msg",
  802b24:	66 81 78 0a 33 01    	cmpw   $0x133,0xa(%eax)
  802b2a:	0f 86 e8 00 00 00    	jbe    802c18 <dhcp_create_request+0x145>
  dhcp->xid = xid++;
  802b30:	8b 15 04 40 81 00    	mov    0x814004,%edx
  802b36:	8d 4a 01             	lea    0x1(%edx),%ecx
  802b39:	89 0d 04 40 81 00    	mov    %ecx,0x814004
  802b3f:	89 53 04             	mov    %edx,0x4(%ebx)
  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
  802b42:	8b 40 04             	mov    0x4(%eax),%eax
  802b45:	89 43 20             	mov    %eax,0x20(%ebx)
  dhcp->msg_out->op = DHCP_BOOTREQUEST;
  802b48:	c6 00 01             	movb   $0x1,(%eax)
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
  802b4b:	8b 43 20             	mov    0x20(%ebx),%eax
  802b4e:	c6 40 01 01          	movb   $0x1,0x1(%eax)
  dhcp->msg_out->hlen = DHCP_HLEN_ETH;
  802b52:	8b 43 20             	mov    0x20(%ebx),%eax
  802b55:	c6 40 02 06          	movb   $0x6,0x2(%eax)
  dhcp->msg_out->hops = 0;
  802b59:	8b 43 20             	mov    0x20(%ebx),%eax
  802b5c:	c6 40 03 00          	movb   $0x0,0x3(%eax)
  dhcp->msg_out->xid = htonl(dhcp->xid);
  802b60:	8b 7b 20             	mov    0x20(%ebx),%edi
  802b63:	83 ec 0c             	sub    $0xc,%esp
  802b66:	ff 73 04             	pushl  0x4(%ebx)
  802b69:	e8 2e 4c 00 00       	call   80779c <htonl>
  802b6e:	89 47 04             	mov    %eax,0x4(%edi)
  dhcp->msg_out->secs = 0;
  802b71:	8b 43 20             	mov    0x20(%ebx),%eax
  802b74:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
  dhcp->msg_out->flags = 0;
  802b7a:	8b 43 20             	mov    0x20(%ebx),%eax
  802b7d:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%eax)
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  802b83:	8b 43 20             	mov    0x20(%ebx),%eax
  802b86:	8b 56 04             	mov    0x4(%esi),%edx
  802b89:	89 50 0c             	mov    %edx,0xc(%eax)
  dhcp->msg_out->yiaddr.addr = 0;
  802b8c:	8b 43 20             	mov    0x20(%ebx),%eax
  802b8f:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  dhcp->msg_out->siaddr.addr = 0;
  802b96:	8b 43 20             	mov    0x20(%ebx),%eax
  802b99:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  dhcp->msg_out->giaddr.addr = 0;
  802ba0:	8b 43 20             	mov    0x20(%ebx),%eax
  802ba3:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  802baa:	83 c4 10             	add    $0x10,%esp
  802bad:	b8 00 00 00 00       	mov    $0x0,%eax
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  802bb2:	bf 00 00 00 00       	mov    $0x0,%edi
  802bb7:	e9 82 00 00 00       	jmp    802c3e <dhcp_create_request+0x16b>
  LWIP_ERROR("dhcp_create_request: netif != NULL", (netif != NULL), return ERR_ARG;);
  802bbc:	83 ec 04             	sub    $0x4,%esp
  802bbf:	68 4c 15 81 00       	push   $0x81154c
  802bc4:	68 2d 05 00 00       	push   $0x52d
  802bc9:	68 02 17 81 00       	push   $0x811702
  802bce:	e8 80 ba 00 00       	call   80e653 <_panic>
  LWIP_ERROR("dhcp_create_request: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  802bd3:	83 ec 04             	sub    $0x4,%esp
  802bd6:	68 70 15 81 00       	push   $0x811570
  802bdb:	68 2f 05 00 00       	push   $0x52f
  802be0:	68 02 17 81 00       	push   $0x811702
  802be5:	e8 69 ba 00 00       	call   80e653 <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  802bea:	83 ec 04             	sub    $0x4,%esp
  802bed:	68 94 15 81 00       	push   $0x811594
  802bf2:	68 30 05 00 00       	push   $0x530
  802bf7:	68 02 17 81 00       	push   $0x811702
  802bfc:	e8 52 ba 00 00       	call   80e653 <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  802c01:	83 ec 04             	sub    $0x4,%esp
  802c04:	68 c0 15 81 00       	push   $0x8115c0
  802c09:	68 31 05 00 00       	push   $0x531
  802c0e:	68 02 17 81 00       	push   $0x811702
  802c13:	e8 3b ba 00 00       	call   80e653 <_panic>
  LWIP_ASSERT("dhcp_create_request: check that first pbuf can hold struct dhcp_msg",
  802c18:	83 ec 04             	sub    $0x4,%esp
  802c1b:	68 ec 15 81 00       	push   $0x8115ec
  802c20:	68 38 05 00 00       	push   $0x538
  802c25:	68 02 17 81 00       	push   $0x811702
  802c2a:	e8 24 ba 00 00       	call   80e653 <_panic>
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  802c2f:	8b 4b 20             	mov    0x20(%ebx),%ecx
  802c32:	88 54 01 1c          	mov    %dl,0x1c(%ecx,%eax,1)
  802c36:	83 c0 01             	add    $0x1,%eax
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
  802c39:	83 f8 10             	cmp    $0x10,%eax
  802c3c:	74 12                	je     802c50 <dhcp_create_request+0x17d>
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  802c3e:	0f b6 4e 24          	movzbl 0x24(%esi),%ecx
  802c42:	89 fa                	mov    %edi,%edx
  802c44:	66 39 c1             	cmp    %ax,%cx
  802c47:	76 e6                	jbe    802c2f <dhcp_create_request+0x15c>
  802c49:	0f b6 54 06 25       	movzbl 0x25(%esi,%eax,1),%edx
  802c4e:	eb df                	jmp    802c2f <dhcp_create_request+0x15c>
  802c50:	b8 00 00 00 00       	mov    $0x0,%eax
    dhcp->msg_out->sname[i] = 0;
  802c55:	8b 53 20             	mov    0x20(%ebx),%edx
  802c58:	c6 44 02 2c 00       	movb   $0x0,0x2c(%edx,%eax,1)
  802c5d:	83 c0 01             	add    $0x1,%eax
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
  802c60:	83 f8 40             	cmp    $0x40,%eax
  802c63:	75 f0                	jne    802c55 <dhcp_create_request+0x182>
  802c65:	b8 00 00 00 00       	mov    $0x0,%eax
    dhcp->msg_out->file[i] = 0;
  802c6a:	8b 53 20             	mov    0x20(%ebx),%edx
  802c6d:	c6 44 02 6c 00       	movb   $0x0,0x6c(%edx,%eax,1)
  802c72:	83 c0 01             	add    $0x1,%eax
  for (i = 0; i < DHCP_FILE_LEN; i++) {
  802c75:	3d 80 00 00 00       	cmp    $0x80,%eax
  802c7a:	75 ee                	jne    802c6a <dhcp_create_request+0x197>
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  802c7c:	8b 73 20             	mov    0x20(%ebx),%esi
  802c7f:	83 ec 0c             	sub    $0xc,%esp
  802c82:	68 63 53 82 63       	push   $0x63825363
  802c87:	e8 10 4b 00 00       	call   80779c <htonl>
  802c8c:	89 86 ec 00 00 00    	mov    %eax,0xec(%esi)
  dhcp->options_out_len = 0;
  802c92:	66 c7 43 24 00 00    	movw   $0x0,0x24(%ebx)
  802c98:	83 c4 10             	add    $0x10,%esp
  802c9b:	b8 00 00 00 00       	mov    $0x0,%eax
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  802ca0:	8b 53 20             	mov    0x20(%ebx),%edx
  802ca3:	88 84 02 f0 00 00 00 	mov    %al,0xf0(%edx,%eax,1)
  802caa:	83 c0 01             	add    $0x1,%eax
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
  802cad:	83 f8 44             	cmp    $0x44,%eax
  802cb0:	75 ee                	jne    802ca0 <dhcp_create_request+0x1cd>
  return ERR_OK;
  802cb2:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802cb7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  802cba:	5b                   	pop    %ebx
  802cbb:	5e                   	pop    %esi
  802cbc:	5f                   	pop    %edi
  802cbd:	5d                   	pop    %ebp
  802cbe:	c3                   	ret    
    return ERR_MEM;
  802cbf:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802cc4:	eb f1                	jmp    802cb7 <dhcp_create_request+0x1e4>

00802cc6 <dhcp_delete_request>:
{
  802cc6:	55                   	push   %ebp
  802cc7:	89 e5                	mov    %esp,%ebp
  802cc9:	53                   	push   %ebx
  802cca:	83 ec 04             	sub    $0x4,%esp
  LWIP_ERROR("dhcp_delete_request: netif != NULL", (netif != NULL), return;);
  802ccd:	85 c0                	test   %eax,%eax
  802ccf:	74 33                	je     802d04 <dhcp_delete_request+0x3e>
  dhcp = netif->dhcp;
  802cd1:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_delete_request: dhcp != NULL", (dhcp != NULL), return;);
  802cd4:	85 db                	test   %ebx,%ebx
  802cd6:	74 43                	je     802d1b <dhcp_delete_request+0x55>
  LWIP_ASSERT("dhcp_delete_request: dhcp->p_out != NULL", dhcp->p_out != NULL);
  802cd8:	8b 43 1c             	mov    0x1c(%ebx),%eax
  802cdb:	85 c0                	test   %eax,%eax
  802cdd:	74 53                	je     802d32 <dhcp_delete_request+0x6c>
  LWIP_ASSERT("dhcp_delete_request: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  802cdf:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  802ce3:	74 64                	je     802d49 <dhcp_delete_request+0x83>
    pbuf_free(dhcp->p_out);
  802ce5:	83 ec 0c             	sub    $0xc,%esp
  802ce8:	50                   	push   %eax
  802ce9:	e8 5f 1b 00 00       	call   80484d <pbuf_free>
  dhcp->p_out = NULL;
  802cee:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
  dhcp->msg_out = NULL;
  802cf5:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
}
  802cfc:	83 c4 10             	add    $0x10,%esp
  802cff:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802d02:	c9                   	leave  
  802d03:	c3                   	ret    
  LWIP_ERROR("dhcp_delete_request: netif != NULL", (netif != NULL), return;);
  802d04:	83 ec 04             	sub    $0x4,%esp
  802d07:	68 30 16 81 00       	push   $0x811630
  802d0c:	68 69 05 00 00       	push   $0x569
  802d11:	68 02 17 81 00       	push   $0x811702
  802d16:	e8 38 b9 00 00       	call   80e653 <_panic>
  LWIP_ERROR("dhcp_delete_request: dhcp != NULL", (dhcp != NULL), return;);
  802d1b:	83 ec 04             	sub    $0x4,%esp
  802d1e:	68 54 16 81 00       	push   $0x811654
  802d23:	68 6b 05 00 00       	push   $0x56b
  802d28:	68 02 17 81 00       	push   $0x811702
  802d2d:	e8 21 b9 00 00       	call   80e653 <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->p_out != NULL", dhcp->p_out != NULL);
  802d32:	83 ec 04             	sub    $0x4,%esp
  802d35:	68 78 16 81 00       	push   $0x811678
  802d3a:	68 6c 05 00 00       	push   $0x56c
  802d3f:	68 02 17 81 00       	push   $0x811702
  802d44:	e8 0a b9 00 00       	call   80e653 <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  802d49:	83 ec 04             	sub    $0x4,%esp
  802d4c:	68 a4 16 81 00       	push   $0x8116a4
  802d51:	68 6d 05 00 00       	push   $0x56d
  802d56:	68 02 17 81 00       	push   $0x811702
  802d5b:	e8 f3 b8 00 00       	call   80e653 <_panic>

00802d60 <dhcp_rebind>:
{
  802d60:	55                   	push   %ebp
  802d61:	89 e5                	mov    %esp,%ebp
  802d63:	57                   	push   %edi
  802d64:	56                   	push   %esi
  802d65:	53                   	push   %ebx
  802d66:	83 ec 0c             	sub    $0xc,%esp
  802d69:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  802d6b:	8b 58 20             	mov    0x20(%eax),%ebx
  dhcp_set_state(dhcp, DHCP_REBINDING);
  802d6e:	ba 04 00 00 00       	mov    $0x4,%edx
  802d73:	89 d8                	mov    %ebx,%eax
  802d75:	e8 c6 f9 ff ff       	call   802740 <dhcp_set_state>
  result = dhcp_create_request(netif);
  802d7a:	89 f8                	mov    %edi,%eax
  802d7c:	e8 52 fd ff ff       	call   802ad3 <dhcp_create_request>
  802d81:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  802d83:	84 c0                	test   %al,%al
  802d85:	74 3e                	je     802dc5 <dhcp_rebind+0x65>
  dhcp->tries++;
  802d87:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  802d8b:	83 c0 01             	add    $0x1,%eax
  802d8e:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  802d91:	ba 10 27 00 00       	mov    $0x2710,%edx
  802d96:	3c 09                	cmp    $0x9,%al
  802d98:	77 08                	ja     802da2 <dhcp_rebind+0x42>
  802d9a:	0f b6 d0             	movzbl %al,%edx
  802d9d:	66 69 d2 e8 03       	imul   $0x3e8,%dx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  802da2:	0f b7 d2             	movzwl %dx,%edx
  802da5:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  802dab:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  802db0:	89 d0                	mov    %edx,%eax
  802db2:	f7 e9                	imul   %ecx
  802db4:	c1 fa 05             	sar    $0x5,%edx
  802db7:	66 89 53 26          	mov    %dx,0x26(%ebx)
}
  802dbb:	89 f0                	mov    %esi,%eax
  802dbd:	8d 65 f4             	lea    -0xc(%ebp),%esp
  802dc0:	5b                   	pop    %ebx
  802dc1:	5e                   	pop    %esi
  802dc2:	5f                   	pop    %edi
  802dc3:	5d                   	pop    %ebp
  802dc4:	c3                   	ret    
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  802dc5:	b9 01 00 00 00       	mov    $0x1,%ecx
  802dca:	ba 35 00 00 00       	mov    $0x35,%edx
  802dcf:	89 d8                	mov    %ebx,%eax
  802dd1:	e8 eb fa ff ff       	call   8028c1 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  802dd6:	ba 03 00 00 00       	mov    $0x3,%edx
  802ddb:	89 d8                	mov    %ebx,%eax
  802ddd:	e8 9e fa ff ff       	call   802880 <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  802de2:	b9 02 00 00 00       	mov    $0x2,%ecx
  802de7:	ba 39 00 00 00       	mov    $0x39,%edx
  802dec:	89 d8                	mov    %ebx,%eax
  802dee:	e8 ce fa ff ff       	call   8028c1 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  802df3:	ba 40 02 00 00       	mov    $0x240,%edx
  802df8:	89 d8                	mov    %ebx,%eax
  802dfa:	e8 29 fb ff ff       	call   802928 <dhcp_option_short>
    dhcp_option_trailer(dhcp);
  802dff:	89 d8                	mov    %ebx,%eax
  802e01:	e8 80 fb ff ff       	call   802986 <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  802e06:	83 ec 08             	sub    $0x8,%esp
  802e09:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  802e0d:	66 05 f0 00          	add    $0xf0,%ax
  802e11:	0f b7 c0             	movzwl %ax,%eax
  802e14:	50                   	push   %eax
  802e15:	ff 73 1c             	pushl  0x1c(%ebx)
  802e18:	e8 61 1d 00 00       	call   804b7e <pbuf_realloc>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  802e1d:	83 c4 0c             	add    $0xc,%esp
  802e20:	6a 43                	push   $0x43
  802e22:	68 c4 1f 81 00       	push   $0x811fc4
  802e27:	ff 73 08             	pushl  0x8(%ebx)
  802e2a:	e8 7f 61 00 00       	call   808fae <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  802e2f:	89 3c 24             	mov    %edi,(%esp)
  802e32:	6a 43                	push   $0x43
  802e34:	68 c0 1f 81 00       	push   $0x811fc0
  802e39:	ff 73 1c             	pushl  0x1c(%ebx)
  802e3c:	ff 73 08             	pushl  0x8(%ebx)
  802e3f:	e8 76 5f 00 00       	call   808dba <udp_sendto_if>
    dhcp_delete_request(netif);
  802e44:	83 c4 20             	add    $0x20,%esp
  802e47:	89 f8                	mov    %edi,%eax
  802e49:	e8 78 fe ff ff       	call   802cc6 <dhcp_delete_request>
  802e4e:	e9 34 ff ff ff       	jmp    802d87 <dhcp_rebind+0x27>

00802e53 <dhcp_discover>:
{
  802e53:	55                   	push   %ebp
  802e54:	89 e5                	mov    %esp,%ebp
  802e56:	57                   	push   %edi
  802e57:	56                   	push   %esi
  802e58:	53                   	push   %ebx
  802e59:	83 ec 0c             	sub    $0xc,%esp
  802e5c:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  802e5e:	8b 58 20             	mov    0x20(%eax),%ebx
  ip_addr_set(&dhcp->offered_ip_addr, IP_ADDR_ANY);
  802e61:	a1 c4 1f 81 00       	mov    0x811fc4,%eax
  802e66:	89 43 30             	mov    %eax,0x30(%ebx)
  result = dhcp_create_request(netif);
  802e69:	89 f8                	mov    %edi,%eax
  802e6b:	e8 63 fc ff ff       	call   802ad3 <dhcp_create_request>
  802e70:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  802e72:	84 c0                	test   %al,%al
  802e74:	74 41                	je     802eb7 <dhcp_discover+0x64>
  dhcp->tries++;
  802e76:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  802e7a:	83 c0 01             	add    $0x1,%eax
  802e7d:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 4 ? (dhcp->tries + 1) * 1000 : 10 * 1000;
  802e80:	ba 10 27 00 00       	mov    $0x2710,%edx
  802e85:	3c 03                	cmp    $0x3,%al
  802e87:	77 0b                	ja     802e94 <dhcp_discover+0x41>
  802e89:	0f b6 d0             	movzbl %al,%edx
  802e8c:	83 c2 01             	add    $0x1,%edx
  802e8f:	66 69 d2 e8 03       	imul   $0x3e8,%dx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  802e94:	0f b7 d2             	movzwl %dx,%edx
  802e97:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  802e9d:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  802ea2:	89 d0                	mov    %edx,%eax
  802ea4:	f7 e9                	imul   %ecx
  802ea6:	c1 fa 05             	sar    $0x5,%edx
  802ea9:	66 89 53 26          	mov    %dx,0x26(%ebx)
}
  802ead:	89 f0                	mov    %esi,%eax
  802eaf:	8d 65 f4             	lea    -0xc(%ebp),%esp
  802eb2:	5b                   	pop    %ebx
  802eb3:	5e                   	pop    %esi
  802eb4:	5f                   	pop    %edi
  802eb5:	5d                   	pop    %ebp
  802eb6:	c3                   	ret    
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  802eb7:	b9 01 00 00 00       	mov    $0x1,%ecx
  802ebc:	ba 35 00 00 00       	mov    $0x35,%edx
  802ec1:	89 d8                	mov    %ebx,%eax
  802ec3:	e8 f9 f9 ff ff       	call   8028c1 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DISCOVER);
  802ec8:	ba 01 00 00 00       	mov    $0x1,%edx
  802ecd:	89 d8                	mov    %ebx,%eax
  802ecf:	e8 ac f9 ff ff       	call   802880 <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  802ed4:	b9 02 00 00 00       	mov    $0x2,%ecx
  802ed9:	ba 39 00 00 00       	mov    $0x39,%edx
  802ede:	89 d8                	mov    %ebx,%eax
  802ee0:	e8 dc f9 ff ff       	call   8028c1 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  802ee5:	ba 40 02 00 00       	mov    $0x240,%edx
  802eea:	89 d8                	mov    %ebx,%eax
  802eec:	e8 37 fa ff ff       	call   802928 <dhcp_option_short>
    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  802ef1:	b9 04 00 00 00       	mov    $0x4,%ecx
  802ef6:	ba 37 00 00 00       	mov    $0x37,%edx
  802efb:	89 d8                	mov    %ebx,%eax
  802efd:	e8 bf f9 ff ff       	call   8028c1 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  802f02:	ba 01 00 00 00       	mov    $0x1,%edx
  802f07:	89 d8                	mov    %ebx,%eax
  802f09:	e8 72 f9 ff ff       	call   802880 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  802f0e:	ba 03 00 00 00       	mov    $0x3,%edx
  802f13:	89 d8                	mov    %ebx,%eax
  802f15:	e8 66 f9 ff ff       	call   802880 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  802f1a:	ba 1c 00 00 00       	mov    $0x1c,%edx
  802f1f:	89 d8                	mov    %ebx,%eax
  802f21:	e8 5a f9 ff ff       	call   802880 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  802f26:	ba 06 00 00 00       	mov    $0x6,%edx
  802f2b:	89 d8                	mov    %ebx,%eax
  802f2d:	e8 4e f9 ff ff       	call   802880 <dhcp_option_byte>
    dhcp_option_trailer(dhcp);
  802f32:	89 d8                	mov    %ebx,%eax
  802f34:	e8 4d fa ff ff       	call   802986 <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  802f39:	83 ec 08             	sub    $0x8,%esp
  802f3c:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  802f40:	66 05 f0 00          	add    $0xf0,%ax
  802f44:	0f b7 c0             	movzwl %ax,%eax
  802f47:	50                   	push   %eax
  802f48:	ff 73 1c             	pushl  0x1c(%ebx)
  802f4b:	e8 2e 1c 00 00       	call   804b7e <pbuf_realloc>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  802f50:	83 c4 0c             	add    $0xc,%esp
  802f53:	6a 43                	push   $0x43
  802f55:	68 c4 1f 81 00       	push   $0x811fc4
  802f5a:	ff 73 08             	pushl  0x8(%ebx)
  802f5d:	e8 4c 60 00 00       	call   808fae <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  802f62:	89 3c 24             	mov    %edi,(%esp)
  802f65:	6a 43                	push   $0x43
  802f67:	68 c0 1f 81 00       	push   $0x811fc0
  802f6c:	ff 73 1c             	pushl  0x1c(%ebx)
  802f6f:	ff 73 08             	pushl  0x8(%ebx)
  802f72:	e8 43 5e 00 00       	call   808dba <udp_sendto_if>
    dhcp_delete_request(netif);
  802f77:	83 c4 20             	add    $0x20,%esp
  802f7a:	89 f8                	mov    %edi,%eax
  802f7c:	e8 45 fd ff ff       	call   802cc6 <dhcp_delete_request>
    dhcp_set_state(dhcp, DHCP_SELECTING);
  802f81:	ba 06 00 00 00       	mov    $0x6,%edx
  802f86:	89 d8                	mov    %ebx,%eax
  802f88:	e8 b3 f7 ff ff       	call   802740 <dhcp_set_state>
  802f8d:	e9 e4 fe ff ff       	jmp    802e76 <dhcp_discover+0x23>

00802f92 <dhcp_select>:
{
  802f92:	55                   	push   %ebp
  802f93:	89 e5                	mov    %esp,%ebp
  802f95:	57                   	push   %edi
  802f96:	56                   	push   %esi
  802f97:	53                   	push   %ebx
  802f98:	83 ec 0c             	sub    $0xc,%esp
  802f9b:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  802f9d:	8b 58 20             	mov    0x20(%eax),%ebx
  result = dhcp_create_request(netif);
  802fa0:	e8 2e fb ff ff       	call   802ad3 <dhcp_create_request>
  802fa5:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  802fa7:	84 c0                	test   %al,%al
  802fa9:	74 3e                	je     802fe9 <dhcp_select+0x57>
  dhcp->tries++;
  802fab:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  802faf:	83 c0 01             	add    $0x1,%eax
  802fb2:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 4 ? dhcp->tries * 1000 : 4 * 1000;
  802fb5:	ba a0 0f 00 00       	mov    $0xfa0,%edx
  802fba:	3c 03                	cmp    $0x3,%al
  802fbc:	77 08                	ja     802fc6 <dhcp_select+0x34>
  802fbe:	0f b6 d0             	movzbl %al,%edx
  802fc1:	66 69 d2 e8 03       	imul   $0x3e8,%dx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  802fc6:	0f b7 d2             	movzwl %dx,%edx
  802fc9:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  802fcf:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  802fd4:	89 d0                	mov    %edx,%eax
  802fd6:	f7 e9                	imul   %ecx
  802fd8:	c1 fa 05             	sar    $0x5,%edx
  802fdb:	66 89 53 26          	mov    %dx,0x26(%ebx)
}
  802fdf:	89 f0                	mov    %esi,%eax
  802fe1:	8d 65 f4             	lea    -0xc(%ebp),%esp
  802fe4:	5b                   	pop    %ebx
  802fe5:	5e                   	pop    %esi
  802fe6:	5f                   	pop    %edi
  802fe7:	5d                   	pop    %ebp
  802fe8:	c3                   	ret    
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  802fe9:	b9 01 00 00 00       	mov    $0x1,%ecx
  802fee:	ba 35 00 00 00       	mov    $0x35,%edx
  802ff3:	89 d8                	mov    %ebx,%eax
  802ff5:	e8 c7 f8 ff ff       	call   8028c1 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  802ffa:	ba 03 00 00 00       	mov    $0x3,%edx
  802fff:	89 d8                	mov    %ebx,%eax
  803001:	e8 7a f8 ff ff       	call   802880 <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803006:	b9 02 00 00 00       	mov    $0x2,%ecx
  80300b:	ba 39 00 00 00       	mov    $0x39,%edx
  803010:	89 d8                	mov    %ebx,%eax
  803012:	e8 aa f8 ff ff       	call   8028c1 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  803017:	ba 40 02 00 00       	mov    $0x240,%edx
  80301c:	89 d8                	mov    %ebx,%eax
  80301e:	e8 05 f9 ff ff       	call   802928 <dhcp_option_short>
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  803023:	b9 04 00 00 00       	mov    $0x4,%ecx
  803028:	ba 32 00 00 00       	mov    $0x32,%edx
  80302d:	89 d8                	mov    %ebx,%eax
  80302f:	e8 8d f8 ff ff       	call   8028c1 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  803034:	83 ec 0c             	sub    $0xc,%esp
  803037:	ff 73 30             	pushl  0x30(%ebx)
  80303a:	e8 7b 49 00 00       	call   8079ba <ntohl>
  80303f:	89 c2                	mov    %eax,%edx
  803041:	89 d8                	mov    %ebx,%eax
  803043:	e8 f3 f9 ff ff       	call   802a3b <dhcp_option_long>
    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
  803048:	b9 04 00 00 00       	mov    $0x4,%ecx
  80304d:	ba 36 00 00 00       	mov    $0x36,%edx
  803052:	89 d8                	mov    %ebx,%eax
  803054:	e8 68 f8 ff ff       	call   8028c1 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
  803059:	83 c4 04             	add    $0x4,%esp
  80305c:	ff 73 2c             	pushl  0x2c(%ebx)
  80305f:	e8 56 49 00 00       	call   8079ba <ntohl>
  803064:	89 c2                	mov    %eax,%edx
  803066:	89 d8                	mov    %ebx,%eax
  803068:	e8 ce f9 ff ff       	call   802a3b <dhcp_option_long>
    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  80306d:	b9 04 00 00 00       	mov    $0x4,%ecx
  803072:	ba 37 00 00 00       	mov    $0x37,%edx
  803077:	89 d8                	mov    %ebx,%eax
  803079:	e8 43 f8 ff ff       	call   8028c1 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  80307e:	ba 01 00 00 00       	mov    $0x1,%edx
  803083:	89 d8                	mov    %ebx,%eax
  803085:	e8 f6 f7 ff ff       	call   802880 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  80308a:	ba 03 00 00 00       	mov    $0x3,%edx
  80308f:	89 d8                	mov    %ebx,%eax
  803091:	e8 ea f7 ff ff       	call   802880 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  803096:	ba 1c 00 00 00       	mov    $0x1c,%edx
  80309b:	89 d8                	mov    %ebx,%eax
  80309d:	e8 de f7 ff ff       	call   802880 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  8030a2:	ba 06 00 00 00       	mov    $0x6,%edx
  8030a7:	89 d8                	mov    %ebx,%eax
  8030a9:	e8 d2 f7 ff ff       	call   802880 <dhcp_option_byte>
    dhcp_option_trailer(dhcp);
  8030ae:	89 d8                	mov    %ebx,%eax
  8030b0:	e8 d1 f8 ff ff       	call   802986 <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  8030b5:	83 c4 08             	add    $0x8,%esp
  8030b8:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  8030bc:	66 05 f0 00          	add    $0xf0,%ax
  8030c0:	0f b7 c0             	movzwl %ax,%eax
  8030c3:	50                   	push   %eax
  8030c4:	ff 73 1c             	pushl  0x1c(%ebx)
  8030c7:	e8 b2 1a 00 00       	call   804b7e <pbuf_realloc>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  8030cc:	89 3c 24             	mov    %edi,(%esp)
  8030cf:	6a 43                	push   $0x43
  8030d1:	68 c0 1f 81 00       	push   $0x811fc0
  8030d6:	ff 73 1c             	pushl  0x1c(%ebx)
  8030d9:	ff 73 08             	pushl  0x8(%ebx)
  8030dc:	e8 d9 5c 00 00       	call   808dba <udp_sendto_if>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  8030e1:	83 c4 1c             	add    $0x1c,%esp
  8030e4:	6a 43                	push   $0x43
  8030e6:	68 c4 1f 81 00       	push   $0x811fc4
  8030eb:	ff 73 08             	pushl  0x8(%ebx)
  8030ee:	e8 bb 5e 00 00       	call   808fae <udp_connect>
    dhcp_delete_request(netif);
  8030f3:	89 f8                	mov    %edi,%eax
  8030f5:	e8 cc fb ff ff       	call   802cc6 <dhcp_delete_request>
    dhcp_set_state(dhcp, DHCP_REQUESTING);
  8030fa:	ba 01 00 00 00       	mov    $0x1,%edx
  8030ff:	89 d8                	mov    %ebx,%eax
  803101:	e8 3a f6 ff ff       	call   802740 <dhcp_set_state>
  803106:	83 c4 10             	add    $0x10,%esp
  803109:	e9 9d fe ff ff       	jmp    802fab <dhcp_select+0x19>

0080310e <dhcp_check>:
{
  80310e:	55                   	push   %ebp
  80310f:	89 e5                	mov    %esp,%ebp
  803111:	53                   	push   %ebx
  803112:	83 ec 08             	sub    $0x8,%esp
  struct dhcp *dhcp = netif->dhcp;
  803115:	8b 58 20             	mov    0x20(%eax),%ebx
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
  803118:	6a 00                	push   $0x0
  80311a:	8d 53 30             	lea    0x30(%ebx),%edx
  80311d:	52                   	push   %edx
  80311e:	50                   	push   %eax
  80311f:	e8 77 68 00 00       	call   80999b <etharp_query>
  dhcp->tries++;
  803124:	80 43 01 01          	addb   $0x1,0x1(%ebx)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803128:	66 c7 43 26 01 00    	movw   $0x1,0x26(%ebx)
  dhcp_set_state(dhcp, DHCP_CHECKING);
  80312e:	ba 08 00 00 00       	mov    $0x8,%edx
  803133:	89 d8                	mov    %ebx,%eax
  803135:	e8 06 f6 ff ff       	call   802740 <dhcp_set_state>
}
  80313a:	83 c4 10             	add    $0x10,%esp
  80313d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  803140:	c9                   	leave  
  803141:	c3                   	ret    

00803142 <dhcp_bind>:
{
  803142:	55                   	push   %ebp
  803143:	89 e5                	mov    %esp,%ebp
  803145:	56                   	push   %esi
  803146:	53                   	push   %ebx
  803147:	83 ec 10             	sub    $0x10,%esp
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
  80314a:	85 c0                	test   %eax,%eax
  80314c:	0f 84 e5 00 00 00    	je     803237 <dhcp_bind+0xf5>
  803152:	89 c6                	mov    %eax,%esi
  dhcp = netif->dhcp;
  803154:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
  803157:	85 db                	test   %ebx,%ebx
  803159:	0f 84 ef 00 00 00    	je     80324e <dhcp_bind+0x10c>
  if (dhcp->offered_t1_renew != 0xffffffffUL) {
  80315f:	8b 43 50             	mov    0x50(%ebx),%eax
  803162:	83 f8 ff             	cmp    $0xffffffff,%eax
  803165:	74 2c                	je     803193 <dhcp_bind+0x51>
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  803167:	8d 50 1e             	lea    0x1e(%eax),%edx
  80316a:	b9 89 88 88 88       	mov    $0x88888889,%ecx
  80316f:	89 d0                	mov    %edx,%eax
  803171:	f7 e1                	mul    %ecx
  803173:	c1 ea 05             	shr    $0x5,%edx
    dhcp->t1_timeout = (u16_t)timeout;
  803176:	81 fa ff ff 00 00    	cmp    $0xffff,%edx
  80317c:	b8 ff ff 00 00       	mov    $0xffff,%eax
  803181:	0f 47 d0             	cmova  %eax,%edx
  803184:	66 85 d2             	test   %dx,%dx
  803187:	b8 01 00 00 00       	mov    $0x1,%eax
  80318c:	0f 44 d0             	cmove  %eax,%edx
  80318f:	66 89 53 28          	mov    %dx,0x28(%ebx)
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
  803193:	8b 43 54             	mov    0x54(%ebx),%eax
  803196:	83 f8 ff             	cmp    $0xffffffff,%eax
  803199:	74 2c                	je     8031c7 <dhcp_bind+0x85>
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  80319b:	8d 50 1e             	lea    0x1e(%eax),%edx
  80319e:	b9 89 88 88 88       	mov    $0x88888889,%ecx
  8031a3:	89 d0                	mov    %edx,%eax
  8031a5:	f7 e1                	mul    %ecx
  8031a7:	c1 ea 05             	shr    $0x5,%edx
    dhcp->t2_timeout = (u16_t)timeout;
  8031aa:	81 fa ff ff 00 00    	cmp    $0xffff,%edx
  8031b0:	b8 ff ff 00 00       	mov    $0xffff,%eax
  8031b5:	0f 47 d0             	cmova  %eax,%edx
  8031b8:	66 85 d2             	test   %dx,%dx
  8031bb:	b8 01 00 00 00       	mov    $0x1,%eax
  8031c0:	0f 44 d0             	cmove  %eax,%edx
  8031c3:	66 89 53 2a          	mov    %dx,0x2a(%ebx)
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  8031c7:	83 fb cc             	cmp    $0xffffffcc,%ebx
  8031ca:	0f 84 e3 00 00 00    	je     8032b3 <dhcp_bind+0x171>
  8031d0:	8b 43 34             	mov    0x34(%ebx),%eax
  8031d3:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (sn_mask.addr == 0) {
  8031d6:	85 c0                	test   %eax,%eax
  8031d8:	0f 84 dc 00 00 00    	je     8032ba <dhcp_bind+0x178>
  ip_addr_set(&gw_addr, &dhcp->offered_gw_addr);
  8031de:	83 fb c8             	cmp    $0xffffffc8,%ebx
  8031e1:	0f 84 ae 00 00 00    	je     803295 <dhcp_bind+0x153>
  8031e7:	8b 43 38             	mov    0x38(%ebx),%eax
  8031ea:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (gw_addr.addr == 0) {
  8031ed:	85 c0                	test   %eax,%eax
  8031ef:	0f 84 a0 00 00 00    	je     803295 <dhcp_bind+0x153>
  netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
  8031f5:	83 ec 08             	sub    $0x8,%esp
  8031f8:	8d 43 30             	lea    0x30(%ebx),%eax
  8031fb:	50                   	push   %eax
  8031fc:	56                   	push   %esi
  8031fd:	e8 9c 13 00 00       	call   80459e <netif_set_ipaddr>
  netif_set_netmask(netif, &sn_mask);
  803202:	83 c4 08             	add    $0x8,%esp
  803205:	8d 45 f4             	lea    -0xc(%ebp),%eax
  803208:	50                   	push   %eax
  803209:	56                   	push   %esi
  80320a:	e8 ec 14 00 00       	call   8046fb <netif_set_netmask>
  netif_set_gw(netif, &gw_addr);
  80320f:	83 c4 08             	add    $0x8,%esp
  803212:	8d 45 f0             	lea    -0x10(%ebp),%eax
  803215:	50                   	push   %eax
  803216:	56                   	push   %esi
  803217:	e8 c6 14 00 00       	call   8046e2 <netif_set_gw>
  netif_set_up(netif);
  80321c:	89 34 24             	mov    %esi,(%esp)
  80321f:	e8 fd 14 00 00       	call   804721 <netif_set_up>
  dhcp_set_state(dhcp, DHCP_BOUND);
  803224:	ba 0a 00 00 00       	mov    $0xa,%edx
  803229:	89 d8                	mov    %ebx,%eax
  80322b:	e8 10 f5 ff ff       	call   802740 <dhcp_set_state>
}
  803230:	8d 65 f8             	lea    -0x8(%ebp),%esp
  803233:	5b                   	pop    %ebx
  803234:	5e                   	pop    %esi
  803235:	5d                   	pop    %ebp
  803236:	c3                   	ret    
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
  803237:	83 ec 04             	sub    $0x4,%esp
  80323a:	68 17 17 81 00       	push   $0x811717
  80323f:	68 3d 03 00 00       	push   $0x33d
  803244:	68 02 17 81 00       	push   $0x811702
  803249:	e8 05 b4 00 00       	call   80e653 <_panic>
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
  80324e:	83 ec 04             	sub    $0x4,%esp
  803251:	68 30 17 81 00       	push   $0x811730
  803256:	68 3f 03 00 00       	push   $0x33f
  80325b:	68 02 17 81 00       	push   $0x811702
  803260:	e8 ee b3 00 00       	call   80e653 <_panic>
      sn_mask.addr = htonl(0xff000000);
  803265:	83 ec 0c             	sub    $0xc,%esp
  803268:	68 00 00 00 ff       	push   $0xff000000
  80326d:	e8 2a 45 00 00       	call   80779c <htonl>
  803272:	89 45 f4             	mov    %eax,-0xc(%ebp)
  803275:	83 c4 10             	add    $0x10,%esp
  803278:	e9 61 ff ff ff       	jmp    8031de <dhcp_bind+0x9c>
      sn_mask.addr = htonl(0xffff0000);
  80327d:	83 ec 0c             	sub    $0xc,%esp
  803280:	68 00 00 ff ff       	push   $0xffff0000
  803285:	e8 12 45 00 00       	call   80779c <htonl>
  80328a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  80328d:	83 c4 10             	add    $0x10,%esp
  803290:	e9 49 ff ff ff       	jmp    8031de <dhcp_bind+0x9c>
    gw_addr.addr = (dhcp->offered_ip_addr.addr & sn_mask.addr);
  803295:	8b 43 30             	mov    0x30(%ebx),%eax
  803298:	23 45 f4             	and    -0xc(%ebp),%eax
  80329b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    gw_addr.addr |= htonl(0x00000001);
  80329e:	83 ec 0c             	sub    $0xc,%esp
  8032a1:	6a 01                	push   $0x1
  8032a3:	e8 f4 44 00 00       	call   80779c <htonl>
  8032a8:	09 45 f0             	or     %eax,-0x10(%ebp)
  8032ab:	83 c4 10             	add    $0x10,%esp
  8032ae:	e9 42 ff ff ff       	jmp    8031f5 <dhcp_bind+0xb3>
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  8032b3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    u8_t first_octet = ip4_addr1(&sn_mask);
  8032ba:	83 ec 0c             	sub    $0xc,%esp
  8032bd:	6a 00                	push   $0x0
  8032bf:	e8 f6 46 00 00       	call   8079ba <ntohl>
  8032c4:	c1 e8 18             	shr    $0x18,%eax
    if (first_octet <= 127) {
  8032c7:	83 c4 10             	add    $0x10,%esp
  8032ca:	84 c0                	test   %al,%al
  8032cc:	79 97                	jns    803265 <dhcp_bind+0x123>
    } else if (first_octet >= 192) {
  8032ce:	3c bf                	cmp    $0xbf,%al
  8032d0:	76 ab                	jbe    80327d <dhcp_bind+0x13b>
      sn_mask.addr = htonl(0xffffff00);
  8032d2:	83 ec 0c             	sub    $0xc,%esp
  8032d5:	68 00 ff ff ff       	push   $0xffffff00
  8032da:	e8 bd 44 00 00       	call   80779c <htonl>
  8032df:	89 45 f4             	mov    %eax,-0xc(%ebp)
  8032e2:	83 c4 10             	add    $0x10,%esp
  8032e5:	e9 f4 fe ff ff       	jmp    8031de <dhcp_bind+0x9c>

008032ea <dhcp_free_reply>:
{
  8032ea:	55                   	push   %ebp
  8032eb:	89 e5                	mov    %esp,%ebp
  8032ed:	53                   	push   %ebx
  8032ee:	83 ec 04             	sub    $0x4,%esp
  8032f1:	89 c3                	mov    %eax,%ebx
  if (dhcp->msg_in != NULL) {
  8032f3:	8b 40 10             	mov    0x10(%eax),%eax
  8032f6:	85 c0                	test   %eax,%eax
  8032f8:	74 13                	je     80330d <dhcp_free_reply+0x23>
    mem_free((void *)dhcp->msg_in);
  8032fa:	83 ec 0c             	sub    $0xc,%esp
  8032fd:	50                   	push   %eax
  8032fe:	e8 2c 0c 00 00       	call   803f2f <mem_free>
    dhcp->msg_in = NULL;
  803303:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  80330a:	83 c4 10             	add    $0x10,%esp
  if (dhcp->options_in) {
  80330d:	8b 43 14             	mov    0x14(%ebx),%eax
  803310:	85 c0                	test   %eax,%eax
  803312:	74 19                	je     80332d <dhcp_free_reply+0x43>
    mem_free((void *)dhcp->options_in);
  803314:	83 ec 0c             	sub    $0xc,%esp
  803317:	50                   	push   %eax
  803318:	e8 12 0c 00 00       	call   803f2f <mem_free>
    dhcp->options_in = NULL;
  80331d:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
    dhcp->options_in_len = 0;
  803324:	66 c7 43 18 00 00    	movw   $0x0,0x18(%ebx)
  80332a:	83 c4 10             	add    $0x10,%esp
}
  80332d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  803330:	c9                   	leave  
  803331:	c3                   	ret    

00803332 <dhcp_recv>:
{
  803332:	55                   	push   %ebp
  803333:	89 e5                	mov    %esp,%ebp
  803335:	57                   	push   %edi
  803336:	56                   	push   %esi
  803337:	53                   	push   %ebx
  803338:	83 ec 1c             	sub    $0x1c,%esp
  80333b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct dhcp *dhcp = netif->dhcp;
  80333e:	8b 73 20             	mov    0x20(%ebx),%esi
  struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
  803341:	8b 45 10             	mov    0x10(%ebp),%eax
  803344:	8b 48 04             	mov    0x4(%eax),%ecx
  dhcp->p = p;
  803347:	89 46 0c             	mov    %eax,0xc(%esi)
  if (reply_msg->op != DHCP_BOOTREPLY) {
  80334a:	80 39 02             	cmpb   $0x2,(%ecx)
  80334d:	74 1a                	je     803369 <dhcp_recv+0x37>
  pbuf_free(p);
  80334f:	83 ec 0c             	sub    $0xc,%esp
  803352:	ff 75 10             	pushl  0x10(%ebp)
  803355:	e8 f3 14 00 00       	call   80484d <pbuf_free>
  dhcp->p = NULL;
  80335a:	c7 46 0c 00 00 00 00 	movl   $0x0,0xc(%esi)
}
  803361:	8d 65 f4             	lea    -0xc(%ebp),%esp
  803364:	5b                   	pop    %ebx
  803365:	5e                   	pop    %esi
  803366:	5f                   	pop    %edi
  803367:	5d                   	pop    %ebp
  803368:	c3                   	ret    
  803369:	0f b6 7b 24          	movzbl 0x24(%ebx),%edi
  for (i = 0; i < netif->hwaddr_len; i++) {
  80336d:	b8 00 00 00 00       	mov    $0x0,%eax
  803372:	39 f8                	cmp    %edi,%eax
  803374:	74 10                	je     803386 <dhcp_recv+0x54>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
  803376:	0f b6 54 03 25       	movzbl 0x25(%ebx,%eax,1),%edx
  80337b:	83 c0 01             	add    $0x1,%eax
  80337e:	3a 54 01 1b          	cmp    0x1b(%ecx,%eax,1),%dl
  803382:	74 ee                	je     803372 <dhcp_recv+0x40>
  803384:	eb c9                	jmp    80334f <dhcp_recv+0x1d>
  if (ntohl(reply_msg->xid) != dhcp->xid) {
  803386:	83 ec 0c             	sub    $0xc,%esp
  803389:	ff 71 04             	pushl  0x4(%ecx)
  80338c:	e8 29 46 00 00       	call   8079ba <ntohl>
  803391:	83 c4 10             	add    $0x10,%esp
  803394:	3b 46 04             	cmp    0x4(%esi),%eax
  803397:	75 b6                	jne    80334f <dhcp_recv+0x1d>
  LWIP_ERROR("dhcp != NULL", (dhcp != NULL), return ERR_ARG;);
  803399:	85 f6                	test   %esi,%esi
  80339b:	0f 84 2a 01 00 00    	je     8034cb <dhcp_recv+0x199>
  LWIP_ERROR("dhcp->p != NULL", (dhcp->p != NULL), return ERR_VAL;);
  8033a1:	83 7e 0c 00          	cmpl   $0x0,0xc(%esi)
  8033a5:	0f 84 37 01 00 00    	je     8034e2 <dhcp_recv+0x1b0>
  dhcp_free_reply(dhcp);
  8033ab:	89 f0                	mov    %esi,%eax
  8033ad:	e8 38 ff ff ff       	call   8032ea <dhcp_free_reply>
  if (dhcp->p->tot_len > (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN)) {
  8033b2:	8b 46 0c             	mov    0xc(%esi),%eax
  8033b5:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  8033b9:	66 3d f0 00          	cmp    $0xf0,%ax
  8033bd:	76 22                	jbe    8033e1 <dhcp_recv+0xaf>
    dhcp->options_in_len = dhcp->p->tot_len - (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  8033bf:	66 2d f0 00          	sub    $0xf0,%ax
  8033c3:	66 89 46 18          	mov    %ax,0x18(%esi)
    dhcp->options_in = mem_malloc(dhcp->options_in_len);
  8033c7:	83 ec 0c             	sub    $0xc,%esp
  8033ca:	0f b7 c0             	movzwl %ax,%eax
  8033cd:	50                   	push   %eax
  8033ce:	e8 4d 0e 00 00       	call   804220 <mem_malloc>
  8033d3:	89 46 14             	mov    %eax,0x14(%esi)
    if (dhcp->options_in == NULL) {
  8033d6:	83 c4 10             	add    $0x10,%esp
  8033d9:	85 c0                	test   %eax,%eax
  8033db:	0f 84 6e ff ff ff    	je     80334f <dhcp_recv+0x1d>
  dhcp->msg_in = mem_malloc(sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  8033e1:	83 ec 0c             	sub    $0xc,%esp
  8033e4:	68 f0 00 00 00       	push   $0xf0
  8033e9:	e8 32 0e 00 00       	call   804220 <mem_malloc>
  8033ee:	89 46 10             	mov    %eax,0x10(%esi)
  if (dhcp->msg_in == NULL) {
  8033f1:	83 c4 10             	add    $0x10,%esp
  8033f4:	85 c0                	test   %eax,%eax
  8033f6:	0f 84 fd 00 00 00    	je     8034f9 <dhcp_recv+0x1c7>
  ret = pbuf_copy_partial(dhcp->p, dhcp->msg_in, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN, 0);
  8033fc:	6a 00                	push   $0x0
  8033fe:	68 f0 00 00 00       	push   $0xf0
  803403:	50                   	push   %eax
  803404:	ff 76 0c             	pushl  0xc(%esi)
  803407:	e8 cb 1b 00 00       	call   804fd7 <pbuf_copy_partial>
  LWIP_ASSERT("ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN", ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80340c:	83 c4 10             	add    $0x10,%esp
  80340f:	66 3d f0 00          	cmp    $0xf0,%ax
  803413:	0f 85 fa 00 00 00    	jne    803513 <dhcp_recv+0x1e1>
  if (dhcp->options_in != NULL) {
  803419:	8b 46 14             	mov    0x14(%esi),%eax
  80341c:	85 c0                	test   %eax,%eax
  80341e:	74 20                	je     803440 <dhcp_recv+0x10e>
    ret = pbuf_copy_partial(dhcp->p, dhcp->options_in, dhcp->options_in_len, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  803420:	68 f0 00 00 00       	push   $0xf0
  803425:	0f b7 56 18          	movzwl 0x18(%esi),%edx
  803429:	52                   	push   %edx
  80342a:	50                   	push   %eax
  80342b:	ff 76 0c             	pushl  0xc(%esi)
  80342e:	e8 a4 1b 00 00       	call   804fd7 <pbuf_copy_partial>
    LWIP_ASSERT("ret == dhcp->options_in_len", ret == dhcp->options_in_len);
  803433:	83 c4 10             	add    $0x10,%esp
  803436:	66 3b 46 18          	cmp    0x18(%esi),%ax
  80343a:	0f 85 ea 00 00 00    	jne    80352a <dhcp_recv+0x1f8>
  options_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_MESSAGE_TYPE);
  803440:	ba 35 00 00 00       	mov    $0x35,%edx
  803445:	89 f0                	mov    %esi,%eax
  803447:	e8 03 f3 ff ff       	call   80274f <dhcp_get_option_ptr>
  if (options_ptr == NULL) {
  80344c:	85 c0                	test   %eax,%eax
  80344e:	0f 84 fb fe ff ff    	je     80334f <dhcp_recv+0x1d>
  return *ptr;
  803454:	0f b6 40 02          	movzbl 0x2(%eax),%eax
  if (msg_type == DHCP_ACK) {
  803458:	3c 05                	cmp    $0x5,%al
  80345a:	0f 84 e1 00 00 00    	je     803541 <dhcp_recv+0x20f>
  else if ((msg_type == DHCP_NAK) &&
  803460:	3c 06                	cmp    $0x6,%al
  803462:	0f 84 8d 02 00 00    	je     8036f5 <dhcp_recv+0x3c3>
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
  803468:	3c 02                	cmp    $0x2,%al
  80346a:	0f 85 df fe ff ff    	jne    80334f <dhcp_recv+0x1d>
  803470:	80 3e 06             	cmpb   $0x6,(%esi)
  803473:	0f 85 d6 fe ff ff    	jne    80334f <dhcp_recv+0x1d>
    dhcp->request_timeout = 0;
  803479:	66 c7 46 26 00 00    	movw   $0x0,0x26(%esi)
  struct dhcp *dhcp = netif->dhcp;
  80347f:	8b 7b 20             	mov    0x20(%ebx),%edi
  u8_t *option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SERVER_ID);
  803482:	ba 36 00 00 00       	mov    $0x36,%edx
  803487:	89 f8                	mov    %edi,%eax
  803489:	e8 c1 f2 ff ff       	call   80274f <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  80348e:	85 c0                	test   %eax,%eax
  803490:	0f 84 b9 fe ff ff    	je     80334f <dhcp_recv+0x1d>
    dhcp->server_ip_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  803496:	83 c0 02             	add    $0x2,%eax
  803499:	e8 bd f3 ff ff       	call   80285b <dhcp_get_option_long>
  80349e:	83 ec 0c             	sub    $0xc,%esp
  8034a1:	50                   	push   %eax
  8034a2:	e8 f5 42 00 00       	call   80779c <htonl>
  8034a7:	89 47 2c             	mov    %eax,0x2c(%edi)
    ip_addr_set(&dhcp->offered_ip_addr, (struct ip_addr *)&dhcp->msg_in->yiaddr);
  8034aa:	8b 47 10             	mov    0x10(%edi),%eax
  8034ad:	83 c4 10             	add    $0x10,%esp
  8034b0:	83 f8 f0             	cmp    $0xfffffff0,%eax
  8034b3:	0f 84 a6 02 00 00    	je     80375f <dhcp_recv+0x42d>
  8034b9:	8b 40 10             	mov    0x10(%eax),%eax
  8034bc:	89 47 30             	mov    %eax,0x30(%edi)
    dhcp_select(netif);
  8034bf:	89 d8                	mov    %ebx,%eax
  8034c1:	e8 cc fa ff ff       	call   802f92 <dhcp_select>
  8034c6:	e9 84 fe ff ff       	jmp    80334f <dhcp_recv+0x1d>
  LWIP_ERROR("dhcp != NULL", (dhcp != NULL), return ERR_ARG;);
  8034cb:	83 ec 04             	sub    $0x4,%esp
  8034ce:	68 3b 17 81 00       	push   $0x81173b
  8034d3:	68 89 04 00 00       	push   $0x489
  8034d8:	68 02 17 81 00       	push   $0x811702
  8034dd:	e8 71 b1 00 00       	call   80e653 <_panic>
  LWIP_ERROR("dhcp->p != NULL", (dhcp->p != NULL), return ERR_VAL;);
  8034e2:	83 ec 04             	sub    $0x4,%esp
  8034e5:	68 48 17 81 00       	push   $0x811748
  8034ea:	68 8a 04 00 00       	push   $0x48a
  8034ef:	68 02 17 81 00       	push   $0x811702
  8034f4:	e8 5a b1 00 00       	call   80e653 <_panic>
    mem_free((void *)dhcp->options_in);
  8034f9:	83 ec 0c             	sub    $0xc,%esp
  8034fc:	ff 76 14             	pushl  0x14(%esi)
  8034ff:	e8 2b 0a 00 00       	call   803f2f <mem_free>
    dhcp->options_in = NULL;
  803504:	c7 46 14 00 00 00 00 	movl   $0x0,0x14(%esi)
  80350b:	83 c4 10             	add    $0x10,%esp
  80350e:	e9 3c fe ff ff       	jmp    80334f <dhcp_recv+0x1d>
  LWIP_ASSERT("ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN", ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  803513:	83 ec 04             	sub    $0x4,%esp
  803516:	68 d0 16 81 00       	push   $0x8116d0
  80351b:	68 a0 04 00 00       	push   $0x4a0
  803520:	68 02 17 81 00       	push   $0x811702
  803525:	e8 29 b1 00 00       	call   80e653 <_panic>
    LWIP_ASSERT("ret == dhcp->options_in_len", ret == dhcp->options_in_len);
  80352a:	83 ec 04             	sub    $0x4,%esp
  80352d:	68 58 17 81 00       	push   $0x811758
  803532:	68 a7 04 00 00       	push   $0x4a7
  803537:	68 02 17 81 00       	push   $0x811702
  80353c:	e8 12 b1 00 00       	call   80e653 <_panic>
    if (dhcp->state == DHCP_REQUESTING) {
  803541:	0f b6 06             	movzbl (%esi),%eax
  803544:	3c 01                	cmp    $0x1,%al
  803546:	74 1d                	je     803565 <dhcp_recv+0x233>
    else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
  803548:	83 e8 03             	sub    $0x3,%eax
  80354b:	3c 02                	cmp    $0x2,%al
  80354d:	0f 87 fc fd ff ff    	ja     80334f <dhcp_recv+0x1d>
      dhcp->request_timeout = 0;
  803553:	66 c7 46 26 00 00    	movw   $0x0,0x26(%esi)
      dhcp_bind(netif);
  803559:	89 d8                	mov    %ebx,%eax
  80355b:	e8 e2 fb ff ff       	call   803142 <dhcp_bind>
  803560:	e9 ea fd ff ff       	jmp    80334f <dhcp_recv+0x1d>
  struct dhcp *dhcp = netif->dhcp;
  803565:	8b 7b 20             	mov    0x20(%ebx),%edi
  dhcp->offered_sn_mask.addr = 0;
  803568:	c7 47 34 00 00 00 00 	movl   $0x0,0x34(%edi)
  dhcp->offered_gw_addr.addr = 0;
  80356f:	c7 47 38 00 00 00 00 	movl   $0x0,0x38(%edi)
  dhcp->offered_bc_addr.addr = 0;
  803576:	c7 47 3c 00 00 00 00 	movl   $0x0,0x3c(%edi)
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_LEASE_TIME);
  80357d:	ba 33 00 00 00       	mov    $0x33,%edx
  803582:	89 f8                	mov    %edi,%eax
  803584:	e8 c6 f1 ff ff       	call   80274f <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803589:	85 c0                	test   %eax,%eax
  80358b:	74 0b                	je     803598 <dhcp_recv+0x266>
    dhcp->offered_t0_lease = dhcp_get_option_long(option_ptr + 2);
  80358d:	83 c0 02             	add    $0x2,%eax
  803590:	e8 c6 f2 ff ff       	call   80285b <dhcp_get_option_long>
  803595:	89 47 4c             	mov    %eax,0x4c(%edi)
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T1);
  803598:	ba 3a 00 00 00       	mov    $0x3a,%edx
  80359d:	89 f8                	mov    %edi,%eax
  80359f:	e8 ab f1 ff ff       	call   80274f <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  8035a4:	85 c0                	test   %eax,%eax
  8035a6:	0f 84 e5 00 00 00    	je     803691 <dhcp_recv+0x35f>
    dhcp->offered_t1_renew = dhcp_get_option_long(option_ptr + 2);
  8035ac:	83 c0 02             	add    $0x2,%eax
  8035af:	e8 a7 f2 ff ff       	call   80285b <dhcp_get_option_long>
  8035b4:	89 47 50             	mov    %eax,0x50(%edi)
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T2);
  8035b7:	ba 3b 00 00 00       	mov    $0x3b,%edx
  8035bc:	89 f8                	mov    %edi,%eax
  8035be:	e8 8c f1 ff ff       	call   80274f <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  8035c3:	85 c0                	test   %eax,%eax
  8035c5:	0f 84 d3 00 00 00    	je     80369e <dhcp_recv+0x36c>
    dhcp->offered_t2_rebind = dhcp_get_option_long(option_ptr + 2);
  8035cb:	83 c0 02             	add    $0x2,%eax
  8035ce:	e8 88 f2 ff ff       	call   80285b <dhcp_get_option_long>
  8035d3:	89 47 54             	mov    %eax,0x54(%edi)
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
  8035d6:	8b 47 10             	mov    0x10(%edi),%eax
  8035d9:	83 f8 f0             	cmp    $0xfffffff0,%eax
  8035dc:	0f 84 c7 00 00 00    	je     8036a9 <dhcp_recv+0x377>
  8035e2:	8b 40 10             	mov    0x10(%eax),%eax
  8035e5:	89 47 30             	mov    %eax,0x30(%edi)
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SUBNET_MASK);
  8035e8:	ba 01 00 00 00       	mov    $0x1,%edx
  8035ed:	89 f8                	mov    %edi,%eax
  8035ef:	e8 5b f1 ff ff       	call   80274f <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  8035f4:	85 c0                	test   %eax,%eax
  8035f6:	74 17                	je     80360f <dhcp_recv+0x2dd>
    dhcp->offered_sn_mask.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  8035f8:	83 c0 02             	add    $0x2,%eax
  8035fb:	e8 5b f2 ff ff       	call   80285b <dhcp_get_option_long>
  803600:	83 ec 0c             	sub    $0xc,%esp
  803603:	50                   	push   %eax
  803604:	e8 93 41 00 00       	call   80779c <htonl>
  803609:	89 47 34             	mov    %eax,0x34(%edi)
  80360c:	83 c4 10             	add    $0x10,%esp
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_ROUTER);
  80360f:	ba 03 00 00 00       	mov    $0x3,%edx
  803614:	89 f8                	mov    %edi,%eax
  803616:	e8 34 f1 ff ff       	call   80274f <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  80361b:	85 c0                	test   %eax,%eax
  80361d:	74 17                	je     803636 <dhcp_recv+0x304>
    dhcp->offered_gw_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  80361f:	83 c0 02             	add    $0x2,%eax
  803622:	e8 34 f2 ff ff       	call   80285b <dhcp_get_option_long>
  803627:	83 ec 0c             	sub    $0xc,%esp
  80362a:	50                   	push   %eax
  80362b:	e8 6c 41 00 00       	call   80779c <htonl>
  803630:	89 47 38             	mov    %eax,0x38(%edi)
  803633:	83 c4 10             	add    $0x10,%esp
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_BROADCAST);
  803636:	ba 1c 00 00 00       	mov    $0x1c,%edx
  80363b:	89 f8                	mov    %edi,%eax
  80363d:	e8 0d f1 ff ff       	call   80274f <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803642:	85 c0                	test   %eax,%eax
  803644:	74 17                	je     80365d <dhcp_recv+0x32b>
    dhcp->offered_bc_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  803646:	83 c0 02             	add    $0x2,%eax
  803649:	e8 0d f2 ff ff       	call   80285b <dhcp_get_option_long>
  80364e:	83 ec 0c             	sub    $0xc,%esp
  803651:	50                   	push   %eax
  803652:	e8 45 41 00 00       	call   80779c <htonl>
  803657:	89 47 3c             	mov    %eax,0x3c(%edi)
  80365a:	83 c4 10             	add    $0x10,%esp
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_DNS_SERVER);
  80365d:	ba 06 00 00 00       	mov    $0x6,%edx
  803662:	89 f8                	mov    %edi,%eax
  803664:	e8 e6 f0 ff ff       	call   80274f <dhcp_get_option_ptr>
  803669:	89 45 e0             	mov    %eax,-0x20(%ebp)
  if (option_ptr != NULL) {
  80366c:	85 c0                	test   %eax,%eax
  80366e:	74 73                	je     8036e3 <dhcp_recv+0x3b1>
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
  803670:	0f b6 40 01          	movzbl 0x1(%eax),%eax
  803674:	c0 e8 02             	shr    $0x2,%al
  803677:	0f b6 c0             	movzbl %al,%eax
  80367a:	83 f8 02             	cmp    $0x2,%eax
  80367d:	ba 02 00 00 00       	mov    $0x2,%edx
  803682:	0f 47 c2             	cmova  %edx,%eax
  803685:	89 47 40             	mov    %eax,0x40(%edi)
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
  803688:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  80368c:	89 5d 08             	mov    %ebx,0x8(%ebp)
  80368f:	eb 46                	jmp    8036d7 <dhcp_recv+0x3a5>
    dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
  803691:	8b 47 4c             	mov    0x4c(%edi),%eax
  803694:	d1 e8                	shr    %eax
  803696:	89 47 50             	mov    %eax,0x50(%edi)
  803699:	e9 19 ff ff ff       	jmp    8035b7 <dhcp_recv+0x285>
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
  80369e:	8b 47 4c             	mov    0x4c(%edi),%eax
  8036a1:	89 47 54             	mov    %eax,0x54(%edi)
  8036a4:	e9 2d ff ff ff       	jmp    8035d6 <dhcp_recv+0x2a4>
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
  8036a9:	b8 00 00 00 00       	mov    $0x0,%eax
  8036ae:	e9 32 ff ff ff       	jmp    8035e5 <dhcp_recv+0x2b3>
      dhcp->offered_dns_addr[n].addr = htonl(dhcp_get_option_long(&option_ptr[2 + n * 4]));
  8036b3:	0f b6 5d e7          	movzbl -0x19(%ebp),%ebx
  8036b7:	8b 55 e0             	mov    -0x20(%ebp),%edx
  8036ba:	8d 44 9a 02          	lea    0x2(%edx,%ebx,4),%eax
  8036be:	e8 98 f1 ff ff       	call   80285b <dhcp_get_option_long>
  8036c3:	83 ec 0c             	sub    $0xc,%esp
  8036c6:	50                   	push   %eax
  8036c7:	e8 d0 40 00 00       	call   80779c <htonl>
  8036cc:	89 44 9f 44          	mov    %eax,0x44(%edi,%ebx,4)
    for (n = 0; n < dhcp->dns_count; n++) {
  8036d0:	80 45 e7 01          	addb   $0x1,-0x19(%ebp)
  8036d4:	83 c4 10             	add    $0x10,%esp
  8036d7:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
  8036db:	3b 47 40             	cmp    0x40(%edi),%eax
  8036de:	72 d3                	jb     8036b3 <dhcp_recv+0x381>
  8036e0:	8b 5d 08             	mov    0x8(%ebp),%ebx
      dhcp->request_timeout = 0;
  8036e3:	66 c7 46 26 00 00    	movw   $0x0,0x26(%esi)
      dhcp_check(netif);
  8036e9:	89 d8                	mov    %ebx,%eax
  8036eb:	e8 1e fa ff ff       	call   80310e <dhcp_check>
  8036f0:	e9 5a fc ff ff       	jmp    80334f <dhcp_recv+0x1d>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
  8036f5:	0f b6 06             	movzbl (%esi),%eax
  8036f8:	8d 50 fd             	lea    -0x3(%eax),%edx
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
  8036fb:	80 fa 02             	cmp    $0x2,%dl
  8036fe:	76 08                	jbe    803708 <dhcp_recv+0x3d6>
  803700:	3c 01                	cmp    $0x1,%al
  803702:	0f 85 47 fc ff ff    	jne    80334f <dhcp_recv+0x1d>
    dhcp->request_timeout = 0;
  803708:	66 c7 46 26 00 00    	movw   $0x0,0x26(%esi)
  struct dhcp *dhcp = netif->dhcp;
  80370e:	8b 7b 20             	mov    0x20(%ebx),%edi
  netif_set_down(netif);
  803711:	83 ec 0c             	sub    $0xc,%esp
  803714:	53                   	push   %ebx
  803715:	e8 3a 10 00 00       	call   804754 <netif_set_down>
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  80371a:	83 c4 08             	add    $0x8,%esp
  80371d:	68 c4 1f 81 00       	push   $0x811fc4
  803722:	53                   	push   %ebx
  803723:	e8 76 0e 00 00       	call   80459e <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  803728:	83 c4 08             	add    $0x8,%esp
  80372b:	68 c4 1f 81 00       	push   $0x811fc4
  803730:	53                   	push   %ebx
  803731:	e8 ac 0f 00 00       	call   8046e2 <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY); 
  803736:	83 c4 08             	add    $0x8,%esp
  803739:	68 c4 1f 81 00       	push   $0x811fc4
  80373e:	53                   	push   %ebx
  80373f:	e8 b7 0f 00 00       	call   8046fb <netif_set_netmask>
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  803744:	ba 0c 00 00 00       	mov    $0xc,%edx
  803749:	89 f8                	mov    %edi,%eax
  80374b:	e8 f0 ef ff ff       	call   802740 <dhcp_set_state>
  dhcp_discover(netif);
  803750:	89 d8                	mov    %ebx,%eax
  803752:	e8 fc f6 ff ff       	call   802e53 <dhcp_discover>
  803757:	83 c4 10             	add    $0x10,%esp
  80375a:	e9 f0 fb ff ff       	jmp    80334f <dhcp_recv+0x1d>
    ip_addr_set(&dhcp->offered_ip_addr, (struct ip_addr *)&dhcp->msg_in->yiaddr);
  80375f:	b8 00 00 00 00       	mov    $0x0,%eax
  803764:	e9 53 fd ff ff       	jmp    8034bc <dhcp_recv+0x18a>

00803769 <dhcp_inform>:
{
  803769:	55                   	push   %ebp
  80376a:	89 e5                	mov    %esp,%ebp
  80376c:	57                   	push   %edi
  80376d:	56                   	push   %esi
  80376e:	53                   	push   %ebx
  80376f:	83 ec 18             	sub    $0x18,%esp
  803772:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp, *old_dhcp = netif->dhcp;
  803775:	8b 7e 20             	mov    0x20(%esi),%edi
  dhcp = mem_malloc(sizeof(struct dhcp));
  803778:	6a 58                	push   $0x58
  80377a:	e8 a1 0a 00 00       	call   804220 <mem_malloc>
  if (dhcp == NULL) {
  80377f:	83 c4 10             	add    $0x10,%esp
  803782:	85 c0                	test   %eax,%eax
  803784:	74 55                	je     8037db <dhcp_inform+0x72>
  803786:	89 c3                	mov    %eax,%ebx
  netif->dhcp = dhcp;
  803788:	89 46 20             	mov    %eax,0x20(%esi)
  memset(dhcp, 0, sizeof(struct dhcp));
  80378b:	83 ec 04             	sub    $0x4,%esp
  80378e:	6a 58                	push   $0x58
  803790:	6a 00                	push   $0x0
  803792:	50                   	push   %eax
  803793:	e8 74 b7 00 00       	call   80ef0c <memset>
  dhcp->pcb = udp_new();
  803798:	e8 f5 58 00 00       	call   809092 <udp_new>
  80379d:	89 43 08             	mov    %eax,0x8(%ebx)
  if (dhcp->pcb == NULL) {
  8037a0:	83 c4 10             	add    $0x10,%esp
  8037a3:	85 c0                	test   %eax,%eax
  8037a5:	74 3c                	je     8037e3 <dhcp_inform+0x7a>
  result = dhcp_create_request(netif);
  8037a7:	89 f0                	mov    %esi,%eax
  8037a9:	e8 25 f3 ff ff       	call   802ad3 <dhcp_create_request>
  if (result == ERR_OK) {
  8037ae:	84 c0                	test   %al,%al
  8037b0:	74 3f                	je     8037f1 <dhcp_inform+0x88>
    if (dhcp->pcb != NULL) {
  8037b2:	8b 43 08             	mov    0x8(%ebx),%eax
  8037b5:	85 c0                	test   %eax,%eax
  8037b7:	74 0c                	je     8037c5 <dhcp_inform+0x5c>
      udp_remove(dhcp->pcb);
  8037b9:	83 ec 0c             	sub    $0xc,%esp
  8037bc:	50                   	push   %eax
  8037bd:	e8 8c 58 00 00       	call   80904e <udp_remove>
  8037c2:	83 c4 10             	add    $0x10,%esp
    dhcp->pcb = NULL;
  8037c5:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mem_free((void *)dhcp);
  8037cc:	83 ec 0c             	sub    $0xc,%esp
  8037cf:	53                   	push   %ebx
  8037d0:	e8 5a 07 00 00       	call   803f2f <mem_free>
    netif->dhcp = old_dhcp;
  8037d5:	89 7e 20             	mov    %edi,0x20(%esi)
  8037d8:	83 c4 10             	add    $0x10,%esp
}
  8037db:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8037de:	5b                   	pop    %ebx
  8037df:	5e                   	pop    %esi
  8037e0:	5f                   	pop    %edi
  8037e1:	5d                   	pop    %ebp
  8037e2:	c3                   	ret    
    mem_free((void *)dhcp);
  8037e3:	83 ec 0c             	sub    $0xc,%esp
  8037e6:	53                   	push   %ebx
  8037e7:	e8 43 07 00 00       	call   803f2f <mem_free>
    return;
  8037ec:	83 c4 10             	add    $0x10,%esp
  8037ef:	eb ea                	jmp    8037db <dhcp_inform+0x72>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  8037f1:	b9 01 00 00 00       	mov    $0x1,%ecx
  8037f6:	ba 35 00 00 00       	mov    $0x35,%edx
  8037fb:	89 d8                	mov    %ebx,%eax
  8037fd:	e8 bf f0 ff ff       	call   8028c1 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_INFORM);
  803802:	ba 08 00 00 00       	mov    $0x8,%edx
  803807:	89 d8                	mov    %ebx,%eax
  803809:	e8 72 f0 ff ff       	call   802880 <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  80380e:	b9 02 00 00 00       	mov    $0x2,%ecx
  803813:	ba 39 00 00 00       	mov    $0x39,%edx
  803818:	89 d8                	mov    %ebx,%eax
  80381a:	e8 a2 f0 ff ff       	call   8028c1 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  80381f:	ba 40 02 00 00       	mov    $0x240,%edx
  803824:	89 d8                	mov    %ebx,%eax
  803826:	e8 fd f0 ff ff       	call   802928 <dhcp_option_short>
    dhcp_option_trailer(dhcp);
  80382b:	89 d8                	mov    %ebx,%eax
  80382d:	e8 54 f1 ff ff       	call   802986 <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803832:	83 ec 08             	sub    $0x8,%esp
  803835:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803839:	66 05 f0 00          	add    $0xf0,%ax
  80383d:	0f b7 c0             	movzwl %ax,%eax
  803840:	50                   	push   %eax
  803841:	ff 73 1c             	pushl  0x1c(%ebx)
  803844:	e8 35 13 00 00       	call   804b7e <pbuf_realloc>
    udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  803849:	83 c4 0c             	add    $0xc,%esp
  80384c:	6a 44                	push   $0x44
  80384e:	68 c4 1f 81 00       	push   $0x811fc4
  803853:	ff 73 08             	pushl  0x8(%ebx)
  803856:	e8 a4 54 00 00       	call   808cff <udp_bind>
    udp_connect(dhcp->pcb, IP_ADDR_BROADCAST, DHCP_SERVER_PORT);
  80385b:	83 c4 0c             	add    $0xc,%esp
  80385e:	6a 43                	push   $0x43
  803860:	68 c0 1f 81 00       	push   $0x811fc0
  803865:	ff 73 08             	pushl  0x8(%ebx)
  803868:	e8 41 57 00 00       	call   808fae <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  80386d:	89 34 24             	mov    %esi,(%esp)
  803870:	6a 43                	push   $0x43
  803872:	68 c0 1f 81 00       	push   $0x811fc0
  803877:	ff 73 1c             	pushl  0x1c(%ebx)
  80387a:	ff 73 08             	pushl  0x8(%ebx)
  80387d:	e8 38 55 00 00       	call   808dba <udp_sendto_if>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803882:	83 c4 1c             	add    $0x1c,%esp
  803885:	6a 43                	push   $0x43
  803887:	68 c4 1f 81 00       	push   $0x811fc4
  80388c:	ff 73 08             	pushl  0x8(%ebx)
  80388f:	e8 1a 57 00 00       	call   808fae <udp_connect>
    dhcp_delete_request(netif);
  803894:	89 f0                	mov    %esi,%eax
  803896:	e8 2b f4 ff ff       	call   802cc6 <dhcp_delete_request>
  80389b:	83 c4 10             	add    $0x10,%esp
  80389e:	e9 0f ff ff ff       	jmp    8037b2 <dhcp_inform+0x49>

008038a3 <dhcp_arp_reply>:
{
  8038a3:	55                   	push   %ebp
  8038a4:	89 e5                	mov    %esp,%ebp
  8038a6:	56                   	push   %esi
  8038a7:	53                   	push   %ebx
  8038a8:	8b 75 08             	mov    0x8(%ebp),%esi
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  8038ab:	85 f6                	test   %esi,%esi
  8038ad:	74 13                	je     8038c2 <dhcp_arp_reply+0x1f>
  if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
  8038af:	8b 5e 20             	mov    0x20(%esi),%ebx
  8038b2:	85 db                	test   %ebx,%ebx
  8038b4:	74 05                	je     8038bb <dhcp_arp_reply+0x18>
  8038b6:	80 3b 08             	cmpb   $0x8,(%ebx)
  8038b9:	74 1e                	je     8038d9 <dhcp_arp_reply+0x36>
}
  8038bb:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8038be:	5b                   	pop    %ebx
  8038bf:	5e                   	pop    %esi
  8038c0:	5d                   	pop    %ebp
  8038c1:	c3                   	ret    
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  8038c2:	83 ec 04             	sub    $0x4,%esp
  8038c5:	68 22 17 81 00       	push   $0x811722
  8038ca:	68 b5 02 00 00       	push   $0x2b5
  8038cf:	68 02 17 81 00       	push   $0x811702
  8038d4:	e8 7a ad 00 00       	call   80e653 <_panic>
    if (ip_addr_cmp(addr, &netif->dhcp->offered_ip_addr)) {
  8038d9:	8b 45 0c             	mov    0xc(%ebp),%eax
  8038dc:	8b 4b 30             	mov    0x30(%ebx),%ecx
  8038df:	39 08                	cmp    %ecx,(%eax)
  8038e1:	75 d8                	jne    8038bb <dhcp_arp_reply+0x18>
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  8038e3:	ba 0c 00 00 00       	mov    $0xc,%edx
  8038e8:	89 d8                	mov    %ebx,%eax
  8038ea:	e8 51 ee ff ff       	call   802740 <dhcp_set_state>
  result = dhcp_create_request(netif);
  8038ef:	89 f0                	mov    %esi,%eax
  8038f1:	e8 dd f1 ff ff       	call   802ad3 <dhcp_create_request>
  if (result == ERR_OK) {
  8038f6:	84 c0                	test   %al,%al
  8038f8:	74 0c                	je     803906 <dhcp_arp_reply+0x63>
  dhcp->tries++;
  8038fa:	80 43 01 01          	addb   $0x1,0x1(%ebx)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  8038fe:	66 c7 43 26 14 00    	movw   $0x14,0x26(%ebx)
}
  803904:	eb b5                	jmp    8038bb <dhcp_arp_reply+0x18>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803906:	b9 01 00 00 00       	mov    $0x1,%ecx
  80390b:	ba 35 00 00 00       	mov    $0x35,%edx
  803910:	89 d8                	mov    %ebx,%eax
  803912:	e8 aa ef ff ff       	call   8028c1 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DECLINE);
  803917:	ba 04 00 00 00       	mov    $0x4,%edx
  80391c:	89 d8                	mov    %ebx,%eax
  80391e:	e8 5d ef ff ff       	call   802880 <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803923:	b9 02 00 00 00       	mov    $0x2,%ecx
  803928:	ba 39 00 00 00       	mov    $0x39,%edx
  80392d:	89 d8                	mov    %ebx,%eax
  80392f:	e8 8d ef ff ff       	call   8028c1 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  803934:	ba 40 02 00 00       	mov    $0x240,%edx
  803939:	89 d8                	mov    %ebx,%eax
  80393b:	e8 e8 ef ff ff       	call   802928 <dhcp_option_short>
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  803940:	b9 04 00 00 00       	mov    $0x4,%ecx
  803945:	ba 32 00 00 00       	mov    $0x32,%edx
  80394a:	89 d8                	mov    %ebx,%eax
  80394c:	e8 70 ef ff ff       	call   8028c1 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  803951:	83 ec 0c             	sub    $0xc,%esp
  803954:	ff 73 30             	pushl  0x30(%ebx)
  803957:	e8 5e 40 00 00       	call   8079ba <ntohl>
  80395c:	89 c2                	mov    %eax,%edx
  80395e:	89 d8                	mov    %ebx,%eax
  803960:	e8 d6 f0 ff ff       	call   802a3b <dhcp_option_long>
    dhcp_option_trailer(dhcp);
  803965:	89 d8                	mov    %ebx,%eax
  803967:	e8 1a f0 ff ff       	call   802986 <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80396c:	83 c4 08             	add    $0x8,%esp
  80396f:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803973:	66 05 f0 00          	add    $0xf0,%ax
  803977:	0f b7 c0             	movzwl %ax,%eax
  80397a:	50                   	push   %eax
  80397b:	ff 73 1c             	pushl  0x1c(%ebx)
  80397e:	e8 fb 11 00 00       	call   804b7e <pbuf_realloc>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803983:	83 c4 0c             	add    $0xc,%esp
  803986:	6a 43                	push   $0x43
  803988:	68 c4 1f 81 00       	push   $0x811fc4
  80398d:	ff 73 08             	pushl  0x8(%ebx)
  803990:	e8 19 56 00 00       	call   808fae <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  803995:	89 34 24             	mov    %esi,(%esp)
  803998:	6a 43                	push   $0x43
  80399a:	68 c0 1f 81 00       	push   $0x811fc0
  80399f:	ff 73 1c             	pushl  0x1c(%ebx)
  8039a2:	ff 73 08             	pushl  0x8(%ebx)
  8039a5:	e8 10 54 00 00       	call   808dba <udp_sendto_if>
    dhcp_delete_request(netif);
  8039aa:	83 c4 20             	add    $0x20,%esp
  8039ad:	89 f0                	mov    %esi,%eax
  8039af:	e8 12 f3 ff ff       	call   802cc6 <dhcp_delete_request>
  8039b4:	e9 41 ff ff ff       	jmp    8038fa <dhcp_arp_reply+0x57>

008039b9 <dhcp_renew>:
{
  8039b9:	55                   	push   %ebp
  8039ba:	89 e5                	mov    %esp,%ebp
  8039bc:	57                   	push   %edi
  8039bd:	56                   	push   %esi
  8039be:	53                   	push   %ebx
  8039bf:	83 ec 1c             	sub    $0x1c,%esp
  8039c2:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct dhcp *dhcp = netif->dhcp;
  8039c5:	8b 5f 20             	mov    0x20(%edi),%ebx
  dhcp_set_state(dhcp, DHCP_RENEWING);
  8039c8:	ba 05 00 00 00       	mov    $0x5,%edx
  8039cd:	89 d8                	mov    %ebx,%eax
  8039cf:	e8 6c ed ff ff       	call   802740 <dhcp_set_state>
  result = dhcp_create_request(netif);
  8039d4:	89 f8                	mov    %edi,%eax
  8039d6:	e8 f8 f0 ff ff       	call   802ad3 <dhcp_create_request>
  8039db:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  8039dd:	84 c0                	test   %al,%al
  8039df:	74 3e                	je     803a1f <dhcp_renew+0x66>
  dhcp->tries++;
  8039e1:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  8039e5:	83 c0 01             	add    $0x1,%eax
  8039e8:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
  8039eb:	ba 20 4e 00 00       	mov    $0x4e20,%edx
  8039f0:	3c 09                	cmp    $0x9,%al
  8039f2:	77 08                	ja     8039fc <dhcp_renew+0x43>
  8039f4:	0f b6 d0             	movzbl %al,%edx
  8039f7:	66 69 d2 d0 07       	imul   $0x7d0,%dx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  8039fc:	0f b7 d2             	movzwl %dx,%edx
  8039ff:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  803a05:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  803a0a:	89 d0                	mov    %edx,%eax
  803a0c:	f7 e9                	imul   %ecx
  803a0e:	c1 fa 05             	sar    $0x5,%edx
  803a11:	66 89 53 26          	mov    %dx,0x26(%ebx)
}
  803a15:	89 f0                	mov    %esi,%eax
  803a17:	8d 65 f4             	lea    -0xc(%ebp),%esp
  803a1a:	5b                   	pop    %ebx
  803a1b:	5e                   	pop    %esi
  803a1c:	5f                   	pop    %edi
  803a1d:	5d                   	pop    %ebp
  803a1e:	c3                   	ret    
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803a1f:	b9 01 00 00 00       	mov    $0x1,%ecx
  803a24:	ba 35 00 00 00       	mov    $0x35,%edx
  803a29:	89 d8                	mov    %ebx,%eax
  803a2b:	e8 91 ee ff ff       	call   8028c1 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  803a30:	ba 03 00 00 00       	mov    $0x3,%edx
  803a35:	89 d8                	mov    %ebx,%eax
  803a37:	e8 44 ee ff ff       	call   802880 <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803a3c:	b9 02 00 00 00       	mov    $0x2,%ecx
  803a41:	ba 39 00 00 00       	mov    $0x39,%edx
  803a46:	89 d8                	mov    %ebx,%eax
  803a48:	e8 74 ee ff ff       	call   8028c1 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  803a4d:	ba 40 02 00 00       	mov    $0x240,%edx
  803a52:	89 d8                	mov    %ebx,%eax
  803a54:	e8 cf ee ff ff       	call   802928 <dhcp_option_short>
    dhcp_option_trailer(dhcp);
  803a59:	89 d8                	mov    %ebx,%eax
  803a5b:	e8 26 ef ff ff       	call   802986 <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803a60:	83 ec 08             	sub    $0x8,%esp
  803a63:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803a67:	66 05 f0 00          	add    $0xf0,%ax
  803a6b:	0f b7 c0             	movzwl %ax,%eax
  803a6e:	50                   	push   %eax
  803a6f:	ff 73 1c             	pushl  0x1c(%ebx)
  803a72:	e8 07 11 00 00       	call   804b7e <pbuf_realloc>
    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  803a77:	8d 43 2c             	lea    0x2c(%ebx),%eax
  803a7a:	83 c4 0c             	add    $0xc,%esp
  803a7d:	6a 43                	push   $0x43
  803a7f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  803a82:	50                   	push   %eax
  803a83:	ff 73 08             	pushl  0x8(%ebx)
  803a86:	e8 23 55 00 00       	call   808fae <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  803a8b:	89 3c 24             	mov    %edi,(%esp)
  803a8e:	6a 43                	push   $0x43
  803a90:	ff 75 e4             	pushl  -0x1c(%ebp)
  803a93:	ff 73 1c             	pushl  0x1c(%ebx)
  803a96:	ff 73 08             	pushl  0x8(%ebx)
  803a99:	e8 1c 53 00 00       	call   808dba <udp_sendto_if>
    dhcp_delete_request(netif);
  803a9e:	83 c4 20             	add    $0x20,%esp
  803aa1:	89 f8                	mov    %edi,%eax
  803aa3:	e8 1e f2 ff ff       	call   802cc6 <dhcp_delete_request>
  803aa8:	e9 34 ff ff ff       	jmp    8039e1 <dhcp_renew+0x28>

00803aad <dhcp_coarse_tmr>:
{
  803aad:	55                   	push   %ebp
  803aae:	89 e5                	mov    %esp,%ebp
  803ab0:	53                   	push   %ebx
  803ab1:	83 ec 04             	sub    $0x4,%esp
  struct netif *netif = netif_list;
  803ab4:	8b 1d 34 b2 b3 00    	mov    0xb3b234,%ebx
  while (netif != NULL) {
  803aba:	eb 1d                	jmp    803ad9 <dhcp_coarse_tmr+0x2c>
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  803abc:	8b 43 20             	mov    0x20(%ebx),%eax
  803abf:	0f b6 00             	movzbl (%eax),%eax
  803ac2:	89 c2                	mov    %eax,%edx
  803ac4:	83 e2 fb             	and    $0xfffffffb,%edx
  803ac7:	80 fa 01             	cmp    $0x1,%dl
  803aca:	74 04                	je     803ad0 <dhcp_coarse_tmr+0x23>
  803acc:	3c 0a                	cmp    $0xa,%al
  803ace:	75 07                	jne    803ad7 <dhcp_coarse_tmr+0x2a>
    dhcp_rebind(netif);
  803ad0:	89 d8                	mov    %ebx,%eax
  803ad2:	e8 89 f2 ff ff       	call   802d60 <dhcp_rebind>
    netif = netif->next;
  803ad7:	8b 1b                	mov    (%ebx),%ebx
  while (netif != NULL) {
  803ad9:	85 db                	test   %ebx,%ebx
  803adb:	74 4e                	je     803b2b <dhcp_coarse_tmr+0x7e>
    if (netif->dhcp != NULL) {
  803add:	8b 43 20             	mov    0x20(%ebx),%eax
  803ae0:	85 c0                	test   %eax,%eax
  803ae2:	74 f3                	je     803ad7 <dhcp_coarse_tmr+0x2a>
      if (netif->dhcp->t2_timeout-- == 1) {
  803ae4:	0f b7 50 2a          	movzwl 0x2a(%eax),%edx
  803ae8:	8d 4a ff             	lea    -0x1(%edx),%ecx
  803aeb:	66 89 48 2a          	mov    %cx,0x2a(%eax)
  803aef:	66 83 fa 01          	cmp    $0x1,%dx
  803af3:	74 c7                	je     803abc <dhcp_coarse_tmr+0xf>
      } else if (netif->dhcp->t1_timeout-- == 1) {
  803af5:	8b 53 20             	mov    0x20(%ebx),%edx
  803af8:	0f b7 42 28          	movzwl 0x28(%edx),%eax
  803afc:	8d 48 ff             	lea    -0x1(%eax),%ecx
  803aff:	66 89 4a 28          	mov    %cx,0x28(%edx)
  803b03:	66 83 f8 01          	cmp    $0x1,%ax
  803b07:	75 ce                	jne    803ad7 <dhcp_coarse_tmr+0x2a>
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  803b09:	8b 43 20             	mov    0x20(%ebx),%eax
  803b0c:	0f b6 00             	movzbl (%eax),%eax
  803b0f:	89 c2                	mov    %eax,%edx
  803b11:	83 e2 fb             	and    $0xfffffffb,%edx
  803b14:	80 fa 01             	cmp    $0x1,%dl
  803b17:	74 04                	je     803b1d <dhcp_coarse_tmr+0x70>
  803b19:	3c 0a                	cmp    $0xa,%al
  803b1b:	75 ba                	jne    803ad7 <dhcp_coarse_tmr+0x2a>
    dhcp_renew(netif);
  803b1d:	83 ec 0c             	sub    $0xc,%esp
  803b20:	53                   	push   %ebx
  803b21:	e8 93 fe ff ff       	call   8039b9 <dhcp_renew>
  803b26:	83 c4 10             	add    $0x10,%esp
  803b29:	eb ac                	jmp    803ad7 <dhcp_coarse_tmr+0x2a>
}
  803b2b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  803b2e:	c9                   	leave  
  803b2f:	c3                   	ret    

00803b30 <dhcp_release>:
{
  803b30:	55                   	push   %ebp
  803b31:	89 e5                	mov    %esp,%ebp
  803b33:	57                   	push   %edi
  803b34:	56                   	push   %esi
  803b35:	53                   	push   %ebx
  803b36:	83 ec 1c             	sub    $0x1c,%esp
  803b39:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  803b3c:	8b 5e 20             	mov    0x20(%esi),%ebx
  dhcp_set_state(dhcp, DHCP_OFF);
  803b3f:	ba 0d 00 00 00       	mov    $0xd,%edx
  803b44:	89 d8                	mov    %ebx,%eax
  803b46:	e8 f5 eb ff ff       	call   802740 <dhcp_set_state>
  dhcp->server_ip_addr.addr = 0;
  803b4b:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
  dhcp->offered_ip_addr.addr = dhcp->offered_sn_mask.addr = 0;
  803b52:	c7 43 34 00 00 00 00 	movl   $0x0,0x34(%ebx)
  803b59:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)
  dhcp->offered_gw_addr.addr = dhcp->offered_bc_addr.addr = 0;
  803b60:	c7 43 3c 00 00 00 00 	movl   $0x0,0x3c(%ebx)
  803b67:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)
  dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
  803b6e:	c7 43 54 00 00 00 00 	movl   $0x0,0x54(%ebx)
  803b75:	c7 43 50 00 00 00 00 	movl   $0x0,0x50(%ebx)
  803b7c:	c7 43 4c 00 00 00 00 	movl   $0x0,0x4c(%ebx)
  dhcp->dns_count = 0;
  803b83:	c7 43 40 00 00 00 00 	movl   $0x0,0x40(%ebx)
  result = dhcp_create_request(netif);
  803b8a:	89 f0                	mov    %esi,%eax
  803b8c:	e8 42 ef ff ff       	call   802ad3 <dhcp_create_request>
  803b91:	89 c7                	mov    %eax,%edi
  if (result == ERR_OK) {
  803b93:	84 c0                	test   %al,%al
  803b95:	74 71                	je     803c08 <dhcp_release+0xd8>
  dhcp->tries++;
  803b97:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  803b9b:	83 c0 01             	add    $0x1,%eax
  803b9e:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  803ba1:	ba 10 27 00 00       	mov    $0x2710,%edx
  803ba6:	3c 09                	cmp    $0x9,%al
  803ba8:	77 08                	ja     803bb2 <dhcp_release+0x82>
  803baa:	0f b6 d0             	movzbl %al,%edx
  803bad:	66 69 d2 e8 03       	imul   $0x3e8,%dx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803bb2:	0f b7 d2             	movzwl %dx,%edx
  803bb5:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  803bbb:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  803bc0:	89 d0                	mov    %edx,%eax
  803bc2:	f7 e9                	imul   %ecx
  803bc4:	c1 fa 05             	sar    $0x5,%edx
  803bc7:	66 89 53 26          	mov    %dx,0x26(%ebx)
  netif_set_down(netif);
  803bcb:	83 ec 0c             	sub    $0xc,%esp
  803bce:	56                   	push   %esi
  803bcf:	e8 80 0b 00 00       	call   804754 <netif_set_down>
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  803bd4:	83 c4 08             	add    $0x8,%esp
  803bd7:	68 c4 1f 81 00       	push   $0x811fc4
  803bdc:	56                   	push   %esi
  803bdd:	e8 bc 09 00 00       	call   80459e <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  803be2:	83 c4 08             	add    $0x8,%esp
  803be5:	68 c4 1f 81 00       	push   $0x811fc4
  803bea:	56                   	push   %esi
  803beb:	e8 f2 0a 00 00       	call   8046e2 <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY);
  803bf0:	83 c4 08             	add    $0x8,%esp
  803bf3:	68 c4 1f 81 00       	push   $0x811fc4
  803bf8:	56                   	push   %esi
  803bf9:	e8 fd 0a 00 00       	call   8046fb <netif_set_netmask>
}
  803bfe:	89 f8                	mov    %edi,%eax
  803c00:	8d 65 f4             	lea    -0xc(%ebp),%esp
  803c03:	5b                   	pop    %ebx
  803c04:	5e                   	pop    %esi
  803c05:	5f                   	pop    %edi
  803c06:	5d                   	pop    %ebp
  803c07:	c3                   	ret    
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803c08:	b9 01 00 00 00       	mov    $0x1,%ecx
  803c0d:	ba 35 00 00 00       	mov    $0x35,%edx
  803c12:	89 d8                	mov    %ebx,%eax
  803c14:	e8 a8 ec ff ff       	call   8028c1 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_RELEASE);
  803c19:	ba 07 00 00 00       	mov    $0x7,%edx
  803c1e:	89 d8                	mov    %ebx,%eax
  803c20:	e8 5b ec ff ff       	call   802880 <dhcp_option_byte>
    dhcp_option_trailer(dhcp);
  803c25:	89 d8                	mov    %ebx,%eax
  803c27:	e8 5a ed ff ff       	call   802986 <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803c2c:	83 ec 08             	sub    $0x8,%esp
  803c2f:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803c33:	66 05 f0 00          	add    $0xf0,%ax
  803c37:	0f b7 c0             	movzwl %ax,%eax
  803c3a:	50                   	push   %eax
  803c3b:	ff 73 1c             	pushl  0x1c(%ebx)
  803c3e:	e8 3b 0f 00 00       	call   804b7e <pbuf_realloc>
    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  803c43:	8d 43 2c             	lea    0x2c(%ebx),%eax
  803c46:	83 c4 0c             	add    $0xc,%esp
  803c49:	6a 43                	push   $0x43
  803c4b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  803c4e:	50                   	push   %eax
  803c4f:	ff 73 08             	pushl  0x8(%ebx)
  803c52:	e8 57 53 00 00       	call   808fae <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  803c57:	89 34 24             	mov    %esi,(%esp)
  803c5a:	6a 43                	push   $0x43
  803c5c:	ff 75 e4             	pushl  -0x1c(%ebp)
  803c5f:	ff 73 1c             	pushl  0x1c(%ebx)
  803c62:	ff 73 08             	pushl  0x8(%ebx)
  803c65:	e8 50 51 00 00       	call   808dba <udp_sendto_if>
    dhcp_delete_request(netif);
  803c6a:	83 c4 20             	add    $0x20,%esp
  803c6d:	89 f0                	mov    %esi,%eax
  803c6f:	e8 52 f0 ff ff       	call   802cc6 <dhcp_delete_request>
  803c74:	e9 1e ff ff ff       	jmp    803b97 <dhcp_release+0x67>

00803c79 <dhcp_fine_tmr>:
{
  803c79:	55                   	push   %ebp
  803c7a:	89 e5                	mov    %esp,%ebp
  803c7c:	53                   	push   %ebx
  803c7d:	83 ec 04             	sub    $0x4,%esp
  struct netif *netif = netif_list;
  803c80:	8b 1d 34 b2 b3 00    	mov    0xb3b234,%ebx
  while (netif != NULL) {
  803c86:	eb 08                	jmp    803c90 <dhcp_fine_tmr+0x17>
      else if (netif->dhcp->request_timeout == 1) {
  803c88:	66 83 fa 01          	cmp    $0x1,%dx
  803c8c:	74 24                	je     803cb2 <dhcp_fine_tmr+0x39>
    netif = netif->next;
  803c8e:	8b 1b                	mov    (%ebx),%ebx
  while (netif != NULL) {
  803c90:	85 db                	test   %ebx,%ebx
  803c92:	0f 84 c4 00 00 00    	je     803d5c <dhcp_fine_tmr+0xe3>
    if (netif->dhcp != NULL) {
  803c98:	8b 43 20             	mov    0x20(%ebx),%eax
  803c9b:	85 c0                	test   %eax,%eax
  803c9d:	74 ef                	je     803c8e <dhcp_fine_tmr+0x15>
      if (netif->dhcp->request_timeout > 1) {
  803c9f:	0f b7 50 26          	movzwl 0x26(%eax),%edx
  803ca3:	66 83 fa 01          	cmp    $0x1,%dx
  803ca7:	76 df                	jbe    803c88 <dhcp_fine_tmr+0xf>
        netif->dhcp->request_timeout--;
  803ca9:	83 ea 01             	sub    $0x1,%edx
  803cac:	66 89 50 26          	mov    %dx,0x26(%eax)
  803cb0:	eb dc                	jmp    803c8e <dhcp_fine_tmr+0x15>
        netif->dhcp->request_timeout--;
  803cb2:	66 c7 40 26 00 00    	movw   $0x0,0x26(%eax)
  struct dhcp *dhcp = netif->dhcp;
  803cb8:	8b 53 20             	mov    0x20(%ebx),%edx
  if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
  803cbb:	0f b6 02             	movzbl (%edx),%eax
  803cbe:	3c 0c                	cmp    $0xc,%al
  803cc0:	74 2f                	je     803cf1 <dhcp_fine_tmr+0x78>
  803cc2:	3c 06                	cmp    $0x6,%al
  803cc4:	74 2b                	je     803cf1 <dhcp_fine_tmr+0x78>
  } else if (dhcp->state == DHCP_REQUESTING) {
  803cc6:	3c 01                	cmp    $0x1,%al
  803cc8:	74 30                	je     803cfa <dhcp_fine_tmr+0x81>
  } else if (dhcp->state == DHCP_CHECKING) {
  803cca:	3c 08                	cmp    $0x8,%al
  803ccc:	74 53                	je     803d21 <dhcp_fine_tmr+0xa8>
  else if (dhcp->state == DHCP_RENEWING) {
  803cce:	3c 05                	cmp    $0x5,%al
  803cd0:	74 6d                	je     803d3f <dhcp_fine_tmr+0xc6>
  } else if (dhcp->state == DHCP_REBINDING) {
  803cd2:	3c 04                	cmp    $0x4,%al
  803cd4:	75 b8                	jne    803c8e <dhcp_fine_tmr+0x15>
    if (dhcp->tries <= 8) {
  803cd6:	80 7a 01 08          	cmpb   $0x8,0x1(%edx)
  803cda:	76 74                	jbe    803d50 <dhcp_fine_tmr+0xd7>
      dhcp_release(netif);
  803cdc:	83 ec 0c             	sub    $0xc,%esp
  803cdf:	53                   	push   %ebx
  803ce0:	e8 4b fe ff ff       	call   803b30 <dhcp_release>
      dhcp_discover(netif);
  803ce5:	89 d8                	mov    %ebx,%eax
  803ce7:	e8 67 f1 ff ff       	call   802e53 <dhcp_discover>
  803cec:	83 c4 10             	add    $0x10,%esp
  803cef:	eb 9d                	jmp    803c8e <dhcp_fine_tmr+0x15>
    dhcp_discover(netif);
  803cf1:	89 d8                	mov    %ebx,%eax
  803cf3:	e8 5b f1 ff ff       	call   802e53 <dhcp_discover>
  803cf8:	eb 94                	jmp    803c8e <dhcp_fine_tmr+0x15>
    if (dhcp->tries <= 5) {
  803cfa:	80 7a 01 05          	cmpb   $0x5,0x1(%edx)
  803cfe:	77 09                	ja     803d09 <dhcp_fine_tmr+0x90>
      dhcp_select(netif);
  803d00:	89 d8                	mov    %ebx,%eax
  803d02:	e8 8b f2 ff ff       	call   802f92 <dhcp_select>
  803d07:	eb 85                	jmp    803c8e <dhcp_fine_tmr+0x15>
      dhcp_release(netif);
  803d09:	83 ec 0c             	sub    $0xc,%esp
  803d0c:	53                   	push   %ebx
  803d0d:	e8 1e fe ff ff       	call   803b30 <dhcp_release>
      dhcp_discover(netif);
  803d12:	89 d8                	mov    %ebx,%eax
  803d14:	e8 3a f1 ff ff       	call   802e53 <dhcp_discover>
  803d19:	83 c4 10             	add    $0x10,%esp
  803d1c:	e9 6d ff ff ff       	jmp    803c8e <dhcp_fine_tmr+0x15>
    if (dhcp->tries <= 1) {
  803d21:	80 7a 01 01          	cmpb   $0x1,0x1(%edx)
  803d25:	76 0c                	jbe    803d33 <dhcp_fine_tmr+0xba>
      dhcp_bind(netif);
  803d27:	89 d8                	mov    %ebx,%eax
  803d29:	e8 14 f4 ff ff       	call   803142 <dhcp_bind>
  803d2e:	e9 5b ff ff ff       	jmp    803c8e <dhcp_fine_tmr+0x15>
      dhcp_check(netif);
  803d33:	89 d8                	mov    %ebx,%eax
  803d35:	e8 d4 f3 ff ff       	call   80310e <dhcp_check>
  803d3a:	e9 4f ff ff ff       	jmp    803c8e <dhcp_fine_tmr+0x15>
    dhcp_renew(netif);
  803d3f:	83 ec 0c             	sub    $0xc,%esp
  803d42:	53                   	push   %ebx
  803d43:	e8 71 fc ff ff       	call   8039b9 <dhcp_renew>
  803d48:	83 c4 10             	add    $0x10,%esp
  803d4b:	e9 3e ff ff ff       	jmp    803c8e <dhcp_fine_tmr+0x15>
      dhcp_rebind(netif);
  803d50:	89 d8                	mov    %ebx,%eax
  803d52:	e8 09 f0 ff ff       	call   802d60 <dhcp_rebind>
  803d57:	e9 32 ff ff ff       	jmp    803c8e <dhcp_fine_tmr+0x15>
}
  803d5c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  803d5f:	c9                   	leave  
  803d60:	c3                   	ret    

00803d61 <dhcp_stop>:
{
  803d61:	55                   	push   %ebp
  803d62:	89 e5                	mov    %esp,%ebp
  803d64:	56                   	push   %esi
  803d65:	53                   	push   %ebx
  803d66:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct dhcp *dhcp = netif->dhcp;
  803d69:	8b 73 20             	mov    0x20(%ebx),%esi
  LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
  803d6c:	85 db                	test   %ebx,%ebx
  803d6e:	74 5d                	je     803dcd <dhcp_stop+0x6c>
  netif->flags &= ~NETIF_FLAG_DHCP;
  803d70:	80 63 2e f7          	andb   $0xf7,0x2e(%ebx)
  if (dhcp != NULL) {
  803d74:	85 f6                	test   %esi,%esi
  803d76:	74 4e                	je     803dc6 <dhcp_stop+0x65>
    if (dhcp->pcb != NULL) {
  803d78:	8b 46 08             	mov    0x8(%esi),%eax
  803d7b:	85 c0                	test   %eax,%eax
  803d7d:	74 13                	je     803d92 <dhcp_stop+0x31>
      udp_remove(dhcp->pcb);
  803d7f:	83 ec 0c             	sub    $0xc,%esp
  803d82:	50                   	push   %eax
  803d83:	e8 c6 52 00 00       	call   80904e <udp_remove>
      dhcp->pcb = NULL;
  803d88:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
  803d8f:	83 c4 10             	add    $0x10,%esp
    if (dhcp->p != NULL) {
  803d92:	8b 46 0c             	mov    0xc(%esi),%eax
  803d95:	85 c0                	test   %eax,%eax
  803d97:	74 13                	je     803dac <dhcp_stop+0x4b>
      pbuf_free(dhcp->p);
  803d99:	83 ec 0c             	sub    $0xc,%esp
  803d9c:	50                   	push   %eax
  803d9d:	e8 ab 0a 00 00       	call   80484d <pbuf_free>
      dhcp->p = NULL;
  803da2:	c7 46 0c 00 00 00 00 	movl   $0x0,0xc(%esi)
  803da9:	83 c4 10             	add    $0x10,%esp
    dhcp_free_reply(dhcp);
  803dac:	89 f0                	mov    %esi,%eax
  803dae:	e8 37 f5 ff ff       	call   8032ea <dhcp_free_reply>
    mem_free((void *)dhcp);
  803db3:	83 ec 0c             	sub    $0xc,%esp
  803db6:	56                   	push   %esi
  803db7:	e8 73 01 00 00       	call   803f2f <mem_free>
    netif->dhcp = NULL;
  803dbc:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
  803dc3:	83 c4 10             	add    $0x10,%esp
}
  803dc6:	8d 65 f8             	lea    -0x8(%ebp),%esp
  803dc9:	5b                   	pop    %ebx
  803dca:	5e                   	pop    %esi
  803dcb:	5d                   	pop    %ebp
  803dcc:	c3                   	ret    
  LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
  803dcd:	83 ec 04             	sub    $0x4,%esp
  803dd0:	68 74 17 81 00       	push   $0x811774
  803dd5:	68 2c 04 00 00       	push   $0x42c
  803dda:	68 02 17 81 00       	push   $0x811702
  803ddf:	e8 6f a8 00 00       	call   80e653 <_panic>

00803de4 <dhcp_start>:
{
  803de4:	55                   	push   %ebp
  803de5:	89 e5                	mov    %esp,%ebp
  803de7:	56                   	push   %esi
  803de8:	53                   	push   %ebx
  803de9:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
  803dec:	85 db                	test   %ebx,%ebx
  803dee:	74 73                	je     803e63 <dhcp_start+0x7f>
  dhcp = netif->dhcp;
  803df0:	8b 73 20             	mov    0x20(%ebx),%esi
  netif->flags &= ~NETIF_FLAG_DHCP;
  803df3:	80 63 2e f7          	andb   $0xf7,0x2e(%ebx)
  if (dhcp == NULL) {
  803df7:	85 f6                	test   %esi,%esi
  803df9:	74 7f                	je     803e7a <dhcp_start+0x96>
  memset(dhcp, 0, sizeof(struct dhcp));
  803dfb:	83 ec 04             	sub    $0x4,%esp
  803dfe:	6a 58                	push   $0x58
  803e00:	6a 00                	push   $0x0
  803e02:	56                   	push   %esi
  803e03:	e8 04 b1 00 00       	call   80ef0c <memset>
  dhcp->pcb = udp_new();
  803e08:	e8 85 52 00 00       	call   809092 <udp_new>
  803e0d:	89 46 08             	mov    %eax,0x8(%esi)
  if (dhcp->pcb == NULL) {
  803e10:	83 c4 10             	add    $0x10,%esp
  803e13:	85 c0                	test   %eax,%eax
  803e15:	74 7e                	je     803e95 <dhcp_start+0xb1>
  udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  803e17:	83 ec 04             	sub    $0x4,%esp
  803e1a:	6a 44                	push   $0x44
  803e1c:	68 c4 1f 81 00       	push   $0x811fc4
  803e21:	50                   	push   %eax
  803e22:	e8 d8 4e 00 00       	call   808cff <udp_bind>
  udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803e27:	83 c4 0c             	add    $0xc,%esp
  803e2a:	6a 43                	push   $0x43
  803e2c:	68 c4 1f 81 00       	push   $0x811fc4
  803e31:	ff 76 08             	pushl  0x8(%esi)
  803e34:	e8 75 51 00 00       	call   808fae <udp_connect>
  udp_recv(dhcp->pcb, dhcp_recv, netif);
  803e39:	83 c4 0c             	add    $0xc,%esp
  803e3c:	53                   	push   %ebx
  803e3d:	68 32 33 80 00       	push   $0x803332
  803e42:	ff 76 08             	pushl  0x8(%esi)
  803e45:	e8 f0 51 00 00       	call   80903a <udp_recv>
  result = dhcp_discover(netif);
  803e4a:	89 d8                	mov    %ebx,%eax
  803e4c:	e8 02 f0 ff ff       	call   802e53 <dhcp_discover>
  if (result != ERR_OK) {
  803e51:	83 c4 10             	add    $0x10,%esp
  803e54:	84 c0                	test   %al,%al
  803e56:	75 57                	jne    803eaf <dhcp_start+0xcb>
  netif->flags |= NETIF_FLAG_DHCP;
  803e58:	80 4b 2e 08          	orb    $0x8,0x2e(%ebx)
}
  803e5c:	8d 65 f8             	lea    -0x8(%ebp),%esp
  803e5f:	5b                   	pop    %ebx
  803e60:	5e                   	pop    %esi
  803e61:	5d                   	pop    %ebp
  803e62:	c3                   	ret    
  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
  803e63:	83 ec 04             	sub    $0x4,%esp
  803e66:	68 22 17 81 00       	push   $0x811722
  803e6b:	68 38 02 00 00       	push   $0x238
  803e70:	68 02 17 81 00       	push   $0x811702
  803e75:	e8 d9 a7 00 00       	call   80e653 <_panic>
    dhcp = mem_malloc(sizeof(struct dhcp));
  803e7a:	83 ec 0c             	sub    $0xc,%esp
  803e7d:	6a 58                	push   $0x58
  803e7f:	e8 9c 03 00 00       	call   804220 <mem_malloc>
  803e84:	89 c6                	mov    %eax,%esi
    if (dhcp == NULL) {
  803e86:	83 c4 10             	add    $0x10,%esp
  803e89:	85 c0                	test   %eax,%eax
  803e8b:	74 35                	je     803ec2 <dhcp_start+0xde>
    netif->dhcp = dhcp;
  803e8d:	89 43 20             	mov    %eax,0x20(%ebx)
  803e90:	e9 66 ff ff ff       	jmp    803dfb <dhcp_start+0x17>
    mem_free((void *)dhcp);
  803e95:	83 ec 0c             	sub    $0xc,%esp
  803e98:	56                   	push   %esi
  803e99:	e8 91 00 00 00       	call   803f2f <mem_free>
    netif->dhcp = dhcp = NULL;
  803e9e:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
    return ERR_MEM;
  803ea5:	83 c4 10             	add    $0x10,%esp
  803ea8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  803ead:	eb ad                	jmp    803e5c <dhcp_start+0x78>
    dhcp_stop(netif);
  803eaf:	83 ec 0c             	sub    $0xc,%esp
  803eb2:	53                   	push   %ebx
  803eb3:	e8 a9 fe ff ff       	call   803d61 <dhcp_stop>
    return ERR_MEM;
  803eb8:	83 c4 10             	add    $0x10,%esp
  803ebb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  803ec0:	eb 9a                	jmp    803e5c <dhcp_start+0x78>
      return ERR_MEM;
  803ec2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  803ec7:	eb 93                	jmp    803e5c <dhcp_start+0x78>

00803ec9 <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
  803ec9:	55                   	push   %ebp
  803eca:	89 e5                	mov    %esp,%ebp
  803ecc:	83 ec 14             	sub    $0x14,%esp

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = LWIP_MEM_ALIGN(ram_heap);
  803ecf:	b8 23 53 81 00       	mov    $0x815323,%eax
  803ed4:	83 e0 fc             	and    $0xfffffffc,%eax
  803ed7:	a3 0c 53 81 00       	mov    %eax,0x81530c
  /* initialize the start of the heap */
  mem = (struct mem *)ram;
  mem->next = MEM_SIZE_ALIGNED;
  803edc:	c7 00 00 00 22 00    	movl   $0x220000,(%eax)
  mem->prev = 0;
  803ee2:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  mem->used = 0;
  803ee9:	c6 40 08 00          	movb   $0x0,0x8(%eax)
  /* initialize the end of the heap */
  ram_end = (struct mem *)&ram[MEM_SIZE_ALIGNED];
  803eed:	8d 90 00 00 22 00    	lea    0x220000(%eax),%edx
  803ef3:	89 15 08 53 81 00    	mov    %edx,0x815308
  ram_end->used = 1;
  803ef9:	c6 80 08 00 22 00 01 	movb   $0x1,0x220008(%eax)
  ram_end->next = MEM_SIZE_ALIGNED;
  803f00:	c7 80 00 00 22 00 00 	movl   $0x220000,0x220000(%eax)
  803f07:	00 22 00 
  ram_end->prev = MEM_SIZE_ALIGNED;
  803f0a:	c7 80 04 00 22 00 00 	movl   $0x220000,0x220004(%eax)
  803f11:	00 22 00 

  mem_sem = sys_sem_new(1);
  803f14:	6a 01                	push   $0x1
  803f16:	e8 4c 5f 00 00       	call   809e67 <sys_sem_new>
  803f1b:	a3 00 53 81 00       	mov    %eax,0x815300

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)ram;
  803f20:	a1 0c 53 81 00       	mov    0x81530c,%eax
  803f25:	a3 04 53 81 00       	mov    %eax,0x815304

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
}
  803f2a:	83 c4 10             	add    $0x10,%esp
  803f2d:	c9                   	leave  
  803f2e:	c3                   	ret    

00803f2f <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
  803f2f:	55                   	push   %ebp
  803f30:	89 e5                	mov    %esp,%ebp
  803f32:	56                   	push   %esi
  803f33:	53                   	push   %ebx
  803f34:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
  803f37:	85 db                	test   %ebx,%ebx
  803f39:	0f 84 e1 00 00 00    	je     804020 <mem_free+0xf1>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | 2, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
  803f3f:	f6 c3 03             	test   $0x3,%bl
  803f42:	0f 85 df 00 00 00    	jne    804027 <mem_free+0xf8>

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  803f48:	39 1d 0c 53 81 00    	cmp    %ebx,0x81530c
  803f4e:	0f 87 ea 00 00 00    	ja     80403e <mem_free+0x10f>
  803f54:	39 1d 08 53 81 00    	cmp    %ebx,0x815308
  803f5a:	0f 86 de 00 00 00    	jbe    80403e <mem_free+0x10f>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return;
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  803f60:	83 ec 08             	sub    $0x8,%esp
  803f63:	6a 00                	push   $0x0
  803f65:	ff 35 00 53 81 00    	pushl  0x815300
  803f6b:	e8 24 62 00 00       	call   80a194 <sys_arch_sem_wait>
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  803f70:	8d 43 f4             	lea    -0xc(%ebx),%eax
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  803f73:	83 c4 10             	add    $0x10,%esp
  803f76:	80 7b fc 00          	cmpb   $0x0,-0x4(%ebx)
  803f7a:	0f 84 d5 00 00 00    	je     804055 <mem_free+0x126>
  /* ... and is now unused. */
  mem->used = 0;
  803f80:	c6 43 fc 00          	movb   $0x0,-0x4(%ebx)

  if (mem < lfree) {
  803f84:	39 05 04 53 81 00    	cmp    %eax,0x815304
  803f8a:	76 05                	jbe    803f91 <mem_free+0x62>
    /* the newly freed struct is now the lowest */
    lfree = mem;
  803f8c:	a3 04 53 81 00       	mov    %eax,0x815304
  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  803f91:	8b 0d 0c 53 81 00    	mov    0x81530c,%ecx
  803f97:	39 c8                	cmp    %ecx,%eax
  803f99:	0f 82 cd 00 00 00    	jb     80406c <mem_free+0x13d>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
  803f9f:	8b 35 08 53 81 00    	mov    0x815308,%esi
  803fa5:	39 f0                	cmp    %esi,%eax
  803fa7:	0f 83 d6 00 00 00    	jae    804083 <mem_free+0x154>
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
  803fad:	8b 53 f4             	mov    -0xc(%ebx),%edx
  803fb0:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  803fb6:	0f 87 de 00 00 00    	ja     80409a <mem_free+0x16b>
  nmem = (struct mem *)&ram[mem->next];
  803fbc:	01 ca                	add    %ecx,%edx
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
  803fbe:	39 d0                	cmp    %edx,%eax
  803fc0:	74 25                	je     803fe7 <mem_free+0xb8>
  803fc2:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  803fc6:	75 1f                	jne    803fe7 <mem_free+0xb8>
  803fc8:	39 d6                	cmp    %edx,%esi
  803fca:	74 1b                	je     803fe7 <mem_free+0xb8>
    if (lfree == nmem) {
  803fcc:	3b 15 04 53 81 00    	cmp    0x815304,%edx
  803fd2:	0f 84 d9 00 00 00    	je     8040b1 <mem_free+0x182>
    mem->next = nmem->next;
  803fd8:	8b 32                	mov    (%edx),%esi
  803fda:	89 73 f4             	mov    %esi,-0xc(%ebx)
    ((struct mem *)&ram[nmem->next])->prev = (u8_t *)mem - ram;
  803fdd:	8b 12                	mov    (%edx),%edx
  803fdf:	89 c6                	mov    %eax,%esi
  803fe1:	29 ce                	sub    %ecx,%esi
  803fe3:	89 74 11 04          	mov    %esi,0x4(%ecx,%edx,1)
  pmem = (struct mem *)&ram[mem->prev];
  803fe7:	8b 73 f8             	mov    -0x8(%ebx),%esi
  803fea:	8d 14 31             	lea    (%ecx,%esi,1),%edx
  if (pmem != mem && pmem->used == 0) {
  803fed:	39 d0                	cmp    %edx,%eax
  803fef:	74 1e                	je     80400f <mem_free+0xe0>
  803ff1:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  803ff5:	75 18                	jne    80400f <mem_free+0xe0>
    if (lfree == mem) {
  803ff7:	3b 05 04 53 81 00    	cmp    0x815304,%eax
  803ffd:	0f 84 b8 00 00 00    	je     8040bb <mem_free+0x18c>
    pmem->next = mem->next;
  804003:	8b 43 f4             	mov    -0xc(%ebx),%eax
  804006:	89 02                	mov    %eax,(%edx)
    ((struct mem *)&ram[mem->next])->prev = (u8_t *)pmem - ram;
  804008:	8b 43 f4             	mov    -0xc(%ebx),%eax
  80400b:	89 74 01 04          	mov    %esi,0x4(%ecx,%eax,1)
  /* finally, see if prev or next are free also */
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  80400f:	83 ec 0c             	sub    $0xc,%esp
  804012:	ff 35 00 53 81 00    	pushl  0x815300
  804018:	e8 07 61 00 00       	call   80a124 <sys_sem_signal>
  80401d:	83 c4 10             	add    $0x10,%esp
}
  804020:	8d 65 f8             	lea    -0x8(%ebp),%esp
  804023:	5b                   	pop    %ebx
  804024:	5e                   	pop    %esi
  804025:	5d                   	pop    %ebp
  804026:	c3                   	ret    
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
  804027:	83 ec 04             	sub    $0x4,%esp
  80402a:	68 90 17 81 00       	push   $0x811790
  80402f:	68 30 01 00 00       	push   $0x130
  804034:	68 87 18 81 00       	push   $0x811887
  804039:	e8 15 a6 00 00       	call   80e653 <_panic>
  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  80403e:	83 ec 04             	sub    $0x4,%esp
  804041:	68 9b 18 81 00       	push   $0x81189b
  804046:	68 33 01 00 00       	push   $0x133
  80404b:	68 87 18 81 00       	push   $0x811887
  804050:	e8 fe a5 00 00       	call   80e653 <_panic>
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  804055:	83 ec 04             	sub    $0x4,%esp
  804058:	68 b2 18 81 00       	push   $0x8118b2
  80405d:	68 43 01 00 00       	push   $0x143
  804062:	68 87 18 81 00       	push   $0x811887
  804067:	e8 e7 a5 00 00       	call   80e653 <_panic>
  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  80406c:	83 ec 04             	sub    $0x4,%esp
  80406f:	68 c6 18 81 00       	push   $0x8118c6
  804074:	68 e3 00 00 00       	push   $0xe3
  804079:	68 87 18 81 00       	push   $0x811887
  80407e:	e8 d0 a5 00 00       	call   80e653 <_panic>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
  804083:	83 ec 04             	sub    $0x4,%esp
  804086:	68 dd 18 81 00       	push   $0x8118dd
  80408b:	68 e4 00 00 00       	push   $0xe4
  804090:	68 87 18 81 00       	push   $0x811887
  804095:	e8 b9 a5 00 00       	call   80e653 <_panic>
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
  80409a:	83 ec 04             	sub    $0x4,%esp
  80409d:	68 b4 17 81 00       	push   $0x8117b4
  8040a2:	68 e8 00 00 00       	push   $0xe8
  8040a7:	68 87 18 81 00       	push   $0x811887
  8040ac:	e8 a2 a5 00 00       	call   80e653 <_panic>
      lfree = mem;
  8040b1:	a3 04 53 81 00       	mov    %eax,0x815304
  8040b6:	e9 1d ff ff ff       	jmp    803fd8 <mem_free+0xa9>
      lfree = pmem;
  8040bb:	89 15 04 53 81 00    	mov    %edx,0x815304
  8040c1:	e9 3d ff ff ff       	jmp    804003 <mem_free+0xd4>

008040c6 <mem_realloc>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_realloc(void *rmem, mem_size_t newsize)
{
  8040c6:	55                   	push   %ebp
  8040c7:	89 e5                	mov    %esp,%ebp
  8040c9:	57                   	push   %edi
  8040ca:	56                   	push   %esi
  8040cb:	53                   	push   %ebx
  8040cc:	83 ec 1c             	sub    $0x1c,%esp
  8040cf:	8b 7d 08             	mov    0x8(%ebp),%edi
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
  8040d2:	8b 45 0c             	mov    0xc(%ebp),%eax
  8040d5:	8d 58 03             	lea    0x3(%eax),%ebx
  8040d8:	83 e3 fc             	and    $0xfffffffc,%ebx

  if(newsize < MIN_SIZE_ALIGNED) {
  8040db:	83 fb 0b             	cmp    $0xb,%ebx
  8040de:	76 12                	jbe    8040f2 <mem_realloc+0x2c>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
  8040e0:	81 fb 00 00 22 00    	cmp    $0x220000,%ebx
  8040e6:	76 0f                	jbe    8040f7 <mem_realloc+0x31>
    return NULL;
  8040e8:	bf 00 00 00 00       	mov    $0x0,%edi
  8040ed:	e9 a3 00 00 00       	jmp    804195 <mem_realloc+0xcf>
    newsize = MIN_SIZE_ALIGNED;
  8040f2:	bb 0c 00 00 00       	mov    $0xc,%ebx
  }

  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  8040f7:	a1 0c 53 81 00       	mov    0x81530c,%eax
  8040fc:	39 f8                	cmp    %edi,%eax
  8040fe:	0f 87 9b 00 00 00    	ja     80419f <mem_realloc+0xd9>
  804104:	39 3d 08 53 81 00    	cmp    %edi,0x815308
  80410a:	0f 86 8f 00 00 00    	jbe    80419f <mem_realloc+0xd9>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return rmem;
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  804110:	8d 57 f4             	lea    -0xc(%edi),%edx
  /* ... and its offset pointer */
  ptr = (u8_t *)mem - ram;
  804113:	29 c2                	sub    %eax,%edx
  804115:	89 55 e4             	mov    %edx,-0x1c(%ebp)

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
  804118:	8b 4f f4             	mov    -0xc(%edi),%ecx
  80411b:	8d 71 f4             	lea    -0xc(%ecx),%esi
  80411e:	29 d6                	sub    %edx,%esi
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  804120:	39 de                	cmp    %ebx,%esi
  804122:	0f 82 8e 00 00 00    	jb     8041b6 <mem_realloc+0xf0>
  if (newsize > size) {
    /* not supported */
    return NULL;
  }
  if (newsize == size) {
  804128:	39 de                	cmp    %ebx,%esi
  80412a:	74 69                	je     804195 <mem_realloc+0xcf>
    /* No change in size, simply return */
    return rmem;
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  80412c:	83 ec 08             	sub    $0x8,%esp
  80412f:	6a 00                	push   $0x0
  804131:	ff 35 00 53 81 00    	pushl  0x815300
  804137:	e8 58 60 00 00       	call   80a194 <sys_arch_sem_wait>

  MEM_STATS_DEC_USED(used, (size - newsize));

  mem2 = (struct mem *)&ram[mem->next];
  80413c:	a1 0c 53 81 00       	mov    0x81530c,%eax
  804141:	89 c2                	mov    %eax,%edx
  804143:	03 57 f4             	add    -0xc(%edi),%edx
  if(mem2->used == 0) {
  804146:	83 c4 10             	add    $0x10,%esp
  804149:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  80414d:	0f 85 85 00 00 00    	jne    8041d8 <mem_realloc+0x112>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
  804153:	8b 0a                	mov    (%edx),%ecx
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  804155:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  804158:	8d 5c 33 0c          	lea    0xc(%ebx,%esi,1),%ebx
    if (lfree == mem2) {
  80415c:	39 15 04 53 81 00    	cmp    %edx,0x815304
  804162:	74 69                	je     8041cd <mem_realloc+0x107>
      lfree = (struct mem *)&ram[ptr2];
    }
    mem2 = (struct mem *)&ram[ptr2];
  804164:	8d 14 18             	lea    (%eax,%ebx,1),%edx
    mem2->used = 0;
  804167:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    /* restore the next pointer */
    mem2->next = next;
  80416b:	89 0a                	mov    %ecx,(%edx)
    /* link it back to mem */
    mem2->prev = ptr;
  80416d:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  804170:	89 4a 04             	mov    %ecx,0x4(%edx)
    /* link mem to it */
    mem->next = ptr2;
  804173:	89 5f f4             	mov    %ebx,-0xc(%edi)
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
  804176:	8b 12                	mov    (%edx),%edx
  804178:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  80417e:	74 04                	je     804184 <mem_realloc+0xbe>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  804180:	89 5c 10 04          	mov    %ebx,0x4(%eax,%edx,1)
    -> the remaining space stays unused since it is too small
  } */
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  804184:	83 ec 0c             	sub    $0xc,%esp
  804187:	ff 35 00 53 81 00    	pushl  0x815300
  80418d:	e8 92 5f 00 00       	call   80a124 <sys_sem_signal>
  return rmem;
  804192:	83 c4 10             	add    $0x10,%esp
}
  804195:	89 f8                	mov    %edi,%eax
  804197:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80419a:	5b                   	pop    %ebx
  80419b:	5e                   	pop    %esi
  80419c:	5f                   	pop    %edi
  80419d:	5d                   	pop    %ebp
  80419e:	c3                   	ret    
  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  80419f:	83 ec 04             	sub    $0x4,%esp
  8041a2:	68 f7 18 81 00       	push   $0x8118f7
  8041a7:	68 79 01 00 00       	push   $0x179
  8041ac:	68 87 18 81 00       	push   $0x811887
  8041b1:	e8 9d a4 00 00       	call   80e653 <_panic>
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  8041b6:	83 ec 04             	sub    $0x4,%esp
  8041b9:	68 e0 17 81 00       	push   $0x8117e0
  8041be:	68 8a 01 00 00       	push   $0x18a
  8041c3:	68 87 18 81 00       	push   $0x811887
  8041c8:	e8 86 a4 00 00       	call   80e653 <_panic>
      lfree = (struct mem *)&ram[ptr2];
  8041cd:	8d 14 18             	lea    (%eax,%ebx,1),%edx
  8041d0:	89 15 04 53 81 00    	mov    %edx,0x815304
  8041d6:	eb 8c                	jmp    804164 <mem_realloc+0x9e>
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
  8041d8:	8d 53 18             	lea    0x18(%ebx),%edx
  8041db:	39 f2                	cmp    %esi,%edx
  8041dd:	77 a5                	ja     804184 <mem_realloc+0xbe>
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  8041df:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8041e2:	8d 4c 0b 0c          	lea    0xc(%ebx,%ecx,1),%ecx
    mem2 = (struct mem *)&ram[ptr2];
  8041e6:	8d 14 08             	lea    (%eax,%ecx,1),%edx
    if (mem2 < lfree) {
  8041e9:	39 15 04 53 81 00    	cmp    %edx,0x815304
  8041ef:	76 06                	jbe    8041f7 <mem_realloc+0x131>
      lfree = mem2;
  8041f1:	89 15 04 53 81 00    	mov    %edx,0x815304
    mem2->used = 0;
  8041f7:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    mem2->next = mem->next;
  8041fb:	8b 5f f4             	mov    -0xc(%edi),%ebx
  8041fe:	89 1a                	mov    %ebx,(%edx)
    mem2->prev = ptr;
  804200:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  804203:	89 72 04             	mov    %esi,0x4(%edx)
    mem->next = ptr2;
  804206:	89 4f f4             	mov    %ecx,-0xc(%edi)
    if (mem2->next != MEM_SIZE_ALIGNED) {
  804209:	8b 12                	mov    (%edx),%edx
  80420b:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  804211:	0f 84 6d ff ff ff    	je     804184 <mem_realloc+0xbe>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  804217:	89 4c 10 04          	mov    %ecx,0x4(%eax,%edx,1)
  80421b:	e9 64 ff ff ff       	jmp    804184 <mem_realloc+0xbe>

00804220 <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
  804220:	55                   	push   %ebp
  804221:	89 e5                	mov    %esp,%ebp
  804223:	57                   	push   %edi
  804224:	56                   	push   %esi
  804225:	53                   	push   %ebx
  804226:	83 ec 1c             	sub    $0x1c,%esp
  804229:	8b 45 08             	mov    0x8(%ebp),%eax
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
  80422c:	85 c0                	test   %eax,%eax
  80422e:	0f 84 a7 01 00 00    	je     8043db <mem_malloc+0x1bb>
    return NULL;
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
  804234:	83 c0 03             	add    $0x3,%eax
  804237:	83 e0 fc             	and    $0xfffffffc,%eax
  80423a:	89 c7                	mov    %eax,%edi

  if(size < MIN_SIZE_ALIGNED) {
  80423c:	83 f8 0b             	cmp    $0xb,%eax
  80423f:	76 37                	jbe    804278 <mem_malloc+0x58>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  }

  if (size > MEM_SIZE_ALIGNED) {
  804241:	3d 00 00 22 00       	cmp    $0x220000,%eax
  804246:	0f 87 96 01 00 00    	ja     8043e2 <mem_malloc+0x1c2>
    return NULL;
  }

  /* protect the heap from concurrent access */
  sys_arch_sem_wait(mem_sem, 0);
  80424c:	83 ec 08             	sub    $0x8,%esp
  80424f:	6a 00                	push   $0x0
  804251:	ff 35 00 53 81 00    	pushl  0x815300
  804257:	e8 38 5f 00 00       	call   80a194 <sys_arch_sem_wait>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  80425c:	8b 35 0c 53 81 00    	mov    0x81530c,%esi
  804262:	a1 04 53 81 00       	mov    0x815304,%eax
  804267:	29 f0                	sub    %esi,%eax
  804269:	83 c4 10             	add    $0x10,%esp
  80426c:	b9 00 00 22 00       	mov    $0x220000,%ecx
  804271:	29 f9                	sub    %edi,%ecx
  804273:	e9 ec 00 00 00       	jmp    804364 <mem_malloc+0x144>
    size = MIN_SIZE_ALIGNED;
  804278:	bf 0c 00 00 00       	mov    $0xc,%edi
  80427d:	eb cd                	jmp    80424c <mem_malloc+0x2c>
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
  80427f:	c6 43 08 01          	movb   $0x1,0x8(%ebx)
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
  804283:	a1 04 53 81 00       	mov    0x815304,%eax
  804288:	39 d8                	cmp    %ebx,%eax
  80428a:	74 4c                	je     8042d8 <mem_malloc+0xb8>
            lfree = (struct mem *)&ram[lfree->next];
          }
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_sem_signal(mem_sem);
  80428c:	83 ec 0c             	sub    $0xc,%esp
  80428f:	ff 35 00 53 81 00    	pushl  0x815300
  804295:	e8 8a 5e 00 00       	call   80a124 <sys_sem_signal>
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
  80429a:	8d 44 3b 0c          	lea    0xc(%ebx,%edi,1),%eax
  80429e:	83 c4 10             	add    $0x10,%esp
  8042a1:	39 05 08 53 81 00    	cmp    %eax,0x815308
  8042a7:	0f 82 87 00 00 00    	jb     804334 <mem_malloc+0x114>
         (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
  8042ad:	8d 43 0c             	lea    0xc(%ebx),%eax
  8042b0:	a8 03                	test   $0x3,%al
  8042b2:	0f 85 93 00 00 00    	jne    80434b <mem_malloc+0x12b>
         (unsigned long)((u8_t *)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
  8042b8:	f6 c3 03             	test   $0x3,%bl
  8042bb:	0f 84 12 01 00 00    	je     8043d3 <mem_malloc+0x1b3>
  8042c1:	83 ec 04             	sub    $0x4,%esp
  8042c4:	68 64 18 81 00       	push   $0x811864
  8042c9:	68 4f 02 00 00       	push   $0x24f
  8042ce:	68 87 18 81 00       	push   $0x811887
  8042d3:	e8 7b a3 00 00       	call   80e653 <_panic>
          while (lfree->used && lfree != ram_end) {
  8042d8:	8b 15 08 53 81 00    	mov    0x815308,%edx
            lfree = (struct mem *)&ram[lfree->next];
  8042de:	8b 35 0c 53 81 00    	mov    0x81530c,%esi
  8042e4:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  8042e8:	b9 01 00 00 00       	mov    $0x1,%ecx
  8042ed:	89 5d e0             	mov    %ebx,-0x20(%ebp)
  8042f0:	eb 09                	jmp    8042fb <mem_malloc+0xdb>
  8042f2:	89 f3                	mov    %esi,%ebx
  8042f4:	03 18                	add    (%eax),%ebx
  8042f6:	89 d8                	mov    %ebx,%eax
  8042f8:	88 4d e4             	mov    %cl,-0x1c(%ebp)
          while (lfree->used && lfree != ram_end) {
  8042fb:	80 78 08 00          	cmpb   $0x0,0x8(%eax)
  8042ff:	74 1c                	je     80431d <mem_malloc+0xfd>
  804301:	39 c2                	cmp    %eax,%edx
  804303:	75 ed                	jne    8042f2 <mem_malloc+0xd2>
  804305:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  804308:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
  80430c:	0f 84 7a ff ff ff    	je     80428c <mem_malloc+0x6c>
  804312:	89 15 04 53 81 00    	mov    %edx,0x815304
  804318:	e9 6f ff ff ff       	jmp    80428c <mem_malloc+0x6c>
  80431d:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  804320:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
  804324:	0f 84 62 ff ff ff    	je     80428c <mem_malloc+0x6c>
  80432a:	a3 04 53 81 00       	mov    %eax,0x815304
  80432f:	e9 58 ff ff ff       	jmp    80428c <mem_malloc+0x6c>
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
  804334:	83 ec 04             	sub    $0x4,%esp
  804337:	68 04 18 81 00       	push   $0x811804
  80433c:	68 4b 02 00 00       	push   $0x24b
  804341:	68 87 18 81 00       	push   $0x811887
  804346:	e8 08 a3 00 00       	call   80e653 <_panic>
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
  80434b:	83 ec 04             	sub    $0x4,%esp
  80434e:	68 34 18 81 00       	push   $0x811834
  804353:	68 4d 02 00 00       	push   $0x24d
  804358:	68 87 18 81 00       	push   $0x811887
  80435d:	e8 f1 a2 00 00       	call   80e653 <_panic>
         ptr = ((struct mem *)&ram[ptr])->next) {
  804362:	8b 03                	mov    (%ebx),%eax
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  804364:	39 c1                	cmp    %eax,%ecx
  804366:	76 55                	jbe    8043bd <mem_malloc+0x19d>
      mem = (struct mem *)&ram[ptr];
  804368:	8d 1c 06             	lea    (%esi,%eax,1),%ebx
      if ((!mem->used) &&
  80436b:	80 7b 08 00          	cmpb   $0x0,0x8(%ebx)
  80436f:	75 f1                	jne    804362 <mem_malloc+0x142>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
  804371:	ba f4 ff ff ff       	mov    $0xfffffff4,%edx
  804376:	29 c2                	sub    %eax,%edx
  804378:	03 13                	add    (%ebx),%edx
      if ((!mem->used) &&
  80437a:	39 fa                	cmp    %edi,%edx
  80437c:	72 e4                	jb     804362 <mem_malloc+0x142>
        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
  80437e:	8d 4f 18             	lea    0x18(%edi),%ecx
  804381:	39 ca                	cmp    %ecx,%edx
  804383:	0f 82 f6 fe ff ff    	jb     80427f <mem_malloc+0x5f>
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
  804389:	8d 4c 38 0c          	lea    0xc(%eax,%edi,1),%ecx
          mem2 = (struct mem *)&ram[ptr2];
  80438d:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  804390:	8d 14 0e             	lea    (%esi,%ecx,1),%edx
          mem2->used = 0;
  804393:	c6 42 08 00          	movb   $0x0,0x8(%edx)
          mem2->next = mem->next;
  804397:	8b 0b                	mov    (%ebx),%ecx
  804399:	89 0a                	mov    %ecx,(%edx)
          mem2->prev = ptr;
  80439b:	89 42 04             	mov    %eax,0x4(%edx)
          mem->next = ptr2;
  80439e:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8043a1:	89 0b                	mov    %ecx,(%ebx)
          mem->used = 1;
  8043a3:	c6 43 08 01          	movb   $0x1,0x8(%ebx)
          if (mem2->next != MEM_SIZE_ALIGNED) {
  8043a7:	8b 02                	mov    (%edx),%eax
  8043a9:	3d 00 00 22 00       	cmp    $0x220000,%eax
  8043ae:	0f 84 cf fe ff ff    	je     804283 <mem_malloc+0x63>
            ((struct mem *)&ram[mem2->next])->prev = ptr2;
  8043b4:	89 4c 06 04          	mov    %ecx,0x4(%esi,%eax,1)
  8043b8:	e9 c6 fe ff ff       	jmp    804283 <mem_malloc+0x63>
  } while(local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  8043bd:	83 ec 0c             	sub    $0xc,%esp
  8043c0:	ff 35 00 53 81 00    	pushl  0x815300
  8043c6:	e8 59 5d 00 00       	call   80a124 <sys_sem_signal>
  return NULL;
  8043cb:	83 c4 10             	add    $0x10,%esp
  8043ce:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8043d3:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8043d6:	5b                   	pop    %ebx
  8043d7:	5e                   	pop    %esi
  8043d8:	5f                   	pop    %edi
  8043d9:	5d                   	pop    %ebp
  8043da:	c3                   	ret    
    return NULL;
  8043db:	b8 00 00 00 00       	mov    $0x0,%eax
  8043e0:	eb f1                	jmp    8043d3 <mem_malloc+0x1b3>
    return NULL;
  8043e2:	b8 00 00 00 00       	mov    $0x0,%eax
  8043e7:	eb ea                	jmp    8043d3 <mem_malloc+0x1b3>

008043e9 <mem_calloc>:
 * @param count number of objects to allocate
 * @param size size of the objects to allocate
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *mem_calloc(mem_size_t count, mem_size_t size)
{
  8043e9:	55                   	push   %ebp
  8043ea:	89 e5                	mov    %esp,%ebp
  8043ec:	56                   	push   %esi
  8043ed:	53                   	push   %ebx
  void *p;

  /* allocate 'count' objects of size 'size' */
  p = mem_malloc(count * size);
  8043ee:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  8043f1:	0f af 5d 08          	imul   0x8(%ebp),%ebx
  8043f5:	83 ec 0c             	sub    $0xc,%esp
  8043f8:	53                   	push   %ebx
  8043f9:	e8 22 fe ff ff       	call   804220 <mem_malloc>
  8043fe:	89 c6                	mov    %eax,%esi
  if (p) {
  804400:	83 c4 10             	add    $0x10,%esp
  804403:	85 c0                	test   %eax,%eax
  804405:	74 0f                	je     804416 <mem_calloc+0x2d>
    /* zero the memory */
    memset(p, 0, count * size);
  804407:	83 ec 04             	sub    $0x4,%esp
  80440a:	53                   	push   %ebx
  80440b:	6a 00                	push   $0x0
  80440d:	50                   	push   %eax
  80440e:	e8 f9 aa 00 00       	call   80ef0c <memset>
  804413:	83 c4 10             	add    $0x10,%esp
  }
  return p;
}
  804416:	89 f0                	mov    %esi,%eax
  804418:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80441b:	5b                   	pop    %ebx
  80441c:	5e                   	pop    %esi
  80441d:	5d                   	pop    %ebp
  80441e:	c3                   	ret    

0080441f <memp_init>:
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
  80441f:	55                   	push   %ebp
  804420:	89 e5                	mov    %esp,%ebp
  804422:	57                   	push   %edi
  804423:	56                   	push   %esi
  804424:	53                   	push   %ebx
  804425:	83 ec 04             	sub    $0x4,%esp
    MEMP_STATS_AVAIL(max, i, 0);
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  804428:	b8 43 53 a3 00       	mov    $0xa35343,%eax
  80442d:	83 e0 fc             	and    $0xfffffffc,%eax
  804430:	c7 45 f0 c0 43 b3 00 	movl   $0xb343c0,-0x10(%ebp)
  804437:	be 00 00 00 00       	mov    $0x0,%esi
  80443c:	eb 29                	jmp    804467 <memp_init+0x48>
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
      memp->next = memp_tab[i];
  80443e:	8b 19                	mov    (%ecx),%ebx
  804440:	89 18                	mov    %ebx,(%eax)
      memp_tab[i] = memp;
  804442:	89 01                	mov    %eax,(%ecx)
      memp = (struct memp *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]);
  804444:	0f b7 9e a4 19 81 00 	movzwl 0x8119a4(%esi),%ebx
  80444b:	01 d8                	add    %ebx,%eax
    for (j = 0; j < memp_num[i]; ++j) {
  80444d:	83 c2 01             	add    $0x1,%edx
  804450:	66 39 d7             	cmp    %dx,%di
  804453:	75 e9                	jne    80443e <memp_init+0x1f>
  804455:	83 45 f0 04          	addl   $0x4,-0x10(%ebp)
  804459:	8b 7d f0             	mov    -0x10(%ebp),%edi
  80445c:	83 c6 02             	add    $0x2,%esi
  for (i = 0; i < MEMP_MAX; ++i) {
  80445f:	81 ff f8 43 b3 00    	cmp    $0xb343f8,%edi
  804465:	74 19                	je     804480 <memp_init+0x61>
  804467:	8b 55 f0             	mov    -0x10(%ebp),%edx
  80446a:	89 d1                	mov    %edx,%ecx
    memp_tab[i] = NULL;
  80446c:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
    for (j = 0; j < memp_num[i]; ++j) {
  804472:	0f b7 be 88 19 81 00 	movzwl 0x811988(%esi),%edi
  804479:	ba 00 00 00 00       	mov    $0x0,%edx
  80447e:	eb d0                	jmp    804450 <memp_init+0x31>
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
  804480:	83 c4 04             	add    $0x4,%esp
  804483:	5b                   	pop    %ebx
  804484:	5e                   	pop    %esi
  804485:	5f                   	pop    %edi
  804486:	5d                   	pop    %ebp
  804487:	c3                   	ret    

00804488 <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char* file, const int line)
#endif
{
  804488:	55                   	push   %ebp
  804489:	89 e5                	mov    %esp,%ebp
  80448b:	83 ec 08             	sub    $0x8,%esp
  80448e:	8b 55 08             	mov    0x8(%ebp),%edx
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
  804491:	83 fa 0d             	cmp    $0xd,%edx
  804494:	77 1a                	ja     8044b0 <memp_malloc+0x28>
  SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
  804496:	8b 04 95 c0 43 b3 00 	mov    0xb343c0(,%edx,4),%eax
  
  if (memp != NULL) {    
  80449d:	85 c0                	test   %eax,%eax
  80449f:	74 0d                	je     8044ae <memp_malloc+0x26>
    memp_tab[type] = memp->next;    
  8044a1:	8b 08                	mov    (%eax),%ecx
  8044a3:	89 0c 95 c0 43 b3 00 	mov    %ecx,0xb343c0(,%edx,4)
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
    LWIP_ASSERT("memp_malloc: memp properly aligned",
  8044aa:	a8 03                	test   $0x3,%al
  8044ac:	75 19                	jne    8044c7 <memp_malloc+0x3f>
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
}
  8044ae:	c9                   	leave  
  8044af:	c3                   	ret    
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
  8044b0:	83 ec 04             	sub    $0x4,%esp
  8044b3:	68 11 19 81 00       	push   $0x811911
  8044b8:	68 2d 01 00 00       	push   $0x12d
  8044bd:	68 2e 19 81 00       	push   $0x81192e
  8044c2:	e8 8c a1 00 00       	call   80e653 <_panic>
    LWIP_ASSERT("memp_malloc: memp properly aligned",
  8044c7:	83 ec 04             	sub    $0x4,%esp
  8044ca:	68 44 19 81 00       	push   $0x811944
  8044cf:	68 3f 01 00 00       	push   $0x13f
  8044d4:	68 2e 19 81 00       	push   $0x81192e
  8044d9:	e8 75 a1 00 00       	call   80e653 <_panic>

008044de <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
  8044de:	55                   	push   %ebp
  8044df:	89 e5                	mov    %esp,%ebp
  8044e1:	83 ec 08             	sub    $0x8,%esp
  8044e4:	8b 55 08             	mov    0x8(%ebp),%edx
  8044e7:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
  8044ea:	85 c0                	test   %eax,%eax
  8044ec:	74 14                	je     804502 <memp_free+0x24>
    return;
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
  8044ee:	a8 03                	test   $0x3,%al
  8044f0:	75 12                	jne    804504 <memp_free+0x26>
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
  
  memp->next = memp_tab[type]; 
  8044f2:	8b 0c 95 c0 43 b3 00 	mov    0xb343c0(,%edx,4),%ecx
  8044f9:	89 08                	mov    %ecx,(%eax)
  memp_tab[type] = memp;
  8044fb:	89 04 95 c0 43 b3 00 	mov    %eax,0xb343c0(,%edx,4)
#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
  804502:	c9                   	leave  
  804503:	c3                   	ret    
  LWIP_ASSERT("memp_free: mem properly aligned",
  804504:	83 ec 04             	sub    $0x4,%esp
  804507:	68 68 19 81 00       	push   $0x811968
  80450c:	68 5b 01 00 00       	push   $0x15b
  804511:	68 2e 19 81 00       	push   $0x81192e
  804516:	e8 38 a1 00 00       	call   80e653 <_panic>

0080451b <netif_remove>:
 * Remove a network interface from the list of lwIP netifs.
 *
 * @param netif the network interface to remove
 */
void netif_remove(struct netif * netif)
{
  80451b:	55                   	push   %ebp
  80451c:	89 e5                	mov    %esp,%ebp
  80451e:	8b 4d 08             	mov    0x8(%ebp),%ecx
  if ( netif == NULL ) return;
  804521:	85 c9                	test   %ecx,%ecx
  804523:	74 2c                	je     804551 <netif_remove+0x36>
#endif /* LWIP_IGMP */

  snmp_delete_ipaddridx_tree(netif);

  /*  is it the first netif? */
  if (netif_list == netif) {
  804525:	a1 34 b2 b3 00       	mov    0xb3b234,%eax
  80452a:	39 c8                	cmp    %ecx,%eax
  80452c:	74 0e                	je     80453c <netif_remove+0x21>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  80452e:	85 c0                	test   %eax,%eax
  804530:	74 1f                	je     804551 <netif_remove+0x36>
      if (tmpNetif->next == netif) {
  804532:	8b 10                	mov    (%eax),%edx
  804534:	39 ca                	cmp    %ecx,%edx
  804536:	74 0d                	je     804545 <netif_remove+0x2a>
  804538:	89 d0                	mov    %edx,%eax
  80453a:	eb f2                	jmp    80452e <netif_remove+0x13>
    netif_list = netif->next;
  80453c:	8b 01                	mov    (%ecx),%eax
  80453e:	a3 34 b2 b3 00       	mov    %eax,0xb3b234
  804543:	eb 04                	jmp    804549 <netif_remove+0x2e>
        tmpNetif->next = netif->next;
  804545:	8b 12                	mov    (%edx),%edx
  804547:	89 10                	mov    %edx,(%eax)
    }
    if (tmpNetif == NULL)
      return; /*  we didn't find any netif today */
  }
  /* this netif is default? */
  if (netif_default == netif)
  804549:	39 0d 38 b2 b3 00    	cmp    %ecx,0xb3b238
  80454f:	74 02                	je     804553 <netif_remove+0x38>
    /* reset default netif */
    netif_set_default(NULL);
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
  804551:	5d                   	pop    %ebp
  804552:	c3                   	ret    
  else
  {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
  804553:	c7 05 38 b2 b3 00 00 	movl   $0x0,0xb3b238
  80455a:	00 00 00 
  80455d:	eb f2                	jmp    804551 <netif_remove+0x36>

0080455f <netif_find>:
{
  80455f:	55                   	push   %ebp
  804560:	89 e5                	mov    %esp,%ebp
  804562:	53                   	push   %ebx
  804563:	8b 4d 08             	mov    0x8(%ebp),%ecx
  if (name == NULL) {
  804566:	85 c9                	test   %ecx,%ecx
  804568:	74 2d                	je     804597 <netif_find+0x38>
  num = name[2] - '0';
  80456a:	0f b6 41 02          	movzbl 0x2(%ecx),%eax
  80456e:	8d 50 d0             	lea    -0x30(%eax),%edx
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  804571:	a1 34 b2 b3 00       	mov    0xb3b234,%eax
  804576:	eb 02                	jmp    80457a <netif_find+0x1b>
  804578:	8b 00                	mov    (%eax),%eax
  80457a:	85 c0                	test   %eax,%eax
  80457c:	74 16                	je     804594 <netif_find+0x35>
    if (num == netif->num &&
  80457e:	38 50 31             	cmp    %dl,0x31(%eax)
  804581:	75 f5                	jne    804578 <netif_find+0x19>
  804583:	0f b6 58 2f          	movzbl 0x2f(%eax),%ebx
  804587:	38 19                	cmp    %bl,(%ecx)
  804589:	75 ed                	jne    804578 <netif_find+0x19>
       name[0] == netif->name[0] &&
  80458b:	0f b6 58 30          	movzbl 0x30(%eax),%ebx
  80458f:	38 59 01             	cmp    %bl,0x1(%ecx)
  804592:	75 e4                	jne    804578 <netif_find+0x19>
}
  804594:	5b                   	pop    %ebx
  804595:	5d                   	pop    %ebp
  804596:	c3                   	ret    
    return NULL;
  804597:	b8 00 00 00 00       	mov    $0x0,%eax
  80459c:	eb f6                	jmp    804594 <netif_find+0x35>

0080459e <netif_set_ipaddr>:
{
  80459e:	55                   	push   %ebp
  80459f:	89 e5                	mov    %esp,%ebp
  8045a1:	57                   	push   %edi
  8045a2:	56                   	push   %esi
  8045a3:	53                   	push   %ebx
  8045a4:	83 ec 0c             	sub    $0xc,%esp
  8045a7:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8045aa:	8b 75 0c             	mov    0xc(%ebp),%esi
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  8045ad:	8b 43 04             	mov    0x4(%ebx),%eax
  8045b0:	39 06                	cmp    %eax,(%esi)
  8045b2:	74 56                	je     80460a <netif_set_ipaddr+0x6c>
    pcb = tcp_active_pcbs;
  8045b4:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
    while (pcb != NULL) {
  8045b9:	eb 11                	jmp    8045cc <netif_set_ipaddr+0x2e>
        struct tcp_pcb *next = pcb->next;
  8045bb:	8b 78 0c             	mov    0xc(%eax),%edi
        tcp_abort(pcb);
  8045be:	83 ec 0c             	sub    $0xc,%esp
  8045c1:	50                   	push   %eax
  8045c2:	e8 57 16 00 00       	call   805c1e <tcp_abort>
  8045c7:	83 c4 10             	add    $0x10,%esp
        pcb = next;
  8045ca:	89 f8                	mov    %edi,%eax
    while (pcb != NULL) {
  8045cc:	85 c0                	test   %eax,%eax
  8045ce:	74 0c                	je     8045dc <netif_set_ipaddr+0x3e>
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  8045d0:	8b 4b 04             	mov    0x4(%ebx),%ecx
  8045d3:	39 08                	cmp    %ecx,(%eax)
  8045d5:	74 e4                	je     8045bb <netif_set_ipaddr+0x1d>
        pcb = pcb->next;
  8045d7:	8b 40 0c             	mov    0xc(%eax),%eax
  8045da:	eb f0                	jmp    8045cc <netif_set_ipaddr+0x2e>
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  8045dc:	a1 44 b2 b3 00       	mov    0xb3b244,%eax
        ip_addr_set(&(lpcb->local_ip), ipaddr);
  8045e1:	b9 00 00 00 00       	mov    $0x0,%ecx
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  8045e6:	eb 05                	jmp    8045ed <netif_set_ipaddr+0x4f>
        ip_addr_set(&(lpcb->local_ip), ipaddr);
  8045e8:	89 10                	mov    %edx,(%eax)
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  8045ea:	8b 40 0c             	mov    0xc(%eax),%eax
  8045ed:	85 c0                	test   %eax,%eax
  8045ef:	74 19                	je     80460a <netif_set_ipaddr+0x6c>
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
  8045f1:	85 c0                	test   %eax,%eax
  8045f3:	74 f5                	je     8045ea <netif_set_ipaddr+0x4c>
  8045f5:	8b 10                	mov    (%eax),%edx
  8045f7:	85 d2                	test   %edx,%edx
  8045f9:	74 ef                	je     8045ea <netif_set_ipaddr+0x4c>
  8045fb:	3b 53 04             	cmp    0x4(%ebx),%edx
  8045fe:	75 ea                	jne    8045ea <netif_set_ipaddr+0x4c>
        ip_addr_set(&(lpcb->local_ip), ipaddr);
  804600:	89 ca                	mov    %ecx,%edx
  804602:	85 f6                	test   %esi,%esi
  804604:	74 e2                	je     8045e8 <netif_set_ipaddr+0x4a>
  804606:	8b 16                	mov    (%esi),%edx
  804608:	eb de                	jmp    8045e8 <netif_set_ipaddr+0x4a>
  ip_addr_set(&(netif->ip_addr), ipaddr);
  80460a:	b8 00 00 00 00       	mov    $0x0,%eax
  80460f:	85 f6                	test   %esi,%esi
  804611:	74 02                	je     804615 <netif_set_ipaddr+0x77>
  804613:	8b 06                	mov    (%esi),%eax
  804615:	89 43 04             	mov    %eax,0x4(%ebx)
}
  804618:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80461b:	5b                   	pop    %ebx
  80461c:	5e                   	pop    %esi
  80461d:	5f                   	pop    %edi
  80461e:	5d                   	pop    %ebp
  80461f:	c3                   	ret    

00804620 <netif_set_addr>:
{
  804620:	55                   	push   %ebp
  804621:	89 e5                	mov    %esp,%ebp
  804623:	57                   	push   %edi
  804624:	56                   	push   %esi
  804625:	53                   	push   %ebx
  804626:	83 ec 14             	sub    $0x14,%esp
  804629:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80462c:	8b 7d 10             	mov    0x10(%ebp),%edi
  80462f:	8b 75 14             	mov    0x14(%ebp),%esi
  netif_set_ipaddr(netif, ipaddr);
  804632:	ff 75 0c             	pushl  0xc(%ebp)
  804635:	53                   	push   %ebx
  804636:	e8 63 ff ff ff       	call   80459e <netif_set_ipaddr>
  ip_addr_set(&(netif->netmask), netmask);
  80463b:	83 c4 10             	add    $0x10,%esp
  80463e:	b8 00 00 00 00       	mov    $0x0,%eax
  804643:	85 ff                	test   %edi,%edi
  804645:	74 02                	je     804649 <netif_set_addr+0x29>
  804647:	8b 07                	mov    (%edi),%eax
  804649:	89 43 08             	mov    %eax,0x8(%ebx)
  ip_addr_set(&(netif->gw), gw);
  80464c:	b8 00 00 00 00       	mov    $0x0,%eax
  804651:	85 f6                	test   %esi,%esi
  804653:	74 02                	je     804657 <netif_set_addr+0x37>
  804655:	8b 06                	mov    (%esi),%eax
  804657:	89 43 0c             	mov    %eax,0xc(%ebx)
}
  80465a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80465d:	5b                   	pop    %ebx
  80465e:	5e                   	pop    %esi
  80465f:	5f                   	pop    %edi
  804660:	5d                   	pop    %ebp
  804661:	c3                   	ret    

00804662 <netif_add>:
{
  804662:	55                   	push   %ebp
  804663:	89 e5                	mov    %esp,%ebp
  804665:	53                   	push   %ebx
  804666:	83 ec 04             	sub    $0x4,%esp
  804669:	8b 5d 08             	mov    0x8(%ebp),%ebx
  netif->ip_addr.addr = 0;
  80466c:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  netif->netmask.addr = 0;
  804673:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netif->gw.addr = 0;
  80467a:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  netif->flags = 0;
  804681:	c6 43 2e 00          	movb   $0x0,0x2e(%ebx)
  netif->dhcp = NULL;
  804685:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
  netif->state = state;
  80468c:	8b 45 18             	mov    0x18(%ebp),%eax
  80468f:	89 43 1c             	mov    %eax,0x1c(%ebx)
  netif->num = netifnum++;
  804692:	0f b6 05 f8 43 b3 00 	movzbl 0xb343f8,%eax
  804699:	8d 50 01             	lea    0x1(%eax),%edx
  80469c:	88 15 f8 43 b3 00    	mov    %dl,0xb343f8
  8046a2:	88 43 31             	mov    %al,0x31(%ebx)
  netif->input = input;
  8046a5:	8b 45 20             	mov    0x20(%ebp),%eax
  8046a8:	89 43 10             	mov    %eax,0x10(%ebx)
  netif_set_addr(netif, ipaddr, netmask, gw);
  8046ab:	ff 75 14             	pushl  0x14(%ebp)
  8046ae:	ff 75 10             	pushl  0x10(%ebp)
  8046b1:	ff 75 0c             	pushl  0xc(%ebp)
  8046b4:	53                   	push   %ebx
  8046b5:	e8 66 ff ff ff       	call   804620 <netif_set_addr>
  if (init(netif) != ERR_OK) {
  8046ba:	89 1c 24             	mov    %ebx,(%esp)
  8046bd:	ff 55 1c             	call   *0x1c(%ebp)
  8046c0:	83 c4 10             	add    $0x10,%esp
  8046c3:	84 c0                	test   %al,%al
  8046c5:	75 14                	jne    8046db <netif_add+0x79>
  netif->next = netif_list;
  8046c7:	a1 34 b2 b3 00       	mov    0xb3b234,%eax
  8046cc:	89 03                	mov    %eax,(%ebx)
  netif_list = netif;
  8046ce:	89 1d 34 b2 b3 00    	mov    %ebx,0xb3b234
  return netif;
  8046d4:	89 d8                	mov    %ebx,%eax
}
  8046d6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8046d9:	c9                   	leave  
  8046da:	c3                   	ret    
    return NULL;
  8046db:	b8 00 00 00 00       	mov    $0x0,%eax
  8046e0:	eb f4                	jmp    8046d6 <netif_add+0x74>

008046e2 <netif_set_gw>:
{
  8046e2:	55                   	push   %ebp
  8046e3:	89 e5                	mov    %esp,%ebp
  8046e5:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&(netif->gw), gw);
  8046e8:	b8 00 00 00 00       	mov    $0x0,%eax
  8046ed:	85 d2                	test   %edx,%edx
  8046ef:	74 02                	je     8046f3 <netif_set_gw+0x11>
  8046f1:	8b 02                	mov    (%edx),%eax
  8046f3:	8b 55 08             	mov    0x8(%ebp),%edx
  8046f6:	89 42 0c             	mov    %eax,0xc(%edx)
}
  8046f9:	5d                   	pop    %ebp
  8046fa:	c3                   	ret    

008046fb <netif_set_netmask>:
{
  8046fb:	55                   	push   %ebp
  8046fc:	89 e5                	mov    %esp,%ebp
  8046fe:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&(netif->netmask), netmask);
  804701:	b8 00 00 00 00       	mov    $0x0,%eax
  804706:	85 d2                	test   %edx,%edx
  804708:	74 02                	je     80470c <netif_set_netmask+0x11>
  80470a:	8b 02                	mov    (%edx),%eax
  80470c:	8b 55 08             	mov    0x8(%ebp),%edx
  80470f:	89 42 08             	mov    %eax,0x8(%edx)
}
  804712:	5d                   	pop    %ebp
  804713:	c3                   	ret    

00804714 <netif_set_default>:
{
  804714:	55                   	push   %ebp
  804715:	89 e5                	mov    %esp,%ebp
  netif_default = netif;
  804717:	8b 45 08             	mov    0x8(%ebp),%eax
  80471a:	a3 38 b2 b3 00       	mov    %eax,0xb3b238
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
           netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
  80471f:	5d                   	pop    %ebp
  804720:	c3                   	ret    

00804721 <netif_set_up>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
  804721:	55                   	push   %ebp
  804722:	89 e5                	mov    %esp,%ebp
  804724:	83 ec 08             	sub    $0x8,%esp
  804727:	8b 55 08             	mov    0x8(%ebp),%edx
  if ( !(netif->flags & NETIF_FLAG_UP )) {
  80472a:	0f b6 42 2e          	movzbl 0x2e(%edx),%eax
  80472e:	a8 01                	test   $0x1,%al
  804730:	75 0c                	jne    80473e <netif_set_up+0x1d>
    netif->flags |= NETIF_FLAG_UP;
  804732:	89 c1                	mov    %eax,%ecx
  804734:	83 c9 01             	or     $0x1,%ecx
  804737:	88 4a 2e             	mov    %cl,0x2e(%edx)
    /** For Ethernet network interfaces, we would like to send a
     *  "gratuitous ARP"; this is an ARP packet sent by a node in order
     *  to spontaneously cause other nodes to update an entry in their
     *  ARP cache. From RFC 3220 "IP Mobility Support for IPv4" section 4.6.
     */ 
    if (netif->flags & NETIF_FLAG_ETHARP) {
  80473a:	a8 20                	test   $0x20,%al
  80473c:	75 02                	jne    804740 <netif_set_up+0x1f>
      etharp_query(netif, &(netif->ip_addr), NULL);
    }
#endif /* LWIP_ARP */
    
  }
}
  80473e:	c9                   	leave  
  80473f:	c3                   	ret    
      etharp_query(netif, &(netif->ip_addr), NULL);
  804740:	83 ec 04             	sub    $0x4,%esp
  804743:	6a 00                	push   $0x0
  804745:	8d 42 04             	lea    0x4(%edx),%eax
  804748:	50                   	push   %eax
  804749:	52                   	push   %edx
  80474a:	e8 4c 52 00 00       	call   80999b <etharp_query>
  80474f:	83 c4 10             	add    $0x10,%esp
}
  804752:	eb ea                	jmp    80473e <netif_set_up+0x1d>

00804754 <netif_set_down>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_down(struct netif *netif)
{
  804754:	55                   	push   %ebp
  804755:	89 e5                	mov    %esp,%ebp
  804757:	8b 55 08             	mov    0x8(%ebp),%edx
  if ( netif->flags & NETIF_FLAG_UP )
  80475a:	0f b6 42 2e          	movzbl 0x2e(%edx),%eax
  80475e:	a8 01                	test   $0x1,%al
  804760:	74 06                	je     804768 <netif_set_down+0x14>
    {
      netif->flags &= ~NETIF_FLAG_UP;
  804762:	83 e0 fe             	and    $0xfffffffe,%eax
  804765:	88 42 2e             	mov    %al,0x2e(%edx)
#endif
      
      NETIF_LINK_CALLBACK(netif);
      NETIF_STATUS_CALLBACK(netif);
    }
}
  804768:	5d                   	pop    %ebp
  804769:	c3                   	ret    

0080476a <netif_is_up>:

/**
 * Ask if an interface is up
 */ 
u8_t netif_is_up(struct netif *netif)
{
  80476a:	55                   	push   %ebp
  80476b:	89 e5                	mov    %esp,%ebp
  return (netif->flags & NETIF_FLAG_UP)?1:0;
  80476d:	8b 45 08             	mov    0x8(%ebp),%eax
  804770:	0f b6 40 2e          	movzbl 0x2e(%eax),%eax
  804774:	83 e0 01             	and    $0x1,%eax
}
  804777:	5d                   	pop    %ebp
  804778:	c3                   	ret    

00804779 <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
  804779:	55                   	push   %ebp
  80477a:	89 e5                	mov    %esp,%ebp
  80477c:	56                   	push   %esi
  80477d:	53                   	push   %ebx
  80477e:	8b 55 08             	mov    0x8(%ebp),%edx
  804781:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  804784:	85 d2                	test   %edx,%edx
  804786:	74 49                	je     8047d1 <pbuf_header+0x58>
  if ((header_size_increment == 0) || (p == NULL))
  804788:	66 85 c9             	test   %cx,%cx
  80478b:	0f 84 b0 00 00 00    	je     804841 <pbuf_header+0xc8>
  if (header_size_increment < 0){
    increment_magnitude = -header_size_increment;
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  } else {
    increment_magnitude = header_size_increment;
  804791:	89 ce                	mov    %ecx,%esi
  if (header_size_increment < 0){
  804793:	66 85 c9             	test   %cx,%cx
  804796:	78 50                	js     8047e8 <pbuf_header+0x6f>
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
  804798:	0f b6 42 0c          	movzbl 0xc(%edx),%eax
  /* remember current payload pointer */
  payload = p->payload;
  80479c:	8b 5a 04             	mov    0x4(%edx),%ebx

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
  80479f:	66 85 c0             	test   %ax,%ax
  8047a2:	74 63                	je     804807 <pbuf_header+0x8e>
  8047a4:	66 83 f8 03          	cmp    $0x3,%ax
  8047a8:	74 5d                	je     804807 <pbuf_header+0x8e>
      p->payload = payload;
      /* bail out unsuccesfully */
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
  8047aa:	83 e8 01             	sub    $0x1,%eax
  8047ad:	66 83 f8 01          	cmp    $0x1,%ax
  8047b1:	77 77                	ja     80482a <pbuf_header+0xb1>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
    } else {
      /* cannot expand payload to front (yet!)
       * bail out unsuccesfully */
      return 1;
  8047b3:	b8 01 00 00 00       	mov    $0x1,%eax
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
  8047b8:	66 85 c9             	test   %cx,%cx
  8047bb:	0f 89 85 00 00 00    	jns    804846 <pbuf_header+0xcd>
  8047c1:	66 39 72 0a          	cmp    %si,0xa(%edx)
  8047c5:	72 7f                	jb     804846 <pbuf_header+0xcd>
      p->payload = (u8_t *)p->payload - header_size_increment;
  8047c7:	0f bf c1             	movswl %cx,%eax
  8047ca:	29 c3                	sub    %eax,%ebx
  8047cc:	89 5a 04             	mov    %ebx,0x4(%edx)
  8047cf:	eb 4a                	jmp    80481b <pbuf_header+0xa2>
  LWIP_ASSERT("p != NULL", p != NULL);
  8047d1:	83 ec 04             	sub    $0x4,%esp
  8047d4:	68 84 1a 81 00       	push   $0x811a84
  8047d9:	68 64 01 00 00       	push   $0x164
  8047de:	68 c0 19 81 00       	push   $0x8119c0
  8047e3:	e8 6b 9e 00 00       	call   80e653 <_panic>
    increment_magnitude = -header_size_increment;
  8047e8:	f7 de                	neg    %esi
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  8047ea:	66 39 72 0a          	cmp    %si,0xa(%edx)
  8047ee:	73 a8                	jae    804798 <pbuf_header+0x1f>
  8047f0:	83 ec 04             	sub    $0x4,%esp
  8047f3:	68 d5 19 81 00       	push   $0x8119d5
  8047f8:	68 6b 01 00 00       	push   $0x16b
  8047fd:	68 c0 19 81 00       	push   $0x8119c0
  804802:	e8 4c 9e 00 00       	call   80e653 <_panic>
    p->payload = (u8_t *)p->payload - header_size_increment;
  804807:	0f bf c1             	movswl %cx,%eax
  80480a:	29 c3                	sub    %eax,%ebx
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  80480c:	8d 72 10             	lea    0x10(%edx),%esi
      return 1;
  80480f:	b8 01 00 00 00       	mov    $0x1,%eax
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  804814:	39 f3                	cmp    %esi,%ebx
  804816:	72 2e                	jb     804846 <pbuf_header+0xcd>
    p->payload = (u8_t *)p->payload - header_size_increment;
  804818:	89 5a 04             	mov    %ebx,0x4(%edx)
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
  80481b:	66 01 4a 0a          	add    %cx,0xa(%edx)
  p->tot_len += header_size_increment;
  80481f:	66 01 4a 08          	add    %cx,0x8(%edx)

  LWIP_DEBUGF(PBUF_DEBUG, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
  804823:	b8 00 00 00 00       	mov    $0x0,%eax
  804828:	eb 1c                	jmp    804846 <pbuf_header+0xcd>
    LWIP_ASSERT("bad pbuf type", 0);
  80482a:	83 ec 04             	sub    $0x4,%esp
  80482d:	68 f3 19 81 00       	push   $0x8119f3
  804832:	68 9a 01 00 00       	push   $0x19a
  804837:	68 c0 19 81 00       	push   $0x8119c0
  80483c:	e8 12 9e 00 00       	call   80e653 <_panic>
    return 0;
  804841:	b8 00 00 00 00       	mov    $0x0,%eax
}
  804846:	8d 65 f8             	lea    -0x8(%ebp),%esp
  804849:	5b                   	pop    %ebx
  80484a:	5e                   	pop    %esi
  80484b:	5d                   	pop    %ebp
  80484c:	c3                   	ret    

0080484d <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
  80484d:	55                   	push   %ebp
  80484e:	89 e5                	mov    %esp,%ebp
  804850:	56                   	push   %esi
  804851:	53                   	push   %ebx
  804852:	8b 45 08             	mov    0x8(%ebp),%eax
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
  804855:	85 c0                	test   %eax,%eax
  804857:	74 0d                	je     804866 <pbuf_free+0x19>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
  804859:	80 78 0c 03          	cmpb   $0x3,0xc(%eax)
  80485d:	77 1e                	ja     80487d <pbuf_free+0x30>
    p->type == PBUF_RAM || p->type == PBUF_ROM ||
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  80485f:	bb 00 00 00 00       	mov    $0x0,%ebx
  804864:	eb 6c                	jmp    8048d2 <pbuf_free+0x85>
    LWIP_ASSERT("p != NULL", p != NULL);
  804866:	83 ec 04             	sub    $0x4,%esp
  804869:	68 84 1a 81 00       	push   $0x811a84
  80486e:	68 d0 01 00 00       	push   $0x1d0
  804873:	68 c0 19 81 00       	push   $0x8119c0
  804878:	e8 d6 9d 00 00       	call   80e653 <_panic>
  LWIP_ASSERT("pbuf_free: sane type",
  80487d:	83 ec 04             	sub    $0x4,%esp
  804880:	68 01 1a 81 00       	push   $0x811a01
  804885:	68 db 01 00 00       	push   $0x1db
  80488a:	68 c0 19 81 00       	push   $0x8119c0
  80488f:	e8 bf 9d 00 00       	call   80e653 <_panic>
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
  804894:	83 ec 04             	sub    $0x4,%esp
  804897:	68 16 1a 81 00       	push   $0x811a16
  80489c:	68 e8 01 00 00       	push   $0x1e8
  8048a1:	68 c0 19 81 00       	push   $0x8119c0
  8048a6:	e8 a8 9d 00 00       	call   80e653 <_panic>
      q = p->next;
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
      /* is this a pbuf from the pool? */
      if (type == PBUF_POOL) {
        memp_free(MEMP_PBUF_POOL, p);
  8048ab:	83 ec 08             	sub    $0x8,%esp
  8048ae:	50                   	push   %eax
  8048af:	6a 0d                	push   $0xd
  8048b1:	e8 28 fc ff ff       	call   8044de <memp_free>
  8048b6:	83 c4 10             	add    $0x10,%esp
  8048b9:	eb 0e                	jmp    8048c9 <pbuf_free+0x7c>
      /* is this a ROM or RAM referencing pbuf? */
      } else if (type == PBUF_ROM || type == PBUF_REF) {
        memp_free(MEMP_PBUF, p);
  8048bb:	83 ec 08             	sub    $0x8,%esp
  8048be:	50                   	push   %eax
  8048bf:	6a 0c                	push   $0xc
  8048c1:	e8 18 fc ff ff       	call   8044de <memp_free>
  8048c6:	83 c4 10             	add    $0x10,%esp
      /* type == PBUF_RAM */
      } else {
        mem_free(p);
      }
      count++;
  8048c9:	83 c3 01             	add    $0x1,%ebx
      /* proceed to next pbuf */
      p = q;
  8048cc:	89 f0                	mov    %esi,%eax
  while (p != NULL) {
  8048ce:	85 f6                	test   %esi,%esi
  8048d0:	74 38                	je     80490a <pbuf_free+0xbd>
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
  8048d2:	0f b7 50 0e          	movzwl 0xe(%eax),%edx
  8048d6:	66 85 d2             	test   %dx,%dx
  8048d9:	74 b9                	je     804894 <pbuf_free+0x47>
    ref = --(p->ref);
  8048db:	83 ea 01             	sub    $0x1,%edx
  8048de:	66 89 50 0e          	mov    %dx,0xe(%eax)
    if (ref == 0) {
  8048e2:	66 85 d2             	test   %dx,%dx
  8048e5:	75 23                	jne    80490a <pbuf_free+0xbd>
      q = p->next;
  8048e7:	8b 30                	mov    (%eax),%esi
      type = p->type;
  8048e9:	0f b6 50 0c          	movzbl 0xc(%eax),%edx
      if (type == PBUF_POOL) {
  8048ed:	66 83 fa 03          	cmp    $0x3,%dx
  8048f1:	74 b8                	je     8048ab <pbuf_free+0x5e>
      } else if (type == PBUF_ROM || type == PBUF_REF) {
  8048f3:	83 ea 01             	sub    $0x1,%edx
  8048f6:	66 83 fa 01          	cmp    $0x1,%dx
  8048fa:	76 bf                	jbe    8048bb <pbuf_free+0x6e>
        mem_free(p);
  8048fc:	83 ec 0c             	sub    $0xc,%esp
  8048ff:	50                   	push   %eax
  804900:	e8 2a f6 ff ff       	call   803f2f <mem_free>
  804905:	83 c4 10             	add    $0x10,%esp
  804908:	eb bf                	jmp    8048c9 <pbuf_free+0x7c>
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
}
  80490a:	89 d8                	mov    %ebx,%eax
  80490c:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80490f:	5b                   	pop    %ebx
  804910:	5e                   	pop    %esi
  804911:	5d                   	pop    %ebp
  804912:	c3                   	ret    

00804913 <pbuf_alloc>:
{
  804913:	55                   	push   %ebp
  804914:	89 e5                	mov    %esp,%ebp
  804916:	57                   	push   %edi
  804917:	56                   	push   %esi
  804918:	53                   	push   %ebx
  804919:	83 ec 1c             	sub    $0x1c,%esp
  80491c:	8b 45 08             	mov    0x8(%ebp),%eax
  80491f:	8b 75 0c             	mov    0xc(%ebp),%esi
  switch (layer) {
  804922:	83 f8 01             	cmp    $0x1,%eax
  804925:	0f 84 95 00 00 00    	je     8049c0 <pbuf_alloc+0xad>
  80492b:	83 f8 01             	cmp    $0x1,%eax
  80492e:	72 19                	jb     804949 <pbuf_alloc+0x36>
  804930:	83 f8 02             	cmp    $0x2,%eax
  804933:	0f 84 8e 00 00 00    	je     8049c7 <pbuf_alloc+0xb4>
  804939:	83 f8 03             	cmp    $0x3,%eax
  80493c:	0f 85 8c 00 00 00    	jne    8049ce <pbuf_alloc+0xbb>
  offset = 0;
  804942:	bb 00 00 00 00       	mov    $0x0,%ebx
  804947:	eb 0b                	jmp    804954 <pbuf_alloc+0x41>
    offset += PBUF_TRANSPORT_HLEN;
  804949:	bb 14 00 00 00       	mov    $0x14,%ebx
    offset += PBUF_IP_HLEN;
  80494e:	83 c3 14             	add    $0x14,%ebx
    offset += PBUF_LINK_HLEN;
  804951:	83 c3 0e             	add    $0xe,%ebx
  switch (type) {
  804954:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
  804958:	0f 87 87 00 00 00    	ja     8049e5 <pbuf_alloc+0xd2>
  80495e:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
  804962:	0f 83 c7 01 00 00    	jae    804b2f <pbuf_alloc+0x21c>
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
  804968:	0f b7 db             	movzwl %bx,%ebx
  80496b:	83 ec 0c             	sub    $0xc,%esp
  80496e:	8d 43 13             	lea    0x13(%ebx),%eax
  804971:	83 e0 fc             	and    $0xfffffffc,%eax
  804974:	89 c2                	mov    %eax,%edx
  804976:	0f b7 c6             	movzwl %si,%eax
  804979:	83 c0 03             	add    $0x3,%eax
  80497c:	83 e0 fc             	and    $0xfffffffc,%eax
  80497f:	01 d0                	add    %edx,%eax
  804981:	50                   	push   %eax
  804982:	e8 99 f8 ff ff       	call   804220 <mem_malloc>
  804987:	89 c7                	mov    %eax,%edi
    if (p == NULL) {
  804989:	83 c4 10             	add    $0x10,%esp
  80498c:	85 c0                	test   %eax,%eax
  80498e:	74 26                	je     8049b6 <pbuf_alloc+0xa3>
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
  804990:	8d 44 18 13          	lea    0x13(%eax,%ebx,1),%eax
  804994:	83 e0 fc             	and    $0xfffffffc,%eax
  804997:	89 47 04             	mov    %eax,0x4(%edi)
    p->len = p->tot_len = length;
  80499a:	66 89 77 08          	mov    %si,0x8(%edi)
  80499e:	66 89 77 0a          	mov    %si,0xa(%edi)
    p->next = NULL;
  8049a2:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
    p->type = type;
  8049a8:	c6 47 0c 00          	movb   $0x0,0xc(%edi)
  p->ref = 1;
  8049ac:	66 c7 47 0e 01 00    	movw   $0x1,0xe(%edi)
  p->flags = 0;
  8049b2:	c6 47 0d 00          	movb   $0x0,0xd(%edi)
}
  8049b6:	89 f8                	mov    %edi,%eax
  8049b8:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8049bb:	5b                   	pop    %ebx
  8049bc:	5e                   	pop    %esi
  8049bd:	5f                   	pop    %edi
  8049be:	5d                   	pop    %ebp
  8049bf:	c3                   	ret    
  offset = 0;
  8049c0:	bb 00 00 00 00       	mov    $0x0,%ebx
  8049c5:	eb 87                	jmp    80494e <pbuf_alloc+0x3b>
  8049c7:	bb 00 00 00 00       	mov    $0x0,%ebx
  8049cc:	eb 83                	jmp    804951 <pbuf_alloc+0x3e>
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
  8049ce:	83 ec 04             	sub    $0x4,%esp
  8049d1:	68 2c 1a 81 00       	push   $0x811a2c
  8049d6:	68 8a 00 00 00       	push   $0x8a
  8049db:	68 c0 19 81 00       	push   $0x8119c0
  8049e0:	e8 6e 9c 00 00       	call   80e653 <_panic>
  switch (type) {
  8049e5:	83 7d 10 03          	cmpl   $0x3,0x10(%ebp)
  8049e9:	0f 85 78 01 00 00    	jne    804b67 <pbuf_alloc+0x254>
      p = memp_malloc(MEMP_PBUF_POOL);
  8049ef:	83 ec 0c             	sub    $0xc,%esp
  8049f2:	6a 0d                	push   $0xd
  8049f4:	e8 8f fa ff ff       	call   804488 <memp_malloc>
  8049f9:	89 c7                	mov    %eax,%edi
    if (p == NULL) {
  8049fb:	83 c4 10             	add    $0x10,%esp
  8049fe:	85 c0                	test   %eax,%eax
  804a00:	74 b4                	je     8049b6 <pbuf_alloc+0xa3>
    p->type = type;
  804a02:	c6 40 0c 03          	movb   $0x3,0xc(%eax)
    p->next = NULL;
  804a06:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
  804a0c:	0f b7 db             	movzwl %bx,%ebx
  804a0f:	8d 54 18 13          	lea    0x13(%eax,%ebx,1),%edx
  804a13:	83 e2 fc             	and    $0xfffffffc,%edx
  804a16:	89 50 04             	mov    %edx,0x4(%eax)
    p->tot_len = length;
  804a19:	66 89 70 08          	mov    %si,0x8(%eax)
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
  804a1d:	0f b7 f6             	movzwl %si,%esi
  804a20:	83 c3 03             	add    $0x3,%ebx
  804a23:	83 e3 fc             	and    $0xfffffffc,%ebx
  804a26:	b8 d0 07 00 00       	mov    $0x7d0,%eax
  804a2b:	29 d8                	sub    %ebx,%eax
  804a2d:	39 f0                	cmp    %esi,%eax
  804a2f:	0f 4f c6             	cmovg  %esi,%eax
  804a32:	66 89 47 0a          	mov    %ax,0xa(%edi)
  804a36:	0f b7 c0             	movzwl %ax,%eax
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  804a39:	8d 9f e0 07 00 00    	lea    0x7e0(%edi),%ebx
  804a3f:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  804a42:	01 c2                	add    %eax,%edx
  804a44:	39 d3                	cmp    %edx,%ebx
  804a46:	72 0c                	jb     804a54 <pbuf_alloc+0x141>
    p->ref = 1;
  804a48:	66 c7 47 0e 01 00    	movw   $0x1,0xe(%edi)
    rem_len = length - p->len;
  804a4e:	29 c6                	sub    %eax,%esi
    r = p;
  804a50:	89 fb                	mov    %edi,%ebx
    while (rem_len > 0) {
  804a52:	eb 67                	jmp    804abb <pbuf_alloc+0x1a8>
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  804a54:	83 ec 04             	sub    $0x4,%esp
  804a57:	68 44 1b 81 00       	push   $0x811b44
  804a5c:	68 a3 00 00 00       	push   $0xa3
  804a61:	68 c0 19 81 00       	push   $0x8119c0
  804a66:	e8 e8 9b 00 00       	call   80e653 <_panic>
  804a6b:	89 c3                	mov    %eax,%ebx
        pbuf_free(p);
  804a6d:	83 ec 0c             	sub    $0xc,%esp
  804a70:	57                   	push   %edi
  804a71:	e8 d7 fd ff ff       	call   80484d <pbuf_free>
        return NULL;
  804a76:	83 c4 10             	add    $0x10,%esp
  804a79:	89 df                	mov    %ebx,%edi
  804a7b:	e9 36 ff ff ff       	jmp    8049b6 <pbuf_alloc+0xa3>
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
  804a80:	83 ec 04             	sub    $0x4,%esp
  804a83:	68 47 1a 81 00       	push   $0x811a47
  804a88:	68 bc 00 00 00       	push   $0xbc
  804a8d:	68 c0 19 81 00       	push   $0x8119c0
  804a92:	e8 bc 9b 00 00       	call   80e653 <_panic>
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
  804a97:	83 ec 04             	sub    $0x4,%esp
  804a9a:	68 78 1b 81 00       	push   $0x811b78
  804a9f:	68 c2 00 00 00       	push   $0xc2
  804aa4:	68 c0 19 81 00       	push   $0x8119c0
  804aa9:	e8 a5 9b 00 00       	call   80e653 <_panic>
      q->ref = 1;
  804aae:	66 c7 40 0e 01 00    	movw   $0x1,0xe(%eax)
      rem_len -= q->len;
  804ab4:	0f b7 d2             	movzwl %dx,%edx
  804ab7:	29 d6                	sub    %edx,%esi
      r = q;
  804ab9:	89 c3                	mov    %eax,%ebx
    while (rem_len > 0) {
  804abb:	85 f6                	test   %esi,%esi
  804abd:	0f 8e e9 fe ff ff    	jle    8049ac <pbuf_alloc+0x99>
      q = memp_malloc(MEMP_PBUF_POOL);
  804ac3:	83 ec 0c             	sub    $0xc,%esp
  804ac6:	6a 0d                	push   $0xd
  804ac8:	e8 bb f9 ff ff       	call   804488 <memp_malloc>
      if (q == NULL) {
  804acd:	83 c4 10             	add    $0x10,%esp
  804ad0:	85 c0                	test   %eax,%eax
  804ad2:	74 97                	je     804a6b <pbuf_alloc+0x158>
      q->type = type;
  804ad4:	c6 40 0c 03          	movb   $0x3,0xc(%eax)
      q->flags = 0;
  804ad8:	c6 40 0d 00          	movb   $0x0,0xd(%eax)
      q->next = NULL;
  804adc:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      r->next = q;
  804ae2:	89 03                	mov    %eax,(%ebx)
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
  804ae4:	81 fe fe ff 00 00    	cmp    $0xfffe,%esi
  804aea:	7f 94                	jg     804a80 <pbuf_alloc+0x16d>
      q->tot_len = (u16_t)rem_len;
  804aec:	66 89 70 08          	mov    %si,0x8(%eax)
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
  804af0:	66 81 fe d0 07       	cmp    $0x7d0,%si
  804af5:	ba d0 07 00 00       	mov    $0x7d0,%edx
  804afa:	0f 46 d6             	cmovbe %esi,%edx
  804afd:	66 89 50 0a          	mov    %dx,0xa(%eax)
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
  804b01:	8d 48 10             	lea    0x10(%eax),%ecx
  804b04:	89 48 04             	mov    %ecx,0x4(%eax)
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
  804b07:	f6 c1 03             	test   $0x3,%cl
  804b0a:	75 8b                	jne    804a97 <pbuf_alloc+0x184>
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  804b0c:	0f b7 4f 0a          	movzwl 0xa(%edi),%ecx
  804b10:	03 4f 04             	add    0x4(%edi),%ecx
  804b13:	39 4d e4             	cmp    %ecx,-0x1c(%ebp)
  804b16:	73 96                	jae    804aae <pbuf_alloc+0x19b>
  804b18:	83 ec 04             	sub    $0x4,%esp
  804b1b:	68 44 1b 81 00       	push   $0x811b44
  804b20:	68 c5 00 00 00       	push   $0xc5
  804b25:	68 c0 19 81 00       	push   $0x8119c0
  804b2a:	e8 24 9b 00 00       	call   80e653 <_panic>
    p = memp_malloc(MEMP_PBUF);
  804b2f:	83 ec 0c             	sub    $0xc,%esp
  804b32:	6a 0c                	push   $0xc
  804b34:	e8 4f f9 ff ff       	call   804488 <memp_malloc>
  804b39:	89 c7                	mov    %eax,%edi
    if (p == NULL) {
  804b3b:	83 c4 10             	add    $0x10,%esp
  804b3e:	85 c0                	test   %eax,%eax
  804b40:	0f 84 70 fe ff ff    	je     8049b6 <pbuf_alloc+0xa3>
    p->payload = NULL;
  804b46:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    p->len = p->tot_len = length;
  804b4d:	66 89 70 08          	mov    %si,0x8(%eax)
  804b51:	66 89 70 0a          	mov    %si,0xa(%eax)
    p->next = NULL;
  804b55:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    p->type = type;
  804b5b:	0f b6 45 10          	movzbl 0x10(%ebp),%eax
  804b5f:	88 47 0c             	mov    %al,0xc(%edi)
    break;
  804b62:	e9 45 fe ff ff       	jmp    8049ac <pbuf_alloc+0x99>
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
  804b67:	83 ec 04             	sub    $0x4,%esp
  804b6a:	68 5b 1a 81 00       	push   $0x811a5b
  804b6f:	68 f1 00 00 00       	push   $0xf1
  804b74:	68 c0 19 81 00       	push   $0x8119c0
  804b79:	e8 d5 9a 00 00       	call   80e653 <_panic>

00804b7e <pbuf_realloc>:
{
  804b7e:	55                   	push   %ebp
  804b7f:	89 e5                	mov    %esp,%ebp
  804b81:	57                   	push   %edi
  804b82:	56                   	push   %esi
  804b83:	53                   	push   %ebx
  804b84:	83 ec 0c             	sub    $0xc,%esp
  804b87:	8b 5d 08             	mov    0x8(%ebp),%ebx
  804b8a:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
  804b8d:	85 db                	test   %ebx,%ebx
  804b8f:	74 53                	je     804be4 <pbuf_realloc+0x66>
  804b91:	89 f2                	mov    %esi,%edx
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
  804b93:	80 7b 0c 03          	cmpb   $0x3,0xc(%ebx)
  804b97:	77 62                	ja     804bfb <pbuf_realloc+0x7d>
  if (new_len >= p->tot_len) {
  804b99:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  804b9d:	66 39 f0             	cmp    %si,%ax
  804ba0:	0f 86 ae 00 00 00    	jbe    804c54 <pbuf_realloc+0xd6>
  grow = new_len - p->tot_len;
  804ba6:	0f b7 ce             	movzwl %si,%ecx
  804ba9:	0f b7 f8             	movzwl %ax,%edi
  804bac:	29 f9                	sub    %edi,%ecx
    q->tot_len += (u16_t)grow;
  804bae:	29 c2                	sub    %eax,%edx
  while (rem_len > q->len) {
  804bb0:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804bb4:	66 39 f0             	cmp    %si,%ax
  804bb7:	73 70                	jae    804c29 <pbuf_realloc+0xab>
    rem_len -= q->len;
  804bb9:	29 c6                	sub    %eax,%esi
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
  804bbb:	81 f9 fe ff 00 00    	cmp    $0xfffe,%ecx
  804bc1:	7f 4f                	jg     804c12 <pbuf_realloc+0x94>
    q->tot_len += (u16_t)grow;
  804bc3:	66 01 53 08          	add    %dx,0x8(%ebx)
    q = q->next;
  804bc7:	8b 1b                	mov    (%ebx),%ebx
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
  804bc9:	85 db                	test   %ebx,%ebx
  804bcb:	75 e3                	jne    804bb0 <pbuf_realloc+0x32>
  804bcd:	83 ec 04             	sub    $0x4,%esp
  804bd0:	68 ba 1a 81 00       	push   $0x811aba
  804bd5:	68 2f 01 00 00       	push   $0x12f
  804bda:	68 c0 19 81 00       	push   $0x8119c0
  804bdf:	e8 6f 9a 00 00       	call   80e653 <_panic>
  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
  804be4:	83 ec 04             	sub    $0x4,%esp
  804be7:	68 76 1a 81 00       	push   $0x811a76
  804bec:	68 13 01 00 00       	push   $0x113
  804bf1:	68 c0 19 81 00       	push   $0x8119c0
  804bf6:	e8 58 9a 00 00       	call   80e653 <_panic>
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
  804bfb:	83 ec 04             	sub    $0x4,%esp
  804bfe:	68 8e 1a 81 00       	push   $0x811a8e
  804c03:	68 17 01 00 00       	push   $0x117
  804c08:	68 c0 19 81 00       	push   $0x8119c0
  804c0d:	e8 41 9a 00 00       	call   80e653 <_panic>
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
  804c12:	83 ec 04             	sub    $0x4,%esp
  804c15:	68 a9 1a 81 00       	push   $0x811aa9
  804c1a:	68 2b 01 00 00       	push   $0x12b
  804c1f:	68 c0 19 81 00       	push   $0x8119c0
  804c24:	e8 2a 9a 00 00       	call   80e653 <_panic>
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
  804c29:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  804c2d:	75 05                	jne    804c34 <pbuf_realloc+0xb6>
  804c2f:	66 39 f0             	cmp    %si,%ax
  804c32:	75 28                	jne    804c5c <pbuf_realloc+0xde>
  q->len = rem_len;
  804c34:	66 89 73 0a          	mov    %si,0xa(%ebx)
  q->tot_len = q->len;
  804c38:	66 89 73 08          	mov    %si,0x8(%ebx)
  if (q->next != NULL) {
  804c3c:	8b 03                	mov    (%ebx),%eax
  804c3e:	85 c0                	test   %eax,%eax
  804c40:	74 0c                	je     804c4e <pbuf_realloc+0xd0>
    pbuf_free(q->next);
  804c42:	83 ec 0c             	sub    $0xc,%esp
  804c45:	50                   	push   %eax
  804c46:	e8 02 fc ff ff       	call   80484d <pbuf_free>
  804c4b:	83 c4 10             	add    $0x10,%esp
  q->next = NULL;
  804c4e:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
}
  804c54:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804c57:	5b                   	pop    %ebx
  804c58:	5e                   	pop    %esi
  804c59:	5f                   	pop    %edi
  804c5a:	5d                   	pop    %ebp
  804c5b:	c3                   	ret    
    q = mem_realloc(q, (u8_t *)q->payload - (u8_t *)q + rem_len);
  804c5c:	8b 43 04             	mov    0x4(%ebx),%eax
  804c5f:	29 d8                	sub    %ebx,%eax
  804c61:	0f b7 d6             	movzwl %si,%edx
  804c64:	01 d0                	add    %edx,%eax
  804c66:	83 ec 08             	sub    $0x8,%esp
  804c69:	50                   	push   %eax
  804c6a:	53                   	push   %ebx
  804c6b:	e8 56 f4 ff ff       	call   8040c6 <mem_realloc>
  804c70:	89 c3                	mov    %eax,%ebx
    LWIP_ASSERT("mem_realloc give q == NULL", q != NULL);
  804c72:	83 c4 10             	add    $0x10,%esp
  804c75:	85 c0                	test   %eax,%eax
  804c77:	75 bb                	jne    804c34 <pbuf_realloc+0xb6>
  804c79:	83 ec 04             	sub    $0x4,%esp
  804c7c:	68 d2 1a 81 00       	push   $0x811ad2
  804c81:	68 39 01 00 00       	push   $0x139
  804c86:	68 c0 19 81 00       	push   $0x8119c0
  804c8b:	e8 c3 99 00 00       	call   80e653 <_panic>

00804c90 <pbuf_clen>:
 * @return the number of pbufs in a chain
 */

u8_t
pbuf_clen(struct pbuf *p)
{
  804c90:	55                   	push   %ebp
  804c91:	89 e5                	mov    %esp,%ebp
  804c93:	8b 55 08             	mov    0x8(%ebp),%edx
  u8_t len;

  len = 0;
  804c96:	b8 00 00 00 00       	mov    $0x0,%eax
  while (p != NULL) {
  804c9b:	eb 05                	jmp    804ca2 <pbuf_clen+0x12>
    ++len;
  804c9d:	83 c0 01             	add    $0x1,%eax
    p = p->next;
  804ca0:	8b 12                	mov    (%edx),%edx
  while (p != NULL) {
  804ca2:	85 d2                	test   %edx,%edx
  804ca4:	75 f7                	jne    804c9d <pbuf_clen+0xd>
  }
  return len;
}
  804ca6:	5d                   	pop    %ebp
  804ca7:	c3                   	ret    

00804ca8 <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
  804ca8:	55                   	push   %ebp
  804ca9:	89 e5                	mov    %esp,%ebp
  804cab:	8b 45 08             	mov    0x8(%ebp),%eax
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
  804cae:	85 c0                	test   %eax,%eax
  804cb0:	74 05                	je     804cb7 <pbuf_ref+0xf>
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
  804cb2:	66 83 40 0e 01       	addw   $0x1,0xe(%eax)
    SYS_ARCH_UNPROTECT(old_level);
  }
}
  804cb7:	5d                   	pop    %ebp
  804cb8:	c3                   	ret    

00804cb9 <pbuf_cat>:
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  804cb9:	55                   	push   %ebp
  804cba:	89 e5                	mov    %esp,%ebp
  804cbc:	53                   	push   %ebx
  804cbd:	83 ec 04             	sub    $0x4,%esp
  804cc0:	8b 45 08             	mov    0x8(%ebp),%eax
  804cc3:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
  804cc6:	85 c0                	test   %eax,%eax
  804cc8:	74 04                	je     804cce <pbuf_cat+0x15>
  804cca:	85 db                	test   %ebx,%ebx
  804ccc:	75 21                	jne    804cef <pbuf_cat+0x36>
  804cce:	83 ec 04             	sub    $0x4,%esp
  804cd1:	68 a8 1b 81 00       	push   $0x811ba8
  804cd6:	68 42 02 00 00       	push   $0x242
  804cdb:	68 c0 19 81 00       	push   $0x8119c0
  804ce0:	e8 6e 99 00 00       	call   80e653 <_panic>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  804ce5:	0f b7 4b 08          	movzwl 0x8(%ebx),%ecx
  804ce9:	66 01 48 08          	add    %cx,0x8(%eax)
  for (p = h; p->next != NULL; p = p->next) {
  804ced:	89 d0                	mov    %edx,%eax
  804cef:	8b 10                	mov    (%eax),%edx
  804cf1:	85 d2                	test   %edx,%edx
  804cf3:	75 f0                	jne    804ce5 <pbuf_cat+0x2c>
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  804cf5:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  804cf9:	66 3b 50 0a          	cmp    0xa(%eax),%dx
  804cfd:	75 0f                	jne    804d0e <pbuf_cat+0x55>
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
  804cff:	66 03 53 08          	add    0x8(%ebx),%dx
  804d03:	66 89 50 08          	mov    %dx,0x8(%eax)
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
  804d07:	89 18                	mov    %ebx,(%eax)
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
  804d09:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  804d0c:	c9                   	leave  
  804d0d:	c3                   	ret    
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  804d0e:	83 ec 04             	sub    $0x4,%esp
  804d11:	68 e0 1b 81 00       	push   $0x811be0
  804d16:	68 4a 02 00 00       	push   $0x24a
  804d1b:	68 c0 19 81 00       	push   $0x8119c0
  804d20:	e8 2e 99 00 00       	call   80e653 <_panic>

00804d25 <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
  804d25:	55                   	push   %ebp
  804d26:	89 e5                	mov    %esp,%ebp
  804d28:	53                   	push   %ebx
  804d29:	83 ec 0c             	sub    $0xc,%esp
  804d2c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  pbuf_cat(h, t);
  804d2f:	53                   	push   %ebx
  804d30:	ff 75 08             	pushl  0x8(%ebp)
  804d33:	e8 81 ff ff ff       	call   804cb9 <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
  804d38:	89 1c 24             	mov    %ebx,(%esp)
  804d3b:	e8 68 ff ff ff       	call   804ca8 <pbuf_ref>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_FRESH | 2, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
  804d40:	83 c4 10             	add    $0x10,%esp
  804d43:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  804d46:	c9                   	leave  
  804d47:	c3                   	ret    

00804d48 <pbuf_dechain>:
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
  804d48:	55                   	push   %ebp
  804d49:	89 e5                	mov    %esp,%ebp
  804d4b:	57                   	push   %edi
  804d4c:	56                   	push   %esi
  804d4d:	53                   	push   %ebx
  804d4e:	83 ec 1c             	sub    $0x1c,%esp
  804d51:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct pbuf *q;
  u8_t tail_gone = 1;
  /* tail */
  q = p->next;
  804d54:	8b 33                	mov    (%ebx),%esi
  /* pbuf has successor in chain? */
  if (q != NULL) {
  804d56:	85 f6                	test   %esi,%esi
  804d58:	74 71                	je     804dcb <pbuf_dechain+0x83>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
  804d5a:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  804d5e:	0f b7 4b 0a          	movzwl 0xa(%ebx),%ecx
  804d62:	0f b7 7e 08          	movzwl 0x8(%esi),%edi
  804d66:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  804d69:	0f b7 d0             	movzwl %ax,%edx
  804d6c:	0f b7 f9             	movzwl %cx,%edi
  804d6f:	29 fa                	sub    %edi,%edx
  804d71:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  804d74:	75 3e                	jne    804db4 <pbuf_dechain+0x6c>
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
  804d76:	29 c8                	sub    %ecx,%eax
  804d78:	66 89 46 08          	mov    %ax,0x8(%esi)
    /* decouple pbuf from remainder */
    p->next = NULL;
  804d7c:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
  804d82:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804d86:	66 89 43 08          	mov    %ax,0x8(%ebx)
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_STATE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
  804d8a:	83 ec 0c             	sub    $0xc,%esp
  804d8d:	56                   	push   %esi
  804d8e:	e8 ba fa ff ff       	call   80484d <pbuf_free>
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  804d93:	83 c4 10             	add    $0x10,%esp
  804d96:	0f b7 4b 0a          	movzwl 0xa(%ebx),%ecx
  804d9a:	66 39 4b 08          	cmp    %cx,0x8(%ebx)
  804d9e:	75 35                	jne    804dd5 <pbuf_dechain+0x8d>
  return ((tail_gone > 0) ? NULL : q);
  804da0:	84 c0                	test   %al,%al
  804da2:	b8 00 00 00 00       	mov    $0x0,%eax
  804da7:	0f 45 f0             	cmovne %eax,%esi
}
  804daa:	89 f0                	mov    %esi,%eax
  804dac:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804daf:	5b                   	pop    %ebx
  804db0:	5e                   	pop    %esi
  804db1:	5f                   	pop    %edi
  804db2:	5d                   	pop    %ebp
  804db3:	c3                   	ret    
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
  804db4:	83 ec 04             	sub    $0x4,%esp
  804db7:	68 10 1c 81 00       	push   $0x811c10
  804dbc:	68 80 02 00 00       	push   $0x280
  804dc1:	68 c0 19 81 00       	push   $0x8119c0
  804dc6:	e8 88 98 00 00       	call   80e653 <_panic>
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  804dcb:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804dcf:	66 39 43 08          	cmp    %ax,0x8(%ebx)
  804dd3:	74 d5                	je     804daa <pbuf_dechain+0x62>
  804dd5:	83 ec 04             	sub    $0x4,%esp
  804dd8:	68 ed 1a 81 00       	push   $0x811aed
  804ddd:	68 91 02 00 00       	push   $0x291
  804de2:	68 c0 19 81 00       	push   $0x8119c0
  804de7:	e8 67 98 00 00       	call   80e653 <_panic>

00804dec <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
  804dec:	55                   	push   %ebp
  804ded:	89 e5                	mov    %esp,%ebp
  804def:	57                   	push   %edi
  804df0:	56                   	push   %esi
  804df1:	53                   	push   %ebx
  804df2:	83 ec 1c             	sub    $0x1c,%esp
  804df5:	8b 5d 08             	mov    0x8(%ebp),%ebx
  804df8:	8b 7d 0c             	mov    0xc(%ebp),%edi

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
  804dfb:	85 db                	test   %ebx,%ebx
  804dfd:	74 22                	je     804e21 <pbuf_copy+0x35>
  804dff:	85 ff                	test   %edi,%edi
  804e01:	74 1e                	je     804e21 <pbuf_copy+0x35>
  804e03:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  804e07:	66 39 43 08          	cmp    %ax,0x8(%ebx)
  804e0b:	72 14                	jb     804e21 <pbuf_copy+0x35>
  u16_t offset_to=0, offset_from=0, len;
  804e0d:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
  804e13:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
  804e19:	89 5d 08             	mov    %ebx,0x8(%ebp)
  804e1c:	e9 d4 00 00 00       	jmp    804ef5 <pbuf_copy+0x109>
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
  804e21:	83 ec 04             	sub    $0x4,%esp
  804e24:	68 34 1c 81 00       	push   $0x811c34
  804e29:	68 b1 02 00 00       	push   $0x2b1
  804e2e:	68 c0 19 81 00       	push   $0x8119c0
  804e33:	e8 1b 98 00 00       	call   80e653 <_panic>
             (p_from != NULL) && (p_to->tot_len >= p_from->tot_len)), return ERR_ARG;);

  /* iterate through pbuf chain */
  do
  {
    LWIP_ASSERT("p_to != NULL", p_to != NULL);
  804e38:	83 ec 04             	sub    $0x4,%esp
  804e3b:	68 02 1b 81 00       	push   $0x811b02
  804e40:	68 b6 02 00 00       	push   $0x2b6
  804e45:	68 c0 19 81 00       	push   $0x8119c0
  804e4a:	e8 04 98 00 00       	call   80e653 <_panic>
      len = p_to->len - offset_to;
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
    offset_to += len;
    offset_from += len;
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
  804e4f:	83 ec 04             	sub    $0x4,%esp
  804e52:	68 0f 1b 81 00       	push   $0x811b0f
  804e57:	68 c2 02 00 00       	push   $0x2c2
  804e5c:	68 c0 19 81 00       	push   $0x8119c0
  804e61:	e8 ed 97 00 00       	call   80e653 <_panic>
    if (offset_to == p_to->len) {
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
  804e66:	8b 45 08             	mov    0x8(%ebp),%eax
  804e69:	8b 00                	mov    (%eax),%eax
  804e6b:	89 45 08             	mov    %eax,0x8(%ebp)
      offset_to = 0;
  804e6e:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
  804e74:	e9 fc 00 00 00       	jmp    804f75 <pbuf_copy+0x189>
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
  804e79:	83 ec 04             	sub    $0x4,%esp
  804e7c:	68 26 1b 81 00       	push   $0x811b26
  804e81:	68 c8 02 00 00       	push   $0x2c8
  804e86:	68 c0 19 81 00       	push   $0x8119c0
  804e8b:	e8 c3 97 00 00       	call   80e653 <_panic>
      p_from = p_from->next;
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  804e90:	83 3f 00             	cmpl   $0x0,(%edi)
  804e93:	0f 84 0e 01 00 00    	je     804fa7 <pbuf_copy+0x1bb>
  804e99:	83 ec 04             	sub    $0x4,%esp
  804e9c:	68 64 1c 81 00       	push   $0x811c64
  804ea1:	68 d2 02 00 00       	push   $0x2d2
  804ea6:	68 c0 19 81 00       	push   $0x8119c0
  804eab:	e8 a3 97 00 00       	call   80e653 <_panic>
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  804eb0:	83 ec 04             	sub    $0x4,%esp
  804eb3:	68 64 1c 81 00       	push   $0x811c64
  804eb8:	68 d7 02 00 00       	push   $0x2d7
  804ebd:	68 c0 19 81 00       	push   $0x8119c0
  804ec2:	e8 8c 97 00 00       	call   80e653 <_panic>
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
  804ec7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  804ecb:	0f 84 f9 00 00 00    	je     804fca <pbuf_copy+0x1de>
  804ed1:	8b 45 08             	mov    0x8(%ebp),%eax
  804ed4:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  804ed8:	8b 4d 08             	mov    0x8(%ebp),%ecx
  804edb:	66 39 41 0a          	cmp    %ax,0xa(%ecx)
  804edf:	0f 85 e5 00 00 00    	jne    804fca <pbuf_copy+0x1de>
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  804ee5:	8b 45 08             	mov    0x8(%ebp),%eax
  804ee8:	83 38 00             	cmpl   $0x0,(%eax)
  804eeb:	75 c3                	jne    804eb0 <pbuf_copy+0xc4>
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
  804eed:	85 ff                	test   %edi,%edi
  804eef:	0f 84 d5 00 00 00    	je     804fca <pbuf_copy+0x1de>
    LWIP_ASSERT("p_to != NULL", p_to != NULL);
  804ef5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  804ef9:	0f 84 39 ff ff ff    	je     804e38 <pbuf_copy+0x4c>
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
  804eff:	8b 45 08             	mov    0x8(%ebp),%eax
  804f02:	0f b7 70 0a          	movzwl 0xa(%eax),%esi
  804f06:	0f b7 ce             	movzwl %si,%ecx
  804f09:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  804f0d:	29 c1                	sub    %eax,%ecx
  804f0f:	0f b7 57 0a          	movzwl 0xa(%edi),%edx
  804f13:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  804f17:	29 c2                	sub    %eax,%edx
      len = p_from->len - offset_from;
  804f19:	0f b7 5f 0a          	movzwl 0xa(%edi),%ebx
  804f1d:	66 2b 5d e6          	sub    -0x1a(%ebp),%bx
  804f21:	89 d8                	mov    %ebx,%eax
  804f23:	0f b7 5d e4          	movzwl -0x1c(%ebp),%ebx
  804f27:	29 de                	sub    %ebx,%esi
  804f29:	39 d1                	cmp    %edx,%ecx
  804f2b:	0f 4d f0             	cmovge %eax,%esi
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
  804f2e:	83 ec 04             	sub    $0x4,%esp
  804f31:	0f b7 c6             	movzwl %si,%eax
  804f34:	50                   	push   %eax
  804f35:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  804f39:	03 47 04             	add    0x4(%edi),%eax
  804f3c:	50                   	push   %eax
  804f3d:	0f b7 c3             	movzwl %bx,%eax
  804f40:	8b 4d 08             	mov    0x8(%ebp),%ecx
  804f43:	03 41 04             	add    0x4(%ecx),%eax
  804f46:	50                   	push   %eax
  804f47:	e8 75 a0 00 00       	call   80efc1 <memcpy>
    offset_to += len;
  804f4c:	89 da                	mov    %ebx,%edx
  804f4e:	01 f2                	add    %esi,%edx
  804f50:	66 89 55 e4          	mov    %dx,-0x1c(%ebp)
    offset_from += len;
  804f54:	66 01 75 e6          	add    %si,-0x1a(%ebp)
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
  804f58:	8b 45 08             	mov    0x8(%ebp),%eax
  804f5b:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  804f5f:	83 c4 10             	add    $0x10,%esp
  804f62:	66 39 d0             	cmp    %dx,%ax
  804f65:	0f 82 e4 fe ff ff    	jb     804e4f <pbuf_copy+0x63>
    if (offset_to == p_to->len) {
  804f6b:	66 3b 45 e4          	cmp    -0x1c(%ebp),%ax
  804f6f:	0f 84 f1 fe ff ff    	je     804e66 <pbuf_copy+0x7a>
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
  804f75:	0f b7 47 0a          	movzwl 0xa(%edi),%eax
  804f79:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
  804f7d:	0f 82 f6 fe ff ff    	jb     804e79 <pbuf_copy+0x8d>
    if (offset_from >= p_from->len) {
  804f83:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
  804f87:	77 08                	ja     804f91 <pbuf_copy+0x1a5>
      p_from = p_from->next;
  804f89:	8b 3f                	mov    (%edi),%edi
      offset_from = 0;
  804f8b:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
  804f91:	85 ff                	test   %edi,%edi
  804f93:	0f 84 2e ff ff ff    	je     804ec7 <pbuf_copy+0xdb>
  804f99:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  804f9d:	66 39 47 0a          	cmp    %ax,0xa(%edi)
  804fa1:	0f 84 e9 fe ff ff    	je     804e90 <pbuf_copy+0xa4>
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
  804fa7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  804fab:	0f 84 44 ff ff ff    	je     804ef5 <pbuf_copy+0x109>
  804fb1:	8b 45 08             	mov    0x8(%ebp),%eax
  804fb4:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  804fb8:	8b 4d 08             	mov    0x8(%ebp),%ecx
  804fbb:	66 39 41 0a          	cmp    %ax,0xa(%ecx)
  804fbf:	0f 85 30 ff ff ff    	jne    804ef5 <pbuf_copy+0x109>
  804fc5:	e9 1b ff ff ff       	jmp    804ee5 <pbuf_copy+0xf9>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 1, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
}
  804fca:	b8 00 00 00 00       	mov    $0x0,%eax
  804fcf:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804fd2:	5b                   	pop    %ebx
  804fd3:	5e                   	pop    %esi
  804fd4:	5f                   	pop    %edi
  804fd5:	5d                   	pop    %ebp
  804fd6:	c3                   	ret    

00804fd7 <pbuf_copy_partial>:
 * @param len length of data to copy (dataptr must be big enough)
 * @param offset offset into the packet buffer from where to begin copying len bytes
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
  804fd7:	55                   	push   %ebp
  804fd8:	89 e5                	mov    %esp,%ebp
  804fda:	57                   	push   %edi
  804fdb:	56                   	push   %esi
  804fdc:	53                   	push   %ebx
  804fdd:	83 ec 1c             	sub    $0x1c,%esp
  804fe0:	8b 75 08             	mov    0x8(%ebp),%esi
  804fe3:	0f b7 7d 10          	movzwl 0x10(%ebp),%edi
  804fe7:	0f b7 45 14          	movzwl 0x14(%ebp),%eax
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;

  LWIP_ERROR("netbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
  804feb:	85 f6                	test   %esi,%esi
  804fed:	74 0e                	je     804ffd <pbuf_copy_partial+0x26>
  LWIP_ERROR("netbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
  804fef:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  804ff3:	74 1f                	je     805014 <pbuf_copy_partial+0x3d>

  left = 0;
  804ff5:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
  804ffb:	eb 65                	jmp    805062 <pbuf_copy_partial+0x8b>
  LWIP_ERROR("netbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
  804ffd:	83 ec 04             	sub    $0x4,%esp
  805000:	68 90 1c 81 00       	push   $0x811c90
  805005:	68 ef 02 00 00       	push   $0x2ef
  80500a:	68 c0 19 81 00       	push   $0x8119c0
  80500f:	e8 3f 96 00 00       	call   80e653 <_panic>
  LWIP_ERROR("netbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
  805014:	83 ec 04             	sub    $0x4,%esp
  805017:	68 b4 1c 81 00       	push   $0x811cb4
  80501c:	68 f0 02 00 00       	push   $0x2f0
  805021:	68 c0 19 81 00       	push   $0x8119c0
  805026:	e8 28 96 00 00       	call   80e653 <_panic>
    if ((offset != 0) && (offset >= p->len)) {
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
  80502b:	0f b7 5e 0a          	movzwl 0xa(%esi),%ebx
  80502f:	29 c3                	sub    %eax,%ebx
  805031:	66 39 df             	cmp    %bx,%di
  805034:	0f 46 df             	cmovbe %edi,%ebx
      if (buf_copy_len > len)
          buf_copy_len = len;
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
  805037:	83 ec 04             	sub    $0x4,%esp
  80503a:	0f b7 d3             	movzwl %bx,%edx
  80503d:	52                   	push   %edx
  80503e:	0f b7 c0             	movzwl %ax,%eax
  805041:	03 46 04             	add    0x4(%esi),%eax
  805044:	50                   	push   %eax
  805045:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  805049:	03 45 0c             	add    0xc(%ebp),%eax
  80504c:	50                   	push   %eax
  80504d:	e8 6f 9f 00 00       	call   80efc1 <memcpy>
      copied_total += buf_copy_len;
  805052:	66 01 5d e6          	add    %bx,-0x1a(%ebp)
      left += buf_copy_len;
      len -= buf_copy_len;
  805056:	29 df                	sub    %ebx,%edi
  805058:	83 c4 10             	add    $0x10,%esp
      offset = 0;
  80505b:	b8 00 00 00 00       	mov    $0x0,%eax
  for(p = buf; len != 0 && p != NULL; p = p->next) {
  805060:	8b 36                	mov    (%esi),%esi
  805062:	66 85 ff             	test   %di,%di
  805065:	74 16                	je     80507d <pbuf_copy_partial+0xa6>
  805067:	85 f6                	test   %esi,%esi
  805069:	74 12                	je     80507d <pbuf_copy_partial+0xa6>
    if ((offset != 0) && (offset >= p->len)) {
  80506b:	66 85 c0             	test   %ax,%ax
  80506e:	74 bb                	je     80502b <pbuf_copy_partial+0x54>
  805070:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  805074:	66 39 c2             	cmp    %ax,%dx
  805077:	77 b2                	ja     80502b <pbuf_copy_partial+0x54>
      offset -= p->len;
  805079:	29 d0                	sub    %edx,%eax
  80507b:	eb e3                	jmp    805060 <pbuf_copy_partial+0x89>
    }
  }
  return copied_total;
}
  80507d:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  805081:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805084:	5b                   	pop    %ebx
  805085:	5e                   	pop    %esi
  805086:	5f                   	pop    %edi
  805087:	5d                   	pop    %ebp
  805088:	c3                   	ret    

00805089 <sswt_handler>:
 *
 * @param arg struct sswt_cb* used to signal a semaphore and end waiting.
 */
static void
sswt_handler(void *arg)
{
  805089:	55                   	push   %ebp
  80508a:	89 e5                	mov    %esp,%ebp
  80508c:	83 ec 14             	sub    $0x14,%esp
  80508f:	8b 45 08             	mov    0x8(%ebp),%eax
  struct sswt_cb *sswt_cb = (struct sswt_cb *) arg;

  /* Timeout. Set flag to TRUE and signal semaphore */
  sswt_cb->timeflag = 1;
  805092:	66 c7 00 01 00       	movw   $0x1,(%eax)
  sys_sem_signal(*(sswt_cb->psem));
  805097:	8b 40 04             	mov    0x4(%eax),%eax
  80509a:	ff 30                	pushl  (%eax)
  80509c:	e8 83 50 00 00       	call   80a124 <sys_sem_signal>
}
  8050a1:	83 c4 10             	add    $0x10,%esp
  8050a4:	c9                   	leave  
  8050a5:	c3                   	ret    

008050a6 <sys_mbox_fetch>:
{
  8050a6:	55                   	push   %ebp
  8050a7:	89 e5                	mov    %esp,%ebp
  8050a9:	57                   	push   %edi
  8050aa:	56                   	push   %esi
  8050ab:	53                   	push   %ebx
  8050ac:	83 ec 0c             	sub    $0xc,%esp
  8050af:	8b 7d 0c             	mov    0xc(%ebp),%edi
  8050b2:	eb 37                	jmp    8050eb <sys_mbox_fetch+0x45>
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
  8050b4:	83 ec 04             	sub    $0x4,%esp
  8050b7:	6a 00                	push   $0x0
  8050b9:	57                   	push   %edi
  8050ba:	ff 75 08             	pushl  0x8(%ebp)
  8050bd:	e8 d7 52 00 00       	call   80a399 <sys_arch_mbox_fetch>
  8050c2:	83 c4 10             	add    $0x10,%esp
}
  8050c5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8050c8:	5b                   	pop    %ebx
  8050c9:	5e                   	pop    %esi
  8050ca:	5f                   	pop    %edi
  8050cb:	5d                   	pop    %ebp
  8050cc:	c3                   	ret    
      tmptimeout = timeouts->next;
  8050cd:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  8050cf:	8b 10                	mov    (%eax),%edx
  8050d1:	89 13                	mov    %edx,(%ebx)
      h   = tmptimeout->h;
  8050d3:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  8050d6:	8b 70 0c             	mov    0xc(%eax),%esi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  8050d9:	83 ec 08             	sub    $0x8,%esp
  8050dc:	50                   	push   %eax
  8050dd:	6a 0b                	push   $0xb
  8050df:	e8 fa f3 ff ff       	call   8044de <memp_free>
      if (h != NULL) {
  8050e4:	83 c4 10             	add    $0x10,%esp
  8050e7:	85 db                	test   %ebx,%ebx
  8050e9:	75 45                	jne    805130 <sys_mbox_fetch+0x8a>
  timeouts = sys_arch_timeouts();
  8050eb:	e8 3e 54 00 00       	call   80a52e <sys_arch_timeouts>
  8050f0:	89 c3                	mov    %eax,%ebx
  if (!timeouts || !timeouts->next) {
  8050f2:	85 c0                	test   %eax,%eax
  8050f4:	74 be                	je     8050b4 <sys_mbox_fetch+0xe>
  8050f6:	8b 00                	mov    (%eax),%eax
  8050f8:	85 c0                	test   %eax,%eax
  8050fa:	74 b8                	je     8050b4 <sys_mbox_fetch+0xe>
    if (timeouts->next->time > 0) {
  8050fc:	8b 40 04             	mov    0x4(%eax),%eax
  8050ff:	85 c0                	test   %eax,%eax
  805101:	74 ca                	je     8050cd <sys_mbox_fetch+0x27>
      time_needed = sys_arch_mbox_fetch(mbox, msg, timeouts->next->time);
  805103:	83 ec 04             	sub    $0x4,%esp
  805106:	50                   	push   %eax
  805107:	57                   	push   %edi
  805108:	ff 75 08             	pushl  0x8(%ebp)
  80510b:	e8 89 52 00 00       	call   80a399 <sys_arch_mbox_fetch>
    if (time_needed == SYS_ARCH_TIMEOUT) {
  805110:	83 c4 10             	add    $0x10,%esp
  805113:	83 f8 ff             	cmp    $0xffffffff,%eax
  805116:	74 b5                	je     8050cd <sys_mbox_fetch+0x27>
      if (time_needed < timeouts->next->time) {
  805118:	8b 1b                	mov    (%ebx),%ebx
  80511a:	8b 4b 04             	mov    0x4(%ebx),%ecx
        timeouts->next->time -= time_needed;
  80511d:	89 ca                	mov    %ecx,%edx
  80511f:	29 c2                	sub    %eax,%edx
  805121:	39 c1                	cmp    %eax,%ecx
  805123:	b8 00 00 00 00       	mov    $0x0,%eax
  805128:	0f 47 c2             	cmova  %edx,%eax
  80512b:	89 43 04             	mov    %eax,0x4(%ebx)
  80512e:	eb 95                	jmp    8050c5 <sys_mbox_fetch+0x1f>
        h(arg);
  805130:	83 ec 0c             	sub    $0xc,%esp
  805133:	56                   	push   %esi
  805134:	ff d3                	call   *%ebx
  805136:	83 c4 10             	add    $0x10,%esp
  805139:	eb b0                	jmp    8050eb <sys_mbox_fetch+0x45>

0080513b <sys_sem_wait>:
{
  80513b:	55                   	push   %ebp
  80513c:	89 e5                	mov    %esp,%ebp
  80513e:	57                   	push   %edi
  80513f:	56                   	push   %esi
  805140:	53                   	push   %ebx
  805141:	83 ec 0c             	sub    $0xc,%esp
  805144:	8b 75 08             	mov    0x8(%ebp),%esi
  805147:	eb 34                	jmp    80517d <sys_sem_wait+0x42>
    sys_arch_sem_wait(sem, 0);
  805149:	83 ec 08             	sub    $0x8,%esp
  80514c:	6a 00                	push   $0x0
  80514e:	56                   	push   %esi
  80514f:	e8 40 50 00 00       	call   80a194 <sys_arch_sem_wait>
  805154:	83 c4 10             	add    $0x10,%esp
}
  805157:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80515a:	5b                   	pop    %ebx
  80515b:	5e                   	pop    %esi
  80515c:	5f                   	pop    %edi
  80515d:	5d                   	pop    %ebp
  80515e:	c3                   	ret    
      tmptimeout = timeouts->next;
  80515f:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  805161:	8b 10                	mov    (%eax),%edx
  805163:	89 13                	mov    %edx,(%ebx)
      h = tmptimeout->h;
  805165:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  805168:	8b 78 0c             	mov    0xc(%eax),%edi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  80516b:	83 ec 08             	sub    $0x8,%esp
  80516e:	50                   	push   %eax
  80516f:	6a 0b                	push   $0xb
  805171:	e8 68 f3 ff ff       	call   8044de <memp_free>
      if (h != NULL) {
  805176:	83 c4 10             	add    $0x10,%esp
  805179:	85 db                	test   %ebx,%ebx
  80517b:	75 42                	jne    8051bf <sys_sem_wait+0x84>
  timeouts = sys_arch_timeouts();
  80517d:	e8 ac 53 00 00       	call   80a52e <sys_arch_timeouts>
  805182:	89 c3                	mov    %eax,%ebx
  if (!timeouts || !timeouts->next) {
  805184:	85 c0                	test   %eax,%eax
  805186:	74 c1                	je     805149 <sys_sem_wait+0xe>
  805188:	8b 00                	mov    (%eax),%eax
  80518a:	85 c0                	test   %eax,%eax
  80518c:	74 bb                	je     805149 <sys_sem_wait+0xe>
    if (timeouts->next->time > 0) {
  80518e:	8b 40 04             	mov    0x4(%eax),%eax
  805191:	85 c0                	test   %eax,%eax
  805193:	74 ca                	je     80515f <sys_sem_wait+0x24>
      time_needed = sys_arch_sem_wait(sem, timeouts->next->time);
  805195:	83 ec 08             	sub    $0x8,%esp
  805198:	50                   	push   %eax
  805199:	56                   	push   %esi
  80519a:	e8 f5 4f 00 00       	call   80a194 <sys_arch_sem_wait>
    if (time_needed == SYS_ARCH_TIMEOUT) {
  80519f:	83 c4 10             	add    $0x10,%esp
  8051a2:	83 f8 ff             	cmp    $0xffffffff,%eax
  8051a5:	74 b8                	je     80515f <sys_sem_wait+0x24>
      if (time_needed < timeouts->next->time) {
  8051a7:	8b 1b                	mov    (%ebx),%ebx
  8051a9:	8b 4b 04             	mov    0x4(%ebx),%ecx
        timeouts->next->time -= time_needed;
  8051ac:	89 ca                	mov    %ecx,%edx
  8051ae:	29 c2                	sub    %eax,%edx
  8051b0:	39 c1                	cmp    %eax,%ecx
  8051b2:	b8 00 00 00 00       	mov    $0x0,%eax
  8051b7:	0f 47 c2             	cmova  %edx,%eax
  8051ba:	89 43 04             	mov    %eax,0x4(%ebx)
  8051bd:	eb 98                	jmp    805157 <sys_sem_wait+0x1c>
        h(arg);
  8051bf:	83 ec 0c             	sub    $0xc,%esp
  8051c2:	57                   	push   %edi
  8051c3:	ff d3                	call   *%ebx
  8051c5:	83 c4 10             	add    $0x10,%esp
  8051c8:	eb b3                	jmp    80517d <sys_sem_wait+0x42>

008051ca <sys_timeout>:
{
  8051ca:	55                   	push   %ebp
  8051cb:	89 e5                	mov    %esp,%ebp
  8051cd:	56                   	push   %esi
  8051ce:	53                   	push   %ebx
  8051cf:	8b 75 08             	mov    0x8(%ebp),%esi
  timeout = memp_malloc(MEMP_SYS_TIMEOUT);
  8051d2:	83 ec 0c             	sub    $0xc,%esp
  8051d5:	6a 0b                	push   $0xb
  8051d7:	e8 ac f2 ff ff       	call   804488 <memp_malloc>
  if (timeout == NULL) {
  8051dc:	83 c4 10             	add    $0x10,%esp
  8051df:	85 c0                	test   %eax,%eax
  8051e1:	74 3f                	je     805222 <sys_timeout+0x58>
  8051e3:	89 c3                	mov    %eax,%ebx
  timeout->next = NULL;
  8051e5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  timeout->h = h;
  8051eb:	8b 45 0c             	mov    0xc(%ebp),%eax
  8051ee:	89 43 08             	mov    %eax,0x8(%ebx)
  timeout->arg = arg;
  8051f1:	8b 45 10             	mov    0x10(%ebp),%eax
  8051f4:	89 43 0c             	mov    %eax,0xc(%ebx)
  timeout->time = msecs;
  8051f7:	89 73 04             	mov    %esi,0x4(%ebx)
  timeouts = sys_arch_timeouts();
  8051fa:	e8 2f 53 00 00       	call   80a52e <sys_arch_timeouts>
  if (timeouts == NULL) {
  8051ff:	85 c0                	test   %eax,%eax
  805201:	74 36                	je     805239 <sys_timeout+0x6f>
  if (timeouts->next == NULL) {
  805203:	8b 10                	mov    (%eax),%edx
  805205:	85 d2                	test   %edx,%edx
  805207:	74 47                	je     805250 <sys_timeout+0x86>
  if (timeouts->next->time > msecs) {
  805209:	8b 4a 04             	mov    0x4(%edx),%ecx
  80520c:	39 f1                	cmp    %esi,%ecx
  80520e:	76 46                	jbe    805256 <sys_timeout+0x8c>
    timeouts->next->time -= msecs;
  805210:	29 f1                	sub    %esi,%ecx
  805212:	89 4a 04             	mov    %ecx,0x4(%edx)
    timeout->next = timeouts->next;
  805215:	8b 10                	mov    (%eax),%edx
  805217:	89 13                	mov    %edx,(%ebx)
    timeouts->next = timeout;
  805219:	89 18                	mov    %ebx,(%eax)
}
  80521b:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80521e:	5b                   	pop    %ebx
  80521f:	5e                   	pop    %esi
  805220:	5d                   	pop    %ebp
  805221:	c3                   	ret    
    LWIP_ASSERT("sys_timeout: timeout != NULL", timeout != NULL);
  805222:	83 ec 04             	sub    $0x4,%esp
  805225:	68 d9 1c 81 00       	push   $0x811cd9
  80522a:	68 c3 00 00 00       	push   $0xc3
  80522f:	68 f6 1c 81 00       	push   $0x811cf6
  805234:	e8 1a 94 00 00       	call   80e653 <_panic>
    LWIP_ASSERT("sys_timeout: timeouts != NULL", timeouts != NULL);
  805239:	83 ec 04             	sub    $0x4,%esp
  80523c:	68 0a 1d 81 00       	push   $0x811d0a
  805241:	68 d1 00 00 00       	push   $0xd1
  805246:	68 f6 1c 81 00       	push   $0x811cf6
  80524b:	e8 03 94 00 00       	call   80e653 <_panic>
    timeouts->next = timeout;
  805250:	89 18                	mov    %ebx,(%eax)
    return;
  805252:	eb c7                	jmp    80521b <sys_timeout+0x51>
      if (t->next == NULL || t->next->time > timeout->time) {
  805254:	89 ca                	mov    %ecx,%edx
      timeout->time -= t->time;
  805256:	8b 43 04             	mov    0x4(%ebx),%eax
  805259:	2b 42 04             	sub    0x4(%edx),%eax
  80525c:	89 43 04             	mov    %eax,0x4(%ebx)
      if (t->next == NULL || t->next->time > timeout->time) {
  80525f:	8b 0a                	mov    (%edx),%ecx
  805261:	85 c9                	test   %ecx,%ecx
  805263:	74 0c                	je     805271 <sys_timeout+0xa7>
  805265:	8b 71 04             	mov    0x4(%ecx),%esi
  805268:	39 f0                	cmp    %esi,%eax
  80526a:	73 e8                	jae    805254 <sys_timeout+0x8a>
          t->next->time -= timeout->time;
  80526c:	29 c6                	sub    %eax,%esi
  80526e:	89 71 04             	mov    %esi,0x4(%ecx)
        timeout->next = t->next;
  805271:	8b 02                	mov    (%edx),%eax
  805273:	89 03                	mov    %eax,(%ebx)
        t->next = timeout;
  805275:	89 1a                	mov    %ebx,(%edx)
        break;
  805277:	eb a2                	jmp    80521b <sys_timeout+0x51>

00805279 <sys_untimeout>:
{
  805279:	55                   	push   %ebp
  80527a:	89 e5                	mov    %esp,%ebp
  80527c:	57                   	push   %edi
  80527d:	56                   	push   %esi
  80527e:	53                   	push   %ebx
  80527f:	83 ec 0c             	sub    $0xc,%esp
  805282:	8b 5d 08             	mov    0x8(%ebp),%ebx
  805285:	8b 75 0c             	mov    0xc(%ebp),%esi
  timeouts = sys_arch_timeouts();
  805288:	e8 a1 52 00 00       	call   80a52e <sys_arch_timeouts>
  if (timeouts == NULL) {
  80528d:	85 c0                	test   %eax,%eax
  80528f:	74 13                	je     8052a4 <sys_untimeout+0x2b>
  if (timeouts->next == NULL) {
  805291:	8b 10                	mov    (%eax),%edx
  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  805293:	bf 00 00 00 00       	mov    $0x0,%edi
  if (timeouts->next == NULL) {
  805298:	85 d2                	test   %edx,%edx
  80529a:	75 2f                	jne    8052cb <sys_untimeout+0x52>
}
  80529c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80529f:	5b                   	pop    %ebx
  8052a0:	5e                   	pop    %esi
  8052a1:	5f                   	pop    %edi
  8052a2:	5d                   	pop    %ebp
  8052a3:	c3                   	ret    
    LWIP_ASSERT("sys_untimeout: timeouts != NULL", timeouts != NULL);
  8052a4:	83 ec 04             	sub    $0x4,%esp
  8052a7:	68 28 1d 81 00       	push   $0x811d28
  8052ac:	68 00 01 00 00       	push   $0x100
  8052b1:	68 f6 1c 81 00       	push   $0x811cf6
  8052b6:	e8 98 93 00 00       	call   80e653 <_panic>
        timeouts->next = t->next;
  8052bb:	8b 0a                	mov    (%edx),%ecx
  8052bd:	89 08                	mov    %ecx,(%eax)
  8052bf:	eb 1c                	jmp    8052dd <sys_untimeout+0x64>
  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  8052c1:	8b 0a                	mov    (%edx),%ecx
  8052c3:	89 d7                	mov    %edx,%edi
  8052c5:	85 c9                	test   %ecx,%ecx
  8052c7:	74 d3                	je     80529c <sys_untimeout+0x23>
  8052c9:	89 ca                	mov    %ecx,%edx
    if ((t->h == h) && (t->arg == arg)) {
  8052cb:	39 5a 08             	cmp    %ebx,0x8(%edx)
  8052ce:	75 f1                	jne    8052c1 <sys_untimeout+0x48>
  8052d0:	39 72 0c             	cmp    %esi,0xc(%edx)
  8052d3:	75 ec                	jne    8052c1 <sys_untimeout+0x48>
      if (prev_t == NULL)
  8052d5:	85 ff                	test   %edi,%edi
  8052d7:	74 e2                	je     8052bb <sys_untimeout+0x42>
        prev_t->next = t->next;
  8052d9:	8b 02                	mov    (%edx),%eax
  8052db:	89 07                	mov    %eax,(%edi)
      if (t->next != NULL)
  8052dd:	8b 02                	mov    (%edx),%eax
  8052df:	85 c0                	test   %eax,%eax
  8052e1:	74 06                	je     8052e9 <sys_untimeout+0x70>
        t->next->time += t->time;
  8052e3:	8b 4a 04             	mov    0x4(%edx),%ecx
  8052e6:	01 48 04             	add    %ecx,0x4(%eax)
      memp_free(MEMP_SYS_TIMEOUT, t);
  8052e9:	83 ec 08             	sub    $0x8,%esp
  8052ec:	52                   	push   %edx
  8052ed:	6a 0b                	push   $0xb
  8052ef:	e8 ea f1 ff ff       	call   8044de <memp_free>
      return;
  8052f4:	83 c4 10             	add    $0x10,%esp
  8052f7:	eb a3                	jmp    80529c <sys_untimeout+0x23>

008052f9 <sys_sem_wait_timeout>:
 * @param timeout timeout in ms (0: wait forever)
 * @return 0 on timeout, 1 otherwise
 */
int
sys_sem_wait_timeout(sys_sem_t sem, u32_t timeout)
{
  8052f9:	55                   	push   %ebp
  8052fa:	89 e5                	mov    %esp,%ebp
  8052fc:	83 ec 18             	sub    $0x18,%esp
  8052ff:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct sswt_cb sswt_cb;

  sswt_cb.psem = &sem;
  805302:	8d 4d 08             	lea    0x8(%ebp),%ecx
  805305:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  sswt_cb.timeflag = 0;
  805308:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%ebp)

  /* If timeout is zero, then just wait forever */
  if (timeout > 0) {
  80530e:	85 c0                	test   %eax,%eax
  805310:	75 1c                	jne    80532e <sys_sem_wait_timeout+0x35>
    /* Create a timer and pass it the address of our flag */
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  }
  sys_sem_wait(sem);
  805312:	83 ec 0c             	sub    $0xc,%esp
  805315:	ff 75 08             	pushl  0x8(%ebp)
  805318:	e8 1e fe ff ff       	call   80513b <sys_sem_wait>
  /* Was it a timeout? */
  if (sswt_cb.timeflag) {
  80531d:	83 c4 10             	add    $0x10,%esp
    /* timeout */
    return 0;
  805320:	b8 00 00 00 00       	mov    $0x0,%eax
  if (sswt_cb.timeflag) {
  805325:	66 83 7d f0 00       	cmpw   $0x0,-0x10(%ebp)
  80532a:	74 19                	je     805345 <sys_sem_wait_timeout+0x4c>
  } else {
    /* Not a timeout. Remove timeout entry */
    sys_untimeout(sswt_handler, &sswt_cb);
    return 1;
  }
}
  80532c:	c9                   	leave  
  80532d:	c3                   	ret    
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  80532e:	83 ec 04             	sub    $0x4,%esp
  805331:	8d 55 f0             	lea    -0x10(%ebp),%edx
  805334:	52                   	push   %edx
  805335:	68 89 50 80 00       	push   $0x805089
  80533a:	50                   	push   %eax
  80533b:	e8 8a fe ff ff       	call   8051ca <sys_timeout>
  805340:	83 c4 10             	add    $0x10,%esp
  805343:	eb cd                	jmp    805312 <sys_sem_wait_timeout+0x19>
    sys_untimeout(sswt_handler, &sswt_cb);
  805345:	83 ec 08             	sub    $0x8,%esp
  805348:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80534b:	50                   	push   %eax
  80534c:	68 89 50 80 00       	push   $0x805089
  805351:	e8 23 ff ff ff       	call   805279 <sys_untimeout>
    return 1;
  805356:	83 c4 10             	add    $0x10,%esp
  805359:	b8 01 00 00 00       	mov    $0x1,%eax
  80535e:	eb cc                	jmp    80532c <sys_sem_wait_timeout+0x33>

00805360 <sys_msleep>:
 *
 * @param ms number of milliseconds to sleep
 */
void
sys_msleep(u32_t ms)
{
  805360:	55                   	push   %ebp
  805361:	89 e5                	mov    %esp,%ebp
  805363:	53                   	push   %ebx
  805364:	83 ec 10             	sub    $0x10,%esp
  sys_sem_t delaysem = sys_sem_new(0);
  805367:	6a 00                	push   $0x0
  805369:	e8 f9 4a 00 00       	call   809e67 <sys_sem_new>
  80536e:	89 c3                	mov    %eax,%ebx

  sys_sem_wait_timeout(delaysem, ms);
  805370:	83 c4 08             	add    $0x8,%esp
  805373:	ff 75 08             	pushl  0x8(%ebp)
  805376:	50                   	push   %eax
  805377:	e8 7d ff ff ff       	call   8052f9 <sys_sem_wait_timeout>

  sys_sem_free(delaysem);
  80537c:	89 1c 24             	mov    %ebx,(%esp)
  80537f:	e8 64 4b 00 00       	call   809ee8 <sys_sem_free>
}
  805384:	83 c4 10             	add    $0x10,%esp
  805387:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80538a:	c9                   	leave  
  80538b:	c3                   	ret    

0080538c <tcp_accept_null>:
/**
 * Default accept callback if no accept callback is specified by the user.
 */
static err_t
tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
{
  80538c:	55                   	push   %ebp
  80538d:	89 e5                	mov    %esp,%ebp
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  return ERR_ABRT;
}
  80538f:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  805394:	5d                   	pop    %ebp
  805395:	c3                   	ret    

00805396 <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
  805396:	55                   	push   %ebp
  805397:	89 e5                	mov    %esp,%ebp
  805399:	57                   	push   %edi
  80539a:	56                   	push   %esi
  80539b:	53                   	push   %ebx
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80539c:	8b 1d 3c b2 b3 00    	mov    0xb3b23c,%ebx
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8053a2:	8b 35 50 b2 b3 00    	mov    0xb3b250,%esi
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  8053a8:	8b 3d 44 b2 b3 00    	mov    0xb3b244,%edi
  8053ae:	0f b7 05 0c 40 81 00 	movzwl 0x81400c,%eax
    port = TCP_LOCAL_PORT_RANGE_START;
  8053b5:	b9 00 10 00 00       	mov    $0x1000,%ecx
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
  8053ba:	66 83 c0 01          	add    $0x1,%ax
    port = TCP_LOCAL_PORT_RANGE_START;
  8053be:	0f 48 c1             	cmovs  %ecx,%eax
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8053c1:	89 da                	mov    %ebx,%edx
  8053c3:	85 d2                	test   %edx,%edx
  8053c5:	74 0b                	je     8053d2 <tcp_new_port+0x3c>
    if (pcb->local_port == port) {
  8053c7:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  8053cb:	74 ed                	je     8053ba <tcp_new_port+0x24>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8053cd:	8b 52 0c             	mov    0xc(%edx),%edx
  8053d0:	eb f1                	jmp    8053c3 <tcp_new_port+0x2d>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8053d2:	89 f2                	mov    %esi,%edx
  8053d4:	85 d2                	test   %edx,%edx
  8053d6:	74 0b                	je     8053e3 <tcp_new_port+0x4d>
    if (pcb->local_port == port) {
  8053d8:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  8053dc:	74 dc                	je     8053ba <tcp_new_port+0x24>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8053de:	8b 52 0c             	mov    0xc(%edx),%edx
  8053e1:	eb f1                	jmp    8053d4 <tcp_new_port+0x3e>
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  8053e3:	89 fa                	mov    %edi,%edx
  8053e5:	85 d2                	test   %edx,%edx
  8053e7:	74 0b                	je     8053f4 <tcp_new_port+0x5e>
    if (pcb->local_port == port) {
  8053e9:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  8053ed:	74 cb                	je     8053ba <tcp_new_port+0x24>
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  8053ef:	8b 52 0c             	mov    0xc(%edx),%edx
  8053f2:	eb f1                	jmp    8053e5 <tcp_new_port+0x4f>
  8053f4:	66 a3 0c 40 81 00    	mov    %ax,0x81400c
      goto again;
    }
  }
  return port;
}
  8053fa:	5b                   	pop    %ebx
  8053fb:	5e                   	pop    %esi
  8053fc:	5f                   	pop    %edi
  8053fd:	5d                   	pop    %ebp
  8053fe:	c3                   	ret    

008053ff <tcp_bind>:
{
  8053ff:	55                   	push   %ebp
  805400:	89 e5                	mov    %esp,%ebp
  805402:	57                   	push   %edi
  805403:	56                   	push   %esi
  805404:	53                   	push   %ebx
  805405:	83 ec 0c             	sub    $0xc,%esp
  805408:	8b 75 08             	mov    0x8(%ebp),%esi
  80540b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80540e:	8b 55 10             	mov    0x10(%ebp),%edx
  LWIP_ERROR("tcp_connect: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  805411:	83 7e 10 00          	cmpl   $0x0,0x10(%esi)
  805415:	75 0f                	jne    805426 <tcp_bind+0x27>
  805417:	89 d0                	mov    %edx,%eax
  if (port == 0) {
  805419:	66 85 d2             	test   %dx,%dx
  80541c:	74 1f                	je     80543d <tcp_bind+0x3e>
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  80541e:	8b 15 44 b2 b3 00    	mov    0xb3b244,%edx
  805424:	eb 21                	jmp    805447 <tcp_bind+0x48>
  LWIP_ERROR("tcp_connect: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  805426:	83 ec 04             	sub    $0x4,%esp
  805429:	68 48 1d 81 00       	push   $0x811d48
  80542e:	68 05 01 00 00       	push   $0x105
  805433:	68 2a 1f 81 00       	push   $0x811f2a
  805438:	e8 16 92 00 00       	call   80e653 <_panic>
    port = tcp_new_port();
  80543d:	e8 54 ff ff ff       	call   805396 <tcp_new_port>
  805442:	eb da                	jmp    80541e <tcp_bind+0x1f>
      cpcb != NULL; cpcb = cpcb->next) {
  805444:	8b 52 0c             	mov    0xc(%edx),%edx
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  805447:	85 d2                	test   %edx,%edx
  805449:	74 34                	je     80547f <tcp_bind+0x80>
    if (cpcb->local_port == port) {
  80544b:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  80544f:	75 f3                	jne    805444 <tcp_bind+0x45>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  805451:	85 d2                	test   %edx,%edx
  805453:	0f 84 f6 00 00 00    	je     80554f <tcp_bind+0x150>
  805459:	8b 0a                	mov    (%edx),%ecx
  80545b:	85 db                	test   %ebx,%ebx
  80545d:	0f 84 f3 00 00 00    	je     805556 <tcp_bind+0x157>
  805463:	85 c9                	test   %ecx,%ecx
  805465:	0f 84 eb 00 00 00    	je     805556 <tcp_bind+0x157>
          ip_addr_isany(ipaddr) ||
  80546b:	8b 3b                	mov    (%ebx),%edi
  80546d:	39 f9                	cmp    %edi,%ecx
  80546f:	74 04                	je     805475 <tcp_bind+0x76>
  805471:	85 ff                	test   %edi,%edi
  805473:	75 cf                	jne    805444 <tcp_bind+0x45>
        return ERR_USE;
  805475:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80547a:	e9 dc 00 00 00       	jmp    80555b <tcp_bind+0x15c>
  for(cpcb = tcp_active_pcbs;
  80547f:	8b 15 3c b2 b3 00    	mov    0xb3b23c,%edx
  805485:	eb 03                	jmp    80548a <tcp_bind+0x8b>
      cpcb != NULL; cpcb = cpcb->next) {
  805487:	8b 52 0c             	mov    0xc(%edx),%edx
  for(cpcb = tcp_active_pcbs;
  80548a:	85 d2                	test   %edx,%edx
  80548c:	74 34                	je     8054c2 <tcp_bind+0xc3>
    if (cpcb->local_port == port) {
  80548e:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  805492:	75 f3                	jne    805487 <tcp_bind+0x88>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  805494:	85 d2                	test   %edx,%edx
  805496:	0f 84 c7 00 00 00    	je     805563 <tcp_bind+0x164>
  80549c:	8b 0a                	mov    (%edx),%ecx
  80549e:	85 db                	test   %ebx,%ebx
  8054a0:	0f 84 c4 00 00 00    	je     80556a <tcp_bind+0x16b>
  8054a6:	85 c9                	test   %ecx,%ecx
  8054a8:	0f 84 bc 00 00 00    	je     80556a <tcp_bind+0x16b>
          ip_addr_isany(ipaddr) ||
  8054ae:	8b 3b                	mov    (%ebx),%edi
  8054b0:	39 f9                	cmp    %edi,%ecx
  8054b2:	74 04                	je     8054b8 <tcp_bind+0xb9>
  8054b4:	85 ff                	test   %edi,%edi
  8054b6:	75 cf                	jne    805487 <tcp_bind+0x88>
        return ERR_USE;
  8054b8:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  8054bd:	e9 99 00 00 00       	jmp    80555b <tcp_bind+0x15c>
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  8054c2:	8b 15 4c b2 b3 00    	mov    0xb3b24c,%edx
  8054c8:	eb 03                	jmp    8054cd <tcp_bind+0xce>
  8054ca:	8b 52 0c             	mov    0xc(%edx),%edx
  8054cd:	85 d2                	test   %edx,%edx
  8054cf:	74 31                	je     805502 <tcp_bind+0x103>
    if (cpcb->local_port == port) {
  8054d1:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  8054d5:	75 f3                	jne    8054ca <tcp_bind+0xcb>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  8054d7:	85 d2                	test   %edx,%edx
  8054d9:	0f 84 92 00 00 00    	je     805571 <tcp_bind+0x172>
  8054df:	8b 0a                	mov    (%edx),%ecx
  8054e1:	85 db                	test   %ebx,%ebx
  8054e3:	0f 84 8f 00 00 00    	je     805578 <tcp_bind+0x179>
  8054e9:	85 c9                	test   %ecx,%ecx
  8054eb:	0f 84 87 00 00 00    	je     805578 <tcp_bind+0x179>
          ip_addr_isany(ipaddr) ||
  8054f1:	8b 3b                	mov    (%ebx),%edi
  8054f3:	39 f9                	cmp    %edi,%ecx
  8054f5:	74 04                	je     8054fb <tcp_bind+0xfc>
  8054f7:	85 ff                	test   %edi,%edi
  8054f9:	75 cf                	jne    8054ca <tcp_bind+0xcb>
        return ERR_USE;
  8054fb:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805500:	eb 59                	jmp    80555b <tcp_bind+0x15c>
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  805502:	8b 15 50 b2 b3 00    	mov    0xb3b250,%edx
  805508:	eb 03                	jmp    80550d <tcp_bind+0x10e>
  80550a:	8b 52 0c             	mov    0xc(%edx),%edx
  80550d:	85 d2                	test   %edx,%edx
  80550f:	74 13                	je     805524 <tcp_bind+0x125>
    if (cpcb->local_port == port) {
  805511:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  805515:	75 f3                	jne    80550a <tcp_bind+0x10b>
      if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  805517:	8b 3b                	mov    (%ebx),%edi
  805519:	39 3a                	cmp    %edi,(%edx)
  80551b:	75 ed                	jne    80550a <tcp_bind+0x10b>
        return ERR_USE;
  80551d:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805522:	eb 37                	jmp    80555b <tcp_bind+0x15c>
  if (!ip_addr_isany(ipaddr)) {
  805524:	85 db                	test   %ebx,%ebx
  805526:	74 09                	je     805531 <tcp_bind+0x132>
  805528:	83 3b 00             	cmpl   $0x0,(%ebx)
  80552b:	74 04                	je     805531 <tcp_bind+0x132>
    pcb->local_ip = *ipaddr;
  80552d:	8b 13                	mov    (%ebx),%edx
  80552f:	89 16                	mov    %edx,(%esi)
  pcb->local_port = port;
  805531:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  TCP_REG(&tcp_bound_pcbs, pcb);
  805535:	a1 4c b2 b3 00       	mov    0xb3b24c,%eax
  80553a:	89 46 0c             	mov    %eax,0xc(%esi)
  80553d:	89 35 4c b2 b3 00    	mov    %esi,0xb3b24c
  805543:	e8 6f cc ff ff       	call   8021b7 <tcp_timer_needed>
  return ERR_OK;
  805548:	b8 00 00 00 00       	mov    $0x0,%eax
  80554d:	eb 0c                	jmp    80555b <tcp_bind+0x15c>
        return ERR_USE;
  80554f:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805554:	eb 05                	jmp    80555b <tcp_bind+0x15c>
  805556:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
}
  80555b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80555e:	5b                   	pop    %ebx
  80555f:	5e                   	pop    %esi
  805560:	5f                   	pop    %edi
  805561:	5d                   	pop    %ebp
  805562:	c3                   	ret    
        return ERR_USE;
  805563:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805568:	eb f1                	jmp    80555b <tcp_bind+0x15c>
  80556a:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80556f:	eb ea                	jmp    80555b <tcp_bind+0x15c>
        return ERR_USE;
  805571:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805576:	eb e3                	jmp    80555b <tcp_bind+0x15c>
  805578:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80557d:	eb dc                	jmp    80555b <tcp_bind+0x15c>

0080557f <tcp_listen_with_backlog>:
{
  80557f:	55                   	push   %ebp
  805580:	89 e5                	mov    %esp,%ebp
  805582:	57                   	push   %edi
  805583:	56                   	push   %esi
  805584:	53                   	push   %ebx
  805585:	83 ec 1c             	sub    $0x1c,%esp
  805588:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
  80558b:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  80558f:	0f 85 8e 00 00 00    	jne    805623 <tcp_listen_with_backlog+0xa4>
  lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
  805595:	83 ec 0c             	sub    $0xc,%esp
  805598:	6a 03                	push   $0x3
  80559a:	e8 e9 ee ff ff       	call   804488 <memp_malloc>
  80559f:	89 c6                	mov    %eax,%esi
  if (lpcb == NULL) {
  8055a1:	83 c4 10             	add    $0x10,%esp
  8055a4:	85 c0                	test   %eax,%eax
  8055a6:	0f 84 03 01 00 00    	je     8056af <tcp_listen_with_backlog+0x130>
  lpcb->callback_arg = pcb->callback_arg;
  8055ac:	8b 43 18             	mov    0x18(%ebx),%eax
  8055af:	89 46 18             	mov    %eax,0x18(%esi)
  lpcb->local_port = pcb->local_port;
  8055b2:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  8055b6:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  lpcb->state = LISTEN;
  8055ba:	c7 46 10 01 00 00 00 	movl   $0x1,0x10(%esi)
  lpcb->so_options |= SOF_ACCEPTCONN;
  8055c1:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  8055c5:	83 c8 02             	or     $0x2,%eax
  8055c8:	66 89 46 08          	mov    %ax,0x8(%esi)
  lpcb->ttl = pcb->ttl;
  8055cc:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  8055d0:	88 46 0b             	mov    %al,0xb(%esi)
  lpcb->tos = pcb->tos;
  8055d3:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  8055d7:	88 46 0a             	mov    %al,0xa(%esi)
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
  8055da:	b8 00 00 00 00       	mov    $0x0,%eax
  8055df:	85 db                	test   %ebx,%ebx
  8055e1:	74 02                	je     8055e5 <tcp_listen_with_backlog+0x66>
  8055e3:	8b 03                	mov    (%ebx),%eax
  8055e5:	89 06                	mov    %eax,(%esi)
  TCP_RMV(&tcp_bound_pcbs, pcb);
  8055e7:	8b 15 4c b2 b3 00    	mov    0xb3b24c,%edx
  8055ed:	39 da                	cmp    %ebx,%edx
  8055ef:	74 49                	je     80563a <tcp_listen_with_backlog+0xbb>
  8055f1:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  8055f7:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  8055fb:	bf 01 00 00 00       	mov    $0x1,%edi
  805600:	89 75 e0             	mov    %esi,-0x20(%ebp)
  805603:	89 de                	mov    %ebx,%esi
  805605:	85 d2                	test   %edx,%edx
  805607:	74 56                	je     80565f <tcp_listen_with_backlog+0xe0>
  805609:	8b 42 0c             	mov    0xc(%edx),%eax
  80560c:	39 f0                	cmp    %esi,%eax
  80560e:	0f 94 c3             	sete   %bl
  805611:	85 c0                	test   %eax,%eax
  805613:	0f 95 c1             	setne  %cl
  805616:	84 cb                	test   %cl,%bl
  805618:	75 2a                	jne    805644 <tcp_listen_with_backlog+0xc5>
  80561a:	89 f9                	mov    %edi,%ecx
  80561c:	88 4d e7             	mov    %cl,-0x19(%ebp)
  80561f:	89 c2                	mov    %eax,%edx
  805621:	eb e2                	jmp    805605 <tcp_listen_with_backlog+0x86>
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
  805623:	83 ec 04             	sub    $0x4,%esp
  805626:	68 74 1d 81 00       	push   $0x811d74
  80562b:	68 60 01 00 00       	push   $0x160
  805630:	68 2a 1f 81 00       	push   $0x811f2a
  805635:	e8 19 90 00 00       	call   80e653 <_panic>
  TCP_RMV(&tcp_bound_pcbs, pcb);
  80563a:	8b 42 0c             	mov    0xc(%edx),%eax
  80563d:	a3 4c b2 b3 00       	mov    %eax,0xb3b24c
  805642:	eb 26                	jmp    80566a <tcp_listen_with_backlog+0xeb>
  805644:	89 f3                	mov    %esi,%ebx
  805646:	8b 75 e0             	mov    -0x20(%ebp),%esi
  805649:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
  80564d:	75 08                	jne    805657 <tcp_listen_with_backlog+0xd8>
  80564f:	8b 43 0c             	mov    0xc(%ebx),%eax
  805652:	89 42 0c             	mov    %eax,0xc(%edx)
  805655:	eb 13                	jmp    80566a <tcp_listen_with_backlog+0xeb>
  805657:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  80565d:	eb f0                	jmp    80564f <tcp_listen_with_backlog+0xd0>
  80565f:	89 f3                	mov    %esi,%ebx
  805661:	8b 75 e0             	mov    -0x20(%ebp),%esi
  805664:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
  805668:	75 39                	jne    8056a3 <tcp_listen_with_backlog+0x124>
  80566a:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  memp_free(MEMP_TCP_PCB, pcb);
  805671:	83 ec 08             	sub    $0x8,%esp
  805674:	53                   	push   %ebx
  805675:	6a 02                	push   $0x2
  805677:	e8 62 ee ff ff       	call   8044de <memp_free>
  lpcb->accept = tcp_accept_null;
  80567c:	c7 46 20 8c 53 80 00 	movl   $0x80538c,0x20(%esi)
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
  805683:	a1 44 b2 b3 00       	mov    0xb3b244,%eax
  805688:	89 46 0c             	mov    %eax,0xc(%esi)
  80568b:	89 35 44 b2 b3 00    	mov    %esi,0xb3b244
  805691:	e8 21 cb ff ff       	call   8021b7 <tcp_timer_needed>
  return (struct tcp_pcb *)lpcb;
  805696:	83 c4 10             	add    $0x10,%esp
}
  805699:	89 f0                	mov    %esi,%eax
  80569b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80569e:	5b                   	pop    %ebx
  80569f:	5e                   	pop    %esi
  8056a0:	5f                   	pop    %edi
  8056a1:	5d                   	pop    %ebp
  8056a2:	c3                   	ret    
  8056a3:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  8056aa:	00 00 00 
  8056ad:	eb bb                	jmp    80566a <tcp_listen_with_backlog+0xeb>
    return NULL;
  8056af:	be 00 00 00 00       	mov    $0x0,%esi
  8056b4:	eb e3                	jmp    805699 <tcp_listen_with_backlog+0x11a>

008056b6 <tcp_recved>:
{
  8056b6:	55                   	push   %ebp
  8056b7:	89 e5                	mov    %esp,%ebp
  8056b9:	56                   	push   %esi
  8056ba:	53                   	push   %ebx
  8056bb:	8b 45 08             	mov    0x8(%ebp),%eax
  8056be:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  if ((u32_t)pcb->rcv_wnd + len > TCP_WND) {
  8056c1:	0f b7 50 28          	movzwl 0x28(%eax),%edx
  8056c5:	0f b7 ca             	movzwl %dx,%ecx
  8056c8:	0f b7 f3             	movzwl %bx,%esi
  8056cb:	01 f1                	add    %esi,%ecx
  8056cd:	81 f9 c0 5d 00 00    	cmp    $0x5dc0,%ecx
  8056d3:	76 27                	jbe    8056fc <tcp_recved+0x46>
    pcb->rcv_wnd = TCP_WND;
  8056d5:	66 c7 40 28 c0 5d    	movw   $0x5dc0,0x28(%eax)
    pcb->rcv_ann_wnd = TCP_WND;
  8056db:	66 c7 40 2a c0 5d    	movw   $0x5dc0,0x2a(%eax)
  if (!(pcb->flags & TF_ACK_DELAY) &&
  8056e1:	0f b6 50 20          	movzbl 0x20(%eax),%edx
  8056e5:	f6 c2 03             	test   $0x3,%dl
  8056e8:	75 3b                	jne    805725 <tcp_recved+0x6f>
    tcp_ack(pcb);
  8056ea:	f6 c2 01             	test   $0x1,%dl
  8056ed:	75 1f                	jne    80570e <tcp_recved+0x58>
  8056ef:	83 ca 01             	or     $0x1,%edx
  8056f2:	88 50 20             	mov    %dl,0x20(%eax)
}
  8056f5:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8056f8:	5b                   	pop    %ebx
  8056f9:	5e                   	pop    %esi
  8056fa:	5d                   	pop    %ebp
  8056fb:	c3                   	ret    
    pcb->rcv_wnd += len;
  8056fc:	01 da                	add    %ebx,%edx
  8056fe:	66 89 50 28          	mov    %dx,0x28(%eax)
    if (pcb->rcv_wnd >= pcb->mss) {
  805702:	66 3b 50 34          	cmp    0x34(%eax),%dx
  805706:	72 d9                	jb     8056e1 <tcp_recved+0x2b>
      pcb->rcv_ann_wnd = pcb->rcv_wnd;
  805708:	66 89 50 2a          	mov    %dx,0x2a(%eax)
  80570c:	eb d3                	jmp    8056e1 <tcp_recved+0x2b>
    tcp_ack(pcb);
  80570e:	83 e2 fe             	and    $0xfffffffe,%edx
  805711:	83 ca 02             	or     $0x2,%edx
  805714:	88 50 20             	mov    %dl,0x20(%eax)
  805717:	83 ec 0c             	sub    $0xc,%esp
  80571a:	50                   	push   %eax
  80571b:	e8 e2 29 00 00       	call   808102 <tcp_output>
  805720:	83 c4 10             	add    $0x10,%esp
  805723:	eb d0                	jmp    8056f5 <tcp_recved+0x3f>
  else if (pcb->flags & TF_ACK_DELAY && pcb->rcv_wnd >= TCP_WND/2) {
  805725:	f6 c2 01             	test   $0x1,%dl
  805728:	74 cb                	je     8056f5 <tcp_recved+0x3f>
  80572a:	66 81 78 28 df 2e    	cmpw   $0x2edf,0x28(%eax)
  805730:	76 c3                	jbe    8056f5 <tcp_recved+0x3f>
    tcp_ack_now(pcb);
  805732:	83 ca 02             	or     $0x2,%edx
  805735:	88 50 20             	mov    %dl,0x20(%eax)
  805738:	83 ec 0c             	sub    $0xc,%esp
  80573b:	50                   	push   %eax
  80573c:	e8 c1 29 00 00       	call   808102 <tcp_output>
  805741:	83 c4 10             	add    $0x10,%esp
}
  805744:	eb af                	jmp    8056f5 <tcp_recved+0x3f>

00805746 <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
  805746:	55                   	push   %ebp
  805747:	89 e5                	mov    %esp,%ebp
  805749:	53                   	push   %ebx
  80574a:	83 ec 04             	sub    $0x4,%esp
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80574d:	8b 1d 3c b2 b3 00    	mov    0xb3b23c,%ebx
  805753:	eb 21                	jmp    805776 <tcp_fasttmr+0x30>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  805755:	83 ec 0c             	sub    $0xc,%esp
  805758:	50                   	push   %eax
  805759:	e8 ef f0 ff ff       	call   80484d <pbuf_free>
  80575e:	83 c4 10             	add    $0x10,%esp
      if (err == ERR_OK) {
        pcb->refused_data = NULL;
  805761:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  805768:	00 00 00 
      }
    }

    /* send delayed ACKs */  
    if (pcb->flags & TF_ACK_DELAY) {
  80576b:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
  80576f:	a8 01                	test   $0x1,%al
  805771:	75 2d                	jne    8057a0 <tcp_fasttmr+0x5a>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  805773:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  805776:	85 db                	test   %ebx,%ebx
  805778:	74 3e                	je     8057b8 <tcp_fasttmr+0x72>
    if (pcb->refused_data != NULL) {
  80577a:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  805780:	85 c0                	test   %eax,%eax
  805782:	74 e7                	je     80576b <tcp_fasttmr+0x25>
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  805784:	8b 93 88 00 00 00    	mov    0x88(%ebx),%edx
  80578a:	85 d2                	test   %edx,%edx
  80578c:	74 c7                	je     805755 <tcp_fasttmr+0xf>
  80578e:	6a 00                	push   $0x0
  805790:	50                   	push   %eax
  805791:	53                   	push   %ebx
  805792:	ff 73 18             	pushl  0x18(%ebx)
  805795:	ff d2                	call   *%edx
      if (err == ERR_OK) {
  805797:	83 c4 10             	add    $0x10,%esp
  80579a:	84 c0                	test   %al,%al
  80579c:	74 c3                	je     805761 <tcp_fasttmr+0x1b>
  80579e:	eb cb                	jmp    80576b <tcp_fasttmr+0x25>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
  8057a0:	83 c8 02             	or     $0x2,%eax
  8057a3:	88 43 20             	mov    %al,0x20(%ebx)
  8057a6:	83 ec 0c             	sub    $0xc,%esp
  8057a9:	53                   	push   %ebx
  8057aa:	e8 53 29 00 00       	call   808102 <tcp_output>
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  8057af:	80 63 20 fc          	andb   $0xfc,0x20(%ebx)
  8057b3:	83 c4 10             	add    $0x10,%esp
  8057b6:	eb bb                	jmp    805773 <tcp_fasttmr+0x2d>
    }
  }
}
  8057b8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8057bb:	c9                   	leave  
  8057bc:	c3                   	ret    

008057bd <tcp_seg_free>:
 * @param seg single tcp_seg to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  8057bd:	55                   	push   %ebp
  8057be:	89 e5                	mov    %esp,%ebp
  8057c0:	56                   	push   %esi
  8057c1:	53                   	push   %ebx
  8057c2:	8b 5d 08             	mov    0x8(%ebp),%ebx
  u8_t count = 0;
  8057c5:	be 00 00 00 00       	mov    $0x0,%esi
  
  if (seg != NULL) {
  8057ca:	85 db                	test   %ebx,%ebx
  8057cc:	74 23                	je     8057f1 <tcp_seg_free+0x34>
    if (seg->p != NULL) {
  8057ce:	8b 43 04             	mov    0x4(%ebx),%eax
  8057d1:	85 c0                	test   %eax,%eax
  8057d3:	74 0e                	je     8057e3 <tcp_seg_free+0x26>
      count = pbuf_free(seg->p);
  8057d5:	83 ec 0c             	sub    $0xc,%esp
  8057d8:	50                   	push   %eax
  8057d9:	e8 6f f0 ff ff       	call   80484d <pbuf_free>
  8057de:	89 c6                	mov    %eax,%esi
  8057e0:	83 c4 10             	add    $0x10,%esp
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
  8057e3:	83 ec 08             	sub    $0x8,%esp
  8057e6:	53                   	push   %ebx
  8057e7:	6a 04                	push   $0x4
  8057e9:	e8 f0 ec ff ff       	call   8044de <memp_free>
  8057ee:	83 c4 10             	add    $0x10,%esp
  }
  return count;
}
  8057f1:	89 f0                	mov    %esi,%eax
  8057f3:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8057f6:	5b                   	pop    %ebx
  8057f7:	5e                   	pop    %esi
  8057f8:	5d                   	pop    %ebp
  8057f9:	c3                   	ret    

008057fa <tcp_segs_free>:
{
  8057fa:	55                   	push   %ebp
  8057fb:	89 e5                	mov    %esp,%ebp
  8057fd:	56                   	push   %esi
  8057fe:	53                   	push   %ebx
  8057ff:	8b 45 08             	mov    0x8(%ebp),%eax
  u8_t count = 0;
  805802:	bb 00 00 00 00       	mov    $0x0,%ebx
  while (seg != NULL) {
  805807:	eb 12                	jmp    80581b <tcp_segs_free+0x21>
    next = seg->next;
  805809:	8b 30                	mov    (%eax),%esi
    count += tcp_seg_free(seg);
  80580b:	83 ec 0c             	sub    $0xc,%esp
  80580e:	50                   	push   %eax
  80580f:	e8 a9 ff ff ff       	call   8057bd <tcp_seg_free>
  805814:	01 c3                	add    %eax,%ebx
    seg = next;
  805816:	83 c4 10             	add    $0x10,%esp
  805819:	89 f0                	mov    %esi,%eax
  while (seg != NULL) {
  80581b:	85 c0                	test   %eax,%eax
  80581d:	75 ea                	jne    805809 <tcp_segs_free+0xf>
}
  80581f:	89 d8                	mov    %ebx,%eax
  805821:	8d 65 f8             	lea    -0x8(%ebp),%esp
  805824:	5b                   	pop    %ebx
  805825:	5e                   	pop    %esi
  805826:	5d                   	pop    %ebp
  805827:	c3                   	ret    

00805828 <tcp_setprio>:
 * @param pcb the tcp_pcb to manipulate
 * @param prio new priority
 */
void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
  805828:	55                   	push   %ebp
  805829:	89 e5                	mov    %esp,%ebp
  pcb->prio = prio;
  80582b:	8b 45 08             	mov    0x8(%ebp),%eax
  80582e:	8b 55 0c             	mov    0xc(%ebp),%edx
  805831:	88 50 14             	mov    %dl,0x14(%eax)
}
  805834:	5d                   	pop    %ebp
  805835:	c3                   	ret    

00805836 <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */ 
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
  805836:	55                   	push   %ebp
  805837:	89 e5                	mov    %esp,%ebp
  805839:	53                   	push   %ebx
  80583a:	83 ec 10             	sub    $0x10,%esp
  struct tcp_seg *cseg;

  cseg = memp_malloc(MEMP_TCP_SEG);
  80583d:	6a 04                	push   $0x4
  80583f:	e8 44 ec ff ff       	call   804488 <memp_malloc>
  805844:	89 c3                	mov    %eax,%ebx
  if (cseg == NULL) {
  805846:	83 c4 10             	add    $0x10,%esp
  805849:	85 c0                	test   %eax,%eax
  80584b:	74 1c                	je     805869 <tcp_seg_copy+0x33>
    return NULL;
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
  80584d:	83 ec 04             	sub    $0x4,%esp
  805850:	6a 14                	push   $0x14
  805852:	ff 75 08             	pushl  0x8(%ebp)
  805855:	50                   	push   %eax
  805856:	e8 66 97 00 00       	call   80efc1 <memcpy>
  pbuf_ref(cseg->p);
  80585b:	83 c4 04             	add    $0x4,%esp
  80585e:	ff 73 04             	pushl  0x4(%ebx)
  805861:	e8 42 f4 ff ff       	call   804ca8 <pbuf_ref>
  return cseg;
  805866:	83 c4 10             	add    $0x10,%esp
}
  805869:	89 d8                	mov    %ebx,%eax
  80586b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80586e:	c9                   	leave  
  80586f:	c3                   	ret    

00805870 <tcp_arg>:
 * @param pcb tcp_pcb to set the callback argument
 * @param arg void pointer argument to pass to callback functions
 */ 
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{  
  805870:	55                   	push   %ebp
  805871:	89 e5                	mov    %esp,%ebp
  pcb->callback_arg = arg;
  805873:	8b 45 08             	mov    0x8(%ebp),%eax
  805876:	8b 55 0c             	mov    0xc(%ebp),%edx
  805879:	89 50 18             	mov    %edx,0x18(%eax)
}
  80587c:	5d                   	pop    %ebp
  80587d:	c3                   	ret    

0080587e <tcp_recv>:
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb,
   err_t (* recv)(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err))
{
  80587e:	55                   	push   %ebp
  80587f:	89 e5                	mov    %esp,%ebp
  pcb->recv = recv;
  805881:	8b 45 08             	mov    0x8(%ebp),%eax
  805884:	8b 55 0c             	mov    0xc(%ebp),%edx
  805887:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
}
  80588d:	5d                   	pop    %ebp
  80588e:	c3                   	ret    

0080588f <tcp_sent>:
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb,
   err_t (* sent)(void *arg, struct tcp_pcb *tpcb, u16_t len))
{
  80588f:	55                   	push   %ebp
  805890:	89 e5                	mov    %esp,%ebp
  pcb->sent = sent;
  805892:	8b 45 08             	mov    0x8(%ebp),%eax
  805895:	8b 55 0c             	mov    0xc(%ebp),%edx
  805898:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)
}
  80589e:	5d                   	pop    %ebp
  80589f:	c3                   	ret    

008058a0 <tcp_err>:
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb,
   void (* errf)(void *arg, err_t err))
{
  8058a0:	55                   	push   %ebp
  8058a1:	89 e5                	mov    %esp,%ebp
  pcb->errf = errf;
  8058a3:	8b 45 08             	mov    0x8(%ebp),%eax
  8058a6:	8b 55 0c             	mov    0xc(%ebp),%edx
  8058a9:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
}
  8058af:	5d                   	pop    %ebp
  8058b0:	c3                   	ret    

008058b1 <tcp_accept>:
 *        connection has been connected to another host
 */ 
void
tcp_accept(struct tcp_pcb *pcb,
     err_t (* accept)(void *arg, struct tcp_pcb *newpcb, err_t err))
{
  8058b1:	55                   	push   %ebp
  8058b2:	89 e5                	mov    %esp,%ebp
  ((struct tcp_pcb_listen *)pcb)->accept = accept;
  8058b4:	8b 45 08             	mov    0x8(%ebp),%eax
  8058b7:	8b 55 0c             	mov    0xc(%ebp),%edx
  8058ba:	89 50 20             	mov    %edx,0x20(%eax)
}
  8058bd:	5d                   	pop    %ebp
  8058be:	c3                   	ret    

008058bf <tcp_poll>:
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb,
   err_t (* poll)(void *arg, struct tcp_pcb *tpcb), u8_t interval)
{
  8058bf:	55                   	push   %ebp
  8058c0:	89 e5                	mov    %esp,%ebp
  8058c2:	8b 45 08             	mov    0x8(%ebp),%eax
#if LWIP_CALLBACK_API
  pcb->poll = poll;
  8058c5:	8b 55 0c             	mov    0xc(%ebp),%edx
  8058c8:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
  8058ce:	8b 55 10             	mov    0x10(%ebp),%edx
  8058d1:	88 50 31             	mov    %dl,0x31(%eax)
}
  8058d4:	5d                   	pop    %ebp
  8058d5:	c3                   	ret    

008058d6 <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  8058d6:	55                   	push   %ebp
  8058d7:	89 e5                	mov    %esp,%ebp
  8058d9:	53                   	push   %ebx
  8058da:	83 ec 04             	sub    $0x4,%esp
  8058dd:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (pcb->state != CLOSED &&
  8058e0:	8b 43 10             	mov    0x10(%ebx),%eax
     pcb->state != TIME_WAIT &&
  8058e3:	83 f8 0a             	cmp    $0xa,%eax
  8058e6:	74 65                	je     80594d <tcp_pcb_purge+0x77>
  8058e8:	83 f8 01             	cmp    $0x1,%eax
  8058eb:	76 60                	jbe    80594d <tcp_pcb_purge+0x77>
     pcb->state != LISTEN) {

    LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));

    if (pcb->refused_data != NULL) {
  8058ed:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  8058f3:	85 c0                	test   %eax,%eax
  8058f5:	74 16                	je     80590d <tcp_pcb_purge+0x37>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
  8058f7:	83 ec 0c             	sub    $0xc,%esp
  8058fa:	50                   	push   %eax
  8058fb:	e8 4d ef ff ff       	call   80484d <pbuf_free>
      pcb->refused_data = NULL;
  805900:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  805907:	00 00 00 
  80590a:	83 c4 10             	add    $0x10,%esp
    }
    if (pcb->unacked != NULL) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->unacked\n"));
    }
#if TCP_QUEUE_OOSEQ /* LW */
    if (pcb->ooseq != NULL) {
  80590d:	8b 43 7c             	mov    0x7c(%ebx),%eax
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
    }

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
  805910:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)

    tcp_segs_free(pcb->ooseq);
  805916:	83 ec 0c             	sub    $0xc,%esp
  805919:	50                   	push   %eax
  80591a:	e8 db fe ff ff       	call   8057fa <tcp_segs_free>
    pcb->ooseq = NULL;
  80591f:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
#endif /* TCP_QUEUE_OOSEQ */
    tcp_segs_free(pcb->unsent);
  805926:	83 c4 04             	add    $0x4,%esp
  805929:	ff 73 74             	pushl  0x74(%ebx)
  80592c:	e8 c9 fe ff ff       	call   8057fa <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
  805931:	83 c4 04             	add    $0x4,%esp
  805934:	ff 73 78             	pushl  0x78(%ebx)
  805937:	e8 be fe ff ff       	call   8057fa <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
  80593c:	c7 43 74 00 00 00 00 	movl   $0x0,0x74(%ebx)
  805943:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)
  80594a:	83 c4 10             	add    $0x10,%esp
  }
}
  80594d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  805950:	c9                   	leave  
  805951:	c3                   	ret    

00805952 <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is also deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  805952:	55                   	push   %ebp
  805953:	89 e5                	mov    %esp,%ebp
  805955:	57                   	push   %edi
  805956:	56                   	push   %esi
  805957:	53                   	push   %ebx
  805958:	83 ec 1c             	sub    $0x1c,%esp
  80595b:	8b 45 08             	mov    0x8(%ebp),%eax
  80595e:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  TCP_RMV(pcblist, pcb);
  805961:	8b 10                	mov    (%eax),%edx
  805963:	39 da                	cmp    %ebx,%edx
  805965:	74 2f                	je     805996 <tcp_pcb_remove+0x44>
  805967:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  80596d:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  805971:	bf 01 00 00 00       	mov    $0x1,%edi
  805976:	89 de                	mov    %ebx,%esi
  805978:	85 d2                	test   %edx,%edx
  80597a:	74 39                	je     8059b5 <tcp_pcb_remove+0x63>
  80597c:	8b 42 0c             	mov    0xc(%edx),%eax
  80597f:	39 f0                	cmp    %esi,%eax
  805981:	0f 94 c3             	sete   %bl
  805984:	85 c0                	test   %eax,%eax
  805986:	0f 95 c1             	setne  %cl
  805989:	84 cb                	test   %cl,%bl
  80598b:	75 10                	jne    80599d <tcp_pcb_remove+0x4b>
  80598d:	89 f9                	mov    %edi,%ecx
  80598f:	88 4d e7             	mov    %cl,-0x19(%ebp)
  805992:	89 c2                	mov    %eax,%edx
  805994:	eb e2                	jmp    805978 <tcp_pcb_remove+0x26>
  805996:	8b 52 0c             	mov    0xc(%edx),%edx
  805999:	89 10                	mov    %edx,(%eax)
  80599b:	eb 20                	jmp    8059bd <tcp_pcb_remove+0x6b>
  80599d:	89 f3                	mov    %esi,%ebx
  80599f:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
  8059a3:	75 08                	jne    8059ad <tcp_pcb_remove+0x5b>
  8059a5:	8b 43 0c             	mov    0xc(%ebx),%eax
  8059a8:	89 42 0c             	mov    %eax,0xc(%edx)
  8059ab:	eb 10                	jmp    8059bd <tcp_pcb_remove+0x6b>
  8059ad:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  8059b3:	eb f0                	jmp    8059a5 <tcp_pcb_remove+0x53>
  8059b5:	89 f3                	mov    %esi,%ebx
  8059b7:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
  8059bb:	75 4f                	jne    805a0c <tcp_pcb_remove+0xba>
  8059bd:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)

  tcp_pcb_purge(pcb);
  8059c4:	83 ec 0c             	sub    $0xc,%esp
  8059c7:	53                   	push   %ebx
  8059c8:	e8 09 ff ff ff       	call   8058d6 <tcp_pcb_purge>
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
  8059cd:	8b 43 10             	mov    0x10(%ebx),%eax
  8059d0:	83 c4 10             	add    $0x10,%esp
  8059d3:	83 f8 0a             	cmp    $0xa,%eax
  8059d6:	74 0d                	je     8059e5 <tcp_pcb_remove+0x93>
  8059d8:	83 f8 01             	cmp    $0x1,%eax
  8059db:	74 08                	je     8059e5 <tcp_pcb_remove+0x93>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
  8059dd:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
     pcb->state != LISTEN &&
  8059e1:	a8 01                	test   $0x1,%al
  8059e3:	75 33                	jne    805a18 <tcp_pcb_remove+0xc6>
    pcb->flags |= TF_ACK_NOW;
    tcp_output(pcb);
  }

  if (pcb->state != LISTEN) {
  8059e5:	83 7b 10 01          	cmpl   $0x1,0x10(%ebx)
  8059e9:	74 12                	je     8059fd <tcp_pcb_remove+0xab>
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
  8059eb:	83 7b 74 00          	cmpl   $0x0,0x74(%ebx)
  8059ef:	75 3b                	jne    805a2c <tcp_pcb_remove+0xda>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
  8059f1:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  8059f5:	75 4c                	jne    805a43 <tcp_pcb_remove+0xf1>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
  8059f7:	83 7b 7c 00          	cmpl   $0x0,0x7c(%ebx)
  8059fb:	75 5d                	jne    805a5a <tcp_pcb_remove+0x108>
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
  8059fd:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
  805a04:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805a07:	5b                   	pop    %ebx
  805a08:	5e                   	pop    %esi
  805a09:	5f                   	pop    %edi
  805a0a:	5d                   	pop    %ebp
  805a0b:	c3                   	ret    
  805a0c:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  805a13:	00 00 00 
  805a16:	eb a5                	jmp    8059bd <tcp_pcb_remove+0x6b>
    pcb->flags |= TF_ACK_NOW;
  805a18:	83 c8 02             	or     $0x2,%eax
  805a1b:	88 43 20             	mov    %al,0x20(%ebx)
    tcp_output(pcb);
  805a1e:	83 ec 0c             	sub    $0xc,%esp
  805a21:	53                   	push   %ebx
  805a22:	e8 db 26 00 00       	call   808102 <tcp_output>
  805a27:	83 c4 10             	add    $0x10,%esp
  805a2a:	eb b9                	jmp    8059e5 <tcp_pcb_remove+0x93>
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
  805a2c:	83 ec 04             	sub    $0x4,%esp
  805a2f:	68 3e 1f 81 00       	push   $0x811f3e
  805a34:	68 b4 04 00 00       	push   $0x4b4
  805a39:	68 2a 1f 81 00       	push   $0x811f2a
  805a3e:	e8 10 8c 00 00       	call   80e653 <_panic>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
  805a43:	83 ec 04             	sub    $0x4,%esp
  805a46:	68 56 1f 81 00       	push   $0x811f56
  805a4b:	68 b5 04 00 00       	push   $0x4b5
  805a50:	68 2a 1f 81 00       	push   $0x811f2a
  805a55:	e8 f9 8b 00 00       	call   80e653 <_panic>
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
  805a5a:	83 ec 04             	sub    $0x4,%esp
  805a5d:	68 6f 1f 81 00       	push   $0x811f6f
  805a62:	68 b7 04 00 00       	push   $0x4b7
  805a67:	68 2a 1f 81 00       	push   $0x811f2a
  805a6c:	e8 e2 8b 00 00       	call   80e653 <_panic>

00805a71 <tcp_close>:
{
  805a71:	55                   	push   %ebp
  805a72:	89 e5                	mov    %esp,%ebp
  805a74:	57                   	push   %edi
  805a75:	56                   	push   %esi
  805a76:	53                   	push   %ebx
  805a77:	83 ec 1c             	sub    $0x1c,%esp
  805a7a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  switch (pcb->state) {
  805a7d:	83 7b 10 07          	cmpl   $0x7,0x10(%ebx)
  805a81:	0f 87 32 01 00 00    	ja     805bb9 <tcp_close+0x148>
  805a87:	8b 43 10             	mov    0x10(%ebx),%eax
  805a8a:	ff 24 85 88 1f 81 00 	jmp    *0x811f88(,%eax,4)
    TCP_RMV(&tcp_bound_pcbs, pcb);
  805a91:	8b 15 4c b2 b3 00    	mov    0xb3b24c,%edx
  805a97:	39 da                	cmp    %ebx,%edx
  805a99:	74 2f                	je     805aca <tcp_close+0x59>
  805a9b:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  805aa1:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  805aa5:	bf 01 00 00 00       	mov    $0x1,%edi
  805aaa:	89 de                	mov    %ebx,%esi
  805aac:	85 d2                	test   %edx,%edx
  805aae:	74 3c                	je     805aec <tcp_close+0x7b>
  805ab0:	8b 42 0c             	mov    0xc(%edx),%eax
  805ab3:	39 f0                	cmp    %esi,%eax
  805ab5:	0f 94 c3             	sete   %bl
  805ab8:	85 c0                	test   %eax,%eax
  805aba:	0f 95 c1             	setne  %cl
  805abd:	84 cb                	test   %cl,%bl
  805abf:	75 13                	jne    805ad4 <tcp_close+0x63>
  805ac1:	89 f9                	mov    %edi,%ecx
  805ac3:	88 4d e7             	mov    %cl,-0x19(%ebp)
  805ac6:	89 c2                	mov    %eax,%edx
  805ac8:	eb e2                	jmp    805aac <tcp_close+0x3b>
  805aca:	8b 42 0c             	mov    0xc(%edx),%eax
  805acd:	a3 4c b2 b3 00       	mov    %eax,0xb3b24c
  805ad2:	eb 20                	jmp    805af4 <tcp_close+0x83>
  805ad4:	89 f3                	mov    %esi,%ebx
  805ad6:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
  805ada:	75 08                	jne    805ae4 <tcp_close+0x73>
  805adc:	8b 43 0c             	mov    0xc(%ebx),%eax
  805adf:	89 42 0c             	mov    %eax,0xc(%edx)
  805ae2:	eb 10                	jmp    805af4 <tcp_close+0x83>
  805ae4:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  805aea:	eb f0                	jmp    805adc <tcp_close+0x6b>
  805aec:	89 f3                	mov    %esi,%ebx
  805aee:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
  805af2:	75 1f                	jne    805b13 <tcp_close+0xa2>
  805af4:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
    memp_free(MEMP_TCP_PCB, pcb);
  805afb:	83 ec 08             	sub    $0x8,%esp
  805afe:	53                   	push   %ebx
  805aff:	6a 02                	push   $0x2
  805b01:	e8 d8 e9 ff ff       	call   8044de <memp_free>
    break;
  805b06:	83 c4 10             	add    $0x10,%esp
    err = ERR_OK;
  805b09:	b8 00 00 00 00       	mov    $0x0,%eax
    break;
  805b0e:	e9 c0 00 00 00       	jmp    805bd3 <tcp_close+0x162>
  805b13:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  805b1a:	00 00 00 
  805b1d:	eb d5                	jmp    805af4 <tcp_close+0x83>
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
  805b1f:	83 ec 08             	sub    $0x8,%esp
  805b22:	53                   	push   %ebx
  805b23:	68 44 b2 b3 00       	push   $0xb3b244
  805b28:	e8 25 fe ff ff       	call   805952 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
  805b2d:	83 c4 08             	add    $0x8,%esp
  805b30:	53                   	push   %ebx
  805b31:	6a 03                	push   $0x3
  805b33:	e8 a6 e9 ff ff       	call   8044de <memp_free>
    break;
  805b38:	83 c4 10             	add    $0x10,%esp
    err = ERR_OK;
  805b3b:	b8 00 00 00 00       	mov    $0x0,%eax
    break;
  805b40:	e9 8e 00 00 00       	jmp    805bd3 <tcp_close+0x162>
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  805b45:	83 ec 08             	sub    $0x8,%esp
  805b48:	53                   	push   %ebx
  805b49:	68 3c b2 b3 00       	push   $0xb3b23c
  805b4e:	e8 ff fd ff ff       	call   805952 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  805b53:	83 c4 08             	add    $0x8,%esp
  805b56:	53                   	push   %ebx
  805b57:	6a 02                	push   $0x2
  805b59:	e8 80 e9 ff ff       	call   8044de <memp_free>
    break;
  805b5e:	83 c4 10             	add    $0x10,%esp
    err = ERR_OK;
  805b61:	b8 00 00 00 00       	mov    $0x0,%eax
    break;
  805b66:	eb 6b                	jmp    805bd3 <tcp_close+0x162>
    err = tcp_send_ctrl(pcb, TCP_FIN);
  805b68:	83 ec 08             	sub    $0x8,%esp
  805b6b:	6a 01                	push   $0x1
  805b6d:	53                   	push   %ebx
  805b6e:	e8 1b 25 00 00       	call   80808e <tcp_send_ctrl>
    if (err == ERR_OK) {
  805b73:	83 c4 10             	add    $0x10,%esp
  805b76:	84 c0                	test   %al,%al
  805b78:	75 59                	jne    805bd3 <tcp_close+0x162>
      pcb->state = FIN_WAIT_1;
  805b7a:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
  805b81:	eb 3b                	jmp    805bbe <tcp_close+0x14d>
    err = tcp_send_ctrl(pcb, TCP_FIN);
  805b83:	83 ec 08             	sub    $0x8,%esp
  805b86:	6a 01                	push   $0x1
  805b88:	53                   	push   %ebx
  805b89:	e8 00 25 00 00       	call   80808e <tcp_send_ctrl>
    if (err == ERR_OK) {
  805b8e:	83 c4 10             	add    $0x10,%esp
  805b91:	84 c0                	test   %al,%al
  805b93:	75 3e                	jne    805bd3 <tcp_close+0x162>
      pcb->state = FIN_WAIT_1;
  805b95:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
  805b9c:	eb 20                	jmp    805bbe <tcp_close+0x14d>
    err = tcp_send_ctrl(pcb, TCP_FIN);
  805b9e:	83 ec 08             	sub    $0x8,%esp
  805ba1:	6a 01                	push   $0x1
  805ba3:	53                   	push   %ebx
  805ba4:	e8 e5 24 00 00       	call   80808e <tcp_send_ctrl>
    if (err == ERR_OK) {
  805ba9:	83 c4 10             	add    $0x10,%esp
  805bac:	84 c0                	test   %al,%al
  805bae:	75 23                	jne    805bd3 <tcp_close+0x162>
      pcb->state = LAST_ACK;
  805bb0:	c7 43 10 09 00 00 00 	movl   $0x9,0x10(%ebx)
  805bb7:	eb 05                	jmp    805bbe <tcp_close+0x14d>
    pcb = NULL;
  805bb9:	bb 00 00 00 00       	mov    $0x0,%ebx
  if (pcb != NULL && err == ERR_OK) {
  805bbe:	85 db                	test   %ebx,%ebx
  805bc0:	74 19                	je     805bdb <tcp_close+0x16a>
    tcp_output(pcb);
  805bc2:	83 ec 0c             	sub    $0xc,%esp
  805bc5:	53                   	push   %ebx
  805bc6:	e8 37 25 00 00       	call   808102 <tcp_output>
  805bcb:	83 c4 10             	add    $0x10,%esp
  805bce:	b8 00 00 00 00       	mov    $0x0,%eax
}
  805bd3:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805bd6:	5b                   	pop    %ebx
  805bd7:	5e                   	pop    %esi
  805bd8:	5f                   	pop    %edi
  805bd9:	5d                   	pop    %ebp
  805bda:	c3                   	ret    
  805bdb:	b8 00 00 00 00       	mov    $0x0,%eax
  return err;
  805be0:	eb f1                	jmp    805bd3 <tcp_close+0x162>

00805be2 <tcp_recv_null>:
{
  805be2:	55                   	push   %ebp
  805be3:	89 e5                	mov    %esp,%ebp
  805be5:	83 ec 08             	sub    $0x8,%esp
  805be8:	8b 45 10             	mov    0x10(%ebp),%eax
  805beb:	8b 55 14             	mov    0x14(%ebp),%edx
  if (p != NULL) {
  805bee:	85 c0                	test   %eax,%eax
  805bf0:	75 19                	jne    805c0b <tcp_recv_null+0x29>
  return ERR_OK;
  805bf2:	b8 00 00 00 00       	mov    $0x0,%eax
  } else if (err == ERR_OK) {
  805bf7:	84 d2                	test   %dl,%dl
  805bf9:	75 21                	jne    805c1c <tcp_recv_null+0x3a>
    return tcp_close(pcb);
  805bfb:	83 ec 0c             	sub    $0xc,%esp
  805bfe:	ff 75 0c             	pushl  0xc(%ebp)
  805c01:	e8 6b fe ff ff       	call   805a71 <tcp_close>
  805c06:	83 c4 10             	add    $0x10,%esp
  805c09:	eb 11                	jmp    805c1c <tcp_recv_null+0x3a>
    pbuf_free(p);
  805c0b:	83 ec 0c             	sub    $0xc,%esp
  805c0e:	50                   	push   %eax
  805c0f:	e8 39 ec ff ff       	call   80484d <pbuf_free>
  805c14:	83 c4 10             	add    $0x10,%esp
  return ERR_OK;
  805c17:	b8 00 00 00 00       	mov    $0x0,%eax
}
  805c1c:	c9                   	leave  
  805c1d:	c3                   	ret    

00805c1e <tcp_abort>:
{
  805c1e:	55                   	push   %ebp
  805c1f:	89 e5                	mov    %esp,%ebp
  805c21:	57                   	push   %edi
  805c22:	56                   	push   %esi
  805c23:	53                   	push   %ebx
  805c24:	83 ec 2c             	sub    $0x2c,%esp
  805c27:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (pcb->state == TIME_WAIT) {
  805c2a:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  805c2e:	0f 84 d5 00 00 00    	je     805d09 <tcp_abort+0xeb>
    seqno = pcb->snd_nxt;
  805c34:	8b 43 54             	mov    0x54(%ebx),%eax
  805c37:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    ackno = pcb->rcv_nxt;
  805c3a:	8b 7b 24             	mov    0x24(%ebx),%edi
    ip_addr_set(&local_ip, &(pcb->local_ip));
  805c3d:	b8 00 00 00 00       	mov    $0x0,%eax
  805c42:	85 db                	test   %ebx,%ebx
  805c44:	74 02                	je     805c48 <tcp_abort+0x2a>
  805c46:	8b 03                	mov    (%ebx),%eax
  805c48:	89 45 e0             	mov    %eax,-0x20(%ebp)
    ip_addr_set(&remote_ip, &(pcb->remote_ip));
  805c4b:	b8 00 00 00 00       	mov    $0x0,%eax
  805c50:	83 fb fc             	cmp    $0xfffffffc,%ebx
  805c53:	74 03                	je     805c58 <tcp_abort+0x3a>
  805c55:	8b 43 04             	mov    0x4(%ebx),%eax
  805c58:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    local_port = pcb->local_port;
  805c5b:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  805c5f:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
    remote_port = pcb->remote_port;
  805c63:	0f b7 43 1e          	movzwl 0x1e(%ebx),%eax
  805c67:	66 89 45 d0          	mov    %ax,-0x30(%ebp)
    errf = pcb->errf;
  805c6b:	8b b3 98 00 00 00    	mov    0x98(%ebx),%esi
    errf_arg = pcb->callback_arg;
  805c71:	8b 43 18             	mov    0x18(%ebx),%eax
  805c74:	89 45 cc             	mov    %eax,-0x34(%ebp)
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  805c77:	83 ec 08             	sub    $0x8,%esp
  805c7a:	53                   	push   %ebx
  805c7b:	68 3c b2 b3 00       	push   $0xb3b23c
  805c80:	e8 cd fc ff ff       	call   805952 <tcp_pcb_remove>
    if (pcb->unacked != NULL) {
  805c85:	8b 43 78             	mov    0x78(%ebx),%eax
  805c88:	83 c4 10             	add    $0x10,%esp
  805c8b:	85 c0                	test   %eax,%eax
  805c8d:	74 0c                	je     805c9b <tcp_abort+0x7d>
      tcp_segs_free(pcb->unacked);
  805c8f:	83 ec 0c             	sub    $0xc,%esp
  805c92:	50                   	push   %eax
  805c93:	e8 62 fb ff ff       	call   8057fa <tcp_segs_free>
  805c98:	83 c4 10             	add    $0x10,%esp
    if (pcb->unsent != NULL) {
  805c9b:	8b 43 74             	mov    0x74(%ebx),%eax
  805c9e:	85 c0                	test   %eax,%eax
  805ca0:	74 0c                	je     805cae <tcp_abort+0x90>
      tcp_segs_free(pcb->unsent);
  805ca2:	83 ec 0c             	sub    $0xc,%esp
  805ca5:	50                   	push   %eax
  805ca6:	e8 4f fb ff ff       	call   8057fa <tcp_segs_free>
  805cab:	83 c4 10             	add    $0x10,%esp
    if (pcb->ooseq != NULL) {
  805cae:	8b 43 7c             	mov    0x7c(%ebx),%eax
  805cb1:	85 c0                	test   %eax,%eax
  805cb3:	74 0c                	je     805cc1 <tcp_abort+0xa3>
      tcp_segs_free(pcb->ooseq);
  805cb5:	83 ec 0c             	sub    $0xc,%esp
  805cb8:	50                   	push   %eax
  805cb9:	e8 3c fb ff ff       	call   8057fa <tcp_segs_free>
  805cbe:	83 c4 10             	add    $0x10,%esp
    memp_free(MEMP_TCP_PCB, pcb);
  805cc1:	83 ec 08             	sub    $0x8,%esp
  805cc4:	53                   	push   %ebx
  805cc5:	6a 02                	push   $0x2
  805cc7:	e8 12 e8 ff ff       	call   8044de <memp_free>
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
  805ccc:	83 c4 10             	add    $0x10,%esp
  805ccf:	85 f6                	test   %esi,%esi
  805cd1:	74 0d                	je     805ce0 <tcp_abort+0xc2>
  805cd3:	83 ec 08             	sub    $0x8,%esp
  805cd6:	6a fb                	push   $0xfffffffb
  805cd8:	ff 75 cc             	pushl  -0x34(%ebp)
  805cdb:	ff d6                	call   *%esi
  805cdd:	83 c4 10             	add    $0x10,%esp
    tcp_rst(seqno, ackno, &local_ip, &remote_ip, local_port, remote_port);
  805ce0:	83 ec 08             	sub    $0x8,%esp
  805ce3:	0f b7 45 d0          	movzwl -0x30(%ebp),%eax
  805ce7:	50                   	push   %eax
  805ce8:	0f b7 45 d2          	movzwl -0x2e(%ebp),%eax
  805cec:	50                   	push   %eax
  805ced:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  805cf0:	50                   	push   %eax
  805cf1:	8d 45 e0             	lea    -0x20(%ebp),%eax
  805cf4:	50                   	push   %eax
  805cf5:	57                   	push   %edi
  805cf6:	ff 75 d4             	pushl  -0x2c(%ebp)
  805cf9:	e8 c5 28 00 00       	call   8085c3 <tcp_rst>
  805cfe:	83 c4 20             	add    $0x20,%esp
}
  805d01:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805d04:	5b                   	pop    %ebx
  805d05:	5e                   	pop    %esi
  805d06:	5f                   	pop    %edi
  805d07:	5d                   	pop    %ebp
  805d08:	c3                   	ret    
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
  805d09:	83 ec 08             	sub    $0x8,%esp
  805d0c:	53                   	push   %ebx
  805d0d:	68 50 b2 b3 00       	push   $0xb3b250
  805d12:	e8 3b fc ff ff       	call   805952 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  805d17:	83 c4 08             	add    $0x8,%esp
  805d1a:	53                   	push   %ebx
  805d1b:	6a 02                	push   $0x2
  805d1d:	e8 bc e7 ff ff       	call   8044de <memp_free>
  805d22:	83 c4 10             	add    $0x10,%esp
  805d25:	eb da                	jmp    805d01 <tcp_abort+0xe3>

00805d27 <tcp_slowtmr>:
{
  805d27:	55                   	push   %ebp
  805d28:	89 e5                	mov    %esp,%ebp
  805d2a:	57                   	push   %edi
  805d2b:	56                   	push   %esi
  805d2c:	53                   	push   %ebx
  805d2d:	83 ec 1c             	sub    $0x1c,%esp
  ++tcp_ticks;
  805d30:	83 05 40 b2 b3 00 01 	addl   $0x1,0xb3b240
  pcb = tcp_active_pcbs;
  805d37:	8b 1d 3c b2 b3 00    	mov    0xb3b23c,%ebx
  err = ERR_OK;
  805d3d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  prev = NULL;
  805d41:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  805d48:	e9 d2 01 00 00       	jmp    805f1f <tcp_slowtmr+0x1f8>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
  805d4d:	83 ec 04             	sub    $0x4,%esp
  805d50:	68 98 1d 81 00       	push   $0x811d98
  805d55:	68 36 02 00 00       	push   $0x236
  805d5a:	68 2a 1f 81 00       	push   $0x811f2a
  805d5f:	e8 ef 88 00 00       	call   80e653 <_panic>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
  805d64:	83 ec 04             	sub    $0x4,%esp
  805d67:	68 c4 1d 81 00       	push   $0x811dc4
  805d6c:	68 37 02 00 00       	push   $0x237
  805d71:	68 2a 1f 81 00       	push   $0x811f2a
  805d76:	e8 d8 88 00 00       	call   80e653 <_panic>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
  805d7b:	83 ec 04             	sub    $0x4,%esp
  805d7e:	68 f0 1d 81 00       	push   $0x811df0
  805d83:	68 38 02 00 00       	push   $0x238
  805d88:	68 2a 1f 81 00       	push   $0x811f2a
  805d8d:	e8 c1 88 00 00       	call   80e653 <_panic>
    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
  805d92:	0f b6 53 46          	movzbl 0x46(%ebx),%edx
  805d96:	80 fa 06             	cmp    $0x6,%dl
  805d99:	0f 84 d0 00 00 00    	je     805e6f <tcp_slowtmr+0x148>
    else if (pcb->nrtx == TCP_MAXRTX) {
  805d9f:	80 fa 0c             	cmp    $0xc,%dl
  805da2:	0f 85 b3 01 00 00    	jne    805f5b <tcp_slowtmr+0x234>
  805da8:	be 01 00 00 00       	mov    $0x1,%esi
  805dad:	e9 c2 00 00 00       	jmp    805e74 <tcp_slowtmr+0x14d>
        if(pcb->rtime >= 0)
  805db2:	0f b7 4b 32          	movzwl 0x32(%ebx),%ecx
  805db6:	66 85 c9             	test   %cx,%cx
  805db9:	78 07                	js     805dc2 <tcp_slowtmr+0x9b>
          ++pcb->rtime;
  805dbb:	83 c1 01             	add    $0x1,%ecx
  805dbe:	66 89 4b 32          	mov    %cx,0x32(%ebx)
        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
  805dc2:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  805dc6:	0f 84 ed 01 00 00    	je     805fb9 <tcp_slowtmr+0x292>
  805dcc:	0f b7 7b 44          	movzwl 0x44(%ebx),%edi
  805dd0:	66 39 7b 32          	cmp    %di,0x32(%ebx)
  805dd4:	0f 8c df 01 00 00    	jl     805fb9 <tcp_slowtmr+0x292>
          if (pcb->state != SYN_SENT) {
  805dda:	83 f8 02             	cmp    $0x2,%eax
  805ddd:	74 1f                	je     805dfe <tcp_slowtmr+0xd7>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
  805ddf:	0f b7 43 40          	movzwl 0x40(%ebx),%eax
  805de3:	66 c1 f8 03          	sar    $0x3,%ax
  805de7:	98                   	cwtl   
  805de8:	0f bf 4b 42          	movswl 0x42(%ebx),%ecx
  805dec:	01 c8                	add    %ecx,%eax
  805dee:	0f b6 d2             	movzbl %dl,%edx
  805df1:	0f b6 8a b0 1f 81 00 	movzbl 0x811fb0(%edx),%ecx
  805df8:	d3 e0                	shl    %cl,%eax
  805dfa:	66 89 43 44          	mov    %ax,0x44(%ebx)
          pcb->rtime = 0;
  805dfe:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
  805e04:	0f b7 43 4e          	movzwl 0x4e(%ebx),%eax
  805e08:	66 39 43 5c          	cmp    %ax,0x5c(%ebx)
  805e0c:	66 0f 46 43 5c       	cmovbe 0x5c(%ebx),%ax
          pcb->ssthresh = eff_wnd >> 1;
  805e11:	66 d1 e8             	shr    %ax
  805e14:	66 89 43 50          	mov    %ax,0x50(%ebx)
          if (pcb->ssthresh < pcb->mss) {
  805e18:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
  805e1c:	66 39 d0             	cmp    %dx,%ax
  805e1f:	73 07                	jae    805e28 <tcp_slowtmr+0x101>
            pcb->ssthresh = pcb->mss * 2;
  805e21:	8d 04 12             	lea    (%edx,%edx,1),%eax
  805e24:	66 89 43 50          	mov    %ax,0x50(%ebx)
          pcb->cwnd = pcb->mss;
  805e28:	66 89 53 4e          	mov    %dx,0x4e(%ebx)
          tcp_rexmit_rto(pcb);
  805e2c:	83 ec 0c             	sub    $0xc,%esp
  805e2f:	53                   	push   %ebx
  805e30:	e8 b7 28 00 00       	call   8086ec <tcp_rexmit_rto>
  805e35:	83 c4 10             	add    $0x10,%esp
  805e38:	e9 7c 01 00 00       	jmp    805fb9 <tcp_slowtmr+0x292>
    pcb_remove = 0;
  805e3d:	be 00 00 00 00       	mov    $0x0,%esi
  805e42:	e9 72 01 00 00       	jmp    805fb9 <tcp_slowtmr+0x292>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  805e47:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  805e4c:	2b 43 2c             	sub    0x2c(%ebx),%eax
        ++pcb_remove;
  805e4f:	83 f8 29             	cmp    $0x29,%eax
  805e52:	89 f0                	mov    %esi,%eax
  805e54:	1c ff                	sbb    $0xff,%al
  805e56:	89 c6                	mov    %eax,%esi
    if (pcb->ooseq != NULL &&
  805e58:	8b 4b 7c             	mov    0x7c(%ebx),%ecx
  805e5b:	85 c9                	test   %ecx,%ecx
  805e5d:	75 1c                	jne    805e7b <tcp_slowtmr+0x154>
  805e5f:	eb 78                	jmp    805ed9 <tcp_slowtmr+0x1b2>
        tcp_abort(pcb);
  805e61:	83 ec 0c             	sub    $0xc,%esp
  805e64:	53                   	push   %ebx
  805e65:	e8 b4 fd ff ff       	call   805c1e <tcp_abort>
  805e6a:	83 c4 10             	add    $0x10,%esp
  805e6d:	eb 05                	jmp    805e74 <tcp_slowtmr+0x14d>
  805e6f:	be 01 00 00 00       	mov    $0x1,%esi
    if (pcb->ooseq != NULL &&
  805e74:	8b 4b 7c             	mov    0x7c(%ebx),%ecx
  805e77:	85 c9                	test   %ecx,%ecx
  805e79:	74 16                	je     805e91 <tcp_slowtmr+0x16a>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
  805e7b:	8b 15 40 b2 b3 00    	mov    0xb3b240,%edx
  805e81:	2b 53 2c             	sub    0x2c(%ebx),%edx
  805e84:	0f bf 43 44          	movswl 0x44(%ebx),%eax
  805e88:	8d 04 40             	lea    (%eax,%eax,2),%eax
  805e8b:	01 c0                	add    %eax,%eax
    if (pcb->ooseq != NULL &&
  805e8d:	39 c2                	cmp    %eax,%edx
  805e8f:	73 22                	jae    805eb3 <tcp_slowtmr+0x18c>
    if (pcb->state == SYN_RCVD) {
  805e91:	8b 43 10             	mov    0x10(%ebx),%eax
  805e94:	83 f8 03             	cmp    $0x3,%eax
  805e97:	74 2f                	je     805ec8 <tcp_slowtmr+0x1a1>
    if (pcb->state == LAST_ACK) {
  805e99:	83 f8 09             	cmp    $0x9,%eax
  805e9c:	75 3b                	jne    805ed9 <tcp_slowtmr+0x1b2>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  805e9e:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  805ea3:	2b 43 2c             	sub    0x2c(%ebx),%eax
        ++pcb_remove;
  805ea6:	3d f1 00 00 00       	cmp    $0xf1,%eax
  805eab:	89 f0                	mov    %esi,%eax
  805ead:	1c ff                	sbb    $0xff,%al
  805eaf:	89 c6                	mov    %eax,%esi
  805eb1:	eb 26                	jmp    805ed9 <tcp_slowtmr+0x1b2>
      tcp_segs_free(pcb->ooseq);
  805eb3:	83 ec 0c             	sub    $0xc,%esp
  805eb6:	51                   	push   %ecx
  805eb7:	e8 3e f9 ff ff       	call   8057fa <tcp_segs_free>
      pcb->ooseq = NULL;
  805ebc:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
  805ec3:	83 c4 10             	add    $0x10,%esp
  805ec6:	eb c9                	jmp    805e91 <tcp_slowtmr+0x16a>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  805ec8:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  805ecd:	2b 43 2c             	sub    0x2c(%ebx),%eax
        ++pcb_remove;
  805ed0:	83 f8 29             	cmp    $0x29,%eax
  805ed3:	89 f0                	mov    %esi,%eax
  805ed5:	1c ff                	sbb    $0xff,%al
  805ed7:	89 c6                	mov    %eax,%esi
    if (pcb_remove) {
  805ed9:	89 f0                	mov    %esi,%eax
  805edb:	84 c0                	test   %al,%al
  805edd:	0f 85 5a 01 00 00    	jne    80603d <tcp_slowtmr+0x316>
      ++pcb->polltmr;
  805ee3:	0f b6 43 30          	movzbl 0x30(%ebx),%eax
  805ee7:	83 c0 01             	add    $0x1,%eax
  805eea:	88 43 30             	mov    %al,0x30(%ebx)
      if (pcb->polltmr >= pcb->pollinterval) {
  805eed:	3a 43 31             	cmp    0x31(%ebx),%al
  805ef0:	72 27                	jb     805f19 <tcp_slowtmr+0x1f2>
        pcb->polltmr = 0;
  805ef2:	c6 43 30 00          	movb   $0x0,0x30(%ebx)
        TCP_EVENT_POLL(pcb, err);
  805ef6:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  805efc:	85 c0                	test   %eax,%eax
  805efe:	74 0f                	je     805f0f <tcp_slowtmr+0x1e8>
  805f00:	83 ec 08             	sub    $0x8,%esp
  805f03:	53                   	push   %ebx
  805f04:	ff 73 18             	pushl  0x18(%ebx)
  805f07:	ff d0                	call   *%eax
  805f09:	88 45 e3             	mov    %al,-0x1d(%ebp)
  805f0c:	83 c4 10             	add    $0x10,%esp
        if (err == ERR_OK) {
  805f0f:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  805f13:	0f 84 b6 01 00 00    	je     8060cf <tcp_slowtmr+0x3a8>
      prev = pcb;
  805f19:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
      pcb = pcb->next;
  805f1c:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  while (pcb != NULL) {
  805f1f:	85 db                	test   %ebx,%ebx
  805f21:	0f 84 b9 01 00 00    	je     8060e0 <tcp_slowtmr+0x3b9>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
  805f27:	8b 43 10             	mov    0x10(%ebx),%eax
  805f2a:	85 c0                	test   %eax,%eax
  805f2c:	0f 84 1b fe ff ff    	je     805d4d <tcp_slowtmr+0x26>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
  805f32:	83 f8 01             	cmp    $0x1,%eax
  805f35:	0f 84 29 fe ff ff    	je     805d64 <tcp_slowtmr+0x3d>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
  805f3b:	83 f8 0a             	cmp    $0xa,%eax
  805f3e:	0f 84 37 fe ff ff    	je     805d7b <tcp_slowtmr+0x54>
    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
  805f44:	83 f8 02             	cmp    $0x2,%eax
  805f47:	0f 84 45 fe ff ff    	je     805d92 <tcp_slowtmr+0x6b>
    else if (pcb->nrtx == TCP_MAXRTX) {
  805f4d:	0f b6 53 46          	movzbl 0x46(%ebx),%edx
      ++pcb_remove;
  805f51:	be 01 00 00 00       	mov    $0x1,%esi
    else if (pcb->nrtx == TCP_MAXRTX) {
  805f56:	80 fa 0c             	cmp    $0xc,%dl
  805f59:	74 5e                	je     805fb9 <tcp_slowtmr+0x292>
      if (pcb->persist_backoff > 0) {
  805f5b:	0f b6 b3 a4 00 00 00 	movzbl 0xa4(%ebx),%esi
  805f62:	89 f1                	mov    %esi,%ecx
  805f64:	84 c9                	test   %cl,%cl
  805f66:	0f 84 46 fe ff ff    	je     805db2 <tcp_slowtmr+0x8b>
        pcb->persist_cnt++;
  805f6c:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
  805f72:	83 c0 01             	add    $0x1,%eax
  805f75:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
  805f7b:	0f b6 d1             	movzbl %cl,%edx
  805f7e:	bf a8 1f 81 00       	mov    $0x811fa8,%edi
  805f83:	0f b6 54 17 ff       	movzbl -0x1(%edi,%edx,1),%edx
  805f88:	39 d0                	cmp    %edx,%eax
  805f8a:	0f 82 ad fe ff ff    	jb     805e3d <tcp_slowtmr+0x116>
          pcb->persist_cnt = 0;
  805f90:	c7 83 a0 00 00 00 00 	movl   $0x0,0xa0(%ebx)
  805f97:	00 00 00 
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
  805f9a:	80 f9 06             	cmp    $0x6,%cl
  805f9d:	77 09                	ja     805fa8 <tcp_slowtmr+0x281>
            pcb->persist_backoff++;
  805f9f:	8d 46 01             	lea    0x1(%esi),%eax
  805fa2:	88 83 a4 00 00 00    	mov    %al,0xa4(%ebx)
          tcp_zero_window_probe(pcb);
  805fa8:	83 ec 0c             	sub    $0xc,%esp
  805fab:	53                   	push   %ebx
  805fac:	e8 07 29 00 00       	call   8088b8 <tcp_zero_window_probe>
  805fb1:	83 c4 10             	add    $0x10,%esp
    pcb_remove = 0;
  805fb4:	be 00 00 00 00       	mov    $0x0,%esi
    if (pcb->state == FIN_WAIT_2) {
  805fb9:	8b 43 10             	mov    0x10(%ebx),%eax
  805fbc:	83 f8 06             	cmp    $0x6,%eax
  805fbf:	0f 84 82 fe ff ff    	je     805e47 <tcp_slowtmr+0x120>
    if((pcb->so_options & SOF_KEEPALIVE) && 
  805fc5:	f6 43 08 08          	testb  $0x8,0x8(%ebx)
  805fc9:	0f 84 a5 fe ff ff    	je     805e74 <tcp_slowtmr+0x14d>
  805fcf:	83 f8 04             	cmp    $0x4,%eax
  805fd2:	74 09                	je     805fdd <tcp_slowtmr+0x2b6>
  805fd4:	83 f8 07             	cmp    $0x7,%eax
  805fd7:	0f 85 97 fe ff ff    	jne    805e74 <tcp_slowtmr+0x14d>
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  805fdd:	8b 0d 40 b2 b3 00    	mov    0xb3b240,%ecx
  805fe3:	2b 4b 2c             	sub    0x2c(%ebx),%ecx
         (pcb->keep_idle + TCP_MAXIDLE) / TCP_SLOW_INTERVAL)
  805fe6:	8b bb 9c 00 00 00    	mov    0x9c(%ebx),%edi
  805fec:	8d 97 b8 4c 0a 00    	lea    0xa4cb8(%edi),%edx
  805ff2:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  805ff7:	f7 e2                	mul    %edx
  805ff9:	c1 ea 05             	shr    $0x5,%edx
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  805ffc:	39 d1                	cmp    %edx,%ecx
  805ffe:	0f 87 5d fe ff ff    	ja     805e61 <tcp_slowtmr+0x13a>
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
  806004:	0f b6 93 a5 00 00 00 	movzbl 0xa5(%ebx),%edx
  80600b:	69 d2 f8 24 01 00    	imul   $0x124f8,%edx,%edx
  806011:	01 fa                	add    %edi,%edx
              / TCP_SLOW_INTERVAL)
  806013:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  806018:	f7 e2                	mul    %edx
  80601a:	c1 ea 05             	shr    $0x5,%edx
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
  80601d:	39 d1                	cmp    %edx,%ecx
  80601f:	0f 86 4f fe ff ff    	jbe    805e74 <tcp_slowtmr+0x14d>
        tcp_keepalive(pcb);
  806025:	83 ec 0c             	sub    $0xc,%esp
  806028:	53                   	push   %ebx
  806029:	e8 64 27 00 00       	call   808792 <tcp_keepalive>
        pcb->keep_cnt_sent++;
  80602e:	80 83 a5 00 00 00 01 	addb   $0x1,0xa5(%ebx)
  806035:	83 c4 10             	add    $0x10,%esp
  806038:	e9 37 fe ff ff       	jmp    805e74 <tcp_slowtmr+0x14d>
      tcp_pcb_purge(pcb);      
  80603d:	83 ec 0c             	sub    $0xc,%esp
  806040:	53                   	push   %ebx
  806041:	e8 90 f8 ff ff       	call   8058d6 <tcp_pcb_purge>
      if (prev != NULL) {
  806046:	83 c4 10             	add    $0x10,%esp
  806049:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  80604d:	74 57                	je     8060a6 <tcp_slowtmr+0x37f>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
  80604f:	3b 1d 3c b2 b3 00    	cmp    0xb3b23c,%ebx
  806055:	74 38                	je     80608f <tcp_slowtmr+0x368>
        prev->next = pcb->next;
  806057:	8b 43 0c             	mov    0xc(%ebx),%eax
  80605a:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80605d:	89 47 0c             	mov    %eax,0xc(%edi)
      TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);
  806060:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  806066:	85 c0                	test   %eax,%eax
  806068:	74 0d                	je     806077 <tcp_slowtmr+0x350>
  80606a:	83 ec 08             	sub    $0x8,%esp
  80606d:	6a fb                	push   $0xfffffffb
  80606f:	ff 73 18             	pushl  0x18(%ebx)
  806072:	ff d0                	call   *%eax
  806074:	83 c4 10             	add    $0x10,%esp
      pcb2 = pcb->next;
  806077:	8b 73 0c             	mov    0xc(%ebx),%esi
      memp_free(MEMP_TCP_PCB, pcb);
  80607a:	83 ec 08             	sub    $0x8,%esp
  80607d:	53                   	push   %ebx
  80607e:	6a 02                	push   $0x2
  806080:	e8 59 e4 ff ff       	call   8044de <memp_free>
  806085:	83 c4 10             	add    $0x10,%esp
      pcb = pcb2;
  806088:	89 f3                	mov    %esi,%ebx
  80608a:	e9 90 fe ff ff       	jmp    805f1f <tcp_slowtmr+0x1f8>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
  80608f:	83 ec 04             	sub    $0x4,%esp
  806092:	68 20 1e 81 00       	push   $0x811e20
  806097:	68 c1 02 00 00       	push   $0x2c1
  80609c:	68 2a 1f 81 00       	push   $0x811f2a
  8060a1:	e8 ad 85 00 00       	call   80e653 <_panic>
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
  8060a6:	3b 1d 3c b2 b3 00    	cmp    0xb3b23c,%ebx
  8060ac:	75 0a                	jne    8060b8 <tcp_slowtmr+0x391>
        tcp_active_pcbs = pcb->next;
  8060ae:	8b 43 0c             	mov    0xc(%ebx),%eax
  8060b1:	a3 3c b2 b3 00       	mov    %eax,0xb3b23c
  8060b6:	eb a8                	jmp    806060 <tcp_slowtmr+0x339>
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
  8060b8:	83 ec 04             	sub    $0x4,%esp
  8060bb:	68 4c 1e 81 00       	push   $0x811e4c
  8060c0:	68 c5 02 00 00       	push   $0x2c5
  8060c5:	68 2a 1f 81 00       	push   $0x811f2a
  8060ca:	e8 84 85 00 00       	call   80e653 <_panic>
          tcp_output(pcb);
  8060cf:	83 ec 0c             	sub    $0xc,%esp
  8060d2:	53                   	push   %ebx
  8060d3:	e8 2a 20 00 00       	call   808102 <tcp_output>
  8060d8:	83 c4 10             	add    $0x10,%esp
  8060db:	e9 39 fe ff ff       	jmp    805f19 <tcp_slowtmr+0x1f2>
  pcb = tcp_tw_pcbs;
  8060e0:	8b 35 50 b2 b3 00    	mov    0xb3b250,%esi
  while (pcb != NULL) {
  8060e6:	eb 48                	jmp    806130 <tcp_slowtmr+0x409>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  8060e8:	83 ec 04             	sub    $0x4,%esp
  8060eb:	68 78 1e 81 00       	push   $0x811e78
  8060f0:	68 e5 02 00 00       	push   $0x2e5
  8060f5:	68 2a 1f 81 00       	push   $0x811f2a
  8060fa:	e8 54 85 00 00       	call   80e653 <_panic>
      tcp_pcb_purge(pcb);      
  8060ff:	83 ec 0c             	sub    $0xc,%esp
  806102:	56                   	push   %esi
  806103:	e8 ce f7 ff ff       	call   8058d6 <tcp_pcb_purge>
      if (prev != NULL) {
  806108:	83 c4 10             	add    $0x10,%esp
  80610b:	85 db                	test   %ebx,%ebx
  80610d:	74 58                	je     806167 <tcp_slowtmr+0x440>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
  80610f:	3b 35 50 b2 b3 00    	cmp    0xb3b250,%esi
  806115:	74 39                	je     806150 <tcp_slowtmr+0x429>
        prev->next = pcb->next;
  806117:	8b 46 0c             	mov    0xc(%esi),%eax
  80611a:	89 43 0c             	mov    %eax,0xc(%ebx)
      pcb2 = pcb->next;
  80611d:	8b 7e 0c             	mov    0xc(%esi),%edi
      memp_free(MEMP_TCP_PCB, pcb);
  806120:	83 ec 08             	sub    $0x8,%esp
  806123:	56                   	push   %esi
  806124:	6a 02                	push   $0x2
  806126:	e8 b3 e3 ff ff       	call   8044de <memp_free>
  80612b:	83 c4 10             	add    $0x10,%esp
      pcb = pcb2;
  80612e:	89 fe                	mov    %edi,%esi
  while (pcb != NULL) {
  806130:	85 f6                	test   %esi,%esi
  806132:	74 5c                	je     806190 <tcp_slowtmr+0x469>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  806134:	83 7e 10 0a          	cmpl   $0xa,0x10(%esi)
  806138:	75 ae                	jne    8060e8 <tcp_slowtmr+0x3c1>
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  80613a:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  80613f:	2b 46 2c             	sub    0x2c(%esi),%eax
  806142:	3d f0 00 00 00       	cmp    $0xf0,%eax
  806147:	77 b6                	ja     8060ff <tcp_slowtmr+0x3d8>
      prev = pcb;
  806149:	89 f3                	mov    %esi,%ebx
      pcb = pcb->next;
  80614b:	8b 76 0c             	mov    0xc(%esi),%esi
  80614e:	eb e0                	jmp    806130 <tcp_slowtmr+0x409>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
  806150:	83 ec 04             	sub    $0x4,%esp
  806153:	68 a8 1e 81 00       	push   $0x811ea8
  806158:	68 f4 02 00 00       	push   $0x2f4
  80615d:	68 2a 1f 81 00       	push   $0x811f2a
  806162:	e8 ec 84 00 00       	call   80e653 <_panic>
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
  806167:	3b 35 50 b2 b3 00    	cmp    0xb3b250,%esi
  80616d:	75 0a                	jne    806179 <tcp_slowtmr+0x452>
        tcp_tw_pcbs = pcb->next;
  80616f:	8b 46 0c             	mov    0xc(%esi),%eax
  806172:	a3 50 b2 b3 00       	mov    %eax,0xb3b250
  806177:	eb a4                	jmp    80611d <tcp_slowtmr+0x3f6>
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
  806179:	83 ec 04             	sub    $0x4,%esp
  80617c:	68 d0 1e 81 00       	push   $0x811ed0
  806181:	68 f8 02 00 00       	push   $0x2f8
  806186:	68 2a 1f 81 00       	push   $0x811f2a
  80618b:	e8 c3 84 00 00       	call   80e653 <_panic>
}
  806190:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806193:	5b                   	pop    %ebx
  806194:	5e                   	pop    %esi
  806195:	5f                   	pop    %edi
  806196:	5d                   	pop    %ebp
  806197:	c3                   	ret    

00806198 <tcp_tmr>:
{
  806198:	55                   	push   %ebp
  806199:	89 e5                	mov    %esp,%ebp
  80619b:	83 ec 08             	sub    $0x8,%esp
  tcp_fasttmr();
  80619e:	e8 a3 f5 ff ff       	call   805746 <tcp_fasttmr>
  if (++tcp_timer & 1) {
  8061a3:	0f b6 05 f9 43 b3 00 	movzbl 0xb343f9,%eax
  8061aa:	83 c0 01             	add    $0x1,%eax
  8061ad:	a2 f9 43 b3 00       	mov    %al,0xb343f9
  8061b2:	a8 01                	test   $0x1,%al
  8061b4:	75 02                	jne    8061b8 <tcp_tmr+0x20>
}
  8061b6:	c9                   	leave  
  8061b7:	c3                   	ret    
    tcp_slowtmr();
  8061b8:	e8 6a fb ff ff       	call   805d27 <tcp_slowtmr>
}
  8061bd:	eb f7                	jmp    8061b6 <tcp_tmr+0x1e>

008061bf <tcp_next_iss>:
 *
 * @return u32_t pseudo random sequence number
 */
u32_t
tcp_next_iss(void)
{
  8061bf:	55                   	push   %ebp
  8061c0:	89 e5                	mov    %esp,%ebp
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
  8061c2:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  8061c7:	03 05 08 40 81 00    	add    0x814008,%eax
  8061cd:	a3 08 40 81 00       	mov    %eax,0x814008
  return iss;
}
  8061d2:	5d                   	pop    %ebp
  8061d3:	c3                   	ret    

008061d4 <tcp_alloc>:
{
  8061d4:	55                   	push   %ebp
  8061d5:	89 e5                	mov    %esp,%ebp
  8061d7:	57                   	push   %edi
  8061d8:	56                   	push   %esi
  8061d9:	53                   	push   %ebx
  8061da:	83 ec 28             	sub    $0x28,%esp
  8061dd:	0f b6 75 08          	movzbl 0x8(%ebp),%esi
  pcb = memp_malloc(MEMP_TCP_PCB);
  8061e1:	6a 02                	push   $0x2
  8061e3:	e8 a0 e2 ff ff       	call   804488 <memp_malloc>
  8061e8:	89 c3                	mov    %eax,%ebx
  if (pcb == NULL) {
  8061ea:	83 c4 10             	add    $0x10,%esp
  8061ed:	85 c0                	test   %eax,%eax
  8061ef:	0f 84 a0 00 00 00    	je     806295 <tcp_alloc+0xc1>
    memset(pcb, 0, sizeof(struct tcp_pcb));
  8061f5:	83 ec 04             	sub    $0x4,%esp
  8061f8:	68 a8 00 00 00       	push   $0xa8
  8061fd:	6a 00                	push   $0x0
  8061ff:	53                   	push   %ebx
  806200:	e8 07 8d 00 00       	call   80ef0c <memset>
    pcb->prio = TCP_PRIO_NORMAL;
  806205:	c6 43 14 40          	movb   $0x40,0x14(%ebx)
    pcb->snd_buf = TCP_SND_BUF;
  806209:	66 c7 43 6e 40 5b    	movw   $0x5b40,0x6e(%ebx)
    pcb->snd_queuelen = 0;
  80620f:	66 c7 43 70 00 00    	movw   $0x0,0x70(%ebx)
    pcb->rcv_wnd = TCP_WND;
  806215:	66 c7 43 28 c0 5d    	movw   $0x5dc0,0x28(%ebx)
    pcb->rcv_ann_wnd = TCP_WND;
  80621b:	66 c7 43 2a c0 5d    	movw   $0x5dc0,0x2a(%ebx)
    pcb->tos = 0;
  806221:	c6 43 0a 00          	movb   $0x0,0xa(%ebx)
    pcb->ttl = TCP_TTL;
  806225:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  806229:	66 c7 43 34 18 02    	movw   $0x218,0x34(%ebx)
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
  80622f:	66 c7 43 44 06 00    	movw   $0x6,0x44(%ebx)
    pcb->sa = 0;
  806235:	66 c7 43 40 00 00    	movw   $0x0,0x40(%ebx)
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
  80623b:	66 c7 43 42 06 00    	movw   $0x6,0x42(%ebx)
    pcb->rtime = -1;
  806241:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
    pcb->cwnd = 1;
  806247:	66 c7 43 4e 01 00    	movw   $0x1,0x4e(%ebx)
    iss = tcp_next_iss();
  80624d:	e8 6d ff ff ff       	call   8061bf <tcp_next_iss>
    pcb->snd_wl2 = iss;
  806252:	89 43 64             	mov    %eax,0x64(%ebx)
    pcb->snd_nxt = iss;
  806255:	89 43 54             	mov    %eax,0x54(%ebx)
    pcb->snd_max = iss;
  806258:	89 43 58             	mov    %eax,0x58(%ebx)
    pcb->lastack = iss;
  80625b:	89 43 48             	mov    %eax,0x48(%ebx)
    pcb->snd_lbb = iss;   
  80625e:	89 43 68             	mov    %eax,0x68(%ebx)
    pcb->tmr = tcp_ticks;
  806261:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  806266:	89 43 2c             	mov    %eax,0x2c(%ebx)
    pcb->polltmr = 0;
  806269:	c6 43 30 00          	movb   $0x0,0x30(%ebx)
    pcb->recv = tcp_recv_null;
  80626d:	c7 83 88 00 00 00 e2 	movl   $0x805be2,0x88(%ebx)
  806274:	5b 80 00 
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
  806277:	c7 83 9c 00 00 00 00 	movl   $0x6ddd00,0x9c(%ebx)
  80627e:	dd 6d 00 
    pcb->keep_cnt_sent = 0;
  806281:	c6 83 a5 00 00 00 00 	movb   $0x0,0xa5(%ebx)
  806288:	83 c4 10             	add    $0x10,%esp
}
  80628b:	89 d8                	mov    %ebx,%eax
  80628d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806290:	5b                   	pop    %ebx
  806291:	5e                   	pop    %esi
  806292:	5f                   	pop    %edi
  806293:	5d                   	pop    %ebp
  806294:	c3                   	ret    
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  806295:	a1 50 b2 b3 00       	mov    0xb3b250,%eax
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  80629a:	8b 3d 40 b2 b3 00    	mov    0xb3b240,%edi
  inactivity = 0;
  8062a0:	b9 00 00 00 00       	mov    $0x0,%ecx
  8062a5:	eb 03                	jmp    8062aa <tcp_alloc+0xd6>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8062a7:	8b 40 0c             	mov    0xc(%eax),%eax
  8062aa:	85 c0                	test   %eax,%eax
  8062ac:	74 0f                	je     8062bd <tcp_alloc+0xe9>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  8062ae:	89 fa                	mov    %edi,%edx
  8062b0:	2b 50 2c             	sub    0x2c(%eax),%edx
  8062b3:	39 ca                	cmp    %ecx,%edx
  8062b5:	72 f0                	jb     8062a7 <tcp_alloc+0xd3>
      inactivity = tcp_ticks - pcb->tmr;
  8062b7:	89 d1                	mov    %edx,%ecx
      inactive = pcb;
  8062b9:	89 c3                	mov    %eax,%ebx
  8062bb:	eb ea                	jmp    8062a7 <tcp_alloc+0xd3>
  if (inactive != NULL) {
  8062bd:	85 db                	test   %ebx,%ebx
  8062bf:	74 0c                	je     8062cd <tcp_alloc+0xf9>
    tcp_abort(inactive);
  8062c1:	83 ec 0c             	sub    $0xc,%esp
  8062c4:	53                   	push   %ebx
  8062c5:	e8 54 f9 ff ff       	call   805c1e <tcp_abort>
  8062ca:	83 c4 10             	add    $0x10,%esp
    pcb = memp_malloc(MEMP_TCP_PCB);
  8062cd:	83 ec 0c             	sub    $0xc,%esp
  8062d0:	6a 02                	push   $0x2
  8062d2:	e8 b1 e1 ff ff       	call   804488 <memp_malloc>
  8062d7:	89 c3                	mov    %eax,%ebx
    if (pcb == NULL) {
  8062d9:	83 c4 10             	add    $0x10,%esp
  8062dc:	85 c0                	test   %eax,%eax
  8062de:	0f 85 11 ff ff ff    	jne    8061f5 <tcp_alloc+0x21>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8062e4:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  8062e9:	8b 3d 40 b2 b3 00    	mov    0xb3b240,%edi
  8062ef:	89 7d dc             	mov    %edi,-0x24(%ebp)
  mprio = TCP_PRIO_MAX;
  8062f2:	ba 7f 00 00 00       	mov    $0x7f,%edx
  inactivity = 0;
  8062f7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  8062fe:	89 df                	mov    %ebx,%edi
  806300:	89 f1                	mov    %esi,%ecx
  806302:	88 4d e7             	mov    %cl,-0x19(%ebp)
  806305:	eb 03                	jmp    80630a <tcp_alloc+0x136>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  806307:	8b 40 0c             	mov    0xc(%eax),%eax
  80630a:	85 c0                	test   %eax,%eax
  80630c:	74 29                	je     806337 <tcp_alloc+0x163>
    if (pcb->prio <= prio &&
  80630e:	0f b6 48 14          	movzbl 0x14(%eax),%ecx
  806312:	0f b6 5d e7          	movzbl -0x19(%ebp),%ebx
  806316:	38 d3                	cmp    %dl,%bl
  806318:	89 d6                	mov    %edx,%esi
  80631a:	0f 46 f3             	cmovbe %ebx,%esi
  80631d:	89 f3                	mov    %esi,%ebx
  80631f:	38 cb                	cmp    %cl,%bl
  806321:	72 e4                	jb     806307 <tcp_alloc+0x133>
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  806323:	8b 75 dc             	mov    -0x24(%ebp),%esi
  806326:	2b 70 2c             	sub    0x2c(%eax),%esi
       pcb->prio <= mprio &&
  806329:	3b 75 e0             	cmp    -0x20(%ebp),%esi
  80632c:	72 d9                	jb     806307 <tcp_alloc+0x133>
      mprio = pcb->prio;
  80632e:	89 ca                	mov    %ecx,%edx
      inactivity = tcp_ticks - pcb->tmr;
  806330:	89 75 e0             	mov    %esi,-0x20(%ebp)
      inactive = pcb;
  806333:	89 c7                	mov    %eax,%edi
  806335:	eb d0                	jmp    806307 <tcp_alloc+0x133>
  if (inactive != NULL) {
  806337:	85 ff                	test   %edi,%edi
  806339:	74 0c                	je     806347 <tcp_alloc+0x173>
    tcp_abort(inactive);
  80633b:	83 ec 0c             	sub    $0xc,%esp
  80633e:	57                   	push   %edi
  80633f:	e8 da f8 ff ff       	call   805c1e <tcp_abort>
  806344:	83 c4 10             	add    $0x10,%esp
      pcb = memp_malloc(MEMP_TCP_PCB);
  806347:	83 ec 0c             	sub    $0xc,%esp
  80634a:	6a 02                	push   $0x2
  80634c:	e8 37 e1 ff ff       	call   804488 <memp_malloc>
  806351:	89 c3                	mov    %eax,%ebx
  if (pcb != NULL) {
  806353:	83 c4 10             	add    $0x10,%esp
  806356:	85 c0                	test   %eax,%eax
  806358:	0f 84 2d ff ff ff    	je     80628b <tcp_alloc+0xb7>
  80635e:	e9 92 fe ff ff       	jmp    8061f5 <tcp_alloc+0x21>

00806363 <tcp_new>:
{
  806363:	55                   	push   %ebp
  806364:	89 e5                	mov    %esp,%ebp
  806366:	83 ec 14             	sub    $0x14,%esp
  return tcp_alloc(TCP_PRIO_NORMAL);
  806369:	6a 40                	push   $0x40
  80636b:	e8 64 fe ff ff       	call   8061d4 <tcp_alloc>
}
  806370:	c9                   	leave  
  806371:	c3                   	ret    

00806372 <tcp_eff_send_mss>:
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, struct ip_addr *addr)
{
  806372:	55                   	push   %ebp
  806373:	89 e5                	mov    %esp,%ebp
  806375:	56                   	push   %esi
  806376:	53                   	push   %ebx
  806377:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80637a:	89 de                	mov    %ebx,%esi
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
  80637c:	83 ec 0c             	sub    $0xc,%esp
  80637f:	ff 75 0c             	pushl  0xc(%ebp)
  806382:	e8 f6 01 00 00       	call   80657d <ip_route>
  if ((outif != NULL) && (outif->mtu != 0)) {
  806387:	83 c4 10             	add    $0x10,%esp
  80638a:	85 c0                	test   %eax,%eax
  80638c:	74 14                	je     8063a2 <tcp_eff_send_mss+0x30>
  80638e:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
  806392:	66 85 c0             	test   %ax,%ax
  806395:	74 0b                	je     8063a2 <tcp_eff_send_mss+0x30>
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
  806397:	83 e8 28             	sub    $0x28,%eax
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * but we only send options with SYN and that is never filled with data! */
    sendmss = LWIP_MIN(sendmss, mss_s);
  80639a:	66 39 c3             	cmp    %ax,%bx
  80639d:	0f 46 c3             	cmovbe %ebx,%eax
  8063a0:	89 c6                	mov    %eax,%esi
  }
  return sendmss;
}
  8063a2:	89 f0                	mov    %esi,%eax
  8063a4:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8063a7:	5b                   	pop    %ebx
  8063a8:	5e                   	pop    %esi
  8063a9:	5d                   	pop    %ebp
  8063aa:	c3                   	ret    

008063ab <tcp_connect>:
{
  8063ab:	55                   	push   %ebp
  8063ac:	89 e5                	mov    %esp,%ebp
  8063ae:	57                   	push   %edi
  8063af:	56                   	push   %esi
  8063b0:	53                   	push   %ebx
  8063b1:	83 ec 2c             	sub    $0x2c,%esp
  8063b4:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8063b7:	8b 75 0c             	mov    0xc(%ebp),%esi
  8063ba:	8b 45 10             	mov    0x10(%ebp),%eax
  LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  8063bd:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  8063c1:	0f 85 b9 00 00 00    	jne    806480 <tcp_connect+0xd5>
  if (ipaddr != NULL) {
  8063c7:	85 f6                	test   %esi,%esi
  8063c9:	0f 84 67 01 00 00    	je     806536 <tcp_connect+0x18b>
    pcb->remote_ip = *ipaddr;
  8063cf:	8b 16                	mov    (%esi),%edx
  8063d1:	89 53 04             	mov    %edx,0x4(%ebx)
  pcb->remote_port = port;
  8063d4:	66 89 43 1e          	mov    %ax,0x1e(%ebx)
  if (pcb->local_port == 0) {
  8063d8:	66 83 7b 1c 00       	cmpw   $0x0,0x1c(%ebx)
  8063dd:	0f 84 b4 00 00 00    	je     806497 <tcp_connect+0xec>
  iss = tcp_next_iss();
  8063e3:	e8 d7 fd ff ff       	call   8061bf <tcp_next_iss>
  pcb->rcv_nxt = 0;
  8063e8:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
  pcb->snd_nxt = iss;
  8063ef:	89 43 54             	mov    %eax,0x54(%ebx)
  pcb->lastack = iss - 1;
  8063f2:	83 e8 01             	sub    $0x1,%eax
  8063f5:	89 43 48             	mov    %eax,0x48(%ebx)
  pcb->snd_lbb = iss - 1;
  8063f8:	89 43 68             	mov    %eax,0x68(%ebx)
  pcb->rcv_wnd = TCP_WND;
  8063fb:	66 c7 43 28 c0 5d    	movw   $0x5dc0,0x28(%ebx)
  pcb->rcv_ann_wnd = TCP_WND;
  806401:	66 c7 43 2a c0 5d    	movw   $0x5dc0,0x2a(%ebx)
  pcb->snd_wnd = TCP_WND;
  806407:	66 c7 43 5c c0 5d    	movw   $0x5dc0,0x5c(%ebx)
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  80640d:	66 c7 43 34 18 02    	movw   $0x218,0x34(%ebx)
  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
  806413:	83 ec 08             	sub    $0x8,%esp
  806416:	56                   	push   %esi
  806417:	68 18 02 00 00       	push   $0x218
  80641c:	e8 51 ff ff ff       	call   806372 <tcp_eff_send_mss>
  806421:	66 89 43 34          	mov    %ax,0x34(%ebx)
  pcb->cwnd = 1;
  806425:	66 c7 43 4e 01 00    	movw   $0x1,0x4e(%ebx)
  pcb->ssthresh = pcb->mss * 10;
  80642b:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80642e:	01 c0                	add    %eax,%eax
  806430:	66 89 43 50          	mov    %ax,0x50(%ebx)
  pcb->state = SYN_SENT;
  806434:	c7 43 10 02 00 00 00 	movl   $0x2,0x10(%ebx)
  pcb->connected = connected;
  80643b:	8b 45 14             	mov    0x14(%ebp),%eax
  80643e:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
  TCP_RMV(&tcp_bound_pcbs, pcb);
  806444:	8b 15 4c b2 b3 00    	mov    0xb3b24c,%edx
  80644a:	83 c4 10             	add    $0x10,%esp
  80644d:	39 da                	cmp    %ebx,%edx
  80644f:	74 54                	je     8064a5 <tcp_connect+0xfa>
  806451:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  806457:	c6 45 d7 00          	movb   $0x0,-0x29(%ebp)
  80645b:	bf 01 00 00 00       	mov    $0x1,%edi
  806460:	89 de                	mov    %ebx,%esi
  806462:	85 d2                	test   %edx,%edx
  806464:	74 61                	je     8064c7 <tcp_connect+0x11c>
  806466:	8b 42 0c             	mov    0xc(%edx),%eax
  806469:	39 f0                	cmp    %esi,%eax
  80646b:	0f 94 c3             	sete   %bl
  80646e:	85 c0                	test   %eax,%eax
  806470:	0f 95 c1             	setne  %cl
  806473:	84 cb                	test   %cl,%bl
  806475:	75 38                	jne    8064af <tcp_connect+0x104>
  806477:	89 f9                	mov    %edi,%ecx
  806479:	88 4d d7             	mov    %cl,-0x29(%ebp)
  80647c:	89 c2                	mov    %eax,%edx
  80647e:	eb e2                	jmp    806462 <tcp_connect+0xb7>
  LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  806480:	83 ec 04             	sub    $0x4,%esp
  806483:	68 f8 1e 81 00       	push   $0x811ef8
  806488:	68 ec 01 00 00       	push   $0x1ec
  80648d:	68 2a 1f 81 00       	push   $0x811f2a
  806492:	e8 bc 81 00 00       	call   80e653 <_panic>
    pcb->local_port = tcp_new_port();
  806497:	e8 fa ee ff ff       	call   805396 <tcp_new_port>
  80649c:	66 89 43 1c          	mov    %ax,0x1c(%ebx)
  8064a0:	e9 3e ff ff ff       	jmp    8063e3 <tcp_connect+0x38>
  TCP_RMV(&tcp_bound_pcbs, pcb);
  8064a5:	8b 42 0c             	mov    0xc(%edx),%eax
  8064a8:	a3 4c b2 b3 00       	mov    %eax,0xb3b24c
  8064ad:	eb 20                	jmp    8064cf <tcp_connect+0x124>
  8064af:	89 f3                	mov    %esi,%ebx
  8064b1:	80 7d d7 00          	cmpb   $0x0,-0x29(%ebp)
  8064b5:	75 08                	jne    8064bf <tcp_connect+0x114>
  8064b7:	8b 43 0c             	mov    0xc(%ebx),%eax
  8064ba:	89 42 0c             	mov    %eax,0xc(%edx)
  8064bd:	eb 10                	jmp    8064cf <tcp_connect+0x124>
  8064bf:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  8064c5:	eb f0                	jmp    8064b7 <tcp_connect+0x10c>
  8064c7:	89 f3                	mov    %esi,%ebx
  8064c9:	80 7d d7 00          	cmpb   $0x0,-0x29(%ebp)
  8064cd:	75 4d                	jne    80651c <tcp_connect+0x171>
  TCP_REG(&tcp_active_pcbs, pcb);
  8064cf:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  8064d4:	89 43 0c             	mov    %eax,0xc(%ebx)
  8064d7:	89 1d 3c b2 b3 00    	mov    %ebx,0xb3b23c
  8064dd:	e8 d5 bc ff ff       	call   8021b7 <tcp_timer_needed>
  optdata = TCP_BUILD_MSS_OPTION();
  8064e2:	83 ec 0c             	sub    $0xc,%esp
  8064e5:	68 b4 05 04 02       	push   $0x20405b4
  8064ea:	e8 ad 12 00 00       	call   80779c <htonl>
  8064ef:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, (u8_t *)&optdata, 4);
  8064f2:	83 c4 0c             	add    $0xc,%esp
  8064f5:	6a 04                	push   $0x4
  8064f7:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8064fa:	50                   	push   %eax
  8064fb:	6a 00                	push   $0x0
  8064fd:	6a 02                	push   $0x2
  8064ff:	6a 00                	push   $0x0
  806501:	6a 00                	push   $0x0
  806503:	53                   	push   %ebx
  806504:	e8 c1 14 00 00       	call   8079ca <tcp_enqueue>
  806509:	89 c6                	mov    %eax,%esi
  if (ret == ERR_OK) { 
  80650b:	83 c4 20             	add    $0x20,%esp
  80650e:	84 c0                	test   %al,%al
  806510:	74 16                	je     806528 <tcp_connect+0x17d>
} 
  806512:	89 f0                	mov    %esi,%eax
  806514:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806517:	5b                   	pop    %ebx
  806518:	5e                   	pop    %esi
  806519:	5f                   	pop    %edi
  80651a:	5d                   	pop    %ebp
  80651b:	c3                   	ret    
  80651c:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  806523:	00 00 00 
  806526:	eb a7                	jmp    8064cf <tcp_connect+0x124>
    tcp_output(pcb);
  806528:	83 ec 0c             	sub    $0xc,%esp
  80652b:	53                   	push   %ebx
  80652c:	e8 d1 1b 00 00       	call   808102 <tcp_output>
  806531:	83 c4 10             	add    $0x10,%esp
  806534:	eb dc                	jmp    806512 <tcp_connect+0x167>
    return ERR_VAL;
  806536:	be f7 ff ff ff       	mov    $0xfffffff7,%esi
  80653b:	eb d5                	jmp    806512 <tcp_connect+0x167>

0080653d <ip_addr_isbroadcast>:
 * @param addr address to be checked
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t ip_addr_isbroadcast(struct ip_addr *addr, struct netif *netif)
{
  80653d:	55                   	push   %ebp
  80653e:	89 e5                	mov    %esp,%ebp
  806540:	53                   	push   %ebx
  806541:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  u32_t addr2test;

  addr2test = addr->addr;
  806544:	8b 45 08             	mov    0x8(%ebp),%eax
  806547:	8b 10                	mov    (%eax),%edx
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  806549:	8d 5a ff             	lea    -0x1(%edx),%ebx
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
  80654c:	b8 01 00 00 00       	mov    $0x1,%eax
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  806551:	83 fb fd             	cmp    $0xfffffffd,%ebx
  806554:	77 24                	ja     80657a <ip_addr_isbroadcast+0x3d>
  /* no broadcast support on this network interface? */
  else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0)
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  806556:	b8 00 00 00 00       	mov    $0x0,%eax
  else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0)
  80655b:	f6 41 2e 02          	testb  $0x2,0x2e(%ecx)
  80655f:	74 19                	je     80657a <ip_addr_isbroadcast+0x3d>
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
  806561:	8b 59 04             	mov    0x4(%ecx),%ebx
  806564:	39 d3                	cmp    %edx,%ebx
  806566:	74 12                	je     80657a <ip_addr_isbroadcast+0x3d>
    return 0;
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
  806568:	8b 49 08             	mov    0x8(%ecx),%ecx
  80656b:	31 d3                	xor    %edx,%ebx
  80656d:	85 cb                	test   %ecx,%ebx
  80656f:	75 09                	jne    80657a <ip_addr_isbroadcast+0x3d>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr2test & ~netif->netmask.addr) ==
  806571:	f7 d1                	not    %ecx
  806573:	21 ca                	and    %ecx,%edx
  806575:	39 ca                	cmp    %ecx,%edx
  806577:	0f 94 c0             	sete   %al
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
    /* => network broadcast address */
    return 1;
  else
    return 0;
}
  80657a:	5b                   	pop    %ebx
  80657b:	5d                   	pop    %ebp
  80657c:	c3                   	ret    

0080657d <ip_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip_route(struct ip_addr *dest)
{
  80657d:	55                   	push   %ebp
  80657e:	89 e5                	mov    %esp,%ebp
  806580:	56                   	push   %esi
  806581:	53                   	push   %ebx
  806582:	8b 75 08             	mov    0x8(%ebp),%esi
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  806585:	8b 1d 34 b2 b3 00    	mov    0xb3b234,%ebx
  80658b:	eb 02                	jmp    80658f <ip_route+0x12>
  80658d:	8b 1b                	mov    (%ebx),%ebx
  80658f:	85 db                	test   %ebx,%ebx
  806591:	74 1c                	je     8065af <ip_route+0x32>
    /* network mask matches? */
    if (netif_is_up(netif)) {
  806593:	83 ec 0c             	sub    $0xc,%esp
  806596:	53                   	push   %ebx
  806597:	e8 ce e1 ff ff       	call   80476a <netif_is_up>
  80659c:	83 c4 10             	add    $0x10,%esp
  80659f:	84 c0                	test   %al,%al
  8065a1:	74 ea                	je     80658d <ip_route+0x10>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
  8065a3:	8b 06                	mov    (%esi),%eax
  8065a5:	33 43 04             	xor    0x4(%ebx),%eax
  8065a8:	85 43 08             	test   %eax,0x8(%ebx)
  8065ab:	75 e0                	jne    80658d <ip_route+0x10>
  8065ad:	eb 1e                	jmp    8065cd <ip_route+0x50>
        /* return netif on which to forward IP packet */
        return netif;
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
  8065af:	a1 38 b2 b3 00       	mov    0xb3b238,%eax
  8065b4:	85 c0                	test   %eax,%eax
  8065b6:	74 1e                	je     8065d6 <ip_route+0x59>
  8065b8:	83 ec 0c             	sub    $0xc,%esp
  8065bb:	50                   	push   %eax
  8065bc:	e8 a9 e1 ff ff       	call   80476a <netif_is_up>
  8065c1:	83 c4 10             	add    $0x10,%esp
    IP_STATS_INC(ip.rterr);
    snmp_inc_ipoutnoroutes();
    return NULL;
  }
  /* no matching netif found, use default netif */
  return netif_default;
  8065c4:	84 c0                	test   %al,%al
  8065c6:	0f 45 1d 38 b2 b3 00 	cmovne 0xb3b238,%ebx
}
  8065cd:	89 d8                	mov    %ebx,%eax
  8065cf:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8065d2:	5b                   	pop    %ebx
  8065d3:	5e                   	pop    %esi
  8065d4:	5d                   	pop    %ebp
  8065d5:	c3                   	ret    
    return NULL;
  8065d6:	89 c3                	mov    %eax,%ebx
  8065d8:	eb f3                	jmp    8065cd <ip_route+0x50>

008065da <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
  8065da:	55                   	push   %ebp
  8065db:	89 e5                	mov    %esp,%ebp
  8065dd:	57                   	push   %edi
  8065de:	56                   	push   %esi
  8065df:	53                   	push   %ebx
  8065e0:	83 ec 28             	sub    $0x28,%esp
  8065e3:	8b 7d 08             	mov    0x8(%ebp),%edi

  IP_STATS_INC(ip.recv);
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = p->payload;
  8065e6:	8b 77 04             	mov    0x4(%edi),%esi
  if (IPH_V(iphdr) != 4) {
  8065e9:	0f b7 06             	movzwl (%esi),%eax
  8065ec:	50                   	push   %eax
  8065ed:	e8 9d 11 00 00       	call   80778f <ntohs>
  8065f2:	66 c1 e8 0c          	shr    $0xc,%ax
  8065f6:	83 c4 10             	add    $0x10,%esp
  8065f9:	66 83 f8 04          	cmp    $0x4,%ax
  8065fd:	74 19                	je     806618 <ip_input+0x3e>
    LWIP_DEBUGF(IP_DEBUG | 1, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
  8065ff:	83 ec 0c             	sub    $0xc,%esp
  806602:	57                   	push   %edi
  806603:	e8 45 e2 ff ff       	call   80484d <pbuf_free>
    IP_STATS_INC(ip.err);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  806608:	83 c4 10             	add    $0x10,%esp
      snmp_inc_ipinunknownprotos();
    }
  }

  return ERR_OK;
}
  80660b:	b8 00 00 00 00       	mov    $0x0,%eax
  806610:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806613:	5b                   	pop    %ebx
  806614:	5e                   	pop    %esi
  806615:	5f                   	pop    %edi
  806616:	5d                   	pop    %ebp
  806617:	c3                   	ret    
  iphdr_hlen = IPH_HL(iphdr);
  806618:	83 ec 0c             	sub    $0xc,%esp
  80661b:	0f b7 06             	movzwl (%esi),%eax
  80661e:	50                   	push   %eax
  80661f:	e8 6b 11 00 00       	call   80778f <ntohs>
  806624:	66 c1 e8 06          	shr    $0x6,%ax
  iphdr_hlen *= 4;
  806628:	83 e0 3c             	and    $0x3c,%eax
  80662b:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  iphdr_len = ntohs(IPH_LEN(iphdr));
  80662f:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  806633:	89 04 24             	mov    %eax,(%esp)
  806636:	e8 54 11 00 00       	call   80778f <ntohs>
  80663b:	89 c3                	mov    %eax,%ebx
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
  80663d:	83 c4 10             	add    $0x10,%esp
  806640:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  806644:	66 39 47 0a          	cmp    %ax,0xa(%edi)
  806648:	72 06                	jb     806650 <ip_input+0x76>
  80664a:	66 39 5f 08          	cmp    %bx,0x8(%edi)
  80664e:	73 0e                	jae    80665e <ip_input+0x84>
    pbuf_free(p);
  806650:	83 ec 0c             	sub    $0xc,%esp
  806653:	57                   	push   %edi
  806654:	e8 f4 e1 ff ff       	call   80484d <pbuf_free>
    return ERR_OK;
  806659:	83 c4 10             	add    $0x10,%esp
  80665c:	eb ad                	jmp    80660b <ip_input+0x31>
  if (inet_chksum(iphdr, iphdr_hlen) != 0) {
  80665e:	83 ec 08             	sub    $0x8,%esp
  806661:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  806665:	50                   	push   %eax
  806666:	56                   	push   %esi
  806667:	e8 f2 0f 00 00       	call   80765e <inet_chksum>
  80666c:	83 c4 10             	add    $0x10,%esp
  80666f:	66 85 c0             	test   %ax,%ax
  806672:	75 25                	jne    806699 <ip_input+0xbf>
  pbuf_realloc(p, iphdr_len);
  806674:	83 ec 08             	sub    $0x8,%esp
  806677:	0f b7 db             	movzwl %bx,%ebx
  80667a:	53                   	push   %ebx
  80667b:	57                   	push   %edi
  80667c:	e8 fd e4 ff ff       	call   804b7e <pbuf_realloc>
  806681:	83 c4 10             	add    $0x10,%esp
    netif = inp;
  806684:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    int first = 1;
  806687:	ba 01 00 00 00       	mov    $0x1,%edx
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  80668c:	8d 46 10             	lea    0x10(%esi),%eax
  80668f:	89 45 e0             	mov    %eax,-0x20(%ebp)
  806692:	89 7d 08             	mov    %edi,0x8(%ebp)
  806695:	89 d7                	mov    %edx,%edi
  806697:	eb 35                	jmp    8066ce <ip_input+0xf4>
    pbuf_free(p);
  806699:	83 ec 0c             	sub    $0xc,%esp
  80669c:	57                   	push   %edi
  80669d:	e8 ab e1 ff ff       	call   80484d <pbuf_free>
    return ERR_OK;
  8066a2:	83 c4 10             	add    $0x10,%esp
  8066a5:	e9 61 ff ff ff       	jmp    80660b <ip_input+0x31>
      if (first) {
  8066aa:	85 ff                	test   %edi,%edi
  8066ac:	0f 84 53 01 00 00    	je     806805 <ip_input+0x22b>
        netif = netif_list;
  8066b2:	8b 1d 34 b2 b3 00    	mov    0xb3b234,%ebx
      if (netif == inp) {
  8066b8:	39 5d 0c             	cmp    %ebx,0xc(%ebp)
  8066bb:	0f 84 4b 01 00 00    	je     80680c <ip_input+0x232>
  8066c1:	bf 00 00 00 00       	mov    $0x0,%edi
    } while(netif != NULL);
  8066c6:	85 db                	test   %ebx,%ebx
  8066c8:	0f 84 45 01 00 00    	je     806813 <ip_input+0x239>
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
  8066ce:	83 ec 0c             	sub    $0xc,%esp
  8066d1:	53                   	push   %ebx
  8066d2:	e8 93 e0 ff ff       	call   80476a <netif_is_up>
  8066d7:	83 c4 10             	add    $0x10,%esp
  8066da:	84 c0                	test   %al,%al
  8066dc:	74 cc                	je     8066aa <ip_input+0xd0>
  8066de:	83 fb fc             	cmp    $0xfffffffc,%ebx
  8066e1:	74 c7                	je     8066aa <ip_input+0xd0>
  8066e3:	8b 43 04             	mov    0x4(%ebx),%eax
  8066e6:	85 c0                	test   %eax,%eax
  8066e8:	74 c0                	je     8066aa <ip_input+0xd0>
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  8066ea:	3b 46 10             	cmp    0x10(%esi),%eax
  8066ed:	74 13                	je     806702 <ip_input+0x128>
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  8066ef:	83 ec 08             	sub    $0x8,%esp
  8066f2:	53                   	push   %ebx
  8066f3:	ff 75 e0             	pushl  -0x20(%ebp)
  8066f6:	e8 42 fe ff ff       	call   80653d <ip_addr_isbroadcast>
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  8066fb:	83 c4 10             	add    $0x10,%esp
  8066fe:	84 c0                	test   %al,%al
  806700:	74 a8                	je     8066aa <ip_input+0xd0>
  806702:	8b 7d 08             	mov    0x8(%ebp),%edi
  if (netif == NULL) {
  806705:	85 db                	test   %ebx,%ebx
  806707:	0f 84 09 01 00 00    	je     806816 <ip_input+0x23c>
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  80670d:	83 ec 08             	sub    $0x8,%esp
  806710:	ff 75 0c             	pushl  0xc(%ebp)
  806713:	8d 46 0c             	lea    0xc(%esi),%eax
  806716:	50                   	push   %eax
  806717:	e8 21 fe ff ff       	call   80653d <ip_addr_isbroadcast>
  80671c:	83 c4 10             	add    $0x10,%esp
  80671f:	84 c0                	test   %al,%al
  806721:	0f 85 2e 01 00 00    	jne    806855 <ip_input+0x27b>
         (ip_addr_ismulticast(&(iphdr->src)))) {
  806727:	8b 46 0c             	mov    0xc(%esi),%eax
  80672a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80672d:	83 ec 0c             	sub    $0xc,%esp
  806730:	68 00 00 00 f0       	push   $0xf0000000
  806735:	e8 80 12 00 00       	call   8079ba <ntohl>
  80673a:	23 45 e4             	and    -0x1c(%ebp),%eax
  80673d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  806740:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  806747:	e8 6e 12 00 00       	call   8079ba <ntohl>
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  80674c:	83 c4 10             	add    $0x10,%esp
  80674f:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
  806752:	0f 84 fd 00 00 00    	je     806855 <ip_input+0x27b>
  if (netif == NULL) {
  806758:	85 db                	test   %ebx,%ebx
  80675a:	0f 84 06 01 00 00    	je     806866 <ip_input+0x28c>
  if ((IPH_OFFSET(iphdr) & htons(IP_OFFMASK | IP_MF)) != 0) {
  806760:	0f b7 5e 06          	movzwl 0x6(%esi),%ebx
  806764:	83 ec 0c             	sub    $0xc,%esp
  806767:	68 ff 3f 00 00       	push   $0x3fff
  80676c:	e8 11 10 00 00       	call   807782 <htons>
  806771:	83 c4 10             	add    $0x10,%esp
  806774:	66 85 c3             	test   %ax,%bx
  806777:	74 19                	je     806792 <ip_input+0x1b8>
    p = ip_reass(p);
  806779:	83 ec 0c             	sub    $0xc,%esp
  80677c:	57                   	push   %edi
  80677d:	e8 79 05 00 00       	call   806cfb <ip_reass>
  806782:	89 c7                	mov    %eax,%edi
    if (p == NULL) {
  806784:	83 c4 10             	add    $0x10,%esp
  806787:	85 c0                	test   %eax,%eax
  806789:	0f 84 7c fe ff ff    	je     80660b <ip_input+0x31>
    iphdr = p->payload;
  80678f:	8b 70 04             	mov    0x4(%eax),%esi
  if (raw_input(p, inp) == 0)
  806792:	83 ec 08             	sub    $0x8,%esp
  806795:	ff 75 0c             	pushl  0xc(%ebp)
  806798:	57                   	push   %edi
  806799:	e8 cf 76 00 00       	call   80de6d <raw_input>
  80679e:	83 c4 10             	add    $0x10,%esp
  8067a1:	84 c0                	test   %al,%al
  8067a3:	0f 85 62 fe ff ff    	jne    80660b <ip_input+0x31>
    switch (IPH_PROTO(iphdr)) {
  8067a9:	83 ec 0c             	sub    $0xc,%esp
  8067ac:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  8067b0:	50                   	push   %eax
  8067b1:	e8 d9 0f 00 00       	call   80778f <ntohs>
  8067b6:	83 c4 10             	add    $0x10,%esp
  8067b9:	0f b6 c0             	movzbl %al,%eax
  8067bc:	66 83 f8 06          	cmp    $0x6,%ax
  8067c0:	0f 84 c5 00 00 00    	je     80688b <ip_input+0x2b1>
  8067c6:	66 83 f8 11          	cmp    $0x11,%ax
  8067ca:	0f 84 a7 00 00 00    	je     806877 <ip_input+0x29d>
  8067d0:	66 83 f8 01          	cmp    $0x1,%ax
  8067d4:	0f 84 c5 00 00 00    	je     80689f <ip_input+0x2c5>
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  8067da:	83 ec 08             	sub    $0x8,%esp
  8067dd:	ff 75 0c             	pushl  0xc(%ebp)
  8067e0:	8d 46 10             	lea    0x10(%esi),%eax
  8067e3:	50                   	push   %eax
  8067e4:	e8 54 fd ff ff       	call   80653d <ip_addr_isbroadcast>
  8067e9:	83 c4 10             	add    $0x10,%esp
  8067ec:	84 c0                	test   %al,%al
  8067ee:	0f 84 bf 00 00 00    	je     8068b3 <ip_input+0x2d9>
      pbuf_free(p);
  8067f4:	83 ec 0c             	sub    $0xc,%esp
  8067f7:	57                   	push   %edi
  8067f8:	e8 50 e0 ff ff       	call   80484d <pbuf_free>
  8067fd:	83 c4 10             	add    $0x10,%esp
  806800:	e9 06 fe ff ff       	jmp    80660b <ip_input+0x31>
        netif = netif->next;
  806805:	8b 1b                	mov    (%ebx),%ebx
  806807:	e9 ac fe ff ff       	jmp    8066b8 <ip_input+0xde>
        netif = netif->next;
  80680c:	8b 1b                	mov    (%ebx),%ebx
  80680e:	e9 ae fe ff ff       	jmp    8066c1 <ip_input+0xe7>
  806813:	8b 7d 08             	mov    0x8(%ebp),%edi
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
  806816:	83 ec 0c             	sub    $0xc,%esp
  806819:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80681d:	50                   	push   %eax
  80681e:	e8 6c 0f 00 00       	call   80778f <ntohs>
  806823:	83 c4 10             	add    $0x10,%esp
  806826:	3c 11                	cmp    $0x11,%al
  806828:	0f 85 df fe ff ff    	jne    80670d <ip_input+0x133>
      if (ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest) == DHCP_CLIENT_PORT) {
  80682e:	83 ec 0c             	sub    $0xc,%esp
  806831:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  806835:	0f b7 44 06 02       	movzwl 0x2(%esi,%eax,1),%eax
  80683a:	50                   	push   %eax
  80683b:	e8 4f 0f 00 00       	call   80778f <ntohs>
  806840:	83 c4 10             	add    $0x10,%esp
  806843:	66 83 f8 44          	cmp    $0x44,%ax
  806847:	0f 85 c0 fe ff ff    	jne    80670d <ip_input+0x133>
        netif = inp;
  80684d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  806850:	e9 03 ff ff ff       	jmp    806758 <ip_input+0x17e>
      pbuf_free(p);
  806855:	83 ec 0c             	sub    $0xc,%esp
  806858:	57                   	push   %edi
  806859:	e8 ef df ff ff       	call   80484d <pbuf_free>
      return ERR_OK;
  80685e:	83 c4 10             	add    $0x10,%esp
  806861:	e9 a5 fd ff ff       	jmp    80660b <ip_input+0x31>
    pbuf_free(p);
  806866:	83 ec 0c             	sub    $0xc,%esp
  806869:	57                   	push   %edi
  80686a:	e8 de df ff ff       	call   80484d <pbuf_free>
    return ERR_OK;
  80686f:	83 c4 10             	add    $0x10,%esp
  806872:	e9 94 fd ff ff       	jmp    80660b <ip_input+0x31>
      udp_input(p, inp);
  806877:	83 ec 08             	sub    $0x8,%esp
  80687a:	ff 75 0c             	pushl  0xc(%ebp)
  80687d:	57                   	push   %edi
  80687e:	e8 88 21 00 00       	call   808a0b <udp_input>
      break;
  806883:	83 c4 10             	add    $0x10,%esp
  806886:	e9 80 fd ff ff       	jmp    80660b <ip_input+0x31>
      tcp_input(p, inp);
  80688b:	83 ec 08             	sub    $0x8,%esp
  80688e:	ff 75 0c             	pushl  0xc(%ebp)
  806891:	57                   	push   %edi
  806892:	e8 84 68 00 00       	call   80d11b <tcp_input>
      break;
  806897:	83 c4 10             	add    $0x10,%esp
  80689a:	e9 6c fd ff ff       	jmp    80660b <ip_input+0x31>
      icmp_input(p, inp);
  80689f:	83 ec 08             	sub    $0x8,%esp
  8068a2:	ff 75 0c             	pushl  0xc(%ebp)
  8068a5:	57                   	push   %edi
  8068a6:	e8 65 78 00 00       	call   80e110 <icmp_input>
      break;
  8068ab:	83 c4 10             	add    $0x10,%esp
  8068ae:	e9 58 fd ff ff       	jmp    80660b <ip_input+0x31>
          !ip_addr_ismulticast(&(iphdr->dest))) {
  8068b3:	8b 5e 10             	mov    0x10(%esi),%ebx
  8068b6:	83 ec 0c             	sub    $0xc,%esp
  8068b9:	68 00 00 00 f0       	push   $0xf0000000
  8068be:	e8 f7 10 00 00       	call   8079ba <ntohl>
  8068c3:	21 c3                	and    %eax,%ebx
  8068c5:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  8068cc:	e8 e9 10 00 00       	call   8079ba <ntohl>
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  8068d1:	83 c4 10             	add    $0x10,%esp
  8068d4:	39 c3                	cmp    %eax,%ebx
  8068d6:	0f 84 18 ff ff ff    	je     8067f4 <ip_input+0x21a>
        p->payload = iphdr;
  8068dc:	89 77 04             	mov    %esi,0x4(%edi)
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
  8068df:	83 ec 08             	sub    $0x8,%esp
  8068e2:	6a 02                	push   $0x2
  8068e4:	57                   	push   %edi
  8068e5:	e8 43 7b 00 00       	call   80e42d <icmp_dest_unreach>
  8068ea:	83 c4 10             	add    $0x10,%esp
  8068ed:	e9 02 ff ff ff       	jmp    8067f4 <ip_input+0x21a>

008068f2 <ip_output_if>:
 */
err_t
ip_output_if(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
  8068f2:	55                   	push   %ebp
  8068f3:	89 e5                	mov    %esp,%ebp
  8068f5:	57                   	push   %edi
  8068f6:	56                   	push   %esi
  8068f7:	53                   	push   %ebx
  8068f8:	83 ec 1c             	sub    $0x1c,%esp
  8068fb:	8b 75 08             	mov    0x8(%ebp),%esi
  8068fe:	8b 7d 14             	mov    0x14(%ebp),%edi
  806901:	8b 45 18             	mov    0x18(%ebp),%eax
  806904:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  806907:	8b 45 1c             	mov    0x1c(%ebp),%eax
  80690a:	89 45 e0             	mov    %eax,-0x20(%ebp)
  static u16_t ip_id = 0;

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
  80690d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  806911:	0f 84 3c 01 00 00    	je     806a53 <ip_output_if+0x161>
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
  806917:	83 ec 08             	sub    $0x8,%esp
  80691a:	6a 14                	push   $0x14
  80691c:	56                   	push   %esi
  80691d:	e8 57 de ff ff       	call   804779 <pbuf_header>
  806922:	83 c4 10             	add    $0x10,%esp
  806925:	84 c0                	test   %al,%al
  806927:	0f 85 4b 01 00 00    	jne    806a78 <ip_output_if+0x186>
      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
    }

    iphdr = p->payload;
  80692d:	8b 5e 04             	mov    0x4(%esi),%ebx
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
  806930:	66 83 7e 0a 13       	cmpw   $0x13,0xa(%esi)
  806935:	0f 86 fc 00 00 00    	jbe    806a37 <ip_output_if+0x145>
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
  80693b:	83 ec 0c             	sub    $0xc,%esp
  80693e:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  806942:	50                   	push   %eax
  806943:	e8 47 0e 00 00       	call   80778f <ntohs>
  806948:	0f b6 c0             	movzbl %al,%eax
  80694b:	c1 e7 08             	shl    $0x8,%edi
  80694e:	09 c7                	or     %eax,%edi
  806950:	0f b7 ff             	movzwl %di,%edi
  806953:	89 3c 24             	mov    %edi,(%esp)
  806956:	e8 27 0e 00 00       	call   807782 <htons>
  80695b:	66 89 43 08          	mov    %ax,0x8(%ebx)
    IPH_PROTO_SET(iphdr, proto);
  80695f:	0f b7 c0             	movzwl %ax,%eax
  806962:	89 04 24             	mov    %eax,(%esp)
  806965:	e8 25 0e 00 00       	call   80778f <ntohs>
  80696a:	89 c2                	mov    %eax,%edx
  80696c:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  806972:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
  806976:	09 d0                	or     %edx,%eax
  806978:	0f b7 c0             	movzwl %ax,%eax
  80697b:	89 04 24             	mov    %eax,(%esp)
  80697e:	e8 ff 0d 00 00       	call   807782 <htons>
  806983:	66 89 43 08          	mov    %ax,0x8(%ebx)

    ip_addr_set(&(iphdr->dest), dest);
  806987:	8b 45 10             	mov    0x10(%ebp),%eax
  80698a:	8b 00                	mov    (%eax),%eax
  80698c:	89 43 10             	mov    %eax,0x10(%ebx)

    IPH_VHLTOS_SET(iphdr, 4, IP_HLEN / 4, tos);
  80698f:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  806993:	80 cc 45             	or     $0x45,%ah
  806996:	89 04 24             	mov    %eax,(%esp)
  806999:	e8 e4 0d 00 00       	call   807782 <htons>
  80699e:	66 89 03             	mov    %ax,(%ebx)
    IPH_LEN_SET(iphdr, htons(p->tot_len));
  8069a1:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  8069a5:	89 04 24             	mov    %eax,(%esp)
  8069a8:	e8 d5 0d 00 00       	call   807782 <htons>
  8069ad:	66 89 43 02          	mov    %ax,0x2(%ebx)
    IPH_OFFSET_SET(iphdr, 0);
  8069b1:	66 c7 43 06 00 00    	movw   $0x0,0x6(%ebx)
    IPH_ID_SET(iphdr, htons(ip_id));
  8069b7:	0f b7 05 fa 43 b3 00 	movzwl 0xb343fa,%eax
  8069be:	89 04 24             	mov    %eax,(%esp)
  8069c1:	e8 bc 0d 00 00       	call   807782 <htons>
  8069c6:	66 89 43 04          	mov    %ax,0x4(%ebx)
    ++ip_id;
  8069ca:	66 83 05 fa 43 b3 00 	addw   $0x1,0xb343fa
  8069d1:	01 

    if (ip_addr_isany(src)) {
  8069d2:	83 c4 10             	add    $0x10,%esp
  8069d5:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  8069d9:	74 09                	je     8069e4 <ip_output_if+0xf2>
  8069db:	8b 45 0c             	mov    0xc(%ebp),%eax
  8069de:	8b 00                	mov    (%eax),%eax
  8069e0:	85 c0                	test   %eax,%eax
  8069e2:	75 6a                	jne    806a4e <ip_output_if+0x15c>
      ip_addr_set(&(iphdr->src), &(netif->ip_addr));
  8069e4:	b8 00 00 00 00       	mov    $0x0,%eax
  8069e9:	83 7d 20 fc          	cmpl   $0xfffffffc,0x20(%ebp)
  8069ed:	74 06                	je     8069f5 <ip_output_if+0x103>
  8069ef:	8b 45 20             	mov    0x20(%ebp),%eax
  8069f2:	8b 40 04             	mov    0x4(%eax),%eax
  8069f5:	89 43 0c             	mov    %eax,0xc(%ebx)
    } else {
      ip_addr_set(&(iphdr->src), src);
    }

    IPH_CHKSUM_SET(iphdr, 0);
  8069f8:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  8069fe:	83 ec 08             	sub    $0x8,%esp
  806a01:	6a 14                	push   $0x14
  806a03:	53                   	push   %ebx
  806a04:	e8 55 0c 00 00       	call   80765e <inet_chksum>
  806a09:	66 89 43 0a          	mov    %ax,0xa(%ebx)
  806a0d:	83 c4 10             	add    $0x10,%esp
    dest = &(iphdr->dest);
  }

#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu))
  806a10:	8b 45 20             	mov    0x20(%ebp),%eax
  806a13:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
  806a17:	66 85 c0             	test   %ax,%ax
  806a1a:	75 42                	jne    806a5e <ip_output_if+0x16c>
  } else
#endif /* (LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF) */
  {
    LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));

    return netif->output(netif, p, dest);
  806a1c:	83 ec 04             	sub    $0x4,%esp
  806a1f:	ff 75 10             	pushl  0x10(%ebp)
  806a22:	56                   	push   %esi
  806a23:	ff 75 20             	pushl  0x20(%ebp)
  806a26:	8b 45 20             	mov    0x20(%ebp),%eax
  806a29:	ff 50 14             	call   *0x14(%eax)
  806a2c:	83 c4 10             	add    $0x10,%esp
  }
}
  806a2f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806a32:	5b                   	pop    %ebx
  806a33:	5e                   	pop    %esi
  806a34:	5f                   	pop    %edi
  806a35:	5d                   	pop    %ebp
  806a36:	c3                   	ret    
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
  806a37:	83 ec 04             	sub    $0x4,%esp
  806a3a:	68 c8 1f 81 00       	push   $0x811fc8
  806a3f:	68 ee 01 00 00       	push   $0x1ee
  806a44:	68 f5 1f 81 00       	push   $0x811ff5
  806a49:	e8 05 7c 00 00       	call   80e653 <_panic>
      ip_addr_set(&(iphdr->src), src);
  806a4e:	89 43 0c             	mov    %eax,0xc(%ebx)
  806a51:	eb a5                	jmp    8069f8 <ip_output_if+0x106>
    dest = &(iphdr->dest);
  806a53:	8b 46 04             	mov    0x4(%esi),%eax
  806a56:	83 c0 10             	add    $0x10,%eax
  806a59:	89 45 10             	mov    %eax,0x10(%ebp)
  806a5c:	eb b2                	jmp    806a10 <ip_output_if+0x11e>
  if (netif->mtu && (p->tot_len > netif->mtu))
  806a5e:	66 3b 46 08          	cmp    0x8(%esi),%ax
  806a62:	73 b8                	jae    806a1c <ip_output_if+0x12a>
    return ip_frag(p,netif,dest);
  806a64:	83 ec 04             	sub    $0x4,%esp
  806a67:	ff 75 10             	pushl  0x10(%ebp)
  806a6a:	ff 75 20             	pushl  0x20(%ebp)
  806a6d:	56                   	push   %esi
  806a6e:	e8 91 07 00 00       	call   807204 <ip_frag>
  806a73:	83 c4 10             	add    $0x10,%esp
  806a76:	eb b7                	jmp    806a2f <ip_output_if+0x13d>
      return ERR_BUF;
  806a78:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  806a7d:	eb b0                	jmp    806a2f <ip_output_if+0x13d>

00806a7f <ip_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
  806a7f:	55                   	push   %ebp
  806a80:	89 e5                	mov    %esp,%ebp
  806a82:	57                   	push   %edi
  806a83:	56                   	push   %esi
  806a84:	53                   	push   %ebx
  806a85:	83 ec 18             	sub    $0x18,%esp
  806a88:	8b 5d 14             	mov    0x14(%ebp),%ebx
  806a8b:	8b 75 18             	mov    0x18(%ebp),%esi
  806a8e:	8b 7d 1c             	mov    0x1c(%ebp),%edi
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
  806a91:	ff 75 10             	pushl  0x10(%ebp)
  806a94:	e8 e4 fa ff ff       	call   80657d <ip_route>
  806a99:	83 c4 10             	add    $0x10,%esp
  806a9c:	85 c0                	test   %eax,%eax
  806a9e:	74 2d                	je     806acd <ip_output+0x4e>
    return ERR_RTE;
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
  806aa0:	83 ec 04             	sub    $0x4,%esp
  806aa3:	50                   	push   %eax
  806aa4:	89 f8                	mov    %edi,%eax
  806aa6:	0f b6 f8             	movzbl %al,%edi
  806aa9:	57                   	push   %edi
  806aaa:	89 f0                	mov    %esi,%eax
  806aac:	0f b6 f0             	movzbl %al,%esi
  806aaf:	56                   	push   %esi
  806ab0:	0f b6 db             	movzbl %bl,%ebx
  806ab3:	53                   	push   %ebx
  806ab4:	ff 75 10             	pushl  0x10(%ebp)
  806ab7:	ff 75 0c             	pushl  0xc(%ebp)
  806aba:	ff 75 08             	pushl  0x8(%ebp)
  806abd:	e8 30 fe ff ff       	call   8068f2 <ip_output_if>
  806ac2:	83 c4 20             	add    $0x20,%esp
}
  806ac5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806ac8:	5b                   	pop    %ebx
  806ac9:	5e                   	pop    %esi
  806aca:	5f                   	pop    %edi
  806acb:	5d                   	pop    %ebp
  806acc:	c3                   	ret    
    return ERR_RTE;
  806acd:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  806ad2:	eb f1                	jmp    806ac5 <ip_output+0x46>

00806ad4 <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  806ad4:	55                   	push   %ebp
  806ad5:	89 e5                	mov    %esp,%ebp
  806ad7:	83 ec 08             	sub    $0x8,%esp
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
  806ada:	39 05 e0 49 b3 00    	cmp    %eax,0xb349e0
  806ae0:	74 18                	je     806afa <ip_reass_dequeue_datagram+0x26>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
  806ae2:	85 d2                	test   %edx,%edx
  806ae4:	74 1e                	je     806b04 <ip_reass_dequeue_datagram+0x30>
    prev->next = ipr->next;
  806ae6:	8b 08                	mov    (%eax),%ecx
  806ae8:	89 0a                	mov    %ecx,(%edx)
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
  806aea:	83 ec 08             	sub    $0x8,%esp
  806aed:	50                   	push   %eax
  806aee:	6a 05                	push   $0x5
  806af0:	e8 e9 d9 ff ff       	call   8044de <memp_free>
}
  806af5:	83 c4 10             	add    $0x10,%esp
  806af8:	c9                   	leave  
  806af9:	c3                   	ret    
    reassdatagrams = ipr->next;
  806afa:	8b 10                	mov    (%eax),%edx
  806afc:	89 15 e0 49 b3 00    	mov    %edx,0xb349e0
  806b02:	eb e6                	jmp    806aea <ip_reass_dequeue_datagram+0x16>
    LWIP_ASSERT("sanity check linked list", prev != NULL);
  806b04:	83 ec 04             	sub    $0x4,%esp
  806b07:	68 0d 20 81 00       	push   $0x81200d
  806b0c:	68 29 01 00 00       	push   $0x129
  806b11:	68 26 20 81 00       	push   $0x812026
  806b16:	e8 38 7b 00 00       	call   80e653 <_panic>

00806b1b <ip_reass_free_complete_datagram>:
{
  806b1b:	55                   	push   %ebp
  806b1c:	89 e5                	mov    %esp,%ebp
  806b1e:	57                   	push   %edi
  806b1f:	56                   	push   %esi
  806b20:	53                   	push   %ebx
  806b21:	83 ec 1c             	sub    $0x1c,%esp
  806b24:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  806b27:	89 55 e0             	mov    %edx,-0x20(%ebp)
  LWIP_ASSERT("prev != ipr", prev != ipr);
  806b2a:	39 c2                	cmp    %eax,%edx
  806b2c:	74 2e                	je     806b5c <ip_reass_free_complete_datagram+0x41>
  if (prev != NULL) {
  806b2e:	8b 45 e0             	mov    -0x20(%ebp),%eax
  806b31:	85 c0                	test   %eax,%eax
  806b33:	74 07                	je     806b3c <ip_reass_free_complete_datagram+0x21>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  806b35:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  806b38:	39 10                	cmp    %edx,(%eax)
  806b3a:	75 37                	jne    806b73 <ip_reass_free_complete_datagram+0x58>
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  806b3c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806b3f:	8b 58 04             	mov    0x4(%eax),%ebx
  806b42:	8b 43 04             	mov    0x4(%ebx),%eax
  int pbufs_freed = 0;
  806b45:	be 00 00 00 00       	mov    $0x0,%esi
  if (iprh->start == 0) {
  806b4a:	66 83 78 04 00       	cmpw   $0x0,0x4(%eax)
  806b4f:	74 39                	je     806b8a <ip_reass_free_complete_datagram+0x6f>
  p = ipr->p;
  806b51:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806b54:	8b 58 04             	mov    0x4(%eax),%ebx
  while (p != NULL) {
  806b57:	e9 8a 00 00 00       	jmp    806be6 <ip_reass_free_complete_datagram+0xcb>
  LWIP_ASSERT("prev != ipr", prev != ipr);
  806b5c:	83 ec 04             	sub    $0x4,%esp
  806b5f:	68 43 20 81 00       	push   $0x812043
  806b64:	68 99 00 00 00       	push   $0x99
  806b69:	68 26 20 81 00       	push   $0x812026
  806b6e:	e8 e0 7a 00 00       	call   80e653 <_panic>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  806b73:	83 ec 04             	sub    $0x4,%esp
  806b76:	68 4f 20 81 00       	push   $0x81204f
  806b7b:	68 9b 00 00 00       	push   $0x9b
  806b80:	68 26 20 81 00       	push   $0x812026
  806b85:	e8 c9 7a 00 00       	call   80e653 <_panic>
    ipr->p = iprh->next_pbuf;
  806b8a:	8b 00                	mov    (%eax),%eax
  806b8c:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  806b8f:	89 41 04             	mov    %eax,0x4(%ecx)
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
  806b92:	83 ec 04             	sub    $0x4,%esp
  806b95:	6a 14                	push   $0x14
  806b97:	8d 41 08             	lea    0x8(%ecx),%eax
  806b9a:	50                   	push   %eax
  806b9b:	ff 73 04             	pushl  0x4(%ebx)
  806b9e:	e8 1e 84 00 00       	call   80efc1 <memcpy>
    icmp_time_exceeded(p, ICMP_TE_FRAG);
  806ba3:	83 c4 08             	add    $0x8,%esp
  806ba6:	6a 01                	push   $0x1
  806ba8:	53                   	push   %ebx
  806ba9:	e8 62 79 00 00       	call   80e510 <icmp_time_exceeded>
    pbufs_freed += pbuf_clen(p);
  806bae:	89 1c 24             	mov    %ebx,(%esp)
  806bb1:	e8 da e0 ff ff       	call   804c90 <pbuf_clen>
  806bb6:	0f b6 f0             	movzbl %al,%esi
    pbuf_free(p);
  806bb9:	89 1c 24             	mov    %ebx,(%esp)
  806bbc:	e8 8c dc ff ff       	call   80484d <pbuf_free>
  806bc1:	83 c4 10             	add    $0x10,%esp
  806bc4:	eb 8b                	jmp    806b51 <ip_reass_free_complete_datagram+0x36>
    iprh = (struct ip_reass_helper *)p->payload;
  806bc6:	8b 43 04             	mov    0x4(%ebx),%eax
    p = iprh->next_pbuf;
  806bc9:	8b 38                	mov    (%eax),%edi
    pbufs_freed += pbuf_clen(pcur);
  806bcb:	83 ec 0c             	sub    $0xc,%esp
  806bce:	53                   	push   %ebx
  806bcf:	e8 bc e0 ff ff       	call   804c90 <pbuf_clen>
  806bd4:	0f b6 c0             	movzbl %al,%eax
  806bd7:	01 c6                	add    %eax,%esi
    pbuf_free(pcur);    
  806bd9:	89 1c 24             	mov    %ebx,(%esp)
  806bdc:	e8 6c dc ff ff       	call   80484d <pbuf_free>
  806be1:	83 c4 10             	add    $0x10,%esp
    p = iprh->next_pbuf;
  806be4:	89 fb                	mov    %edi,%ebx
  while (p != NULL) {
  806be6:	85 db                	test   %ebx,%ebx
  806be8:	75 dc                	jne    806bc6 <ip_reass_free_complete_datagram+0xab>
  ip_reass_dequeue_datagram(ipr, prev);
  806bea:	8b 55 e0             	mov    -0x20(%ebp),%edx
  806bed:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806bf0:	e8 df fe ff ff       	call   806ad4 <ip_reass_dequeue_datagram>
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  806bf5:	0f b7 05 dc 49 b3 00 	movzwl 0xb349dc,%eax
  806bfc:	0f b7 d0             	movzwl %ax,%edx
  806bff:	39 f2                	cmp    %esi,%edx
  806c01:	7c 12                	jl     806c15 <ip_reass_free_complete_datagram+0xfa>
  ip_reass_pbufcount -= pbufs_freed;
  806c03:	29 f0                	sub    %esi,%eax
  806c05:	66 a3 dc 49 b3 00    	mov    %ax,0xb349dc
}
  806c0b:	89 f0                	mov    %esi,%eax
  806c0d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806c10:	5b                   	pop    %ebx
  806c11:	5e                   	pop    %esi
  806c12:	5f                   	pop    %edi
  806c13:	5d                   	pop    %ebp
  806c14:	c3                   	ret    
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  806c15:	83 ec 04             	sub    $0x4,%esp
  806c18:	68 61 20 81 00       	push   $0x812061
  806c1d:	68 bc 00 00 00       	push   $0xbc
  806c22:	68 26 20 81 00       	push   $0x812026
  806c27:	e8 27 7a 00 00       	call   80e653 <_panic>

00806c2c <ip_reass_remove_oldest_datagram>:
{
  806c2c:	55                   	push   %ebp
  806c2d:	89 e5                	mov    %esp,%ebp
  806c2f:	57                   	push   %edi
  806c30:	56                   	push   %esi
  806c31:	53                   	push   %ebx
  806c32:	83 ec 1c             	sub    $0x1c,%esp
  806c35:	89 c6                	mov    %eax,%esi
  806c37:	89 55 dc             	mov    %edx,-0x24(%ebp)
  int pbufs_freed = 0, pbufs_freed_current;
  806c3a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  806c41:	eb 5b                	jmp    806c9e <ip_reass_remove_oldest_datagram+0x72>
        other_datagrams++;
  806c43:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
        if (oldest == NULL) {
  806c47:	85 c0                	test   %eax,%eax
  806c49:	74 33                	je     806c7e <ip_reass_remove_oldest_datagram+0x52>
          oldest = r;
  806c4b:	0f b6 58 1f          	movzbl 0x1f(%eax),%ebx
  806c4f:	38 59 1f             	cmp    %bl,0x1f(%ecx)
  806c52:	0f 46 c1             	cmovbe %ecx,%eax
      if (r->next != NULL) {
  806c55:	8b 39                	mov    (%ecx),%edi
        prev = r;
  806c57:	85 ff                	test   %edi,%edi
  806c59:	0f 45 d1             	cmovne %ecx,%edx
  806c5c:	89 f9                	mov    %edi,%ecx
    while (r != NULL) {
  806c5e:	85 c9                	test   %ecx,%ecx
  806c60:	74 20                	je     806c82 <ip_reass_remove_oldest_datagram+0x56>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
  806c62:	8b 5e 0c             	mov    0xc(%esi),%ebx
  806c65:	39 59 14             	cmp    %ebx,0x14(%ecx)
  806c68:	75 d9                	jne    806c43 <ip_reass_remove_oldest_datagram+0x17>
  806c6a:	8b 7e 10             	mov    0x10(%esi),%edi
  806c6d:	39 79 18             	cmp    %edi,0x18(%ecx)
  806c70:	75 d1                	jne    806c43 <ip_reass_remove_oldest_datagram+0x17>
  806c72:	0f b7 7e 04          	movzwl 0x4(%esi),%edi
  806c76:	66 39 79 0c          	cmp    %di,0xc(%ecx)
  806c7a:	75 c7                	jne    806c43 <ip_reass_remove_oldest_datagram+0x17>
  806c7c:	eb d7                	jmp    806c55 <ip_reass_remove_oldest_datagram+0x29>
          oldest = r;
  806c7e:	89 c8                	mov    %ecx,%eax
  806c80:	eb d3                	jmp    806c55 <ip_reass_remove_oldest_datagram+0x29>
  806c82:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    if (oldest != NULL) {
  806c85:	85 c0                	test   %eax,%eax
  806c87:	74 08                	je     806c91 <ip_reass_remove_oldest_datagram+0x65>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
  806c89:	e8 8d fe ff ff       	call   806b1b <ip_reass_free_complete_datagram>
      pbufs_freed += pbufs_freed_current;
  806c8e:	01 45 e0             	add    %eax,-0x20(%ebp)
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
  806c91:	8b 55 dc             	mov    -0x24(%ebp),%edx
  806c94:	39 55 e0             	cmp    %edx,-0x20(%ebp)
  806c97:	7d 1f                	jge    806cb8 <ip_reass_remove_oldest_datagram+0x8c>
  806c99:	83 fb 01             	cmp    $0x1,%ebx
  806c9c:	7e 1a                	jle    806cb8 <ip_reass_remove_oldest_datagram+0x8c>
    r = reassdatagrams;
  806c9e:	8b 0d e0 49 b3 00    	mov    0xb349e0,%ecx
    other_datagrams = 0;
  806ca4:	bb 00 00 00 00       	mov    $0x0,%ebx
    prev = NULL;
  806ca9:	ba 00 00 00 00       	mov    $0x0,%edx
    oldest = NULL;
  806cae:	b8 00 00 00 00       	mov    $0x0,%eax
  806cb3:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
    while (r != NULL) {
  806cb6:	eb a6                	jmp    806c5e <ip_reass_remove_oldest_datagram+0x32>
}
  806cb8:	8b 45 e0             	mov    -0x20(%ebp),%eax
  806cbb:	83 c4 1c             	add    $0x1c,%esp
  806cbe:	5b                   	pop    %ebx
  806cbf:	5e                   	pop    %esi
  806cc0:	5f                   	pop    %edi
  806cc1:	5d                   	pop    %ebp
  806cc2:	c3                   	ret    

00806cc3 <ip_reass_tmr>:
{
  806cc3:	55                   	push   %ebp
  806cc4:	89 e5                	mov    %esp,%ebp
  806cc6:	56                   	push   %esi
  806cc7:	53                   	push   %ebx
  r = reassdatagrams;
  806cc8:	a1 e0 49 b3 00       	mov    0xb349e0,%eax
  struct ip_reassdata *r, *prev = NULL;
  806ccd:	bb 00 00 00 00       	mov    $0x0,%ebx
  while (r != NULL) {
  806cd2:	eb 0b                	jmp    806cdf <ip_reass_tmr+0x1c>
      r = r->next;
  806cd4:	8b 30                	mov    (%eax),%esi
      ip_reass_free_complete_datagram(tmp, prev);
  806cd6:	89 da                	mov    %ebx,%edx
  806cd8:	e8 3e fe ff ff       	call   806b1b <ip_reass_free_complete_datagram>
      r = r->next;
  806cdd:	89 f0                	mov    %esi,%eax
  while (r != NULL) {
  806cdf:	85 c0                	test   %eax,%eax
  806ce1:	74 14                	je     806cf7 <ip_reass_tmr+0x34>
    if (r->timer > 0) {
  806ce3:	0f b6 50 1f          	movzbl 0x1f(%eax),%edx
  806ce7:	84 d2                	test   %dl,%dl
  806ce9:	74 e9                	je     806cd4 <ip_reass_tmr+0x11>
      r->timer--;
  806ceb:	83 ea 01             	sub    $0x1,%edx
  806cee:	88 50 1f             	mov    %dl,0x1f(%eax)
      prev = r;
  806cf1:	89 c3                	mov    %eax,%ebx
      r = r->next;
  806cf3:	8b 00                	mov    (%eax),%eax
  806cf5:	eb e8                	jmp    806cdf <ip_reass_tmr+0x1c>
}
  806cf7:	5b                   	pop    %ebx
  806cf8:	5e                   	pop    %esi
  806cf9:	5d                   	pop    %ebp
  806cfa:	c3                   	ret    

00806cfb <ip_reass>:
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
  806cfb:	55                   	push   %ebp
  806cfc:	89 e5                	mov    %esp,%ebp
  806cfe:	57                   	push   %edi
  806cff:	56                   	push   %esi
  806d00:	53                   	push   %ebx
  806d01:	83 ec 38             	sub    $0x38,%esp
  struct ip_reassdata *ipr_prev = NULL;

  IPFRAG_STATS_INC(ip_frag.recv);
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;
  806d04:	8b 45 08             	mov    0x8(%ebp),%eax
  806d07:	8b 58 04             	mov    0x4(%eax),%ebx

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
  806d0a:	0f b7 03             	movzwl (%ebx),%eax
  806d0d:	50                   	push   %eax
  806d0e:	e8 7c 0a 00 00       	call   80778f <ntohs>
  806d13:	66 c1 e8 08          	shr    $0x8,%ax
  806d17:	83 e0 0f             	and    $0xf,%eax
  806d1a:	83 c4 10             	add    $0x10,%esp
  806d1d:	83 f8 05             	cmp    $0x5,%eax
  806d20:	0f 85 e3 01 00 00    	jne    806f09 <ip_reass+0x20e>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  806d26:	83 ec 0c             	sub    $0xc,%esp
  806d29:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  806d2d:	50                   	push   %eax
  806d2e:	e8 5c 0a 00 00       	call   80778f <ntohs>
  806d33:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  806d37:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  806d3b:	89 04 24             	mov    %eax,(%esp)
  806d3e:	e8 4c 0a 00 00       	call   80778f <ntohs>
  806d43:	66 89 45 da          	mov    %ax,-0x26(%ebp)
  806d47:	0f b7 03             	movzwl (%ebx),%eax
  806d4a:	89 04 24             	mov    %eax,(%esp)
  806d4d:	e8 3d 0a 00 00       	call   80778f <ntohs>
  806d52:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  806d56:	83 c4 04             	add    $0x4,%esp
  806d59:	ff 75 08             	pushl  0x8(%ebp)
  806d5c:	e8 2f df ff ff       	call   804c90 <pbuf_clen>
  806d61:	88 45 e4             	mov    %al,-0x1c(%ebp)
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
  806d64:	0f b6 f0             	movzbl %al,%esi
  806d67:	0f b7 05 dc 49 b3 00 	movzwl 0xb349dc,%eax
  806d6e:	01 f0                	add    %esi,%eax
  806d70:	83 c4 10             	add    $0x10,%esp
  806d73:	83 f8 0a             	cmp    $0xa,%eax
  806d76:	7f 0d                	jg     806d85 <ip_reass+0x8a>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  806d78:	8b 3d e0 49 b3 00    	mov    0xb349e0,%edi
  struct ip_reassdata *ipr_prev = NULL;
  806d7e:	b8 00 00 00 00       	mov    $0x0,%eax
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  806d83:	eb 28                	jmp    806dad <ip_reass+0xb2>
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  806d85:	89 f2                	mov    %esi,%edx
  806d87:	89 d8                	mov    %ebx,%eax
  806d89:	e8 9e fe ff ff       	call   806c2c <ip_reass_remove_oldest_datagram>
  806d8e:	85 c0                	test   %eax,%eax
  806d90:	0f 84 73 01 00 00    	je     806f09 <ip_reass+0x20e>
        ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
  806d96:	0f b7 05 dc 49 b3 00 	movzwl 0xb349dc,%eax
  806d9d:	01 f0                	add    %esi,%eax
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  806d9f:	83 f8 0a             	cmp    $0xa,%eax
  806da2:	7e d4                	jle    806d78 <ip_reass+0x7d>
  806da4:	e9 60 01 00 00       	jmp    806f09 <ip_reass+0x20e>
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  806da9:	89 f8                	mov    %edi,%eax
  806dab:	8b 3f                	mov    (%edi),%edi
  806dad:	85 ff                	test   %edi,%edi
  806daf:	0f 84 f7 00 00 00    	je     806eac <ip_reass+0x1b1>
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
  806db5:	8b 4b 0c             	mov    0xc(%ebx),%ecx
  806db8:	39 4f 14             	cmp    %ecx,0x14(%edi)
  806dbb:	75 ec                	jne    806da9 <ip_reass+0xae>
  806dbd:	8b 53 10             	mov    0x10(%ebx),%edx
  806dc0:	39 57 18             	cmp    %edx,0x18(%edi)
  806dc3:	75 e4                	jne    806da9 <ip_reass+0xae>
  806dc5:	0f b7 4b 04          	movzwl 0x4(%ebx),%ecx
  806dc9:	66 39 4f 0c          	cmp    %cx,0xc(%edi)
  806dcd:	75 da                	jne    806da9 <ip_reass+0xae>
  806dcf:	89 45 e0             	mov    %eax,-0x20(%ebp)
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  806dd2:	83 ec 0c             	sub    $0xc,%esp
  806dd5:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  806dd9:	50                   	push   %eax
  806dda:	e8 b0 09 00 00       	call   80778f <ntohs>
  806ddf:	83 c4 10             	add    $0x10,%esp
  806de2:	66 a9 ff 1f          	test   $0x1fff,%ax
  806de6:	0f 84 4c 01 00 00    	je     806f38 <ip_reass+0x23d>
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
    }
  }
  /* Track the current number of pbufs current 'in-flight', in order to limit 
  the number of fragments that may be enqueued at any one time */
  ip_reass_pbufcount += clen;
  806dec:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  806df0:	66 01 05 dc 49 b3 00 	add    %ax,0xb349dc

  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((ntohs(IPH_OFFSET(fraghdr)) & IP_MF) == 0) {
  806df7:	83 ec 0c             	sub    $0xc,%esp
  806dfa:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  806dfe:	50                   	push   %eax
  806dff:	e8 8b 09 00 00       	call   80778f <ntohs>
  806e04:	83 c4 10             	add    $0x10,%esp
  806e07:	f6 c4 20             	test   $0x20,%ah
  806e0a:	75 20                	jne    806e2c <ip_reass+0x131>
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
  806e0c:	80 4f 1e 01          	orb    $0x1,0x1e(%edi)
    ipr->datagram_len = offset + len;
  806e10:	0f b7 45 dc          	movzwl -0x24(%ebp),%eax
  806e14:	0f b7 75 da          	movzwl -0x26(%ebp),%esi
  806e18:	8d 04 c6             	lea    (%esi,%eax,8),%eax
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  806e1b:	0f b7 55 d4          	movzwl -0x2c(%ebp),%edx
  806e1f:	66 c1 ea 06          	shr    $0x6,%dx
  806e23:	83 e2 3c             	and    $0x3c,%edx
    ipr->datagram_len = offset + len;
  806e26:	29 d0                	sub    %edx,%eax
  806e28:	66 89 47 1c          	mov    %ax,0x1c(%edi)
  fraghdr = (struct ip_hdr*)new_p->payload; 
  806e2c:	8b 45 08             	mov    0x8(%ebp),%eax
  806e2f:	8b 70 04             	mov    0x4(%eax),%esi
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  806e32:	83 ec 0c             	sub    $0xc,%esp
  806e35:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  806e39:	50                   	push   %eax
  806e3a:	e8 50 09 00 00       	call   80778f <ntohs>
  806e3f:	89 c3                	mov    %eax,%ebx
  806e41:	0f b7 06             	movzwl (%esi),%eax
  806e44:	89 04 24             	mov    %eax,(%esp)
  806e47:	e8 43 09 00 00       	call   80778f <ntohs>
  806e4c:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  806e50:	0f b7 46 06          	movzwl 0x6(%esi),%eax
  806e54:	89 04 24             	mov    %eax,(%esp)
  806e57:	e8 33 09 00 00       	call   80778f <ntohs>
  806e5c:	8d 0c c5 00 00 00 00 	lea    0x0(,%eax,8),%ecx
  iprh = (struct ip_reass_helper*)new_p->payload;
  806e63:	8b 75 08             	mov    0x8(%ebp),%esi
  806e66:	8b 56 04             	mov    0x4(%esi),%edx
  806e69:	89 55 dc             	mov    %edx,-0x24(%ebp)
  iprh->next_pbuf = NULL;
  806e6c:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
  iprh->start = offset;
  806e72:	66 89 4a 04          	mov    %cx,0x4(%edx)
  iprh->end = offset + len;
  806e76:	01 cb                	add    %ecx,%ebx
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  806e78:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  806e7c:	66 c1 e8 06          	shr    $0x6,%ax
  806e80:	83 e0 3c             	and    $0x3c,%eax
  iprh->end = offset + len;
  806e83:	29 c3                	sub    %eax,%ebx
  806e85:	66 89 5d da          	mov    %bx,-0x26(%ebp)
  806e89:	66 89 5a 06          	mov    %bx,0x6(%edx)
  for (q = ipr->p; q != NULL;) {
  806e8d:	8b 47 04             	mov    0x4(%edi),%eax
  806e90:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  806e93:	83 c4 10             	add    $0x10,%esp
  806e96:	89 c3                	mov    %eax,%ebx
  int valid = 1;
  806e98:	b8 01 00 00 00       	mov    $0x1,%eax
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
  806e9d:	be 00 00 00 00       	mov    $0x0,%esi
  806ea2:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  806ea5:	89 c7                	mov    %eax,%edi
  806ea7:	e9 3e 01 00 00       	jmp    806fea <ip_reass+0x2ef>
  806eac:	89 45 e0             	mov    %eax,-0x20(%ebp)
  ipr = memp_malloc(MEMP_REASSDATA);
  806eaf:	83 ec 0c             	sub    $0xc,%esp
  806eb2:	6a 05                	push   $0x5
  806eb4:	e8 cf d5 ff ff       	call   804488 <memp_malloc>
  806eb9:	89 c7                	mov    %eax,%edi
  if (ipr == NULL) {
  806ebb:	83 c4 10             	add    $0x10,%esp
  806ebe:	85 c0                	test   %eax,%eax
  806ec0:	74 3a                	je     806efc <ip_reass+0x201>
  memset(ipr, 0, sizeof(struct ip_reassdata));
  806ec2:	83 ec 04             	sub    $0x4,%esp
  806ec5:	6a 20                	push   $0x20
  806ec7:	6a 00                	push   $0x0
  806ec9:	57                   	push   %edi
  806eca:	e8 3d 80 00 00       	call   80ef0c <memset>
  ipr->timer = IP_REASS_MAXAGE;
  806ecf:	c6 47 1f 03          	movb   $0x3,0x1f(%edi)
  ipr->next = reassdatagrams;
  806ed3:	a1 e0 49 b3 00       	mov    0xb349e0,%eax
  806ed8:	89 07                	mov    %eax,(%edi)
  reassdatagrams = ipr;
  806eda:	89 3d e0 49 b3 00    	mov    %edi,0xb349e0
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
  806ee0:	83 c4 0c             	add    $0xc,%esp
  806ee3:	6a 14                	push   $0x14
  806ee5:	53                   	push   %ebx
  806ee6:	8d 47 08             	lea    0x8(%edi),%eax
  806ee9:	50                   	push   %eax
  806eea:	e8 d2 80 00 00       	call   80efc1 <memcpy>
    if(ipr == NULL) {
  806eef:	83 c4 10             	add    $0x10,%esp
  806ef2:	85 ff                	test   %edi,%edi
  806ef4:	0f 85 f2 fe ff ff    	jne    806dec <ip_reass+0xf1>
  806efa:	eb 0d                	jmp    806f09 <ip_reass+0x20e>
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
  806efc:	89 f2                	mov    %esi,%edx
  806efe:	89 d8                	mov    %ebx,%eax
  806f00:	e8 27 fd ff ff       	call   806c2c <ip_reass_remove_oldest_datagram>
  806f05:	39 c6                	cmp    %eax,%esi
  806f07:	7e 1a                	jle    806f23 <ip_reass+0x228>
  return NULL;

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  806f09:	83 ec 0c             	sub    $0xc,%esp
  806f0c:	ff 75 08             	pushl  0x8(%ebp)
  806f0f:	e8 39 d9 ff ff       	call   80484d <pbuf_free>
  return NULL;
  806f14:	83 c4 10             	add    $0x10,%esp
  806f17:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  806f1e:	e9 c9 01 00 00       	jmp    8070ec <ip_reass+0x3f1>
      ipr = memp_malloc(MEMP_REASSDATA);
  806f23:	83 ec 0c             	sub    $0xc,%esp
  806f26:	6a 05                	push   $0x5
  806f28:	e8 5b d5 ff ff       	call   804488 <memp_malloc>
  806f2d:	89 c7                	mov    %eax,%edi
    if (ipr == NULL)
  806f2f:	83 c4 10             	add    $0x10,%esp
  806f32:	85 c0                	test   %eax,%eax
  806f34:	75 8c                	jne    806ec2 <ip_reass+0x1c7>
  806f36:	eb d1                	jmp    806f09 <ip_reass+0x20e>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
  806f38:	83 ec 0c             	sub    $0xc,%esp
  806f3b:	0f b7 47 0e          	movzwl 0xe(%edi),%eax
  806f3f:	50                   	push   %eax
  806f40:	e8 4a 08 00 00       	call   80778f <ntohs>
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  806f45:	83 c4 10             	add    $0x10,%esp
  806f48:	66 a9 ff 1f          	test   $0x1fff,%ax
  806f4c:	0f 84 9a fe ff ff    	je     806dec <ip_reass+0xf1>
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
  806f52:	83 ec 04             	sub    $0x4,%esp
  806f55:	6a 14                	push   $0x14
  806f57:	53                   	push   %ebx
  806f58:	8d 47 08             	lea    0x8(%edi),%eax
  806f5b:	50                   	push   %eax
  806f5c:	e8 60 80 00 00       	call   80efc1 <memcpy>
  806f61:	83 c4 10             	add    $0x10,%esp
  806f64:	e9 83 fe ff ff       	jmp    806dec <ip_reass+0xf1>
  806f69:	89 7d d0             	mov    %edi,-0x30(%ebp)
  806f6c:	8b 7d e4             	mov    -0x1c(%ebp),%edi
      iprh->next_pbuf = q;
  806f6f:	8b 45 dc             	mov    -0x24(%ebp),%eax
  806f72:	89 18                	mov    %ebx,(%eax)
      if (iprh_prev != NULL) {
  806f74:	85 f6                	test   %esi,%esi
  806f76:	74 1f                	je     806f97 <ip_reass+0x29c>
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
  806f78:	66 3b 4e 06          	cmp    0x6(%esi),%cx
  806f7c:	0f 82 40 01 00 00    	jb     8070c2 <ip_reass+0x3c7>
  806f82:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
  806f86:	66 3b 42 04          	cmp    0x4(%edx),%ax
  806f8a:	0f 87 32 01 00 00    	ja     8070c2 <ip_reass+0x3c7>
        iprh_prev->next_pbuf = new_p;
  806f90:	8b 45 08             	mov    0x8(%ebp),%eax
  806f93:	89 06                	mov    %eax,(%esi)
  806f95:	eb 06                	jmp    806f9d <ip_reass+0x2a2>
        ipr->p = new_p;
  806f97:	8b 45 08             	mov    0x8(%ebp),%eax
  806f9a:	89 47 04             	mov    %eax,0x4(%edi)
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
  806f9d:	f6 47 1e 01          	testb  $0x1,0x1e(%edi)
  806fa1:	0f 84 3e 01 00 00    	je     8070e5 <ip_reass+0x3ea>
    if (valid) {
  806fa7:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
  806fab:	0f 84 34 01 00 00    	je     8070e5 <ip_reass+0x3ea>
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
  806fb1:	8b 4f 04             	mov    0x4(%edi),%ecx
  806fb4:	8b 59 04             	mov    0x4(%ecx),%ebx
  806fb7:	66 83 7b 04 00       	cmpw   $0x0,0x4(%ebx)
  806fbc:	0f 85 23 01 00 00    	jne    8070e5 <ip_reass+0x3ea>
        q = iprh->next_pbuf;
  806fc2:	8b 75 dc             	mov    -0x24(%ebp),%esi
  806fc5:	8b 16                	mov    (%esi),%edx
        while (q != NULL) {
  806fc7:	85 d2                	test   %edx,%edx
  806fc9:	0f 84 ab 01 00 00    	je     80717a <ip_reass+0x47f>
          iprh = (struct ip_reass_helper*)q->payload;
  806fcf:	8b 42 04             	mov    0x4(%edx),%eax
          if (iprh_prev->end != iprh->start) {
  806fd2:	0f b7 50 04          	movzwl 0x4(%eax),%edx
  806fd6:	66 39 56 06          	cmp    %dx,0x6(%esi)
  806fda:	0f 85 5f 01 00 00    	jne    80713f <ip_reass+0x444>
          q = iprh->next_pbuf;
  806fe0:	8b 10                	mov    (%eax),%edx
          iprh = (struct ip_reass_helper*)q->payload;
  806fe2:	89 c6                	mov    %eax,%esi
  806fe4:	eb e1                	jmp    806fc7 <ip_reass+0x2cc>
    q = iprh_tmp->next_pbuf;
  806fe6:	8b 1a                	mov    (%edx),%ebx
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  806fe8:	89 d6                	mov    %edx,%esi
  for (q = ipr->p; q != NULL;) {
  806fea:	85 db                	test   %ebx,%ebx
  806fec:	0f 84 56 01 00 00    	je     807148 <ip_reass+0x44d>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  806ff2:	8b 53 04             	mov    0x4(%ebx),%edx
    if (iprh->start < iprh_tmp->start) {
  806ff5:	0f b7 42 04          	movzwl 0x4(%edx),%eax
  806ff9:	66 39 c1             	cmp    %ax,%cx
  806ffc:	0f 82 67 ff ff ff    	jb     806f69 <ip_reass+0x26e>
    } else if(iprh->start == iprh_tmp->start) {
  807002:	66 39 c1             	cmp    %ax,%cx
  807005:	0f 84 b7 00 00 00    	je     8070c2 <ip_reass+0x3c7>
    } else if(iprh->start < iprh_tmp->end) {
  80700b:	66 3b 4a 06          	cmp    0x6(%edx),%cx
  80700f:	0f 82 ad 00 00 00    	jb     8070c2 <ip_reass+0x3c7>
      if (iprh_prev != NULL) {
  807015:	85 f6                	test   %esi,%esi
  807017:	74 cd                	je     806fe6 <ip_reass+0x2eb>
          valid = 0;
  807019:	66 3b 46 06          	cmp    0x6(%esi),%ax
  80701d:	b8 00 00 00 00       	mov    $0x0,%eax
  807022:	0f 45 f8             	cmovne %eax,%edi
  807025:	eb bf                	jmp    806fe6 <ip_reass+0x2eb>
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
  807027:	83 ec 04             	sub    $0x4,%esp
  80702a:	68 7c 20 81 00       	push   $0x81207c
  80702f:	68 83 01 00 00       	push   $0x183
  807034:	68 26 20 81 00       	push   $0x812026
  807039:	e8 15 76 00 00       	call   80e653 <_panic>
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
  80703e:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  807042:	75 0b                	jne    80704f <ip_reass+0x354>
      ipr->p = new_p;
  807044:	8b 45 08             	mov    0x8(%ebp),%eax
  807047:	89 47 04             	mov    %eax,0x4(%edi)
  80704a:	e9 4e ff ff ff       	jmp    806f9d <ip_reass+0x2a2>
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
  80704f:	83 ec 04             	sub    $0x4,%esp
  807052:	68 a8 20 81 00       	push   $0x8120a8
  807057:	68 8c 01 00 00       	push   $0x18c
  80705c:	68 26 20 81 00       	push   $0x812026
  807061:	e8 ed 75 00 00       	call   80e653 <_panic>
          LWIP_ASSERT("sanity check", ipr->p != NULL);
  807066:	83 ec 04             	sub    $0x4,%esp
  807069:	68 9a 20 81 00       	push   $0x81209a
  80706e:	68 ac 01 00 00       	push   $0x1ac
  807073:	68 26 20 81 00       	push   $0x812026
  807078:	e8 d6 75 00 00       	call   80e653 <_panic>
          LWIP_ASSERT("sanity check",
  80707d:	83 ec 04             	sub    $0x4,%esp
  807080:	68 9a 20 81 00       	push   $0x81209a
  807085:	68 ae 01 00 00       	push   $0x1ae
  80708a:	68 26 20 81 00       	push   $0x812026
  80708f:	e8 bf 75 00 00       	call   80e653 <_panic>
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
  807094:	83 ec 04             	sub    $0x4,%esp
  807097:	68 e0 20 81 00       	push   $0x8120e0
  80709c:	68 b0 01 00 00       	push   $0x1b0
  8070a1:	68 26 20 81 00       	push   $0x812026
  8070a6:	e8 a8 75 00 00       	call   80e653 <_panic>
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
  8070ab:	83 ec 04             	sub    $0x4,%esp
  8070ae:	68 04 21 81 00       	push   $0x812104
  8070b3:	68 b2 01 00 00       	push   $0x1b2
  8070b8:	68 26 20 81 00       	push   $0x812026
  8070bd:	e8 91 75 00 00       	call   80e653 <_panic>
  ip_reass_pbufcount -= pbuf_clen(new_p);
  8070c2:	83 ec 0c             	sub    $0xc,%esp
  8070c5:	ff 75 08             	pushl  0x8(%ebp)
  8070c8:	e8 c3 db ff ff       	call   804c90 <pbuf_clen>
  8070cd:	0f b6 c0             	movzbl %al,%eax
  8070d0:	66 29 05 dc 49 b3 00 	sub    %ax,0xb349dc
  pbuf_free(new_p);
  8070d7:	83 c4 04             	add    $0x4,%esp
  8070da:	ff 75 08             	pushl  0x8(%ebp)
  8070dd:	e8 6b d7 ff ff       	call   80484d <pbuf_free>
  8070e2:	83 c4 10             	add    $0x10,%esp
  return NULL;
  8070e5:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
}
  8070ec:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8070ef:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8070f2:	5b                   	pop    %ebx
  8070f3:	5e                   	pop    %esi
  8070f4:	5f                   	pop    %edi
  8070f5:	5d                   	pop    %ebp
  8070f6:	c3                   	ret    
      iprh = (struct ip_reass_helper*)r->payload;
  8070f7:	8b 73 04             	mov    0x4(%ebx),%esi
      pbuf_header(r, -IP_HLEN);
  8070fa:	83 ec 08             	sub    $0x8,%esp
  8070fd:	6a ec                	push   $0xffffffec
  8070ff:	53                   	push   %ebx
  807100:	e8 74 d6 ff ff       	call   804779 <pbuf_header>
      pbuf_cat(p, r);
  807105:	83 c4 08             	add    $0x8,%esp
  807108:	53                   	push   %ebx
  807109:	57                   	push   %edi
  80710a:	e8 aa db ff ff       	call   804cb9 <pbuf_cat>
      r = iprh->next_pbuf;
  80710f:	8b 1e                	mov    (%esi),%ebx
  807111:	83 c4 10             	add    $0x10,%esp
    while(r != NULL) {
  807114:	85 db                	test   %ebx,%ebx
  807116:	75 df                	jne    8070f7 <ip_reass+0x3fc>
  807118:	8b 7d dc             	mov    -0x24(%ebp),%edi
    ip_reass_dequeue_datagram(ipr, ipr_prev);
  80711b:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80711e:	89 f8                	mov    %edi,%eax
  807120:	e8 af f9 ff ff       	call   806ad4 <ip_reass_dequeue_datagram>
    ip_reass_pbufcount -= pbuf_clen(p);
  807125:	83 ec 0c             	sub    $0xc,%esp
  807128:	ff 75 e4             	pushl  -0x1c(%ebp)
  80712b:	e8 60 db ff ff       	call   804c90 <pbuf_clen>
  807130:	0f b6 c0             	movzbl %al,%eax
  807133:	66 29 05 dc 49 b3 00 	sub    %ax,0xb349dc
    return p;
  80713a:	83 c4 10             	add    $0x10,%esp
  80713d:	eb ad                	jmp    8070ec <ip_reass+0x3f1>
  return NULL;
  80713f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  807146:	eb a4                	jmp    8070ec <ip_reass+0x3f1>
  807148:	89 7d d0             	mov    %edi,-0x30(%ebp)
  80714b:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    if (iprh_prev != NULL) {
  80714e:	85 f6                	test   %esi,%esi
  807150:	0f 84 e8 fe ff ff    	je     80703e <ip_reass+0x343>
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
  807156:	0f b7 46 06          	movzwl 0x6(%esi),%eax
  80715a:	66 39 c1             	cmp    %ax,%cx
  80715d:	0f 82 c4 fe ff ff    	jb     807027 <ip_reass+0x32c>
      iprh_prev->next_pbuf = new_p;
  807163:	8b 4d 08             	mov    0x8(%ebp),%ecx
  807166:	89 0e                	mov    %ecx,(%esi)
      if (iprh_prev->end != iprh->start) {
  807168:	8b 75 dc             	mov    -0x24(%ebp),%esi
  80716b:	66 3b 46 04          	cmp    0x4(%esi),%ax
  80716f:	0f 85 70 ff ff ff    	jne    8070e5 <ip_reass+0x3ea>
  807175:	e9 23 fe ff ff       	jmp    806f9d <ip_reass+0x2a2>
  80717a:	89 75 dc             	mov    %esi,-0x24(%ebp)
          LWIP_ASSERT("sanity check", ipr->p != NULL);
  80717d:	85 c9                	test   %ecx,%ecx
  80717f:	0f 84 e1 fe ff ff    	je     807066 <ip_reass+0x36b>
          LWIP_ASSERT("sanity check",
  807185:	3b 5d dc             	cmp    -0x24(%ebp),%ebx
  807188:	0f 84 ef fe ff ff    	je     80707d <ip_reass+0x382>
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
  80718e:	8b 45 dc             	mov    -0x24(%ebp),%eax
  807191:	83 38 00             	cmpl   $0x0,(%eax)
  807194:	0f 85 fa fe ff ff    	jne    807094 <ip_reass+0x399>
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
  80719a:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  80719e:	8b 75 dc             	mov    -0x24(%ebp),%esi
  8071a1:	66 39 46 06          	cmp    %ax,0x6(%esi)
  8071a5:	0f 85 00 ff ff ff    	jne    8070ab <ip_reass+0x3b0>
    ipr->datagram_len += IP_HLEN;
  8071ab:	83 c0 14             	add    $0x14,%eax
  8071ae:	66 89 47 1c          	mov    %ax,0x1c(%edi)
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
  8071b2:	8b 71 04             	mov    0x4(%ecx),%esi
  8071b5:	8b 1e                	mov    (%esi),%ebx
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
  8071b7:	83 ec 04             	sub    $0x4,%esp
  8071ba:	6a 14                	push   $0x14
  8071bc:	8d 47 08             	lea    0x8(%edi),%eax
  8071bf:	50                   	push   %eax
  8071c0:	56                   	push   %esi
  8071c1:	e8 fb 7d 00 00       	call   80efc1 <memcpy>
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
  8071c6:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  8071ca:	89 04 24             	mov    %eax,(%esp)
  8071cd:	e8 b0 05 00 00       	call   807782 <htons>
  8071d2:	66 89 46 02          	mov    %ax,0x2(%esi)
    IPH_OFFSET_SET(fraghdr, 0);
  8071d6:	66 c7 46 06 00 00    	movw   $0x0,0x6(%esi)
    IPH_CHKSUM_SET(fraghdr, 0);
  8071dc:	66 c7 46 0a 00 00    	movw   $0x0,0xa(%esi)
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
  8071e2:	83 c4 08             	add    $0x8,%esp
  8071e5:	6a 14                	push   $0x14
  8071e7:	56                   	push   %esi
  8071e8:	e8 71 04 00 00       	call   80765e <inet_chksum>
  8071ed:	66 89 46 0a          	mov    %ax,0xa(%esi)
    p = ipr->p;
  8071f1:	8b 47 04             	mov    0x4(%edi),%eax
  8071f4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    while(r != NULL) {
  8071f7:	83 c4 10             	add    $0x10,%esp
  8071fa:	89 7d dc             	mov    %edi,-0x24(%ebp)
  8071fd:	89 c7                	mov    %eax,%edi
  8071ff:	e9 10 ff ff ff       	jmp    807114 <ip_reass+0x419>

00807204 <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, struct ip_addr *dest)
{
  807204:	55                   	push   %ebp
  807205:	89 e5                	mov    %esp,%ebp
  807207:	57                   	push   %edi
  807208:	56                   	push   %esi
  807209:	53                   	push   %ebx
  80720a:	83 ec 30             	sub    $0x30,%esp
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
  80720d:	8b 45 0c             	mov    0xc(%ebp),%eax
  807210:	0f b7 58 2c          	movzwl 0x2c(%eax),%ebx
#if IP_FRAG_USES_STATIC_BUF
  /* When using a static buffer, we use a PBUF_REF, which we will
   * use to reference the packet (without link header).
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  807214:	6a 02                	push   $0x2
  807216:	6a 00                	push   $0x0
  807218:	6a 02                	push   $0x2
  80721a:	e8 f4 d6 ff ff       	call   804913 <pbuf_alloc>
  80721f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  if (rambuf == NULL) {
  807222:	83 c4 10             	add    $0x10,%esp
  807225:	85 c0                	test   %eax,%eax
  807227:	0f 84 b5 01 00 00    	je     8073e2 <ip_frag+0x1de>
  80722d:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  }
  rambuf->tot_len = rambuf->len = mtu;
  80722f:	66 89 58 0a          	mov    %bx,0xa(%eax)
  807233:	66 89 58 08          	mov    %bx,0x8(%eax)
  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
  807237:	b8 03 44 b3 00       	mov    $0xb34403,%eax
  80723c:	83 e0 fc             	and    $0xfffffffc,%eax
  80723f:	89 c7                	mov    %eax,%edi
  807241:	89 46 04             	mov    %eax,0x4(%esi)

  /* Copy the IP header in it */
  iphdr = rambuf->payload;
  SMEMCPY(iphdr, p->payload, IP_HLEN);
  807244:	83 ec 04             	sub    $0x4,%esp
  807247:	6a 14                	push   $0x14
  807249:	8b 45 08             	mov    0x8(%ebp),%eax
  80724c:	ff 70 04             	pushl  0x4(%eax)
  80724f:	57                   	push   %edi
  807250:	e8 6c 7d 00 00       	call   80efc1 <memcpy>
  original_iphdr = p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  807255:	0f b7 47 06          	movzwl 0x6(%edi),%eax
  807259:	89 04 24             	mov    %eax,(%esp)
  80725c:	e8 2e 05 00 00       	call   80778f <ntohs>
  ofo = tmp & IP_OFFMASK;
  807261:	89 c2                	mov    %eax,%edx
  807263:	66 81 e2 ff 1f       	and    $0x1fff,%dx
  807268:	66 89 55 de          	mov    %dx,-0x22(%ebp)
  omf = tmp & IP_MF;
  80726c:	66 25 00 20          	and    $0x2000,%ax
  807270:	66 89 45 dc          	mov    %ax,-0x24(%ebp)

  left = p->tot_len - IP_HLEN;
  807274:	8b 45 08             	mov    0x8(%ebp),%eax
  807277:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80727b:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
  80727f:	8d 70 ec             	lea    -0x14(%eax),%esi

  nfb = (mtu - IP_HLEN) / 8;
  807282:	0f b7 db             	movzwl %bx,%ebx
  807285:	8d 43 f3             	lea    -0xd(%ebx),%eax
  807288:	83 c4 10             	add    $0x10,%esp
  80728b:	83 eb 14             	sub    $0x14,%ebx
  80728e:	89 5d e0             	mov    %ebx,-0x20(%ebp)
  807291:	0f 49 c3             	cmovns %ebx,%eax
  807294:	c1 f8 03             	sar    $0x3,%eax
  807297:	66 89 45 ce          	mov    %ax,-0x32(%ebp)
  u16_t poff = IP_HLEN;
  80729b:	66 c7 45 e4 14 00    	movw   $0x14,-0x1c(%ebp)
    tmp = omf | (IP_OFFMASK & (ofo));
    if (!last)
      tmp = tmp | IP_MF;

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  8072a1:	c1 e0 03             	shl    $0x3,%eax
  8072a4:	66 89 45 cc          	mov    %ax,-0x34(%ebp)

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  8072a8:	8d 47 14             	lea    0x14(%edi),%eax
  8072ab:	89 45 d0             	mov    %eax,-0x30(%ebp)
  while (left) {
  8072ae:	e9 b0 00 00 00       	jmp    807363 <ip_frag+0x15f>
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  8072b3:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  8072b7:	50                   	push   %eax
  8072b8:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  8072bc:	50                   	push   %eax
  8072bd:	ff 75 d0             	pushl  -0x30(%ebp)
  8072c0:	ff 75 08             	pushl  0x8(%ebp)
  8072c3:	e8 0f dd ff ff       	call   804fd7 <pbuf_copy_partial>
  8072c8:	66 01 45 e4          	add    %ax,-0x1c(%ebp)
    }
    poff = newpbuflen;
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
  8072cc:	0f b7 db             	movzwl %bx,%ebx
  8072cf:	89 1c 24             	mov    %ebx,(%esp)
  8072d2:	e8 ab 04 00 00       	call   807782 <htons>
  8072d7:	66 89 47 06          	mov    %ax,0x6(%edi)
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  8072db:	0f b7 4d e6          	movzwl -0x1a(%ebp),%ecx
  8072df:	8d 41 14             	lea    0x14(%ecx),%eax
  8072e2:	0f b7 c0             	movzwl %ax,%eax
  8072e5:	89 04 24             	mov    %eax,(%esp)
  8072e8:	e8 95 04 00 00       	call   807782 <htons>
  8072ed:	66 89 47 02          	mov    %ax,0x2(%edi)
    IPH_CHKSUM_SET(iphdr, 0);
  8072f1:	66 c7 47 0a 00 00    	movw   $0x0,0xa(%edi)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  8072f7:	83 c4 08             	add    $0x8,%esp
  8072fa:	6a 14                	push   $0x14
  8072fc:	57                   	push   %edi
  8072fd:	e8 5c 03 00 00       	call   80765e <inet_chksum>
  807302:	66 89 47 0a          	mov    %ax,0xa(%edi)

#if IP_FRAG_USES_STATIC_BUF
    if (last)
  807306:	83 c4 10             	add    $0x10,%esp
  807309:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80730c:	39 55 e0             	cmp    %edx,-0x20(%ebp)
  80730f:	0f 8d 83 00 00 00    	jge    807398 <ip_frag+0x194>
    /* This part is ugly: we alloc a RAM based pbuf for 
     * the link level header for each chunk and then 
     * free it.A PBUF_ROM style pbuf for which pbuf_header
     * worked would make things simpler.
     */
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
  807315:	83 ec 04             	sub    $0x4,%esp
  807318:	6a 00                	push   $0x0
  80731a:	6a 00                	push   $0x0
  80731c:	6a 02                	push   $0x2
  80731e:	e8 f0 d5 ff ff       	call   804913 <pbuf_alloc>
  807323:	89 c3                	mov    %eax,%ebx
    if (header != NULL) {
  807325:	83 c4 10             	add    $0x10,%esp
  807328:	85 c0                	test   %eax,%eax
  80732a:	0f 84 82 00 00 00    	je     8073b2 <ip_frag+0x1ae>
      pbuf_chain(header, rambuf);
  807330:	83 ec 08             	sub    $0x8,%esp
  807333:	ff 75 d4             	pushl  -0x2c(%ebp)
  807336:	50                   	push   %eax
  807337:	e8 e9 d9 ff ff       	call   804d25 <pbuf_chain>
      netif->output(netif, header, dest);
  80733c:	83 c4 0c             	add    $0xc,%esp
  80733f:	ff 75 10             	pushl  0x10(%ebp)
  807342:	53                   	push   %ebx
  807343:	ff 75 0c             	pushl  0xc(%ebp)
  807346:	8b 45 0c             	mov    0xc(%ebp),%eax
  807349:	ff 50 14             	call   *0x14(%eax)
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
  80734c:	89 1c 24             	mov    %ebx,(%esp)
  80734f:	e8 f9 d4 ff ff       	call   80484d <pbuf_free>
     * there will be zero memory penalty.
     */
    
    pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
  807354:	66 2b 75 e6          	sub    -0x1a(%ebp),%si
    ofo += nfb;
  807358:	0f b7 4d ce          	movzwl -0x32(%ebp),%ecx
  80735c:	66 01 4d de          	add    %cx,-0x22(%ebp)
  807360:	83 c4 10             	add    $0x10,%esp
  while (left) {
  807363:	66 85 f6             	test   %si,%si
  807366:	74 5f                	je     8073c7 <ip_frag+0x1c3>
    last = (left <= mtu - IP_HLEN);
  807368:	0f b7 c6             	movzwl %si,%eax
  80736b:	89 45 d8             	mov    %eax,-0x28(%ebp)
    tmp = omf | (IP_OFFMASK & (ofo));
  80736e:	0f b7 5d de          	movzwl -0x22(%ebp),%ebx
  807372:	66 81 e3 ff 1f       	and    $0x1fff,%bx
  807377:	66 0b 5d dc          	or     -0x24(%ebp),%bx
    cop = last ? left : nfb * 8;
  80737b:	66 89 75 e6          	mov    %si,-0x1a(%ebp)
    if (!last)
  80737f:	39 45 e0             	cmp    %eax,-0x20(%ebp)
  807382:	0f 8d 2b ff ff ff    	jge    8072b3 <ip_frag+0xaf>
      tmp = tmp | IP_MF;
  807388:	80 cf 20             	or     $0x20,%bh
    cop = last ? left : nfb * 8;
  80738b:	0f b7 45 cc          	movzwl -0x34(%ebp),%eax
  80738f:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
  807393:	e9 1b ff ff ff       	jmp    8072b3 <ip_frag+0xaf>
      pbuf_realloc(rambuf, left + IP_HLEN);
  807398:	83 ec 08             	sub    $0x8,%esp
  80739b:	8d 46 14             	lea    0x14(%esi),%eax
  80739e:	0f b7 c0             	movzwl %ax,%eax
  8073a1:	50                   	push   %eax
  8073a2:	ff 75 d4             	pushl  -0x2c(%ebp)
  8073a5:	e8 d4 d7 ff ff       	call   804b7e <pbuf_realloc>
  8073aa:	83 c4 10             	add    $0x10,%esp
  8073ad:	e9 63 ff ff ff       	jmp    807315 <ip_frag+0x111>
      pbuf_free(rambuf);
  8073b2:	83 ec 0c             	sub    $0xc,%esp
  8073b5:	ff 75 d4             	pushl  -0x2c(%ebp)
  8073b8:	e8 90 d4 ff ff       	call   80484d <pbuf_free>
      return ERR_MEM;
  8073bd:	83 c4 10             	add    $0x10,%esp
  8073c0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8073c5:	eb 13                	jmp    8073da <ip_frag+0x1d6>
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
  8073c7:	83 ec 0c             	sub    $0xc,%esp
  8073ca:	ff 75 d4             	pushl  -0x2c(%ebp)
  8073cd:	e8 7b d4 ff ff       	call   80484d <pbuf_free>
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
  8073d2:	83 c4 10             	add    $0x10,%esp
  8073d5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8073da:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8073dd:	5b                   	pop    %ebx
  8073de:	5e                   	pop    %esi
  8073df:	5f                   	pop    %edi
  8073e0:	5d                   	pop    %ebp
  8073e1:	c3                   	ret    
    return ERR_MEM;
  8073e2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8073e7:	eb f1                	jmp    8073da <ip_frag+0x1d6>

008073e9 <lwip_standard_chksum>:
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
{
  8073e9:	55                   	push   %ebp
  8073ea:	89 e5                	mov    %esp,%ebp
  8073ec:	57                   	push   %edi
  8073ed:	56                   	push   %esi
  8073ee:	53                   	push   %ebx
  8073ef:	83 ec 1c             	sub    $0x1c,%esp
  8073f2:	89 d7                	mov    %edx,%edi
  8073f4:	66 d1 ef             	shr    %di
  8073f7:	66 89 7d e6          	mov    %di,-0x1a(%ebp)
  8073fb:	0f b7 cf             	movzwl %di,%ecx
  8073fe:	8d 3c 48             	lea    (%eax,%ecx,2),%edi
  u32_t acc;
  u16_t src;
  u8_t *octetptr;

  acc = 0;
  807401:	be 00 00 00 00       	mov    $0x0,%esi
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
  807406:	eb 16                	jmp    80741e <lwip_standard_chksum+0x35>
    /* declare first octet as most significant
       thus assume network order, ignoring host order */
    src = (*octetptr) << 8;
  807408:	0f b6 08             	movzbl (%eax),%ecx
  80740b:	89 cb                	mov    %ecx,%ebx
  80740d:	c1 e3 08             	shl    $0x8,%ebx
    octetptr++;
    /* declare second octet as least significant */
    src |= (*octetptr);
  807410:	0f b6 48 01          	movzbl 0x1(%eax),%ecx
  807414:	09 d9                	or     %ebx,%ecx
  807416:	83 c0 02             	add    $0x2,%eax
    octetptr++;
    acc += src;
  807419:	0f b7 c9             	movzwl %cx,%ecx
  80741c:	01 ce                	add    %ecx,%esi
  while (len > 1) {
  80741e:	39 f8                	cmp    %edi,%eax
  807420:	75 e6                	jne    807408 <lwip_standard_chksum+0x1f>
    len -= 2;
  }
  if (len > 0) {
  807422:	0f b7 4d e6          	movzwl -0x1a(%ebp),%ecx
  807426:	01 c9                	add    %ecx,%ecx
  807428:	66 39 d1             	cmp    %dx,%cx
  80742b:	74 0b                	je     807438 <lwip_standard_chksum+0x4f>
    /* accumulate remaining octet */
    src = (*octetptr) << 8;
  80742d:	0f b6 00             	movzbl (%eax),%eax
  807430:	c1 e0 08             	shl    $0x8,%eax
    acc += src;
  807433:	0f b7 c0             	movzwl %ax,%eax
  807436:	01 c6                	add    %eax,%esi
  }
  /* add deferred carry bits */
  acc = (acc >> 16) + (acc & 0x0000ffffUL);
  807438:	89 f0                	mov    %esi,%eax
  80743a:	c1 e8 10             	shr    $0x10,%eax
  80743d:	0f b7 f6             	movzwl %si,%esi
  807440:	01 c6                	add    %eax,%esi
  if ((acc & 0xffff0000) != 0) {
  807442:	f7 c6 00 00 ff ff    	test   $0xffff0000,%esi
  807448:	74 0a                	je     807454 <lwip_standard_chksum+0x6b>
    acc = (acc >> 16) + (acc & 0x0000ffffUL);
  80744a:	89 f0                	mov    %esi,%eax
  80744c:	c1 e8 10             	shr    $0x10,%eax
  80744f:	0f b7 f6             	movzwl %si,%esi
  807452:	01 c6                	add    %eax,%esi
  }
  /* This maybe a little confusing: reorder sum using htons()
     instead of ntohs() since it has a little less call overhead.
     The caller must invert bits for Internet sum ! */
  return htons((u16_t)acc);
  807454:	83 ec 0c             	sub    $0xc,%esp
  807457:	0f b7 f6             	movzwl %si,%esi
  80745a:	56                   	push   %esi
  80745b:	e8 22 03 00 00       	call   807782 <htons>
}
  807460:	8d 65 f4             	lea    -0xc(%ebp),%esp
  807463:	5b                   	pop    %ebx
  807464:	5e                   	pop    %esi
  807465:	5f                   	pop    %edi
  807466:	5d                   	pop    %ebp
  807467:	c3                   	ret    

00807468 <inet_chksum_pseudo>:
 */
u16_t
inet_chksum_pseudo(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len)
{
  807468:	55                   	push   %ebp
  807469:	89 e5                	mov    %esp,%ebp
  80746b:	57                   	push   %edi
  80746c:	56                   	push   %esi
  80746d:	53                   	push   %ebx
  80746e:	83 ec 1c             	sub    $0x1c,%esp
  807471:	8b 75 08             	mov    0x8(%ebp),%esi
  807474:	8b 45 14             	mov    0x14(%ebp),%eax
  807477:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80747a:	8b 45 18             	mov    0x18(%ebp),%eax
  80747d:	89 45 e0             	mov    %eax,-0x20(%ebp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  807480:	bf 00 00 00 00       	mov    $0x0,%edi
  acc = 0;
  807485:	bb 00 00 00 00       	mov    $0x0,%ebx
  80748a:	89 f8                	mov    %edi,%eax
  80748c:	89 df                	mov    %ebx,%edi
  80748e:	89 c3                	mov    %eax,%ebx
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  807490:	eb 02                	jmp    807494 <inet_chksum_pseudo+0x2c>
  807492:	8b 36                	mov    (%esi),%esi
  807494:	85 f6                	test   %esi,%esi
  807496:	74 3d                	je     8074d5 <inet_chksum_pseudo+0x6d>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
  807498:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  80749c:	8b 46 04             	mov    0x4(%esi),%eax
  80749f:	e8 45 ff ff ff       	call   8073e9 <lwip_standard_chksum>
  8074a4:	0f b7 c0             	movzwl %ax,%eax
  8074a7:	01 f8                	add    %edi,%eax
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
  8074a9:	89 c7                	mov    %eax,%edi
  8074ab:	c1 ef 10             	shr    $0x10,%edi
  8074ae:	0f b7 c0             	movzwl %ax,%eax
  8074b1:	01 c7                	add    %eax,%edi
    if (q->len % 2 != 0) {
  8074b3:	f6 46 0a 01          	testb  $0x1,0xa(%esi)
  8074b7:	74 d9                	je     807492 <inet_chksum_pseudo+0x2a>
      swapped = 1 - swapped;
  8074b9:	b8 01 00 00 00       	mov    $0x1,%eax
  8074be:	29 d8                	sub    %ebx,%eax
  8074c0:	89 c3                	mov    %eax,%ebx
      acc = SWAP_BYTES_IN_WORD(acc);
  8074c2:	89 fa                	mov    %edi,%edx
  8074c4:	c1 e2 08             	shl    $0x8,%edx
  8074c7:	0f b7 d2             	movzwl %dx,%edx
  8074ca:	89 f8                	mov    %edi,%eax
  8074cc:	0f b6 c4             	movzbl %ah,%eax
  8074cf:	09 c2                	or     %eax,%edx
  8074d1:	89 d7                	mov    %edx,%edi
  8074d3:	eb bd                	jmp    807492 <inet_chksum_pseudo+0x2a>
  8074d5:	89 d8                	mov    %ebx,%eax
  8074d7:	89 fb                	mov    %edi,%ebx
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  8074d9:	84 c0                	test   %al,%al
  8074db:	74 0d                	je     8074ea <inet_chksum_pseudo+0x82>
    acc = SWAP_BYTES_IN_WORD(acc);
  8074dd:	89 f8                	mov    %edi,%eax
  8074df:	c1 e0 08             	shl    $0x8,%eax
  8074e2:	0f b7 c0             	movzwl %ax,%eax
  8074e5:	0f b6 df             	movzbl %bh,%ebx
  8074e8:	09 c3                	or     %eax,%ebx
  }
  acc += (src->addr & 0xffffUL);
  8074ea:	8b 45 0c             	mov    0xc(%ebp),%eax
  8074ed:	8b 00                	mov    (%eax),%eax
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  8074ef:	8b 55 10             	mov    0x10(%ebp),%edx
  8074f2:	8b 12                	mov    (%edx),%edx
  8074f4:	0f b7 ca             	movzwl %dx,%ecx
  acc += ((dest->addr >> 16) & 0xffffUL);
  8074f7:	c1 ea 10             	shr    $0x10,%edx
  8074fa:	01 ca                	add    %ecx,%edx
  acc += (src->addr & 0xffffUL);
  8074fc:	0f b7 c8             	movzwl %ax,%ecx
  acc += ((dest->addr >> 16) & 0xffffUL);
  8074ff:	01 ca                	add    %ecx,%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  807501:	c1 e8 10             	shr    $0x10,%eax
  acc += ((dest->addr >> 16) & 0xffffUL);
  807504:	01 d0                	add    %edx,%eax
  807506:	01 c3                	add    %eax,%ebx
  acc += (u32_t)htons((u16_t)proto);
  807508:	83 ec 0c             	sub    $0xc,%esp
  80750b:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  80750f:	50                   	push   %eax
  807510:	e8 6d 02 00 00       	call   807782 <htons>
  807515:	0f b7 c0             	movzwl %ax,%eax
  807518:	01 c3                	add    %eax,%ebx
  acc += (u32_t)htons(proto_len);
  80751a:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  80751e:	89 04 24             	mov    %eax,(%esp)
  807521:	e8 5c 02 00 00       	call   807782 <htons>
  807526:	0f b7 c0             	movzwl %ax,%eax
  807529:	01 c3                	add    %eax,%ebx

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  80752b:	89 d8                	mov    %ebx,%eax
  80752d:	c1 e8 10             	shr    $0x10,%eax
  807530:	0f b7 db             	movzwl %bx,%ebx
  807533:	01 c3                	add    %eax,%ebx
  acc = FOLD_U32T(acc);
  807535:	89 d8                	mov    %ebx,%eax
  807537:	c1 e8 10             	shr    $0x10,%eax
  80753a:	01 d8                	add    %ebx,%eax
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  80753c:	f7 d0                	not    %eax
}
  80753e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  807541:	5b                   	pop    %ebx
  807542:	5e                   	pop    %esi
  807543:	5f                   	pop    %edi
  807544:	5d                   	pop    %ebp
  807545:	c3                   	ret    

00807546 <inet_chksum_pseudo_partial>:
 */
u16_t
inet_chksum_pseudo_partial(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len, u16_t chksum_len)
{
  807546:	55                   	push   %ebp
  807547:	89 e5                	mov    %esp,%ebp
  807549:	57                   	push   %edi
  80754a:	56                   	push   %esi
  80754b:	53                   	push   %ebx
  80754c:	83 ec 1c             	sub    $0x1c,%esp
  80754f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  807552:	8b 45 14             	mov    0x14(%ebp),%eax
  807555:	89 45 dc             	mov    %eax,-0x24(%ebp)
  807558:	8b 45 18             	mov    0x18(%ebp),%eax
  80755b:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80755e:	0f b7 75 1c          	movzwl 0x1c(%ebp),%esi
  struct pbuf *q;
  u8_t swapped;
  u16_t chklen;

  acc = 0;
  swapped = 0;
  807562:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  acc = 0;
  807566:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  80756d:	eb 19                	jmp    807588 <inet_chksum_pseudo_partial+0x42>
    if (chklen > chksum_len) {
      chklen = chksum_len;
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
    chksum_len -= chklen;
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
  80756f:	83 ec 04             	sub    $0x4,%esp
  807572:	68 31 21 81 00       	push   $0x812131
  807577:	68 60 01 00 00       	push   $0x160
  80757c:	68 3c 21 81 00       	push   $0x81213c
  807581:	e8 cd 70 00 00       	call   80e653 <_panic>
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  807586:	8b 1b                	mov    (%ebx),%ebx
  807588:	85 db                	test   %ebx,%ebx
  80758a:	74 5c                	je     8075e8 <inet_chksum_pseudo_partial+0xa2>
  80758c:	66 85 f6             	test   %si,%si
  80758f:	74 57                	je     8075e8 <inet_chksum_pseudo_partial+0xa2>
    chklen = q->len;
  807591:	0f b7 7b 0a          	movzwl 0xa(%ebx),%edi
  807595:	66 39 fe             	cmp    %di,%si
  807598:	0f 46 fe             	cmovbe %esi,%edi
    acc += LWIP_CHKSUM(q->payload, chklen);
  80759b:	0f b7 d7             	movzwl %di,%edx
  80759e:	8b 43 04             	mov    0x4(%ebx),%eax
  8075a1:	e8 43 fe ff ff       	call   8073e9 <lwip_standard_chksum>
  8075a6:	0f b7 c0             	movzwl %ax,%eax
  8075a9:	03 45 e4             	add    -0x1c(%ebp),%eax
    chksum_len -= chklen;
  8075ac:	29 fe                	sub    %edi,%esi
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
  8075ae:	66 81 fe fe 7f       	cmp    $0x7ffe,%si
  8075b3:	77 ba                	ja     80756f <inet_chksum_pseudo_partial+0x29>
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
  8075b5:	89 c2                	mov    %eax,%edx
  8075b7:	c1 ea 10             	shr    $0x10,%edx
  8075ba:	0f b7 c0             	movzwl %ax,%eax
  8075bd:	8d 3c 02             	lea    (%edx,%eax,1),%edi
  8075c0:	89 7d e4             	mov    %edi,-0x1c(%ebp)
    if (q->len % 2 != 0) {
  8075c3:	f6 43 0a 01          	testb  $0x1,0xa(%ebx)
  8075c7:	74 bd                	je     807586 <inet_chksum_pseudo_partial+0x40>
      swapped = 1 - swapped;
  8075c9:	b8 01 00 00 00       	mov    $0x1,%eax
  8075ce:	2a 45 e3             	sub    -0x1d(%ebp),%al
  8075d1:	88 45 e3             	mov    %al,-0x1d(%ebp)
      acc = SWAP_BYTES_IN_WORD(acc);
  8075d4:	89 fa                	mov    %edi,%edx
  8075d6:	c1 e2 08             	shl    $0x8,%edx
  8075d9:	0f b7 d2             	movzwl %dx,%edx
  8075dc:	89 f8                	mov    %edi,%eax
  8075de:	0f b6 c4             	movzbl %ah,%eax
  8075e1:	09 c2                	or     %eax,%edx
  8075e3:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  8075e6:	eb 9e                	jmp    807586 <inet_chksum_pseudo_partial+0x40>
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  8075e8:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  8075ec:	74 13                	je     807601 <inet_chksum_pseudo_partial+0xbb>
    acc = SWAP_BYTES_IN_WORD(acc);
  8075ee:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8075f1:	89 c8                	mov    %ecx,%eax
  8075f3:	c1 e0 08             	shl    $0x8,%eax
  8075f6:	0f b7 c0             	movzwl %ax,%eax
  8075f9:	0f b6 d5             	movzbl %ch,%edx
  8075fc:	09 d0                	or     %edx,%eax
  8075fe:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  }
  acc += (src->addr & 0xffffUL);
  807601:	8b 45 0c             	mov    0xc(%ebp),%eax
  807604:	8b 18                	mov    (%eax),%ebx
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  807606:	8b 45 10             	mov    0x10(%ebp),%eax
  807609:	8b 00                	mov    (%eax),%eax
  80760b:	0f b7 d0             	movzwl %ax,%edx
  acc += ((dest->addr >> 16) & 0xffffUL);
  80760e:	c1 e8 10             	shr    $0x10,%eax
  807611:	01 d0                	add    %edx,%eax
  acc += (src->addr & 0xffffUL);
  807613:	0f b7 d3             	movzwl %bx,%edx
  acc += ((dest->addr >> 16) & 0xffffUL);
  807616:	01 d0                	add    %edx,%eax
  acc += ((src->addr >> 16) & 0xffffUL);
  807618:	c1 eb 10             	shr    $0x10,%ebx
  acc += ((dest->addr >> 16) & 0xffffUL);
  80761b:	01 c3                	add    %eax,%ebx
  80761d:	03 5d e4             	add    -0x1c(%ebp),%ebx
  acc += (u32_t)htons((u16_t)proto);
  807620:	83 ec 0c             	sub    $0xc,%esp
  807623:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
  807627:	50                   	push   %eax
  807628:	e8 55 01 00 00       	call   807782 <htons>
  80762d:	0f b7 f0             	movzwl %ax,%esi
  807630:	01 de                	add    %ebx,%esi
  acc += (u32_t)htons(proto_len);
  807632:	0f b7 45 d8          	movzwl -0x28(%ebp),%eax
  807636:	89 04 24             	mov    %eax,(%esp)
  807639:	e8 44 01 00 00       	call   807782 <htons>
  80763e:	0f b7 d8             	movzwl %ax,%ebx
  807641:	01 f3                	add    %esi,%ebx

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  807643:	89 d8                	mov    %ebx,%eax
  807645:	c1 e8 10             	shr    $0x10,%eax
  807648:	0f b7 db             	movzwl %bx,%ebx
  80764b:	01 c3                	add    %eax,%ebx
  acc = FOLD_U32T(acc);
  80764d:	89 d8                	mov    %ebx,%eax
  80764f:	c1 e8 10             	shr    $0x10,%eax
  807652:	01 d8                	add    %ebx,%eax
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  807654:	f7 d0                	not    %eax
}
  807656:	8d 65 f4             	lea    -0xc(%ebp),%esp
  807659:	5b                   	pop    %ebx
  80765a:	5e                   	pop    %esi
  80765b:	5f                   	pop    %edi
  80765c:	5d                   	pop    %ebp
  80765d:	c3                   	ret    

0080765e <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
  80765e:	55                   	push   %ebp
  80765f:	89 e5                	mov    %esp,%ebp
  807661:	83 ec 08             	sub    $0x8,%esp
  return ~LWIP_CHKSUM(dataptr, len);
  807664:	0f b7 55 0c          	movzwl 0xc(%ebp),%edx
  807668:	8b 45 08             	mov    0x8(%ebp),%eax
  80766b:	e8 79 fd ff ff       	call   8073e9 <lwip_standard_chksum>
  807670:	f7 d0                	not    %eax
}
  807672:	c9                   	leave  
  807673:	c3                   	ret    

00807674 <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
  807674:	55                   	push   %ebp
  807675:	89 e5                	mov    %esp,%ebp
  807677:	57                   	push   %edi
  807678:	56                   	push   %esi
  807679:	53                   	push   %ebx
  80767a:	83 ec 0c             	sub    $0xc,%esp
  80767d:	8b 75 08             	mov    0x8(%ebp),%esi
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  807680:	bf 00 00 00 00       	mov    $0x0,%edi
  acc = 0;
  807685:	bb 00 00 00 00       	mov    $0x0,%ebx
  for(q = p; q != NULL; q = q->next) {
  80768a:	eb 02                	jmp    80768e <inet_chksum_pbuf+0x1a>
  80768c:	8b 36                	mov    (%esi),%esi
  80768e:	85 f6                	test   %esi,%esi
  807690:	74 3b                	je     8076cd <inet_chksum_pbuf+0x59>
    acc += LWIP_CHKSUM(q->payload, q->len);
  807692:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  807696:	8b 46 04             	mov    0x4(%esi),%eax
  807699:	e8 4b fd ff ff       	call   8073e9 <lwip_standard_chksum>
  80769e:	0f b7 c0             	movzwl %ax,%eax
  8076a1:	01 c3                	add    %eax,%ebx
    acc = FOLD_U32T(acc);
  8076a3:	89 d8                	mov    %ebx,%eax
  8076a5:	c1 e8 10             	shr    $0x10,%eax
  8076a8:	0f b7 db             	movzwl %bx,%ebx
  8076ab:	01 c3                	add    %eax,%ebx
    if (q->len % 2 != 0) {
  8076ad:	f6 46 0a 01          	testb  $0x1,0xa(%esi)
  8076b1:	74 d9                	je     80768c <inet_chksum_pbuf+0x18>
      swapped = 1 - swapped;
  8076b3:	b8 01 00 00 00       	mov    $0x1,%eax
  8076b8:	89 f9                	mov    %edi,%ecx
  8076ba:	29 c8                	sub    %ecx,%eax
  8076bc:	89 c7                	mov    %eax,%edi
      acc = SWAP_BYTES_IN_WORD(acc);
  8076be:	89 da                	mov    %ebx,%edx
  8076c0:	c1 e2 08             	shl    $0x8,%edx
  8076c3:	0f b7 d2             	movzwl %dx,%edx
  8076c6:	0f b6 df             	movzbl %bh,%ebx
  8076c9:	09 d3                	or     %edx,%ebx
  8076cb:	eb bf                	jmp    80768c <inet_chksum_pbuf+0x18>
    }
  }

  if (swapped) {
  8076cd:	89 f8                	mov    %edi,%eax
  8076cf:	84 c0                	test   %al,%al
  8076d1:	74 0d                	je     8076e0 <inet_chksum_pbuf+0x6c>
    acc = SWAP_BYTES_IN_WORD(acc);
  8076d3:	89 da                	mov    %ebx,%edx
  8076d5:	c1 e2 08             	shl    $0x8,%edx
  8076d8:	0f b7 d2             	movzwl %dx,%edx
  8076db:	0f b6 df             	movzbl %bh,%ebx
  8076de:	09 d3                	or     %edx,%ebx
  }
  return (u16_t)~(acc & 0xffffUL);
  8076e0:	89 d8                	mov    %ebx,%eax
  8076e2:	f7 d0                	not    %eax
}
  8076e4:	83 c4 0c             	add    $0xc,%esp
  8076e7:	5b                   	pop    %ebx
  8076e8:	5e                   	pop    %esi
  8076e9:	5f                   	pop    %edi
  8076ea:	5d                   	pop    %ebp
  8076eb:	c3                   	ret    

008076ec <inet_ntoa>:
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
{
  8076ec:	55                   	push   %ebp
  8076ed:	89 e5                	mov    %esp,%ebp
  8076ef:	57                   	push   %edi
  8076f0:	56                   	push   %esi
  8076f1:	53                   	push   %ebx
  8076f2:	83 ec 14             	sub    $0x14,%esp
  static char str[16];
  u32_t s_addr = addr.s_addr;
  8076f5:	8b 45 08             	mov    0x8(%ebp),%eax
  8076f8:	89 45 f0             	mov    %eax,-0x10(%ebp)
  u8_t rem;
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  8076fb:	8d 7d f0             	lea    -0x10(%ebp),%edi
  rp = str;
  8076fe:	c7 45 e0 e4 49 b3 00 	movl   $0xb349e4,-0x20(%ebp)
  807705:	eb 30                	jmp    807737 <inet_ntoa+0x4b>
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
      *rp++ = inv[i];
  807707:	0f b6 c2             	movzbl %dl,%eax
  80770a:	0f b6 44 05 ed       	movzbl -0x13(%ebp,%eax,1),%eax
  80770f:	88 01                	mov    %al,(%ecx)
  807711:	83 c1 01             	add    $0x1,%ecx
    while(i--)
  807714:	83 ea 01             	sub    $0x1,%edx
  807717:	80 fa ff             	cmp    $0xff,%dl
  80771a:	75 eb                	jne    807707 <inet_ntoa+0x1b>
  80771c:	89 f0                	mov    %esi,%eax
  80771e:	0f b6 f0             	movzbl %al,%esi
  807721:	03 75 e0             	add    -0x20(%ebp),%esi
    *rp++ = '.';
  807724:	8d 46 01             	lea    0x1(%esi),%eax
  807727:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80772a:	c6 06 2e             	movb   $0x2e,(%esi)
  80772d:	83 c7 01             	add    $0x1,%edi
  for(n = 0; n < 4; n++) {
  807730:	8d 45 f4             	lea    -0xc(%ebp),%eax
  807733:	39 c7                	cmp    %eax,%edi
  807735:	74 3b                	je     807772 <inet_ntoa+0x86>
  rp = str;
  807737:	b9 00 00 00 00       	mov    $0x0,%ecx
      rem = *ap % (u8_t)10;
  80773c:	0f b6 17             	movzbl (%edi),%edx
      *ap /= (u8_t)10;
  80773f:	0f b6 da             	movzbl %dl,%ebx
  807742:	8d 04 9b             	lea    (%ebx,%ebx,4),%eax
  807745:	8d 04 c3             	lea    (%ebx,%eax,8),%eax
  807748:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80774b:	66 c1 e8 0b          	shr    $0xb,%ax
  80774f:	88 07                	mov    %al,(%edi)
      inv[i++] = '0' + rem;
  807751:	8d 71 01             	lea    0x1(%ecx),%esi
  807754:	0f b6 c9             	movzbl %cl,%ecx
      rem = *ap % (u8_t)10;
  807757:	8d 1c 80             	lea    (%eax,%eax,4),%ebx
  80775a:	01 db                	add    %ebx,%ebx
  80775c:	29 da                	sub    %ebx,%edx
      inv[i++] = '0' + rem;
  80775e:	83 c2 30             	add    $0x30,%edx
  807761:	88 54 0d ed          	mov    %dl,-0x13(%ebp,%ecx,1)
  807765:	89 f1                	mov    %esi,%ecx
    } while(*ap);
  807767:	84 c0                	test   %al,%al
  807769:	75 d1                	jne    80773c <inet_ntoa+0x50>
  80776b:	8b 4d e0             	mov    -0x20(%ebp),%ecx
      inv[i++] = '0' + rem;
  80776e:	89 f2                	mov    %esi,%edx
  807770:	eb a2                	jmp    807714 <inet_ntoa+0x28>
    ap++;
  }
  *--rp = 0;
  807772:	c6 06 00             	movb   $0x0,(%esi)
  return str;
}
  807775:	b8 e4 49 b3 00       	mov    $0xb349e4,%eax
  80777a:	83 c4 14             	add    $0x14,%esp
  80777d:	5b                   	pop    %ebx
  80777e:	5e                   	pop    %esi
  80777f:	5f                   	pop    %edi
  807780:	5d                   	pop    %ebp
  807781:	c3                   	ret    

00807782 <htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t
htons(u16_t n)
{
  807782:	55                   	push   %ebp
  807783:	89 e5                	mov    %esp,%ebp
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
  807785:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  807789:	66 c1 c0 08          	rol    $0x8,%ax
}
  80778d:	5d                   	pop    %ebp
  80778e:	c3                   	ret    

0080778f <ntohs>:
 * @param n u16_t in network byte order
 * @return n in host byte order
 */
u16_t
ntohs(u16_t n)
{
  80778f:	55                   	push   %ebp
  807790:	89 e5                	mov    %esp,%ebp
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
  807792:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  807796:	66 c1 c0 08          	rol    $0x8,%ax
  return htons(n);
}
  80779a:	5d                   	pop    %ebp
  80779b:	c3                   	ret    

0080779c <htonl>:
 * @param n u32_t in host byte order
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  80779c:	55                   	push   %ebp
  80779d:	89 e5                	mov    %esp,%ebp
  80779f:	8b 55 08             	mov    0x8(%ebp),%edx
  return ((n & 0xff) << 24) |
  8077a2:	89 d0                	mov    %edx,%eax
  8077a4:	c1 e0 18             	shl    $0x18,%eax
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
  8077a7:	89 d1                	mov    %edx,%ecx
  8077a9:	c1 e9 18             	shr    $0x18,%ecx
    ((n & 0xff0000UL) >> 8) |
  8077ac:	09 c8                	or     %ecx,%eax
    ((n & 0xff00) << 8) |
  8077ae:	89 d1                	mov    %edx,%ecx
  8077b0:	c1 e1 08             	shl    $0x8,%ecx
  8077b3:	81 e1 00 00 ff 00    	and    $0xff0000,%ecx
    ((n & 0xff0000UL) >> 8) |
  8077b9:	09 c8                	or     %ecx,%eax
  8077bb:	c1 ea 08             	shr    $0x8,%edx
  8077be:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  8077c4:	09 d0                	or     %edx,%eax
}
  8077c6:	5d                   	pop    %ebp
  8077c7:	c3                   	ret    

008077c8 <inet_aton>:
{
  8077c8:	55                   	push   %ebp
  8077c9:	89 e5                	mov    %esp,%ebp
  8077cb:	57                   	push   %edi
  8077cc:	56                   	push   %esi
  8077cd:	53                   	push   %ebx
  8077ce:	83 ec 1c             	sub    $0x1c,%esp
  8077d1:	8b 45 08             	mov    0x8(%ebp),%eax
  c = *cp;
  8077d4:	0f be 10             	movsbl (%eax),%edx
  u32_t *pp = parts;
  8077d7:	8d 75 e4             	lea    -0x1c(%ebp),%esi
  8077da:	89 75 d8             	mov    %esi,-0x28(%ebp)
  8077dd:	e9 a9 00 00 00       	jmp    80788b <inet_aton+0xc3>
      c = *++cp;
  8077e2:	0f b6 50 01          	movzbl 0x1(%eax),%edx
      if (c == 'x' || c == 'X') {
  8077e6:	89 d1                	mov    %edx,%ecx
  8077e8:	83 e1 df             	and    $0xffffffdf,%ecx
  8077eb:	80 f9 58             	cmp    $0x58,%cl
  8077ee:	74 12                	je     807802 <inet_aton+0x3a>
      c = *++cp;
  8077f0:	83 c0 01             	add    $0x1,%eax
  8077f3:	0f be d2             	movsbl %dl,%edx
        base = 8;
  8077f6:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
  8077fd:	e9 a5 00 00 00       	jmp    8078a7 <inet_aton+0xdf>
        c = *++cp;
  807802:	0f be 50 02          	movsbl 0x2(%eax),%edx
  807806:	8d 40 02             	lea    0x2(%eax),%eax
        base = 16;
  807809:	c7 45 dc 10 00 00 00 	movl   $0x10,-0x24(%ebp)
  807810:	e9 92 00 00 00       	jmp    8078a7 <inet_aton+0xdf>
      } else if (base == 16 && isxdigit(c)) {
  807815:	83 7d dc 10          	cmpl   $0x10,-0x24(%ebp)
  807819:	75 4a                	jne    807865 <inet_aton+0x9d>
  80781b:	8d 5e 9f             	lea    -0x61(%esi),%ebx
  80781e:	89 d1                	mov    %edx,%ecx
  807820:	83 e1 df             	and    $0xffffffdf,%ecx
  807823:	83 e9 41             	sub    $0x41,%ecx
  807826:	80 f9 05             	cmp    $0x5,%cl
  807829:	77 3a                	ja     807865 <inet_aton+0x9d>
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
  80782b:	c1 e7 04             	shl    $0x4,%edi
  80782e:	83 c2 0a             	add    $0xa,%edx
  807831:	80 fb 1a             	cmp    $0x1a,%bl
  807834:	19 c9                	sbb    %ecx,%ecx
  807836:	83 e1 20             	and    $0x20,%ecx
  807839:	83 c1 41             	add    $0x41,%ecx
  80783c:	29 ca                	sub    %ecx,%edx
  80783e:	09 d7                	or     %edx,%edi
        c = *++cp;
  807840:	8b 75 e0             	mov    -0x20(%ebp),%esi
  807843:	0f be 56 01          	movsbl 0x1(%esi),%edx
  807847:	83 c0 01             	add    $0x1,%eax
  80784a:	89 45 e0             	mov    %eax,-0x20(%ebp)
      if (isdigit(c)) {
  80784d:	89 d6                	mov    %edx,%esi
  80784f:	8d 4a d0             	lea    -0x30(%edx),%ecx
  807852:	80 f9 09             	cmp    $0x9,%cl
  807855:	77 be                	ja     807815 <inet_aton+0x4d>
        val = (val * base) + (int)(c - '0');
  807857:	0f af 7d dc          	imul   -0x24(%ebp),%edi
  80785b:	8d 7c 3a d0          	lea    -0x30(%edx,%edi,1),%edi
        c = *++cp;
  80785f:	0f be 50 01          	movsbl 0x1(%eax),%edx
  807863:	eb e2                	jmp    807847 <inet_aton+0x7f>
    if (c == '.') {
  807865:	83 fa 2e             	cmp    $0x2e,%edx
  807868:	75 44                	jne    8078ae <inet_aton+0xe6>
      if (pp >= parts + 3)
  80786a:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80786d:	8b 5d d8             	mov    -0x28(%ebp),%ebx
  807870:	39 c3                	cmp    %eax,%ebx
  807872:	0f 84 13 01 00 00    	je     80798b <inet_aton+0x1c3>
      *pp++ = val;
  807878:	83 c3 04             	add    $0x4,%ebx
  80787b:	89 5d d8             	mov    %ebx,-0x28(%ebp)
  80787e:	89 7b fc             	mov    %edi,-0x4(%ebx)
      c = *++cp;
  807881:	8b 75 e0             	mov    -0x20(%ebp),%esi
  807884:	8d 46 01             	lea    0x1(%esi),%eax
  807887:	0f be 56 01          	movsbl 0x1(%esi),%edx
    if (!isdigit(c))
  80788b:	8d 4a d0             	lea    -0x30(%edx),%ecx
  80788e:	80 f9 09             	cmp    $0x9,%cl
  807891:	0f 87 ed 00 00 00    	ja     807984 <inet_aton+0x1bc>
    base = 10;
  807897:	c7 45 dc 0a 00 00 00 	movl   $0xa,-0x24(%ebp)
    if (c == '0') {
  80789e:	83 fa 30             	cmp    $0x30,%edx
  8078a1:	0f 84 3b ff ff ff    	je     8077e2 <inet_aton+0x1a>
        base = 8;
  8078a7:	bf 00 00 00 00       	mov    $0x0,%edi
  8078ac:	eb 9c                	jmp    80784a <inet_aton+0x82>
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  8078ae:	85 d2                	test   %edx,%edx
  8078b0:	74 29                	je     8078db <inet_aton+0x113>
    return (0);
  8078b2:	b8 00 00 00 00       	mov    $0x0,%eax
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  8078b7:	89 f3                	mov    %esi,%ebx
  8078b9:	80 fb 1f             	cmp    $0x1f,%bl
  8078bc:	0f 86 ce 00 00 00    	jbe    807990 <inet_aton+0x1c8>
  8078c2:	84 d2                	test   %dl,%dl
  8078c4:	0f 88 c6 00 00 00    	js     807990 <inet_aton+0x1c8>
  8078ca:	83 fa 20             	cmp    $0x20,%edx
  8078cd:	74 0c                	je     8078db <inet_aton+0x113>
  8078cf:	83 ea 09             	sub    $0x9,%edx
  8078d2:	83 fa 04             	cmp    $0x4,%edx
  8078d5:	0f 87 b5 00 00 00    	ja     807990 <inet_aton+0x1c8>
  n = pp - parts + 1;
  8078db:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8078de:	8b 75 d8             	mov    -0x28(%ebp),%esi
  8078e1:	29 c6                	sub    %eax,%esi
  8078e3:	89 f0                	mov    %esi,%eax
  8078e5:	c1 f8 02             	sar    $0x2,%eax
  8078e8:	83 c0 01             	add    $0x1,%eax
  switch (n) {
  8078eb:	83 f8 02             	cmp    $0x2,%eax
  8078ee:	74 5e                	je     80794e <inet_aton+0x186>
  8078f0:	83 f8 02             	cmp    $0x2,%eax
  8078f3:	7e 35                	jle    80792a <inet_aton+0x162>
  8078f5:	83 f8 03             	cmp    $0x3,%eax
  8078f8:	74 6b                	je     807965 <inet_aton+0x19d>
  8078fa:	83 f8 04             	cmp    $0x4,%eax
  8078fd:	75 2f                	jne    80792e <inet_aton+0x166>
      return (0);
  8078ff:	b8 00 00 00 00       	mov    $0x0,%eax
    if (val > 0xff)
  807904:	81 ff ff 00 00 00    	cmp    $0xff,%edi
  80790a:	0f 87 80 00 00 00    	ja     807990 <inet_aton+0x1c8>
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
  807910:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807913:	c1 e0 18             	shl    $0x18,%eax
  807916:	8b 55 e8             	mov    -0x18(%ebp),%edx
  807919:	c1 e2 10             	shl    $0x10,%edx
  80791c:	09 d0                	or     %edx,%eax
  80791e:	8b 55 ec             	mov    -0x14(%ebp),%edx
  807921:	c1 e2 08             	shl    $0x8,%edx
  807924:	09 d0                	or     %edx,%eax
  807926:	09 c7                	or     %eax,%edi
    break;
  807928:	eb 04                	jmp    80792e <inet_aton+0x166>
  switch (n) {
  80792a:	85 c0                	test   %eax,%eax
  80792c:	74 62                	je     807990 <inet_aton+0x1c8>
  return (1);
  80792e:	b8 01 00 00 00       	mov    $0x1,%eax
  if (addr)
  807933:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  807937:	74 57                	je     807990 <inet_aton+0x1c8>
    addr->s_addr = htonl(val);
  807939:	57                   	push   %edi
  80793a:	e8 5d fe ff ff       	call   80779c <htonl>
  80793f:	83 c4 04             	add    $0x4,%esp
  807942:	8b 75 0c             	mov    0xc(%ebp),%esi
  807945:	89 06                	mov    %eax,(%esi)
  return (1);
  807947:	b8 01 00 00 00       	mov    $0x1,%eax
  80794c:	eb 42                	jmp    807990 <inet_aton+0x1c8>
      return (0);
  80794e:	b8 00 00 00 00       	mov    $0x0,%eax
    if (val > 0xffffffUL)
  807953:	81 ff ff ff ff 00    	cmp    $0xffffff,%edi
  807959:	77 35                	ja     807990 <inet_aton+0x1c8>
    val |= parts[0] << 24;
  80795b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80795e:	c1 e0 18             	shl    $0x18,%eax
  807961:	09 c7                	or     %eax,%edi
    break;
  807963:	eb c9                	jmp    80792e <inet_aton+0x166>
      return (0);
  807965:	b8 00 00 00 00       	mov    $0x0,%eax
    if (val > 0xffff)
  80796a:	81 ff ff ff 00 00    	cmp    $0xffff,%edi
  807970:	77 1e                	ja     807990 <inet_aton+0x1c8>
    val |= (parts[0] << 24) | (parts[1] << 16);
  807972:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807975:	c1 e0 18             	shl    $0x18,%eax
  807978:	8b 55 e8             	mov    -0x18(%ebp),%edx
  80797b:	c1 e2 10             	shl    $0x10,%edx
  80797e:	09 d0                	or     %edx,%eax
  807980:	09 c7                	or     %eax,%edi
    break;
  807982:	eb aa                	jmp    80792e <inet_aton+0x166>
      return (0);
  807984:	b8 00 00 00 00       	mov    $0x0,%eax
  807989:	eb 05                	jmp    807990 <inet_aton+0x1c8>
        return (0);
  80798b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  807990:	8d 65 f4             	lea    -0xc(%ebp),%esp
  807993:	5b                   	pop    %ebx
  807994:	5e                   	pop    %esi
  807995:	5f                   	pop    %edi
  807996:	5d                   	pop    %ebp
  807997:	c3                   	ret    

00807998 <inet_addr>:
{
  807998:	55                   	push   %ebp
  807999:	89 e5                	mov    %esp,%ebp
  80799b:	83 ec 10             	sub    $0x10,%esp
  if (inet_aton(cp, &val)) {
  80799e:	8d 45 fc             	lea    -0x4(%ebp),%eax
  8079a1:	50                   	push   %eax
  8079a2:	ff 75 08             	pushl  0x8(%ebp)
  8079a5:	e8 1e fe ff ff       	call   8077c8 <inet_aton>
  8079aa:	83 c4 08             	add    $0x8,%esp
    return (val.s_addr);
  8079ad:	85 c0                	test   %eax,%eax
  8079af:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8079b4:	0f 45 45 fc          	cmovne -0x4(%ebp),%eax
}
  8079b8:	c9                   	leave  
  8079b9:	c3                   	ret    

008079ba <ntohl>:
 * @param n u32_t in network byte order
 * @return n in host byte order
 */
u32_t
ntohl(u32_t n)
{
  8079ba:	55                   	push   %ebp
  8079bb:	89 e5                	mov    %esp,%ebp
  return htonl(n);
  8079bd:	ff 75 08             	pushl  0x8(%ebp)
  8079c0:	e8 d7 fd ff ff       	call   80779c <htonl>
  8079c5:	83 c4 04             	add    $0x4,%esp
}
  8079c8:	c9                   	leave  
  8079c9:	c3                   	ret    

008079ca <tcp_enqueue>:
 */
err_t
tcp_enqueue(struct tcp_pcb *pcb, void *arg, u16_t len,
  u8_t flags, u8_t apiflags,
  u8_t *optdata, u8_t optlen)
{
  8079ca:	55                   	push   %ebp
  8079cb:	89 e5                	mov    %esp,%ebp
  8079cd:	57                   	push   %edi
  8079ce:	56                   	push   %esi
  8079cf:	53                   	push   %ebx
  8079d0:	83 ec 3c             	sub    $0x3c,%esp
  8079d3:	8b 7d 08             	mov    0x8(%ebp),%edi
  8079d6:	8b 75 10             	mov    0x10(%ebp),%esi
  8079d9:	89 75 c0             	mov    %esi,-0x40(%ebp)
  8079dc:	8b 55 14             	mov    0x14(%ebp),%edx
  8079df:	89 55 bc             	mov    %edx,-0x44(%ebp)
  8079e2:	8b 5d 18             	mov    0x18(%ebp),%ebx
  8079e5:	89 5d b8             	mov    %ebx,-0x48(%ebp)
  8079e8:	8b 45 20             	mov    0x20(%ebp),%eax
  8079eb:	66 89 75 c4          	mov    %si,-0x3c(%ebp)
  8079ef:	88 55 cb             	mov    %dl,-0x35(%ebp)
  8079f2:	89 da                	mov    %ebx,%edx
  8079f4:	88 45 ca             	mov    %al,-0x36(%ebp)
  void *ptr;
  u16_t queuelen;

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_enqueue(pcb=%p, arg=%p, len=%"U16_F", flags=%"X16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)flags, (u16_t)apiflags));
  LWIP_ERROR("tcp_enqueue: len == 0 || optlen == 0 (programmer violates API)",
  8079f7:	66 85 f6             	test   %si,%si
  8079fa:	74 04                	je     807a00 <tcp_enqueue+0x36>
  8079fc:	84 c0                	test   %al,%al
  8079fe:	75 54                	jne    807a54 <tcp_enqueue+0x8a>
      ((len == 0) || (optlen == 0)), return ERR_ARG;);
  LWIP_ERROR("tcp_enqueue: arg == NULL || optdata == NULL (programmer violates API)",
  807a00:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  807a04:	74 06                	je     807a0c <tcp_enqueue+0x42>
  807a06:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  807a0a:	75 5f                	jne    807a6b <tcp_enqueue+0xa1>
      ((arg == NULL) || (optdata == NULL)), return ERR_ARG;);
  /* fail on too much data */
  if (len > pcb->snd_buf) {
  807a0c:	0f b7 4d c0          	movzwl -0x40(%ebp),%ecx
  807a10:	66 39 4f 6e          	cmp    %cx,0x6e(%edi)
  807a14:	72 6c                	jb     807a82 <tcp_enqueue+0xb8>
  left = len;
  ptr = arg;

  /* seqno will be the sequence number of the first segment enqueued
   * by the call to this function. */
  seqno = pcb->snd_lbb;
  807a16:	8b 4f 68             	mov    0x68(%edi),%ecx
  807a19:	89 4d d8             	mov    %ecx,-0x28(%ebp)

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  queuelen = pcb->snd_queuelen;
  807a1c:	0f b7 4f 70          	movzwl 0x70(%edi),%ecx
  807a20:	66 89 4d e0          	mov    %cx,-0x20(%ebp)
  /* check for configured max queuelen and possible overflow */
  if ((queuelen >= TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  807a24:	66 83 f9 1f          	cmp    $0x1f,%cx
  807a28:	77 66                	ja     807a90 <tcp_enqueue+0xc6>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too long queue %"U16_F" (max %"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
    return ERR_MEM;
  }
  if (queuelen != 0) {
  807a2a:	66 83 7d e0 00       	cmpw   $0x0,-0x20(%ebp)
  807a2f:	74 6d                	je     807a9e <tcp_enqueue+0xd4>
    LWIP_ASSERT("tcp_enqueue: pbufs on queue => at least one queue non-empty",
  807a31:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  807a35:	75 7b                	jne    807ab2 <tcp_enqueue+0xe8>
  807a37:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  807a3b:	75 75                	jne    807ab2 <tcp_enqueue+0xe8>
  807a3d:	83 ec 04             	sub    $0x4,%esp
  807a40:	68 e8 21 81 00       	push   $0x8121e8
  807a45:	68 ae 00 00 00       	push   $0xae
  807a4a:	68 02 23 81 00       	push   $0x812302
  807a4f:	e8 ff 6b 00 00       	call   80e653 <_panic>
  LWIP_ERROR("tcp_enqueue: len == 0 || optlen == 0 (programmer violates API)",
  807a54:	83 ec 04             	sub    $0x4,%esp
  807a57:	68 60 21 81 00       	push   $0x812160
  807a5c:	68 90 00 00 00       	push   $0x90
  807a61:	68 02 23 81 00       	push   $0x812302
  807a66:	e8 e8 6b 00 00       	call   80e653 <_panic>
  LWIP_ERROR("tcp_enqueue: arg == NULL || optdata == NULL (programmer violates API)",
  807a6b:	83 ec 04             	sub    $0x4,%esp
  807a6e:	68 a0 21 81 00       	push   $0x8121a0
  807a73:	68 92 00 00 00       	push   $0x92
  807a78:	68 02 23 81 00       	push   $0x812302
  807a7d:	e8 d1 6b 00 00       	call   80e653 <_panic>
    pcb->flags |= TF_NAGLEMEMERR;
  807a82:	80 4f 20 80          	orb    $0x80,0x20(%edi)
    return ERR_MEM;
  807a86:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807a8b:	e9 a4 03 00 00       	jmp    807e34 <tcp_enqueue+0x46a>
    pcb->flags |= TF_NAGLEMEMERR;
  807a90:	80 4f 20 80          	orb    $0x80,0x20(%edi)
    return ERR_MEM;
  807a94:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807a99:	e9 96 03 00 00       	jmp    807e34 <tcp_enqueue+0x46a>
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_enqueue: no pbufs on queue => both queues empty",
  807a9e:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  807aa2:	0f 85 05 02 00 00    	jne    807cad <tcp_enqueue+0x2e3>
  807aa8:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  807aac:	0f 85 fb 01 00 00    	jne    807cad <tcp_enqueue+0x2e3>
    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  807ab2:	c0 e8 02             	shr    $0x2,%al
  807ab5:	c1 e0 0c             	shl    $0xc,%eax
  807ab8:	66 05 00 50          	add    $0x5000,%ax
  807abc:	66 89 45 c8          	mov    %ax,-0x38(%ebp)
  807ac0:	8b 45 0c             	mov    0xc(%ebp),%eax
  807ac3:	89 45 d0             	mov    %eax,-0x30(%ebp)
  807ac6:	0f b7 45 c0          	movzwl -0x40(%ebp),%eax
  807aca:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
  807ace:	be 00 00 00 00       	mov    $0x0,%esi
  while (queue == NULL || left > 0) {
  807ad3:	c6 45 e4 01          	movb   $0x1,-0x1c(%ebp)
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  807ad7:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  807ade:	83 e2 01             	and    $0x1,%edx
  807ae1:	88 55 c7             	mov    %dl,-0x39(%ebp)
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  807ae4:	0f b6 45 ca          	movzbl -0x36(%ebp),%eax
  807ae8:	89 45 cc             	mov    %eax,-0x34(%ebp)
    seglen = left > pcb->mss? pcb->mss: left;
  807aeb:	0f b7 45 dc          	movzwl -0x24(%ebp),%eax
  807aef:	66 39 47 34          	cmp    %ax,0x34(%edi)
  807af3:	66 0f 46 47 34       	cmovbe 0x34(%edi),%ax
  807af8:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
    seg = memp_malloc(MEMP_TCP_SEG);
  807afc:	83 ec 0c             	sub    $0xc,%esp
  807aff:	6a 04                	push   $0x4
  807b01:	e8 82 c9 ff ff       	call   804488 <memp_malloc>
  807b06:	89 c3                	mov    %eax,%ebx
    if (seg == NULL) {
  807b08:	83 c4 10             	add    $0x10,%esp
  807b0b:	85 c0                	test   %eax,%eax
  807b0d:	0f 84 e6 02 00 00    	je     807df9 <tcp_enqueue+0x42f>
    seg->next = NULL;
  807b13:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    seg->p = NULL;
  807b19:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    if (queue == NULL) {
  807b20:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
  807b24:	0f 85 b1 01 00 00    	jne    807cdb <tcp_enqueue+0x311>
      LWIP_ASSERT("useg != NULL", useg != NULL);
  807b2a:	85 f6                	test   %esi,%esi
  807b2c:	0f 84 92 01 00 00    	je     807cc4 <tcp_enqueue+0x2fa>
      useg->next = seg;
  807b32:	89 06                	mov    %eax,(%esi)
    if (optdata != NULL) {
  807b34:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  807b38:	0f 84 bc 01 00 00    	je     807cfa <tcp_enqueue+0x330>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  807b3e:	83 ec 04             	sub    $0x4,%esp
  807b41:	6a 00                	push   $0x0
  807b43:	ff 75 cc             	pushl  -0x34(%ebp)
  807b46:	6a 00                	push   $0x0
  807b48:	e8 c6 cd ff ff       	call   804913 <pbuf_alloc>
  807b4d:	89 43 04             	mov    %eax,0x4(%ebx)
  807b50:	83 c4 10             	add    $0x10,%esp
  807b53:	85 c0                	test   %eax,%eax
  807b55:	0f 84 9e 02 00 00    	je     807df9 <tcp_enqueue+0x42f>
      LWIP_ASSERT("check that first pbuf can hold optlen",
  807b5b:	0f b6 55 ca          	movzbl -0x36(%ebp),%edx
  807b5f:	66 39 50 0a          	cmp    %dx,0xa(%eax)
  807b63:	0f 82 7a 01 00 00    	jb     807ce3 <tcp_enqueue+0x319>
      queuelen += pbuf_clen(seg->p);
  807b69:	83 ec 0c             	sub    $0xc,%esp
  807b6c:	50                   	push   %eax
  807b6d:	e8 1e d1 ff ff       	call   804c90 <pbuf_clen>
  807b72:	0f b6 c0             	movzbl %al,%eax
  807b75:	66 01 45 e0          	add    %ax,-0x20(%ebp)
      seg->dataptr = seg->p->payload;
  807b79:	8b 43 04             	mov    0x4(%ebx),%eax
  807b7c:	8b 40 04             	mov    0x4(%eax),%eax
  807b7f:	89 43 08             	mov    %eax,0x8(%ebx)
  807b82:	83 c4 10             	add    $0x10,%esp
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  807b85:	66 83 7d e0 20       	cmpw   $0x20,-0x20(%ebp)
  807b8a:	0f 87 69 02 00 00    	ja     807df9 <tcp_enqueue+0x42f>
    seg->len = seglen;
  807b90:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  807b94:	66 89 43 0c          	mov    %ax,0xc(%ebx)
    if (pbuf_header(seg->p, TCP_HLEN)) {
  807b98:	83 ec 08             	sub    $0x8,%esp
  807b9b:	6a 14                	push   $0x14
  807b9d:	ff 73 04             	pushl  0x4(%ebx)
  807ba0:	e8 d4 cb ff ff       	call   804779 <pbuf_header>
  807ba5:	83 c4 10             	add    $0x10,%esp
  807ba8:	84 c0                	test   %al,%al
  807baa:	0f 85 49 02 00 00    	jne    807df9 <tcp_enqueue+0x42f>
    seg->tcphdr = seg->p->payload;
  807bb0:	8b 43 04             	mov    0x4(%ebx),%eax
  807bb3:	8b 70 04             	mov    0x4(%eax),%esi
  807bb6:	89 73 10             	mov    %esi,0x10(%ebx)
    seg->tcphdr->src = htons(pcb->local_port);
  807bb9:	83 ec 0c             	sub    $0xc,%esp
  807bbc:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  807bc0:	50                   	push   %eax
  807bc1:	e8 bc fb ff ff       	call   807782 <htons>
  807bc6:	66 89 06             	mov    %ax,(%esi)
    seg->tcphdr->dest = htons(pcb->remote_port);
  807bc9:	8b 73 10             	mov    0x10(%ebx),%esi
  807bcc:	0f b7 47 1e          	movzwl 0x1e(%edi),%eax
  807bd0:	89 04 24             	mov    %eax,(%esp)
  807bd3:	e8 aa fb ff ff       	call   807782 <htons>
  807bd8:	66 89 46 02          	mov    %ax,0x2(%esi)
    seg->tcphdr->seqno = htonl(seqno);
  807bdc:	8b 73 10             	mov    0x10(%ebx),%esi
  807bdf:	83 c4 04             	add    $0x4,%esp
  807be2:	ff 75 d8             	pushl  -0x28(%ebp)
  807be5:	e8 b2 fb ff ff       	call   80779c <htonl>
  807bea:	89 46 04             	mov    %eax,0x4(%esi)
    seg->tcphdr->urgp = 0;
  807bed:	8b 43 10             	mov    0x10(%ebx),%eax
  807bf0:	66 c7 40 12 00 00    	movw   $0x0,0x12(%eax)
    TCPH_FLAGS_SET(seg->tcphdr, flags);
  807bf6:	8b 43 10             	mov    0x10(%ebx),%eax
  807bf9:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807bfd:	89 04 24             	mov    %eax,(%esp)
  807c00:	e8 8a fb ff ff       	call   80778f <ntohs>
  807c05:	8b 73 10             	mov    0x10(%ebx),%esi
  807c08:	83 e0 c0             	and    $0xffffffc0,%eax
  807c0b:	0f b6 55 cb          	movzbl -0x35(%ebp),%edx
  807c0f:	09 d0                	or     %edx,%eax
  807c11:	0f b7 c0             	movzwl %ax,%eax
  807c14:	89 04 24             	mov    %eax,(%esp)
  807c17:	e8 66 fb ff ff       	call   807782 <htons>
  807c1c:	66 89 46 0c          	mov    %ax,0xc(%esi)
    if (optdata == NULL) {
  807c20:	83 c4 10             	add    $0x10,%esp
  807c23:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  807c27:	0f 84 0f 02 00 00    	je     807e3c <tcp_enqueue+0x472>
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  807c2d:	83 ec 0c             	sub    $0xc,%esp
  807c30:	8b 43 10             	mov    0x10(%ebx),%eax
  807c33:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807c37:	50                   	push   %eax
  807c38:	e8 52 fb ff ff       	call   80778f <ntohs>
  807c3d:	8b 73 10             	mov    0x10(%ebx),%esi
  807c40:	83 e0 3f             	and    $0x3f,%eax
  807c43:	66 0b 45 c8          	or     -0x38(%ebp),%ax
  807c47:	0f b7 c0             	movzwl %ax,%eax
  807c4a:	89 04 24             	mov    %eax,(%esp)
  807c4d:	e8 30 fb ff ff       	call   807782 <htons>
  807c52:	66 89 46 0c          	mov    %ax,0xc(%esi)
      /* Copy options into data portion of segment.
       Options can thus only be sent in non data carrying
       segments such as SYN|ACK. */
      SMEMCPY(seg->dataptr, optdata, optlen);
  807c56:	83 c4 0c             	add    $0xc,%esp
  807c59:	ff 75 cc             	pushl  -0x34(%ebp)
  807c5c:	ff 75 1c             	pushl  0x1c(%ebp)
  807c5f:	ff 73 08             	pushl  0x8(%ebx)
  807c62:	e8 5a 73 00 00       	call   80efc1 <memcpy>
  807c67:	83 c4 10             	add    $0x10,%esp
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
      (u16_t)flags));

    left -= seglen;
    seqno += seglen;
  807c6a:	0f b7 4d e2          	movzwl -0x1e(%ebp),%ecx
  807c6e:	0f b7 c1             	movzwl %cx,%eax
  807c71:	01 45 d8             	add    %eax,-0x28(%ebp)
    ptr = (void *)((u8_t *)ptr + seglen);
  807c74:	01 45 d0             	add    %eax,-0x30(%ebp)
  while (queue == NULL || left > 0) {
  807c77:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  807c7b:	0f 94 45 e4          	sete   -0x1c(%ebp)
  807c7f:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
    seg = memp_malloc(MEMP_TCP_SEG);
  807c83:	89 de                	mov    %ebx,%esi
  while (queue == NULL || left > 0) {
  807c85:	66 29 4d dc          	sub    %cx,-0x24(%ebp)
  807c89:	0f 85 5c fe ff ff    	jne    807aeb <tcp_enqueue+0x121>
  807c8f:	84 c0                	test   %al,%al
  807c91:	0f 85 54 fe ff ff    	jne    807aeb <tcp_enqueue+0x121>
  }

  /* Now that the data to be enqueued has been broken up into TCP
  segments in the queue variable, we add them to the end of the
  pcb->unsent queue. */
  if (pcb->unsent == NULL) {
  807c97:	8b 47 74             	mov    0x74(%edi),%eax
  807c9a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  807c9d:	85 c0                	test   %eax,%eax
  807c9f:	0f 84 de 03 00 00    	je     808083 <tcp_enqueue+0x6b9>
  807ca5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807ca8:	e9 be 01 00 00       	jmp    807e6b <tcp_enqueue+0x4a1>
    LWIP_ASSERT("tcp_enqueue: no pbufs on queue => both queues empty",
  807cad:	83 ec 04             	sub    $0x4,%esp
  807cb0:	68 24 22 81 00       	push   $0x812224
  807cb5:	68 b1 00 00 00       	push   $0xb1
  807cba:	68 02 23 81 00       	push   $0x812302
  807cbf:	e8 8f 69 00 00       	call   80e653 <_panic>
      LWIP_ASSERT("useg != NULL", useg != NULL);
  807cc4:	83 ec 04             	sub    $0x4,%esp
  807cc7:	68 1a 23 81 00       	push   $0x81231a
  807ccc:	68 ce 00 00 00       	push   $0xce
  807cd1:	68 02 23 81 00       	push   $0x812302
  807cd6:	e8 78 69 00 00       	call   80e653 <_panic>
    seg = memp_malloc(MEMP_TCP_SEG);
  807cdb:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  807cde:	e9 51 fe ff ff       	jmp    807b34 <tcp_enqueue+0x16a>
      LWIP_ASSERT("check that first pbuf can hold optlen",
  807ce3:	83 ec 04             	sub    $0x4,%esp
  807ce6:	68 58 22 81 00       	push   $0x812258
  807ceb:	68 df 00 00 00       	push   $0xdf
  807cf0:	68 02 23 81 00       	push   $0x812302
  807cf5:	e8 59 69 00 00       	call   80e653 <_panic>
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  807cfa:	80 7d c7 00          	cmpb   $0x0,-0x39(%ebp)
  807cfe:	74 7f                	je     807d7f <tcp_enqueue+0x3b5>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_RAM)) == NULL) {
  807d00:	83 ec 04             	sub    $0x4,%esp
  807d03:	6a 00                	push   $0x0
  807d05:	0f b7 75 e2          	movzwl -0x1e(%ebp),%esi
  807d09:	0f b7 c6             	movzwl %si,%eax
  807d0c:	50                   	push   %eax
  807d0d:	6a 00                	push   $0x0
  807d0f:	e8 ff cb ff ff       	call   804913 <pbuf_alloc>
  807d14:	89 43 04             	mov    %eax,0x4(%ebx)
  807d17:	83 c4 10             	add    $0x10,%esp
  807d1a:	85 c0                	test   %eax,%eax
  807d1c:	0f 84 d7 00 00 00    	je     807df9 <tcp_enqueue+0x42f>
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
  807d22:	66 39 70 0a          	cmp    %si,0xa(%eax)
  807d26:	72 40                	jb     807d68 <tcp_enqueue+0x39e>
      queuelen += pbuf_clen(seg->p);
  807d28:	83 ec 0c             	sub    $0xc,%esp
  807d2b:	50                   	push   %eax
  807d2c:	e8 5f cf ff ff       	call   804c90 <pbuf_clen>
  807d31:	0f b6 c0             	movzbl %al,%eax
  807d34:	66 01 45 e0          	add    %ax,-0x20(%ebp)
      if (arg != NULL) {
  807d38:	83 c4 10             	add    $0x10,%esp
  807d3b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  807d3f:	74 19                	je     807d5a <tcp_enqueue+0x390>
        MEMCPY(seg->p->payload, ptr, seglen);
  807d41:	83 ec 04             	sub    $0x4,%esp
  807d44:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  807d48:	50                   	push   %eax
  807d49:	ff 75 d0             	pushl  -0x30(%ebp)
  807d4c:	8b 43 04             	mov    0x4(%ebx),%eax
  807d4f:	ff 70 04             	pushl  0x4(%eax)
  807d52:	e8 6a 72 00 00       	call   80efc1 <memcpy>
  807d57:	83 c4 10             	add    $0x10,%esp
      seg->dataptr = seg->p->payload;
  807d5a:	8b 43 04             	mov    0x4(%ebx),%eax
  807d5d:	8b 40 04             	mov    0x4(%eax),%eax
  807d60:	89 43 08             	mov    %eax,0x8(%ebx)
  807d63:	e9 1d fe ff ff       	jmp    807b85 <tcp_enqueue+0x1bb>
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
  807d68:	83 ec 04             	sub    $0x4,%esp
  807d6b:	68 80 22 81 00       	push   $0x812280
  807d70:	68 ea 00 00 00       	push   $0xea
  807d75:	68 02 23 81 00       	push   $0x812302
  807d7a:	e8 d4 68 00 00       	call   80e653 <_panic>
      if ((p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
  807d7f:	83 ec 04             	sub    $0x4,%esp
  807d82:	6a 01                	push   $0x1
  807d84:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  807d88:	50                   	push   %eax
  807d89:	6a 00                	push   $0x0
  807d8b:	e8 83 cb ff ff       	call   804913 <pbuf_alloc>
  807d90:	89 c6                	mov    %eax,%esi
  807d92:	83 c4 10             	add    $0x10,%esp
  807d95:	85 c0                	test   %eax,%eax
  807d97:	74 60                	je     807df9 <tcp_enqueue+0x42f>
      ++queuelen;
  807d99:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  807d9d:	83 c0 01             	add    $0x1,%eax
  807da0:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
      p->payload = ptr;
  807da4:	8b 45 d0             	mov    -0x30(%ebp),%eax
  807da7:	89 46 04             	mov    %eax,0x4(%esi)
      seg->dataptr = ptr;
  807daa:	89 43 08             	mov    %eax,0x8(%ebx)
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_RAM)) == NULL) {
  807dad:	83 ec 04             	sub    $0x4,%esp
  807db0:	6a 00                	push   $0x0
  807db2:	6a 00                	push   $0x0
  807db4:	6a 00                	push   $0x0
  807db6:	e8 58 cb ff ff       	call   804913 <pbuf_alloc>
  807dbb:	89 43 04             	mov    %eax,0x4(%ebx)
  807dbe:	83 c4 10             	add    $0x10,%esp
  807dc1:	85 c0                	test   %eax,%eax
  807dc3:	74 28                	je     807ded <tcp_enqueue+0x423>
      queuelen += pbuf_clen(seg->p);
  807dc5:	83 ec 0c             	sub    $0xc,%esp
  807dc8:	50                   	push   %eax
  807dc9:	e8 c2 ce ff ff       	call   804c90 <pbuf_clen>
  807dce:	0f b6 c0             	movzbl %al,%eax
  807dd1:	66 03 45 e4          	add    -0x1c(%ebp),%ax
  807dd5:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
      pbuf_cat(seg->p/*header*/, p/*data*/);
  807dd9:	83 c4 08             	add    $0x8,%esp
  807ddc:	56                   	push   %esi
  807ddd:	ff 73 04             	pushl  0x4(%ebx)
  807de0:	e8 d4 ce ff ff       	call   804cb9 <pbuf_cat>
  807de5:	83 c4 10             	add    $0x10,%esp
  807de8:	e9 98 fd ff ff       	jmp    807b85 <tcp_enqueue+0x1bb>
        pbuf_free(p);
  807ded:	83 ec 0c             	sub    $0xc,%esp
  807df0:	56                   	push   %esi
  807df1:	e8 57 ca ff ff       	call   80484d <pbuf_free>
        goto memerr;
  807df6:	83 c4 10             	add    $0x10,%esp
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
  807df9:	80 4f 20 80          	orb    $0x80,0x20(%edi)
  TCP_STATS_INC(tcp.memerr);

  if (queue != NULL) {
  807dfd:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  807e00:	85 c0                	test   %eax,%eax
  807e02:	74 0c                	je     807e10 <tcp_enqueue+0x446>
    tcp_segs_free(queue);
  807e04:	83 ec 0c             	sub    $0xc,%esp
  807e07:	50                   	push   %eax
  807e08:	e8 ed d9 ff ff       	call   8057fa <tcp_segs_free>
  807e0d:	83 c4 10             	add    $0x10,%esp
  }
  if (pcb->snd_queuelen != 0) {
  807e10:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  807e15:	0f 84 54 02 00 00    	je     80806f <tcp_enqueue+0x6a5>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
  807e1b:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  807e1f:	0f 85 54 02 00 00    	jne    808079 <tcp_enqueue+0x6af>
  807e25:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  807e29:	0f 84 1f 02 00 00    	je     80804e <tcp_enqueue+0x684>
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_enqueue: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
  807e2f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  807e34:	8d 65 f4             	lea    -0xc(%ebp),%esp
  807e37:	5b                   	pop    %ebx
  807e38:	5e                   	pop    %esi
  807e39:	5f                   	pop    %edi
  807e3a:	5d                   	pop    %ebp
  807e3b:	c3                   	ret    
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
  807e3c:	83 ec 0c             	sub    $0xc,%esp
  807e3f:	8b 43 10             	mov    0x10(%ebx),%eax
  807e42:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807e46:	50                   	push   %eax
  807e47:	e8 43 f9 ff ff       	call   80778f <ntohs>
  807e4c:	8b 73 10             	mov    0x10(%ebx),%esi
  807e4f:	83 e0 3f             	and    $0x3f,%eax
  807e52:	80 cc 50             	or     $0x50,%ah
  807e55:	89 04 24             	mov    %eax,(%esp)
  807e58:	e8 25 f9 ff ff       	call   807782 <htons>
  807e5d:	66 89 46 0c          	mov    %ax,0xc(%esi)
  807e61:	83 c4 10             	add    $0x10,%esp
  807e64:	e9 01 fe ff ff       	jmp    807c6a <tcp_enqueue+0x2a0>
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
  807e69:	89 f0                	mov    %esi,%eax
  807e6b:	8b 30                	mov    (%eax),%esi
  807e6d:	85 f6                	test   %esi,%esi
  807e6f:	75 f8                	jne    807e69 <tcp_enqueue+0x49f>
  807e71:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if (useg != NULL &&
  807e74:	85 c0                	test   %eax,%eax
  807e76:	0f 84 07 02 00 00    	je     808083 <tcp_enqueue+0x6b9>
    TCP_TCPLEN(useg) != 0 &&
  807e7c:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
  807e80:	89 55 dc             	mov    %edx,-0x24(%ebp)
  807e83:	83 ec 0c             	sub    $0xc,%esp
  807e86:	8b 40 10             	mov    0x10(%eax),%eax
  807e89:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807e8d:	50                   	push   %eax
  807e8e:	e8 fc f8 ff ff       	call   80778f <ntohs>
  807e93:	83 c4 10             	add    $0x10,%esp
  807e96:	ba 01 00 00 00       	mov    $0x1,%edx
  807e9b:	a8 01                	test   $0x1,%al
  807e9d:	0f 84 b7 00 00 00    	je     807f5a <tcp_enqueue+0x590>
  if (useg != NULL &&
  807ea3:	8b 45 dc             	mov    -0x24(%ebp),%eax
  807ea6:	01 d0                	add    %edx,%eax
  807ea8:	0f 85 cf 00 00 00    	jne    807f7d <tcp_enqueue+0x5b3>
      useg->next = queue;
  807eae:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807eb1:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  807eb4:	89 10                	mov    %edx,(%eax)
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
  807eb6:	0f b6 55 bc          	movzbl -0x44(%ebp),%edx
  807eba:	83 e2 03             	and    $0x3,%edx
    ++len;
  807ebd:	0f b7 45 c0          	movzwl -0x40(%ebp),%eax
  807ec1:	83 c0 01             	add    $0x1,%eax
  807ec4:	84 d2                	test   %dl,%dl
  807ec6:	66 0f 44 45 c4       	cmove  -0x3c(%ebp),%ax
  807ecb:	66 89 45 c4          	mov    %ax,-0x3c(%ebp)
  if (flags & TCP_FIN) {
  807ecf:	f6 45 bc 01          	testb  $0x1,-0x44(%ebp)
  807ed3:	74 04                	je     807ed9 <tcp_enqueue+0x50f>
    pcb->flags |= TF_FIN;
  807ed5:	80 4f 20 20          	orb    $0x20,0x20(%edi)
  pcb->snd_lbb += len;
  807ed9:	0f b7 55 c4          	movzwl -0x3c(%ebp),%edx
  807edd:	0f b7 c2             	movzwl %dx,%eax
  807ee0:	01 47 68             	add    %eax,0x68(%edi)
  pcb->snd_buf -= len;
  807ee3:	66 29 57 6e          	sub    %dx,0x6e(%edi)
  pcb->snd_queuelen = queuelen;
  807ee7:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  807eeb:	66 89 47 70          	mov    %ax,0x70(%edi)
  if (pcb->snd_queuelen != 0) {
  807eef:	66 85 c0             	test   %ax,%ax
  807ef2:	74 0a                	je     807efe <tcp_enqueue+0x534>
    LWIP_ASSERT("tcp_enqueue: valid queue length",
  807ef4:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  807ef8:	0f 84 2f 01 00 00    	je     80802d <tcp_enqueue+0x663>
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  807efe:	85 db                	test   %ebx,%ebx
  807f00:	0f 84 5f 01 00 00    	je     808065 <tcp_enqueue+0x69b>
  807f06:	66 83 7d e2 00       	cmpw   $0x0,-0x1e(%ebp)
  807f0b:	0f 84 54 01 00 00    	je     808065 <tcp_enqueue+0x69b>
  807f11:	8b 53 10             	mov    0x10(%ebx),%edx
  return ERR_OK;
  807f14:	b8 00 00 00 00       	mov    $0x0,%eax
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  807f19:	85 d2                	test   %edx,%edx
  807f1b:	0f 84 13 ff ff ff    	je     807e34 <tcp_enqueue+0x46a>
  807f21:	f6 45 b8 02          	testb  $0x2,-0x48(%ebp)
  807f25:	0f 85 09 ff ff ff    	jne    807e34 <tcp_enqueue+0x46a>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  807f2b:	83 ec 0c             	sub    $0xc,%esp
  807f2e:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  807f32:	50                   	push   %eax
  807f33:	e8 57 f8 ff ff       	call   80778f <ntohs>
  807f38:	8b 5b 10             	mov    0x10(%ebx),%ebx
  807f3b:	83 c8 08             	or     $0x8,%eax
  807f3e:	0f b7 c0             	movzwl %ax,%eax
  807f41:	89 04 24             	mov    %eax,(%esp)
  807f44:	e8 39 f8 ff ff       	call   807782 <htons>
  807f49:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  807f4d:	83 c4 10             	add    $0x10,%esp
  return ERR_OK;
  807f50:	b8 00 00 00 00       	mov    $0x0,%eax
  807f55:	e9 da fe ff ff       	jmp    807e34 <tcp_enqueue+0x46a>
    TCP_TCPLEN(useg) != 0 &&
  807f5a:	83 ec 0c             	sub    $0xc,%esp
  807f5d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807f60:	8b 40 10             	mov    0x10(%eax),%eax
  807f63:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807f67:	50                   	push   %eax
  807f68:	e8 22 f8 ff ff       	call   80778f <ntohs>
  807f6d:	66 d1 e8             	shr    %ax
  807f70:	89 c2                	mov    %eax,%edx
  807f72:	83 e2 01             	and    $0x1,%edx
  807f75:	83 c4 10             	add    $0x10,%esp
  807f78:	e9 26 ff ff ff       	jmp    807ea3 <tcp_enqueue+0x4d9>
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  807f7d:	83 ec 0c             	sub    $0xc,%esp
  807f80:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807f83:	8b 40 10             	mov    0x10(%eax),%eax
  807f86:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807f8a:	50                   	push   %eax
  807f8b:	e8 ff f7 ff ff       	call   80778f <ntohs>
    TCP_TCPLEN(useg) != 0 &&
  807f90:	83 c4 10             	add    $0x10,%esp
  807f93:	a8 03                	test   $0x3,%al
  807f95:	0f 85 13 ff ff ff    	jne    807eae <tcp_enqueue+0x4e4>
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  807f9b:	f6 45 bc 03          	testb  $0x3,-0x44(%ebp)
  807f9f:	0f 85 09 ff ff ff    	jne    807eae <tcp_enqueue+0x4e4>
    useg->len + queue->len <= pcb->mss) {
  807fa5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807fa8:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807fac:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  807faf:	0f b7 52 0c          	movzwl 0xc(%edx),%edx
  807fb3:	01 d0                	add    %edx,%eax
  807fb5:	0f b7 57 34          	movzwl 0x34(%edi),%edx
    !(flags & (TCP_SYN | TCP_FIN)) &&
  807fb9:	39 d0                	cmp    %edx,%eax
  807fbb:	0f 8f ed fe ff ff    	jg     807eae <tcp_enqueue+0x4e4>
    if(pbuf_header(queue->p, -TCP_HLEN)) {
  807fc1:	83 ec 08             	sub    $0x8,%esp
  807fc4:	6a ec                	push   $0xffffffec
  807fc6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  807fc9:	ff 70 04             	pushl  0x4(%eax)
  807fcc:	e8 a8 c7 ff ff       	call   804779 <pbuf_header>
  807fd1:	83 c4 10             	add    $0x10,%esp
  807fd4:	84 c0                	test   %al,%al
  807fd6:	75 3e                	jne    808016 <tcp_enqueue+0x64c>
    pbuf_cat(useg->p, queue->p);
  807fd8:	83 ec 08             	sub    $0x8,%esp
  807fdb:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  807fde:	ff 72 04             	pushl  0x4(%edx)
  807fe1:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  807fe4:	ff 71 04             	pushl  0x4(%ecx)
  807fe7:	e8 cd cc ff ff       	call   804cb9 <pbuf_cat>
    useg->len += queue->len;
  807fec:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  807fef:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  807ff3:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  807ff6:	66 01 41 0c          	add    %ax,0xc(%ecx)
    useg->next = queue->next;
  807ffa:	8b 02                	mov    (%edx),%eax
  807ffc:	89 01                	mov    %eax,(%ecx)
    if (seg == queue) {
  807ffe:	83 c4 08             	add    $0x8,%esp
      seg = NULL;
  808001:	39 da                	cmp    %ebx,%edx
  808003:	0f 44 de             	cmove  %esi,%ebx
    memp_free(MEMP_TCP_SEG, queue);
  808006:	52                   	push   %edx
  808007:	6a 04                	push   $0x4
  808009:	e8 d0 c4 ff ff       	call   8044de <memp_free>
  80800e:	83 c4 10             	add    $0x10,%esp
  808011:	e9 b9 fe ff ff       	jmp    807ecf <tcp_enqueue+0x505>
      LWIP_ASSERT("pbuf_header failed\n", 0);
  808016:	83 ec 04             	sub    $0x4,%esp
  808019:	68 27 23 81 00       	push   $0x812327
  80801e:	68 52 01 00 00       	push   $0x152
  808023:	68 02 23 81 00       	push   $0x812302
  808028:	e8 26 66 00 00       	call   80e653 <_panic>
    LWIP_ASSERT("tcp_enqueue: valid queue length",
  80802d:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  808031:	0f 85 c7 fe ff ff    	jne    807efe <tcp_enqueue+0x534>
  808037:	83 ec 04             	sub    $0x4,%esp
  80803a:	68 b4 22 81 00       	push   $0x8122b4
  80803f:	68 7a 01 00 00       	push   $0x17a
  808044:	68 02 23 81 00       	push   $0x812302
  808049:	e8 05 66 00 00       	call   80e653 <_panic>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
  80804e:	83 ec 04             	sub    $0x4,%esp
  808051:	68 b4 22 81 00       	push   $0x8122b4
  808056:	68 8d 01 00 00       	push   $0x18d
  80805b:	68 02 23 81 00       	push   $0x812302
  808060:	e8 ee 65 00 00       	call   80e653 <_panic>
  return ERR_OK;
  808065:	b8 00 00 00 00       	mov    $0x0,%eax
  80806a:	e9 c5 fd ff ff       	jmp    807e34 <tcp_enqueue+0x46a>
  return ERR_MEM;
  80806f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  808074:	e9 bb fd ff ff       	jmp    807e34 <tcp_enqueue+0x46a>
  808079:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80807e:	e9 b1 fd ff ff       	jmp    807e34 <tcp_enqueue+0x46a>
      pcb->unsent = queue;
  808083:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  808086:	89 47 74             	mov    %eax,0x74(%edi)
  808089:	e9 28 fe ff ff       	jmp    807eb6 <tcp_enqueue+0x4ec>

0080808e <tcp_send_ctrl>:
{
  80808e:	55                   	push   %ebp
  80808f:	89 e5                	mov    %esp,%ebp
  808091:	83 ec 0c             	sub    $0xc,%esp
  return tcp_enqueue(pcb, NULL, 0, flags, TCP_WRITE_FLAG_COPY, NULL, 0);
  808094:	6a 00                	push   $0x0
  808096:	6a 00                	push   $0x0
  808098:	6a 01                	push   $0x1
  80809a:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
  80809e:	50                   	push   %eax
  80809f:	6a 00                	push   $0x0
  8080a1:	6a 00                	push   $0x0
  8080a3:	ff 75 08             	pushl  0x8(%ebp)
  8080a6:	e8 1f f9 ff ff       	call   8079ca <tcp_enqueue>
}
  8080ab:	c9                   	leave  
  8080ac:	c3                   	ret    

008080ad <tcp_write>:
{
  8080ad:	55                   	push   %ebp
  8080ae:	89 e5                	mov    %esp,%ebp
  8080b0:	56                   	push   %esi
  8080b1:	53                   	push   %ebx
  8080b2:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8080b5:	8b 55 10             	mov    0x10(%ebp),%edx
  8080b8:	8b 5d 14             	mov    0x14(%ebp),%ebx
  if (pcb->state == ESTABLISHED ||
  8080bb:	8b 41 10             	mov    0x10(%ecx),%eax
     pcb->state == CLOSE_WAIT ||
  8080be:	8d 70 fe             	lea    -0x2(%eax),%esi
     pcb->state == SYN_SENT ||
  8080c1:	83 fe 02             	cmp    $0x2,%esi
  8080c4:	76 05                	jbe    8080cb <tcp_write+0x1e>
  8080c6:	83 f8 07             	cmp    $0x7,%eax
  8080c9:	75 30                	jne    8080fb <tcp_write+0x4e>
    return ERR_OK;
  8080cb:	b8 00 00 00 00       	mov    $0x0,%eax
    if (len > 0) {
  8080d0:	66 85 d2             	test   %dx,%dx
  8080d3:	75 07                	jne    8080dc <tcp_write+0x2f>
}
  8080d5:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8080d8:	5b                   	pop    %ebx
  8080d9:	5e                   	pop    %esi
  8080da:	5d                   	pop    %ebp
  8080db:	c3                   	ret    
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, NULL, 0);
  8080dc:	83 ec 04             	sub    $0x4,%esp
  8080df:	6a 00                	push   $0x0
  8080e1:	6a 00                	push   $0x0
  8080e3:	0f b6 db             	movzbl %bl,%ebx
  8080e6:	53                   	push   %ebx
  8080e7:	6a 00                	push   $0x0
  8080e9:	0f b7 d2             	movzwl %dx,%edx
  8080ec:	52                   	push   %edx
  8080ed:	ff 75 0c             	pushl  0xc(%ebp)
  8080f0:	51                   	push   %ecx
  8080f1:	e8 d4 f8 ff ff       	call   8079ca <tcp_enqueue>
  8080f6:	83 c4 20             	add    $0x20,%esp
  8080f9:	eb da                	jmp    8080d5 <tcp_write+0x28>
    return ERR_CONN;
  8080fb:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  808100:	eb d3                	jmp    8080d5 <tcp_write+0x28>

00808102 <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
  808102:	55                   	push   %ebp
  808103:	89 e5                	mov    %esp,%ebp
  808105:	57                   	push   %edi
  808106:	56                   	push   %esi
  808107:	53                   	push   %ebx
  808108:	83 ec 1c             	sub    $0x1c,%esp
  80810b:	8b 7d 08             	mov    0x8(%ebp),%edi

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
  80810e:	39 3d 58 b2 b3 00    	cmp    %edi,0xb3b258
  808114:	0f 84 81 04 00 00    	je     80859b <tcp_output+0x499>
    return ERR_OK;
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
  80811a:	0f b7 57 5c          	movzwl 0x5c(%edi),%edx
  80811e:	0f b7 47 4e          	movzwl 0x4e(%edi),%eax
  808122:	0f b7 ca             	movzwl %dx,%ecx
  808125:	0f b7 d8             	movzwl %ax,%ebx
  808128:	66 39 c2             	cmp    %ax,%dx
  80812b:	0f 43 cb             	cmovae %ebx,%ecx
  80812e:	89 4d d8             	mov    %ecx,-0x28(%ebp)

  seg = pcb->unsent;
  808131:	8b 5f 74             	mov    0x74(%edi),%ebx

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
  808134:	8b 47 78             	mov    0x78(%edi),%eax
  808137:	89 45 dc             	mov    %eax,-0x24(%ebp)
  80813a:	8b 55 dc             	mov    -0x24(%ebp),%edx
  if (useg != NULL) {
  80813d:	85 c0                	test   %eax,%eax
  80813f:	75 04                	jne    808145 <tcp_output+0x43>
  808141:	eb 0b                	jmp    80814e <tcp_output+0x4c>
    for (; useg->next != NULL; useg = useg->next);
  808143:	89 c2                	mov    %eax,%edx
  808145:	8b 02                	mov    (%edx),%eax
  808147:	85 c0                	test   %eax,%eax
  808149:	75 f8                	jne    808143 <tcp_output+0x41>
  80814b:	89 55 dc             	mov    %edx,-0x24(%ebp)
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
  80814e:	f6 47 20 02          	testb  $0x2,0x20(%edi)
  808152:	0f 84 03 04 00 00    	je     80855b <tcp_output+0x459>
  808158:	85 db                	test   %ebx,%ebx
  80815a:	74 23                	je     80817f <tcp_output+0x7d>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
  80815c:	83 ec 0c             	sub    $0xc,%esp
  80815f:	8b 43 10             	mov    0x10(%ebx),%eax
  808162:	ff 70 04             	pushl  0x4(%eax)
  808165:	e8 50 f8 ff ff       	call   8079ba <ntohl>
  80816a:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  80816e:	2b 57 48             	sub    0x48(%edi),%edx
  808171:	01 d0                	add    %edx,%eax
     (seg == NULL ||
  808173:	83 c4 10             	add    $0x10,%esp
  808176:	3b 45 d8             	cmp    -0x28(%ebp),%eax
  808179:	0f 86 dc 03 00 00    	jbe    80855b <tcp_output+0x459>
    p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  80817f:	83 ec 04             	sub    $0x4,%esp
  808182:	6a 00                	push   $0x0
  808184:	6a 14                	push   $0x14
  808186:	6a 01                	push   $0x1
  808188:	e8 86 c7 ff ff       	call   804913 <pbuf_alloc>
  80818d:	89 c6                	mov    %eax,%esi
    if (p == NULL) {
  80818f:	83 c4 10             	add    $0x10,%esp
  808192:	85 c0                	test   %eax,%eax
  808194:	0f 84 08 04 00 00    	je     8085a2 <tcp_output+0x4a0>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
      return ERR_BUF;
    }
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
    /* remove ACK flags from the PCB, as we send an empty ACK now */
    pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  80819a:	80 67 20 fc          	andb   $0xfc,0x20(%edi)

    tcphdr = p->payload;
  80819e:	8b 58 04             	mov    0x4(%eax),%ebx
    tcphdr->src = htons(pcb->local_port);
  8081a1:	83 ec 0c             	sub    $0xc,%esp
  8081a4:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  8081a8:	50                   	push   %eax
  8081a9:	e8 d4 f5 ff ff       	call   807782 <htons>
  8081ae:	66 89 03             	mov    %ax,(%ebx)
    tcphdr->dest = htons(pcb->remote_port);
  8081b1:	0f b7 47 1e          	movzwl 0x1e(%edi),%eax
  8081b5:	89 04 24             	mov    %eax,(%esp)
  8081b8:	e8 c5 f5 ff ff       	call   807782 <htons>
  8081bd:	66 89 43 02          	mov    %ax,0x2(%ebx)
    tcphdr->seqno = htonl(pcb->snd_nxt);
  8081c1:	83 c4 04             	add    $0x4,%esp
  8081c4:	ff 77 54             	pushl  0x54(%edi)
  8081c7:	e8 d0 f5 ff ff       	call   80779c <htonl>
  8081cc:	89 43 04             	mov    %eax,0x4(%ebx)
    tcphdr->ackno = htonl(pcb->rcv_nxt);
  8081cf:	83 c4 04             	add    $0x4,%esp
  8081d2:	ff 77 24             	pushl  0x24(%edi)
  8081d5:	e8 c2 f5 ff ff       	call   80779c <htonl>
  8081da:	89 43 08             	mov    %eax,0x8(%ebx)
    TCPH_FLAGS_SET(tcphdr, TCP_ACK);
  8081dd:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  8081e1:	89 04 24             	mov    %eax,(%esp)
  8081e4:	e8 a6 f5 ff ff       	call   80778f <ntohs>
  8081e9:	25 c0 ff 00 00       	and    $0xffc0,%eax
  8081ee:	83 c8 10             	or     $0x10,%eax
  8081f1:	89 04 24             	mov    %eax,(%esp)
  8081f4:	e8 89 f5 ff ff       	call   807782 <htons>
  8081f9:	66 89 43 0c          	mov    %ax,0xc(%ebx)
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  8081fd:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  808201:	89 04 24             	mov    %eax,(%esp)
  808204:	e8 79 f5 ff ff       	call   807782 <htons>
  808209:	66 89 43 0e          	mov    %ax,0xe(%ebx)
    tcphdr->urgp = 0;
  80820d:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
    TCPH_HDRLEN_SET(tcphdr, 5);
  808213:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808217:	89 04 24             	mov    %eax,(%esp)
  80821a:	e8 70 f5 ff ff       	call   80778f <ntohs>
  80821f:	83 e0 3f             	and    $0x3f,%eax
  808222:	80 cc 50             	or     $0x50,%ah
  808225:	89 04 24             	mov    %eax,(%esp)
  808228:	e8 55 f5 ff ff       	call   807782 <htons>
  80822d:	66 89 43 0c          	mov    %ax,0xc(%ebx)

    tcphdr->chksum = 0;
  808231:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
    tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
  808237:	8d 47 04             	lea    0x4(%edi),%eax
  80823a:	89 c1                	mov    %eax,%ecx
  80823c:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  808240:	89 04 24             	mov    %eax,(%esp)
  808243:	6a 06                	push   $0x6
  808245:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  808248:	51                   	push   %ecx
  808249:	57                   	push   %edi
  80824a:	56                   	push   %esi
  80824b:	e8 18 f2 ff ff       	call   807468 <inet_chksum_pseudo>
  808250:	66 89 43 10          	mov    %ax,0x10(%ebx)
                     pcb->tos, IP_PROTO_TCP, netif);
        netif->addr_hint = NULL;
      }
    }
#else /* LWIP_NETIF_HWADDRHINT*/
    ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  808254:	83 c4 18             	add    $0x18,%esp
  808257:	6a 06                	push   $0x6
  808259:	0f b6 47 0a          	movzbl 0xa(%edi),%eax
  80825d:	50                   	push   %eax
  80825e:	0f b6 47 0b          	movzbl 0xb(%edi),%eax
  808262:	50                   	push   %eax
  808263:	ff 75 e4             	pushl  -0x1c(%ebp)
  808266:	57                   	push   %edi
  808267:	56                   	push   %esi
  808268:	e8 12 e8 ff ff       	call   806a7f <ip_output>
        IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
    pbuf_free(p);
  80826d:	83 c4 14             	add    $0x14,%esp
  808270:	56                   	push   %esi
  808271:	e8 d7 c5 ff ff       	call   80484d <pbuf_free>

    return ERR_OK;
  808276:	83 c4 10             	add    $0x10,%esp
  808279:	b8 00 00 00 00       	mov    $0x0,%eax
  80827e:	e9 38 03 00 00       	jmp    8085bb <tcp_output+0x4b9>
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!", 
  808283:	83 ec 04             	sub    $0x4,%esp
  808286:	68 3b 23 81 00       	push   $0x81233b
  80828b:	68 05 02 00 00       	push   $0x205
  808290:	68 02 23 81 00       	push   $0x812302
  808295:	e8 b9 63 00 00       	call   80e653 <_panic>
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;

    if (pcb->state != SYN_SENT) {
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
  80829a:	83 ec 0c             	sub    $0xc,%esp
  80829d:	8b 43 10             	mov    0x10(%ebx),%eax
  8082a0:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8082a4:	50                   	push   %eax
  8082a5:	e8 e5 f4 ff ff       	call   80778f <ntohs>
  8082aa:	8b 73 10             	mov    0x10(%ebx),%esi
  8082ad:	83 c8 10             	or     $0x10,%eax
  8082b0:	0f b7 c0             	movzwl %ax,%eax
  8082b3:	89 04 24             	mov    %eax,(%esp)
  8082b6:	e8 c7 f4 ff ff       	call   807782 <htons>
  8082bb:	66 89 46 0c          	mov    %ax,0xc(%esi)
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  8082bf:	80 67 20 fc          	andb   $0xfc,0x20(%edi)
  8082c3:	83 c4 10             	add    $0x10,%esp
  8082c6:	e9 f4 00 00 00       	jmp    8083bf <tcp_output+0x2bd>
    ip_addr_set(&(pcb->local_ip), &(netif->ip_addr));
  }

  /* Set retransmission timer running if it is not currently enabled */
  if(pcb->rtime == -1)
    pcb->rtime = 0;
  8082cb:	66 c7 47 32 00 00    	movw   $0x0,0x32(%edi)
  8082d1:	e9 49 01 00 00       	jmp    80841f <tcp_output+0x31d>

  if (pcb->rttest == 0) {
    pcb->rttest = tcp_ticks;
  8082d6:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  8082db:	89 47 38             	mov    %eax,0x38(%edi)
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
  8082de:	83 ec 0c             	sub    $0xc,%esp
  8082e1:	8b 43 10             	mov    0x10(%ebx),%eax
  8082e4:	ff 70 04             	pushl  0x4(%eax)
  8082e7:	e8 ce f6 ff ff       	call   8079ba <ntohl>
  8082ec:	89 47 3c             	mov    %eax,0x3c(%edi)
  8082ef:	83 c4 10             	add    $0x10,%esp
  8082f2:	e9 32 01 00 00       	jmp    808429 <tcp_output+0x327>
    pcb->snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
  8082f7:	83 ec 0c             	sub    $0xc,%esp
  8082fa:	8b 43 10             	mov    0x10(%ebx),%eax
  8082fd:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808301:	50                   	push   %eax
  808302:	e8 88 f4 ff ff       	call   80778f <ntohs>
  808307:	66 d1 e8             	shr    %ax
  80830a:	89 c2                	mov    %eax,%edx
  80830c:	83 e2 01             	and    $0x1,%edx
  80830f:	83 c4 10             	add    $0x10,%esp
  808312:	e9 a8 01 00 00       	jmp    8084bf <tcp_output+0x3bd>
      pcb->snd_max = pcb->snd_nxt;
  808317:	89 77 58             	mov    %esi,0x58(%edi)
  80831a:	e9 b1 01 00 00       	jmp    8084d0 <tcp_output+0x3ce>
    if (TCP_TCPLEN(seg) > 0) {
  80831f:	83 ec 0c             	sub    $0xc,%esp
  808322:	8b 43 10             	mov    0x10(%ebx),%eax
  808325:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808329:	50                   	push   %eax
  80832a:	e8 60 f4 ff ff       	call   80778f <ntohs>
  80832f:	66 d1 e8             	shr    %ax
  808332:	89 c2                	mov    %eax,%edx
  808334:	83 e2 01             	and    $0x1,%edx
  808337:	83 c4 10             	add    $0x10,%esp
  80833a:	e9 b5 01 00 00       	jmp    8084f4 <tcp_output+0x3f2>
        pcb->unacked = seg;
  80833f:	89 5f 78             	mov    %ebx,0x78(%edi)
  808342:	89 5d dc             	mov    %ebx,-0x24(%ebp)
    seg = pcb->unsent;
  808345:	8b 5f 74             	mov    0x74(%edi),%ebx
  while (seg != NULL &&
  808348:	85 db                	test   %ebx,%ebx
  80834a:	0f 84 62 02 00 00    	je     8085b2 <tcp_output+0x4b0>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
  808350:	83 ec 0c             	sub    $0xc,%esp
  808353:	8b 43 10             	mov    0x10(%ebx),%eax
  808356:	ff 70 04             	pushl  0x4(%eax)
  808359:	e8 5c f6 ff ff       	call   8079ba <ntohl>
  80835e:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  808362:	2b 57 48             	sub    0x48(%edi),%edx
  808365:	01 d0                	add    %edx,%eax
  while (seg != NULL &&
  808367:	83 c4 10             	add    $0x10,%esp
  80836a:	3b 45 d8             	cmp    -0x28(%ebp),%eax
  80836d:	0f 87 36 02 00 00    	ja     8085a9 <tcp_output+0x4a7>
    LWIP_ASSERT("RST not expected here!", 
  808373:	83 ec 0c             	sub    $0xc,%esp
  808376:	8b 43 10             	mov    0x10(%ebx),%eax
  808379:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80837d:	50                   	push   %eax
  80837e:	e8 0c f4 ff ff       	call   80778f <ntohs>
  808383:	83 c4 10             	add    $0x10,%esp
  808386:	a8 04                	test   $0x4,%al
  808388:	0f 85 f5 fe ff ff    	jne    808283 <tcp_output+0x181>
    if((tcp_do_output_nagle(pcb) == 0) &&
  80838e:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  808392:	74 1c                	je     8083b0 <tcp_output+0x2ae>
  808394:	0f b6 47 20          	movzbl 0x20(%edi),%eax
  808398:	a8 40                	test   $0x40,%al
  80839a:	75 14                	jne    8083b0 <tcp_output+0x2ae>
  80839c:	8b 57 74             	mov    0x74(%edi),%edx
  80839f:	85 d2                	test   %edx,%edx
  8083a1:	74 05                	je     8083a8 <tcp_output+0x2a6>
  8083a3:	83 3a 00             	cmpl   $0x0,(%edx)
  8083a6:	75 08                	jne    8083b0 <tcp_output+0x2ae>
  8083a8:	a8 a0                	test   $0xa0,%al
  8083aa:	0f 84 f9 01 00 00    	je     8085a9 <tcp_output+0x4a7>
    pcb->unsent = seg->next;
  8083b0:	8b 03                	mov    (%ebx),%eax
  8083b2:	89 47 74             	mov    %eax,0x74(%edi)
    if (pcb->state != SYN_SENT) {
  8083b5:	83 7f 10 02          	cmpl   $0x2,0x10(%edi)
  8083b9:	0f 85 db fe ff ff    	jne    80829a <tcp_output+0x198>
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
  8083bf:	8b 73 10             	mov    0x10(%ebx),%esi
  8083c2:	83 ec 0c             	sub    $0xc,%esp
  8083c5:	ff 77 24             	pushl  0x24(%edi)
  8083c8:	e8 cf f3 ff ff       	call   80779c <htonl>
  8083cd:	89 46 08             	mov    %eax,0x8(%esi)
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  8083d0:	8b 73 10             	mov    0x10(%ebx),%esi
  8083d3:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  8083d7:	89 04 24             	mov    %eax,(%esp)
  8083da:	e8 a3 f3 ff ff       	call   807782 <htons>
  8083df:	66 89 46 0e          	mov    %ax,0xe(%esi)
  if (ip_addr_isany(&(pcb->local_ip))) {
  8083e3:	83 c4 10             	add    $0x10,%esp
  8083e6:	85 ff                	test   %edi,%edi
  8083e8:	74 05                	je     8083ef <tcp_output+0x2ed>
  8083ea:	83 3f 00             	cmpl   $0x0,(%edi)
  8083ed:	75 25                	jne    808414 <tcp_output+0x312>
    netif = ip_route(&(pcb->remote_ip));
  8083ef:	83 ec 0c             	sub    $0xc,%esp
  8083f2:	ff 75 e4             	pushl  -0x1c(%ebp)
  8083f5:	e8 83 e1 ff ff       	call   80657d <ip_route>
    if (netif == NULL) {
  8083fa:	83 c4 10             	add    $0x10,%esp
  8083fd:	85 c0                	test   %eax,%eax
  8083ff:	0f 84 86 00 00 00    	je     80848b <tcp_output+0x389>
    ip_addr_set(&(pcb->local_ip), &(netif->ip_addr));
  808405:	ba 00 00 00 00       	mov    $0x0,%edx
  80840a:	83 f8 fc             	cmp    $0xfffffffc,%eax
  80840d:	74 03                	je     808412 <tcp_output+0x310>
  80840f:	8b 50 04             	mov    0x4(%eax),%edx
  808412:	89 17                	mov    %edx,(%edi)
  if(pcb->rtime == -1)
  808414:	66 83 7f 32 ff       	cmpw   $0xffff,0x32(%edi)
  808419:	0f 84 ac fe ff ff    	je     8082cb <tcp_output+0x1c9>
  if (pcb->rttest == 0) {
  80841f:	83 7f 38 00          	cmpl   $0x0,0x38(%edi)
  808423:	0f 84 ad fe ff ff    	je     8082d6 <tcp_output+0x1d4>
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
  808429:	8b 53 04             	mov    0x4(%ebx),%edx
  80842c:	8b 43 10             	mov    0x10(%ebx),%eax
  80842f:	2b 42 04             	sub    0x4(%edx),%eax

  seg->p->len -= len;
  808432:	66 29 42 0a          	sub    %ax,0xa(%edx)
  seg->p->tot_len -= len;
  808436:	8b 53 04             	mov    0x4(%ebx),%edx
  808439:	66 29 42 08          	sub    %ax,0x8(%edx)

  seg->p->payload = seg->tcphdr;
  80843d:	8b 43 04             	mov    0x4(%ebx),%eax
  808440:	8b 53 10             	mov    0x10(%ebx),%edx
  808443:	89 50 04             	mov    %edx,0x4(%eax)

  seg->tcphdr->chksum = 0;
  808446:	8b 43 10             	mov    0x10(%ebx),%eax
  808449:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
             &(pcb->local_ip),
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len);
  80844f:	8b 43 04             	mov    0x4(%ebx),%eax
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  808452:	8b 73 10             	mov    0x10(%ebx),%esi
  808455:	83 ec 0c             	sub    $0xc,%esp
  808458:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  80845c:	52                   	push   %edx
  80845d:	6a 06                	push   $0x6
  80845f:	ff 75 e4             	pushl  -0x1c(%ebp)
  808462:	57                   	push   %edi
  808463:	50                   	push   %eax
  808464:	e8 ff ef ff ff       	call   807468 <inet_chksum_pseudo>
  808469:	66 89 46 10          	mov    %ax,0x10(%esi)
                   pcb->tos, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  80846d:	83 c4 18             	add    $0x18,%esp
  808470:	6a 06                	push   $0x6
  808472:	0f b6 47 0a          	movzbl 0xa(%edi),%eax
  808476:	50                   	push   %eax
  808477:	0f b6 47 0b          	movzbl 0xb(%edi),%eax
  80847b:	50                   	push   %eax
  80847c:	ff 75 e4             	pushl  -0x1c(%ebp)
  80847f:	57                   	push   %edi
  808480:	ff 73 04             	pushl  0x4(%ebx)
  808483:	e8 f7 e5 ff ff       	call   806a7f <ip_output>
  808488:	83 c4 20             	add    $0x20,%esp
    pcb->snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
  80848b:	83 ec 0c             	sub    $0xc,%esp
  80848e:	8b 43 10             	mov    0x10(%ebx),%eax
  808491:	ff 70 04             	pushl  0x4(%eax)
  808494:	e8 21 f5 ff ff       	call   8079ba <ntohl>
  808499:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80849c:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  8084a0:	8b 43 10             	mov    0x10(%ebx),%eax
  8084a3:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8084a7:	89 04 24             	mov    %eax,(%esp)
  8084aa:	e8 e0 f2 ff ff       	call   80778f <ntohs>
  8084af:	83 c4 10             	add    $0x10,%esp
  8084b2:	ba 01 00 00 00       	mov    $0x1,%edx
  8084b7:	a8 01                	test   $0x1,%al
  8084b9:	0f 84 38 fe ff ff    	je     8082f7 <tcp_output+0x1f5>
  8084bf:	01 d6                	add    %edx,%esi
  8084c1:	03 75 e0             	add    -0x20(%ebp),%esi
  8084c4:	89 77 54             	mov    %esi,0x54(%edi)
    if (TCP_SEQ_LT(pcb->snd_max, pcb->snd_nxt)) {
  8084c7:	39 77 58             	cmp    %esi,0x58(%edi)
  8084ca:	0f 88 47 fe ff ff    	js     808317 <tcp_output+0x215>
    if (TCP_TCPLEN(seg) > 0) {
  8084d0:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  8084d4:	83 ec 0c             	sub    $0xc,%esp
  8084d7:	8b 43 10             	mov    0x10(%ebx),%eax
  8084da:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8084de:	50                   	push   %eax
  8084df:	e8 ab f2 ff ff       	call   80778f <ntohs>
  8084e4:	83 c4 10             	add    $0x10,%esp
  8084e7:	ba 01 00 00 00       	mov    $0x1,%edx
  8084ec:	a8 01                	test   $0x1,%al
  8084ee:	0f 84 2b fe ff ff    	je     80831f <tcp_output+0x21d>
  8084f4:	01 d6                	add    %edx,%esi
  8084f6:	74 52                	je     80854a <tcp_output+0x448>
      seg->next = NULL;
  8084f8:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
      if (pcb->unacked == NULL) {
  8084fe:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  808502:	0f 84 37 fe ff ff    	je     80833f <tcp_output+0x23d>
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))){
  808508:	83 ec 0c             	sub    $0xc,%esp
  80850b:	8b 43 10             	mov    0x10(%ebx),%eax
  80850e:	ff 70 04             	pushl  0x4(%eax)
  808511:	e8 a4 f4 ff ff       	call   8079ba <ntohl>
  808516:	89 c6                	mov    %eax,%esi
  808518:	83 c4 04             	add    $0x4,%esp
  80851b:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80851e:	8b 40 10             	mov    0x10(%eax),%eax
  808521:	ff 70 04             	pushl  0x4(%eax)
  808524:	e8 91 f4 ff ff       	call   8079ba <ntohl>
  808529:	83 c4 10             	add    $0x10,%esp
  80852c:	39 c6                	cmp    %eax,%esi
  80852e:	78 0d                	js     80853d <tcp_output+0x43b>
          useg->next = seg;
  808530:	8b 45 dc             	mov    -0x24(%ebp),%eax
  808533:	89 18                	mov    %ebx,(%eax)
  808535:	89 5d dc             	mov    %ebx,-0x24(%ebp)
  808538:	e9 08 fe ff ff       	jmp    808345 <tcp_output+0x243>
          seg->next = pcb->unacked;
  80853d:	8b 47 78             	mov    0x78(%edi),%eax
  808540:	89 03                	mov    %eax,(%ebx)
          pcb->unacked = seg;
  808542:	89 5f 78             	mov    %ebx,0x78(%edi)
  808545:	e9 fb fd ff ff       	jmp    808345 <tcp_output+0x243>
      tcp_seg_free(seg);
  80854a:	83 ec 0c             	sub    $0xc,%esp
  80854d:	53                   	push   %ebx
  80854e:	e8 6a d2 ff ff       	call   8057bd <tcp_seg_free>
  808553:	83 c4 10             	add    $0x10,%esp
  808556:	e9 ea fd ff ff       	jmp    808345 <tcp_output+0x243>
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  80855b:	8d 47 04             	lea    0x4(%edi),%eax
  80855e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  808561:	e9 e2 fd ff ff       	jmp    808348 <tcp_output+0x246>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
  808566:	83 ec 0c             	sub    $0xc,%esp
  808569:	8b 43 10             	mov    0x10(%ebx),%eax
  80856c:	ff 70 04             	pushl  0x4(%eax)
  80856f:	e8 46 f4 ff ff       	call   8079ba <ntohl>
  808574:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  808578:	2b 57 48             	sub    0x48(%edi),%edx
  80857b:	01 d0                	add    %edx,%eax
  80857d:	0f b7 57 5c          	movzwl 0x5c(%edi),%edx
  if (seg != NULL && pcb->persist_backoff == 0 && 
  808581:	83 c4 10             	add    $0x10,%esp
  808584:	39 d0                	cmp    %edx,%eax
  808586:	76 2a                	jbe    8085b2 <tcp_output+0x4b0>
    pcb->persist_cnt = 0;
  808588:	c7 87 a0 00 00 00 00 	movl   $0x0,0xa0(%edi)
  80858f:	00 00 00 
    pcb->persist_backoff = 1;
  808592:	c6 87 a4 00 00 00 01 	movb   $0x1,0xa4(%edi)
  808599:	eb 17                	jmp    8085b2 <tcp_output+0x4b0>
    return ERR_OK;
  80859b:	b8 00 00 00 00       	mov    $0x0,%eax
  8085a0:	eb 19                	jmp    8085bb <tcp_output+0x4b9>
      return ERR_BUF;
  8085a2:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  8085a7:	eb 12                	jmp    8085bb <tcp_output+0x4b9>
  if (seg != NULL && pcb->persist_backoff == 0 && 
  8085a9:	80 bf a4 00 00 00 00 	cmpb   $0x0,0xa4(%edi)
  8085b0:	74 b4                	je     808566 <tcp_output+0x464>
  pcb->flags &= ~TF_NAGLEMEMERR;
  8085b2:	80 67 20 7f          	andb   $0x7f,0x20(%edi)
  return ERR_OK;
  8085b6:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8085bb:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8085be:	5b                   	pop    %ebx
  8085bf:	5e                   	pop    %esi
  8085c0:	5f                   	pop    %edi
  8085c1:	5d                   	pop    %ebp
  8085c2:	c3                   	ret    

008085c3 <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  struct ip_addr *local_ip, struct ip_addr *remote_ip,
  u16_t local_port, u16_t remote_port)
{
  8085c3:	55                   	push   %ebp
  8085c4:	89 e5                	mov    %esp,%ebp
  8085c6:	57                   	push   %edi
  8085c7:	56                   	push   %esi
  8085c8:	53                   	push   %ebx
  8085c9:	83 ec 20             	sub    $0x20,%esp
  8085cc:	8b 7d 18             	mov    0x18(%ebp),%edi
  8085cf:	8b 45 1c             	mov    0x1c(%ebp),%eax
  8085d2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  8085d5:	6a 00                	push   $0x0
  8085d7:	6a 14                	push   $0x14
  8085d9:	6a 01                	push   $0x1
  8085db:	e8 33 c3 ff ff       	call   804913 <pbuf_alloc>
  if (p == NULL) {
  8085e0:	83 c4 10             	add    $0x10,%esp
  8085e3:	85 c0                	test   %eax,%eax
  8085e5:	0f 84 e2 00 00 00    	je     8086cd <tcp_rst+0x10a>
  8085eb:	89 c6                	mov    %eax,%esi
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  8085ed:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  8085f2:	0f 86 dd 00 00 00    	jbe    8086d5 <tcp_rst+0x112>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  8085f8:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(local_port);
  8085fb:	83 ec 0c             	sub    $0xc,%esp
  8085fe:	0f b7 ff             	movzwl %di,%edi
  808601:	57                   	push   %edi
  808602:	e8 7b f1 ff ff       	call   807782 <htons>
  808607:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(remote_port);
  80860a:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80860e:	89 04 24             	mov    %eax,(%esp)
  808611:	e8 6c f1 ff ff       	call   807782 <htons>
  808616:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(seqno);
  80861a:	83 c4 04             	add    $0x4,%esp
  80861d:	ff 75 08             	pushl  0x8(%ebp)
  808620:	e8 77 f1 ff ff       	call   80779c <htonl>
  808625:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(ackno);
  808628:	83 c4 04             	add    $0x4,%esp
  80862b:	ff 75 0c             	pushl  0xc(%ebp)
  80862e:	e8 69 f1 ff ff       	call   80779c <htonl>
  808633:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, TCP_RST | TCP_ACK);
  808636:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80863a:	89 04 24             	mov    %eax,(%esp)
  80863d:	e8 4d f1 ff ff       	call   80778f <ntohs>
  808642:	25 c0 ff 00 00       	and    $0xffc0,%eax
  808647:	83 c8 14             	or     $0x14,%eax
  80864a:	89 04 24             	mov    %eax,(%esp)
  80864d:	e8 30 f1 ff ff       	call   807782 <htons>
  808652:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(TCP_WND);
  808656:	c7 04 24 c0 5d 00 00 	movl   $0x5dc0,(%esp)
  80865d:	e8 20 f1 ff ff       	call   807782 <htons>
  808662:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  808666:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  80866c:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808670:	89 04 24             	mov    %eax,(%esp)
  808673:	e8 17 f1 ff ff       	call   80778f <ntohs>
  808678:	83 e0 3f             	and    $0x3f,%eax
  80867b:	80 cc 50             	or     $0x50,%ah
  80867e:	89 04 24             	mov    %eax,(%esp)
  808681:	e8 fc f0 ff ff       	call   807782 <htons>
  808686:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  80868a:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
  808690:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  808694:	89 04 24             	mov    %eax,(%esp)
  808697:	6a 06                	push   $0x6
  808699:	ff 75 14             	pushl  0x14(%ebp)
  80869c:	ff 75 10             	pushl  0x10(%ebp)
  80869f:	56                   	push   %esi
  8086a0:	e8 c3 ed ff ff       	call   807468 <inet_chksum_pseudo>
  8086a5:	66 89 43 10          	mov    %ax,0x10(%ebx)
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  8086a9:	83 c4 18             	add    $0x18,%esp
  8086ac:	6a 06                	push   $0x6
  8086ae:	6a 00                	push   $0x0
  8086b0:	68 ff 00 00 00       	push   $0xff
  8086b5:	ff 75 14             	pushl  0x14(%ebp)
  8086b8:	ff 75 10             	pushl  0x10(%ebp)
  8086bb:	56                   	push   %esi
  8086bc:	e8 be e3 ff ff       	call   806a7f <ip_output>
  pbuf_free(p);
  8086c1:	83 c4 14             	add    $0x14,%esp
  8086c4:	56                   	push   %esi
  8086c5:	e8 83 c1 ff ff       	call   80484d <pbuf_free>
  8086ca:	83 c4 10             	add    $0x10,%esp
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
  8086cd:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8086d0:	5b                   	pop    %ebx
  8086d1:	5e                   	pop    %esi
  8086d2:	5f                   	pop    %edi
  8086d3:	5d                   	pop    %ebp
  8086d4:	c3                   	ret    
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  8086d5:	83 ec 04             	sub    $0x4,%esp
  8086d8:	68 d4 22 81 00       	push   $0x8122d4
  8086dd:	68 be 02 00 00       	push   $0x2be
  8086e2:	68 02 23 81 00       	push   $0x812302
  8086e7:	e8 67 5f 00 00       	call   80e653 <_panic>

008086ec <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  8086ec:	55                   	push   %ebp
  8086ed:	89 e5                	mov    %esp,%ebp
  8086ef:	53                   	push   %ebx
  8086f0:	83 ec 04             	sub    $0x4,%esp
  8086f3:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  8086f6:	8b 53 78             	mov    0x78(%ebx),%edx
  8086f9:	85 d2                	test   %edx,%edx
  8086fb:	75 04                	jne    808701 <tcp_rexmit_rto+0x15>
  8086fd:	eb 41                	jmp    808740 <tcp_rexmit_rto+0x54>
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
  8086ff:	89 c2                	mov    %eax,%edx
  808701:	8b 02                	mov    (%edx),%eax
  808703:	85 c0                	test   %eax,%eax
  808705:	75 f8                	jne    8086ff <tcp_rexmit_rto+0x13>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
  808707:	8b 43 74             	mov    0x74(%ebx),%eax
  80870a:	89 02                	mov    %eax,(%edx)
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
  80870c:	8b 43 78             	mov    0x78(%ebx),%eax
  80870f:	89 43 74             	mov    %eax,0x74(%ebx)
  /* unacked queue is now empty */
  pcb->unacked = NULL;
  808712:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  808719:	83 ec 0c             	sub    $0xc,%esp
  80871c:	8b 40 10             	mov    0x10(%eax),%eax
  80871f:	ff 70 04             	pushl  0x4(%eax)
  808722:	e8 93 f2 ff ff       	call   8079ba <ntohl>
  808727:	89 43 54             	mov    %eax,0x54(%ebx)
  /* increment number of retransmissions */
  ++pcb->nrtx;
  80872a:	80 43 46 01          	addb   $0x1,0x46(%ebx)

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
  80872e:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission */
  tcp_output(pcb);
  808735:	89 1c 24             	mov    %ebx,(%esp)
  808738:	e8 c5 f9 ff ff       	call   808102 <tcp_output>
  80873d:	83 c4 10             	add    $0x10,%esp
}
  808740:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  808743:	c9                   	leave  
  808744:	c3                   	ret    

00808745 <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
  808745:	55                   	push   %ebp
  808746:	89 e5                	mov    %esp,%ebp
  808748:	53                   	push   %ebx
  808749:	83 ec 04             	sub    $0x4,%esp
  80874c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  80874f:	8b 43 78             	mov    0x78(%ebx),%eax
  808752:	85 c0                	test   %eax,%eax
  808754:	74 37                	je     80878d <tcp_rexmit+0x48>
    return;
  }

  /* Move the first unacked segment to the unsent queue */
  seg = pcb->unacked->next;
  808756:	8b 10                	mov    (%eax),%edx
  pcb->unacked->next = pcb->unsent;
  808758:	8b 4b 74             	mov    0x74(%ebx),%ecx
  80875b:	89 08                	mov    %ecx,(%eax)
  pcb->unsent = pcb->unacked;
  80875d:	8b 43 78             	mov    0x78(%ebx),%eax
  808760:	89 43 74             	mov    %eax,0x74(%ebx)
  pcb->unacked = seg;
  808763:	89 53 78             	mov    %edx,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  808766:	83 ec 0c             	sub    $0xc,%esp
  808769:	8b 40 10             	mov    0x10(%eax),%eax
  80876c:	ff 70 04             	pushl  0x4(%eax)
  80876f:	e8 46 f2 ff ff       	call   8079ba <ntohl>
  808774:	89 43 54             	mov    %eax,0x54(%ebx)

  ++pcb->nrtx;
  808777:	80 43 46 01          	addb   $0x1,0x46(%ebx)

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
  80877b:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission. */
  snmp_inc_tcpretranssegs();
  tcp_output(pcb);
  808782:	89 1c 24             	mov    %ebx,(%esp)
  808785:	e8 78 f9 ff ff       	call   808102 <tcp_output>
  80878a:	83 c4 10             	add    $0x10,%esp
}
  80878d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  808790:	c9                   	leave  
  808791:	c3                   	ret    

00808792 <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
  808792:	55                   	push   %ebp
  808793:	89 e5                	mov    %esp,%ebp
  808795:	57                   	push   %edi
  808796:	56                   	push   %esi
  808797:	53                   	push   %ebx
  808798:	83 ec 20             	sub    $0x20,%esp
  80879b:	8b 75 08             	mov    0x8(%ebp),%esi
                          ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  80879e:	6a 00                	push   $0x0
  8087a0:	6a 14                	push   $0x14
  8087a2:	6a 01                	push   $0x1
  8087a4:	e8 6a c1 ff ff       	call   804913 <pbuf_alloc>
   
  if(p == NULL) {
  8087a9:	83 c4 10             	add    $0x10,%esp
  8087ac:	85 c0                	test   %eax,%eax
  8087ae:	0f 84 e5 00 00 00    	je     808899 <tcp_keepalive+0x107>
  8087b4:	89 c7                	mov    %eax,%edi
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  8087b6:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  8087bb:	0f 86 e0 00 00 00    	jbe    8088a1 <tcp_keepalive+0x10f>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  8087c1:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  8087c4:	83 ec 0c             	sub    $0xc,%esp
  8087c7:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  8087cb:	50                   	push   %eax
  8087cc:	e8 b1 ef ff ff       	call   807782 <htons>
  8087d1:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  8087d4:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  8087d8:	89 04 24             	mov    %eax,(%esp)
  8087db:	e8 a2 ef ff ff       	call   807782 <htons>
  8087e0:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(pcb->snd_nxt - 1);
  8087e4:	8b 46 54             	mov    0x54(%esi),%eax
  8087e7:	83 e8 01             	sub    $0x1,%eax
  8087ea:	89 04 24             	mov    %eax,(%esp)
  8087ed:	e8 aa ef ff ff       	call   80779c <htonl>
  8087f2:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  8087f5:	83 c4 04             	add    $0x4,%esp
  8087f8:	ff 76 24             	pushl  0x24(%esi)
  8087fb:	e8 9c ef ff ff       	call   80779c <htonl>
  808800:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  808803:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808807:	89 04 24             	mov    %eax,(%esp)
  80880a:	e8 80 ef ff ff       	call   80778f <ntohs>
  80880f:	25 c0 ff 00 00       	and    $0xffc0,%eax
  808814:	89 04 24             	mov    %eax,(%esp)
  808817:	e8 66 ef ff ff       	call   807782 <htons>
  80881c:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  808820:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  808824:	89 04 24             	mov    %eax,(%esp)
  808827:	e8 56 ef ff ff       	call   807782 <htons>
  80882c:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  808830:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  808836:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80883a:	89 04 24             	mov    %eax,(%esp)
  80883d:	e8 4d ef ff ff       	call   80778f <ntohs>
  808842:	83 e0 3f             	and    $0x3f,%eax
  808845:	80 cc 50             	or     $0x50,%ah
  808848:	89 04 24             	mov    %eax,(%esp)
  80884b:	e8 32 ef ff ff       	call   807782 <htons>
  808850:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  808854:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  80885a:	8d 46 04             	lea    0x4(%esi),%eax
  80885d:	89 c2                	mov    %eax,%edx
  80885f:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  808863:	89 04 24             	mov    %eax,(%esp)
  808866:	6a 06                	push   $0x6
  808868:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  80886b:	52                   	push   %edx
  80886c:	56                   	push   %esi
  80886d:	57                   	push   %edi
  80886e:	e8 f5 eb ff ff       	call   807468 <inet_chksum_pseudo>
  808873:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  808877:	83 c4 18             	add    $0x18,%esp
  80887a:	6a 06                	push   $0x6
  80887c:	6a 00                	push   $0x0
  80887e:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  808882:	50                   	push   %eax
  808883:	ff 75 e4             	pushl  -0x1c(%ebp)
  808886:	56                   	push   %esi
  808887:	57                   	push   %edi
  808888:	e8 f2 e1 ff ff       	call   806a7f <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  80888d:	83 c4 14             	add    $0x14,%esp
  808890:	57                   	push   %edi
  808891:	e8 b7 bf ff ff       	call   80484d <pbuf_free>
  808896:	83 c4 10             	add    $0x10,%esp

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  808899:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80889c:	5b                   	pop    %ebx
  80889d:	5e                   	pop    %esi
  80889e:	5f                   	pop    %edi
  80889f:	5d                   	pop    %ebp
  8088a0:	c3                   	ret    
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  8088a1:	83 ec 04             	sub    $0x4,%esp
  8088a4:	68 d4 22 81 00       	push   $0x8122d4
  8088a9:	68 3a 03 00 00       	push   $0x33a
  8088ae:	68 02 23 81 00       	push   $0x812302
  8088b3:	e8 9b 5d 00 00       	call   80e653 <_panic>

008088b8 <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
  8088b8:	55                   	push   %ebp
  8088b9:	89 e5                	mov    %esp,%ebp
  8088bb:	57                   	push   %edi
  8088bc:	56                   	push   %esi
  8088bd:	53                   	push   %ebx
  8088be:	83 ec 0c             	sub    $0xc,%esp
  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
  8088c1:	8b 45 08             	mov    0x8(%ebp),%eax
  8088c4:	8b 78 78             	mov    0x78(%eax),%edi

  if(seg == NULL)
  8088c7:	85 ff                	test   %edi,%edi
  8088c9:	0f 84 19 01 00 00    	je     8089e8 <tcp_zero_window_probe+0x130>
    seg = pcb->unsent;

  if(seg == NULL)
    return;

  p = pbuf_alloc(PBUF_IP, TCP_HLEN + 1, PBUF_RAM);
  8088cf:	83 ec 04             	sub    $0x4,%esp
  8088d2:	6a 00                	push   $0x0
  8088d4:	6a 15                	push   $0x15
  8088d6:	6a 01                	push   $0x1
  8088d8:	e8 36 c0 ff ff       	call   804913 <pbuf_alloc>
  8088dd:	89 c6                	mov    %eax,%esi
   
  if(p == NULL) {
  8088df:	83 c4 10             	add    $0x10,%esp
  8088e2:	85 c0                	test   %eax,%eax
  8088e4:	0f 84 f6 00 00 00    	je     8089e0 <tcp_zero_window_probe+0x128>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  8088ea:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  8088ef:	0f 86 ff 00 00 00    	jbe    8089f4 <tcp_zero_window_probe+0x13c>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  8088f5:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  8088f8:	83 ec 0c             	sub    $0xc,%esp
  8088fb:	8b 45 08             	mov    0x8(%ebp),%eax
  8088fe:	0f b7 40 1c          	movzwl 0x1c(%eax),%eax
  808902:	50                   	push   %eax
  808903:	e8 7a ee ff ff       	call   807782 <htons>
  808908:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  80890b:	8b 45 08             	mov    0x8(%ebp),%eax
  80890e:	0f b7 40 1e          	movzwl 0x1e(%eax),%eax
  808912:	89 04 24             	mov    %eax,(%esp)
  808915:	e8 68 ee ff ff       	call   807782 <htons>
  80891a:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = seg->tcphdr->seqno;
  80891e:	8b 47 10             	mov    0x10(%edi),%eax
  808921:	8b 40 04             	mov    0x4(%eax),%eax
  808924:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  808927:	83 c4 04             	add    $0x4,%esp
  80892a:	8b 45 08             	mov    0x8(%ebp),%eax
  80892d:	ff 70 24             	pushl  0x24(%eax)
  808930:	e8 67 ee ff ff       	call   80779c <htonl>
  808935:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  808938:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80893c:	89 04 24             	mov    %eax,(%esp)
  80893f:	e8 4b ee ff ff       	call   80778f <ntohs>
  808944:	25 c0 ff 00 00       	and    $0xffc0,%eax
  808949:	89 04 24             	mov    %eax,(%esp)
  80894c:	e8 31 ee ff ff       	call   807782 <htons>
  808951:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  808955:	8b 45 08             	mov    0x8(%ebp),%eax
  808958:	0f b7 40 2a          	movzwl 0x2a(%eax),%eax
  80895c:	89 04 24             	mov    %eax,(%esp)
  80895f:	e8 1e ee ff ff       	call   807782 <htons>
  808964:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  808968:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  80896e:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808972:	89 04 24             	mov    %eax,(%esp)
  808975:	e8 15 ee ff ff       	call   80778f <ntohs>
  80897a:	83 e0 3f             	and    $0x3f,%eax
  80897d:	80 cc 50             	or     $0x50,%ah
  808980:	89 04 24             	mov    %eax,(%esp)
  808983:	e8 fa ed ff ff       	call   807782 <htons>
  808988:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  /* Copy in one byte from the head of the unacked queue */
  *((char *)p->payload + sizeof(struct tcp_hdr)) = *(char *)seg->dataptr;
  80898c:	8b 46 04             	mov    0x4(%esi),%eax
  80898f:	8b 57 08             	mov    0x8(%edi),%edx
  808992:	0f b6 12             	movzbl (%edx),%edx
  808995:	88 50 14             	mov    %dl,0x14(%eax)

  tcphdr->chksum = 0;
  808998:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  80899e:	8b 45 08             	mov    0x8(%ebp),%eax
  8089a1:	8d 78 04             	lea    0x4(%eax),%edi
  8089a4:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  8089a8:	89 04 24             	mov    %eax,(%esp)
  8089ab:	6a 06                	push   $0x6
  8089ad:	57                   	push   %edi
  8089ae:	ff 75 08             	pushl  0x8(%ebp)
  8089b1:	56                   	push   %esi
  8089b2:	e8 b1 ea ff ff       	call   807468 <inet_chksum_pseudo>
  8089b7:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  8089bb:	83 c4 18             	add    $0x18,%esp
  8089be:	6a 06                	push   $0x6
  8089c0:	6a 00                	push   $0x0
  8089c2:	8b 45 08             	mov    0x8(%ebp),%eax
  8089c5:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
  8089c9:	50                   	push   %eax
  8089ca:	57                   	push   %edi
  8089cb:	ff 75 08             	pushl  0x8(%ebp)
  8089ce:	56                   	push   %esi
  8089cf:	e8 ab e0 ff ff       	call   806a7f <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  8089d4:	83 c4 14             	add    $0x14,%esp
  8089d7:	56                   	push   %esi
  8089d8:	e8 70 be ff ff       	call   80484d <pbuf_free>
  8089dd:	83 c4 10             	add    $0x10,%esp

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  8089e0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8089e3:	5b                   	pop    %ebx
  8089e4:	5e                   	pop    %esi
  8089e5:	5f                   	pop    %edi
  8089e6:	5d                   	pop    %ebp
  8089e7:	c3                   	ret    
    seg = pcb->unsent;
  8089e8:	8b 78 74             	mov    0x74(%eax),%edi
  if(seg == NULL)
  8089eb:	85 ff                	test   %edi,%edi
  8089ed:	74 f1                	je     8089e0 <tcp_zero_window_probe+0x128>
  8089ef:	e9 db fe ff ff       	jmp    8088cf <tcp_zero_window_probe+0x17>
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  8089f4:	83 ec 04             	sub    $0x4,%esp
  8089f7:	68 d4 22 81 00       	push   $0x8122d4
  8089fc:	68 8d 03 00 00       	push   $0x38d
  808a01:	68 02 23 81 00       	push   $0x812302
  808a06:	e8 48 5c 00 00       	call   80e653 <_panic>

00808a0b <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
  808a0b:	55                   	push   %ebp
  808a0c:	89 e5                	mov    %esp,%ebp
  808a0e:	57                   	push   %edi
  808a0f:	56                   	push   %esi
  808a10:	53                   	push   %ebx
  808a11:	83 ec 38             	sub    $0x38,%esp
  808a14:	8b 75 08             	mov    0x8(%ebp),%esi

  PERF_START;

  UDP_STATS_INC(udp.recv);

  iphdr = p->payload;
  808a17:	8b 7e 04             	mov    0x4(%esi),%edi

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
  808a1a:	0f b7 5e 08          	movzwl 0x8(%esi),%ebx
  808a1e:	0f b7 07             	movzwl (%edi),%eax
  808a21:	50                   	push   %eax
  808a22:	e8 68 ed ff ff       	call   80778f <ntohs>
  808a27:	66 c1 e8 08          	shr    $0x8,%ax
  808a2b:	83 e0 0f             	and    $0xf,%eax
  808a2e:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
  808a35:	83 c4 10             	add    $0x10,%esp
  808a38:	39 c3                	cmp    %eax,%ebx
  808a3a:	7c 27                	jl     808a63 <udp_input+0x58>
  808a3c:	83 ec 0c             	sub    $0xc,%esp
  808a3f:	0f b7 07             	movzwl (%edi),%eax
  808a42:	50                   	push   %eax
  808a43:	e8 47 ed ff ff       	call   80778f <ntohs>
  808a48:	83 c4 08             	add    $0x8,%esp
  808a4b:	66 c1 e8 06          	shr    $0x6,%ax
  808a4f:	83 e0 3c             	and    $0x3c,%eax
  808a52:	f7 d8                	neg    %eax
  808a54:	98                   	cwtl   
  808a55:	50                   	push   %eax
  808a56:	56                   	push   %esi
  808a57:	e8 1d bd ff ff       	call   804779 <pbuf_header>
  808a5c:	83 c4 10             	add    $0x10,%esp
  808a5f:	84 c0                	test   %al,%al
  808a61:	74 14                	je     808a77 <udp_input+0x6c>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
    UDP_STATS_INC(udp.drop);
    snmp_inc_udpinerrors();
    pbuf_free(p);
  808a63:	83 ec 0c             	sub    $0xc,%esp
  808a66:	56                   	push   %esi
  808a67:	e8 e1 bd ff ff       	call   80484d <pbuf_free>
    goto end;
  808a6c:	83 c4 10             	add    $0x10,%esp
  } else {
    pbuf_free(p);
  }
end:
  PERF_STOP("udp_input");
}
  808a6f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808a72:	5b                   	pop    %ebx
  808a73:	5e                   	pop    %esi
  808a74:	5f                   	pop    %edi
  808a75:	5d                   	pop    %ebp
  808a76:	c3                   	ret    
  udphdr = (struct udp_hdr *)p->payload;
  808a77:	8b 5e 04             	mov    0x4(%esi),%ebx
  808a7a:	89 5d d8             	mov    %ebx,-0x28(%ebp)
  src = ntohs(udphdr->src);
  808a7d:	83 ec 0c             	sub    $0xc,%esp
  808a80:	0f b7 03             	movzwl (%ebx),%eax
  808a83:	50                   	push   %eax
  808a84:	e8 06 ed ff ff       	call   80778f <ntohs>
  808a89:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
  dest = ntohs(udphdr->dest);
  808a8d:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  808a91:	89 04 24             	mov    %eax,(%esp)
  808a94:	e8 f6 ec ff ff       	call   80778f <ntohs>
  808a99:	89 c1                	mov    %eax,%ecx
  if (dest == DHCP_CLIENT_PORT) {
  808a9b:	83 c4 10             	add    $0x10,%esp
  808a9e:	66 83 f8 44          	cmp    $0x44,%ax
  808aa2:	74 24                	je     808ac8 <udp_input+0xbd>
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  808aa4:	8b 1d 54 b2 b3 00    	mov    0xb3b254,%ebx
    uncon_pcb = NULL;
  808aaa:	ba 00 00 00 00       	mov    $0x0,%edx
    prev = NULL;
  808aaf:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  808ab6:	8d 47 10             	lea    0x10(%edi),%eax
  808ab9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  808abc:	89 7d dc             	mov    %edi,-0x24(%ebp)
  808abf:	89 d7                	mov    %edx,%edi
  808ac1:	89 75 08             	mov    %esi,0x8(%ebp)
  808ac4:	89 ce                	mov    %ecx,%esi
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  808ac6:	eb 65                	jmp    808b2d <udp_input+0x122>
    if (src == DHCP_SERVER_PORT) {
  808ac8:	66 83 7d e2 43       	cmpw   $0x43,-0x1e(%ebp)
  808acd:	74 19                	je     808ae8 <udp_input+0xdd>
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
  808acf:	8b 45 0c             	mov    0xc(%ebp),%eax
  808ad2:	8b 57 10             	mov    0x10(%edi),%edx
  808ad5:	39 50 04             	cmp    %edx,0x4(%eax)
  808ad8:	0f 85 10 02 00 00    	jne    808cee <udp_input+0x2e3>
  808ade:	bb 00 00 00 00       	mov    $0x0,%ebx
  808ae3:	e9 cd 00 00 00       	jmp    808bb5 <udp_input+0x1aa>
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
  808ae8:	8b 45 0c             	mov    0xc(%ebp),%eax
  808aeb:	8b 40 20             	mov    0x20(%eax),%eax
  808aee:	85 c0                	test   %eax,%eax
  808af0:	74 dd                	je     808acf <udp_input+0xc4>
  808af2:	8b 40 08             	mov    0x8(%eax),%eax
  808af5:	89 c3                	mov    %eax,%ebx
  808af7:	85 c0                	test   %eax,%eax
  808af9:	74 d4                	je     808acf <udp_input+0xc4>
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
  808afb:	83 f8 fc             	cmp    $0xfffffffc,%eax
  808afe:	0f 84 b1 00 00 00    	je     808bb5 <udp_input+0x1aa>
  808b04:	8b 40 04             	mov    0x4(%eax),%eax
  808b07:	85 c0                	test   %eax,%eax
  808b09:	0f 84 a6 00 00 00    	je     808bb5 <udp_input+0x1aa>
  808b0f:	3b 47 0c             	cmp    0xc(%edi),%eax
  808b12:	75 bb                	jne    808acf <udp_input+0xc4>
  808b14:	e9 9c 00 00 00       	jmp    808bb5 <udp_input+0x1aa>
        if ((uncon_pcb == NULL) && 
  808b19:	85 ff                	test   %edi,%edi
  808b1b:	74 43                	je     808b60 <udp_input+0x155>
      if ((local_match != 0) &&
  808b1d:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  808b21:	66 3b 43 14          	cmp    0x14(%ebx),%ax
  808b25:	74 45                	je     808b6c <udp_input+0x161>
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  808b27:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  808b2a:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  808b2d:	85 db                	test   %ebx,%ebx
  808b2f:	74 72                	je     808ba3 <udp_input+0x198>
      if ((pcb->local_port == dest) &&
  808b31:	66 3b 73 12          	cmp    0x12(%ebx),%si
  808b35:	75 f0                	jne    808b27 <udp_input+0x11c>
  808b37:	85 db                	test   %ebx,%ebx
  808b39:	74 de                	je     808b19 <udp_input+0x10e>
          (ip_addr_isany(&pcb->local_ip) ||
  808b3b:	8b 03                	mov    (%ebx),%eax
  808b3d:	85 c0                	test   %eax,%eax
  808b3f:	74 d8                	je     808b19 <udp_input+0x10e>
  808b41:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  808b44:	3b 41 10             	cmp    0x10(%ecx),%eax
  808b47:	74 d0                	je     808b19 <udp_input+0x10e>
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  808b49:	83 ec 08             	sub    $0x8,%esp
  808b4c:	ff 75 0c             	pushl  0xc(%ebp)
  808b4f:	ff 75 d4             	pushl  -0x2c(%ebp)
  808b52:	e8 e6 d9 ff ff       	call   80653d <ip_addr_isbroadcast>
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
  808b57:	83 c4 10             	add    $0x10,%esp
  808b5a:	84 c0                	test   %al,%al
  808b5c:	74 c9                	je     808b27 <udp_input+0x11c>
  808b5e:	eb b9                	jmp    808b19 <udp_input+0x10e>
        if ((uncon_pcb == NULL) && 
  808b60:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  808b64:	83 e0 04             	and    $0x4,%eax
  808b67:	0f 44 fb             	cmove  %ebx,%edi
  808b6a:	eb b1                	jmp    808b1d <udp_input+0x112>
          (pcb->remote_port == src) &&
  808b6c:	83 fb fc             	cmp    $0xfffffffc,%ebx
  808b6f:	74 0f                	je     808b80 <udp_input+0x175>
          (ip_addr_isany(&pcb->remote_ip) ||
  808b71:	8b 43 04             	mov    0x4(%ebx),%eax
  808b74:	85 c0                	test   %eax,%eax
  808b76:	74 08                	je     808b80 <udp_input+0x175>
  808b78:	8b 55 dc             	mov    -0x24(%ebp),%edx
  808b7b:	3b 42 0c             	cmp    0xc(%edx),%eax
  808b7e:	75 a7                	jne    808b27 <udp_input+0x11c>
  808b80:	8b 7d dc             	mov    -0x24(%ebp),%edi
  808b83:	8b 75 08             	mov    0x8(%ebp),%esi
        if (prev != NULL) {
  808b86:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  808b89:	85 d2                	test   %edx,%edx
  808b8b:	74 28                	je     808bb5 <udp_input+0x1aa>
          prev->next = pcb->next;
  808b8d:	8b 43 0c             	mov    0xc(%ebx),%eax
  808b90:	89 42 0c             	mov    %eax,0xc(%edx)
          pcb->next = udp_pcbs;
  808b93:	a1 54 b2 b3 00       	mov    0xb3b254,%eax
  808b98:	89 43 0c             	mov    %eax,0xc(%ebx)
          udp_pcbs = pcb;
  808b9b:	89 1d 54 b2 b3 00    	mov    %ebx,0xb3b254
  808ba1:	eb 12                	jmp    808bb5 <udp_input+0x1aa>
  808ba3:	89 f8                	mov    %edi,%eax
  808ba5:	89 fb                	mov    %edi,%ebx
  808ba7:	8b 7d dc             	mov    -0x24(%ebp),%edi
  808baa:	8b 75 08             	mov    0x8(%ebp),%esi
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
  808bad:	85 c0                	test   %eax,%eax
  808baf:	0f 84 1a ff ff ff    	je     808acf <udp_input+0xc4>
      if (udphdr->chksum != 0) {
  808bb5:	8b 45 d8             	mov    -0x28(%ebp),%eax
  808bb8:	66 83 78 06 00       	cmpw   $0x0,0x6(%eax)
  808bbd:	74 20                	je     808bdf <udp_input+0x1d4>
        if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  808bbf:	83 ec 0c             	sub    $0xc,%esp
  808bc2:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  808bc6:	50                   	push   %eax
  808bc7:	6a 11                	push   $0x11
  808bc9:	8d 47 10             	lea    0x10(%edi),%eax
  808bcc:	50                   	push   %eax
  808bcd:	8d 47 0c             	lea    0xc(%edi),%eax
  808bd0:	50                   	push   %eax
  808bd1:	56                   	push   %esi
  808bd2:	e8 91 e8 ff ff       	call   807468 <inet_chksum_pseudo>
  808bd7:	83 c4 20             	add    $0x20,%esp
  808bda:	66 85 c0             	test   %ax,%ax
  808bdd:	75 38                	jne    808c17 <udp_input+0x20c>
    if(pbuf_header(p, -UDP_HLEN)) {
  808bdf:	83 ec 08             	sub    $0x8,%esp
  808be2:	6a f8                	push   $0xfffffff8
  808be4:	56                   	push   %esi
  808be5:	e8 8f bb ff ff       	call   804779 <pbuf_header>
  808bea:	83 c4 10             	add    $0x10,%esp
  808bed:	84 c0                	test   %al,%al
  808bef:	75 37                	jne    808c28 <udp_input+0x21d>
    if (pcb != NULL) {
  808bf1:	85 db                	test   %ebx,%ebx
  808bf3:	74 5b                	je     808c50 <udp_input+0x245>
      if (pcb->recv != NULL) {
  808bf5:	8b 43 18             	mov    0x18(%ebx),%eax
  808bf8:	85 c0                	test   %eax,%eax
  808bfa:	74 43                	je     808c3f <udp_input+0x234>
        pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src), src);
  808bfc:	83 ec 0c             	sub    $0xc,%esp
  808bff:	0f b7 55 e2          	movzwl -0x1e(%ebp),%edx
  808c03:	52                   	push   %edx
  808c04:	83 c7 0c             	add    $0xc,%edi
  808c07:	57                   	push   %edi
  808c08:	56                   	push   %esi
  808c09:	53                   	push   %ebx
  808c0a:	ff 73 1c             	pushl  0x1c(%ebx)
  808c0d:	ff d0                	call   *%eax
  808c0f:	83 c4 20             	add    $0x20,%esp
  808c12:	e9 58 fe ff ff       	jmp    808a6f <udp_input+0x64>
          pbuf_free(p);
  808c17:	83 ec 0c             	sub    $0xc,%esp
  808c1a:	56                   	push   %esi
  808c1b:	e8 2d bc ff ff       	call   80484d <pbuf_free>
          goto end;
  808c20:	83 c4 10             	add    $0x10,%esp
  808c23:	e9 47 fe ff ff       	jmp    808a6f <udp_input+0x64>
      LWIP_ASSERT("pbuf_header failed\n", 0);
  808c28:	83 ec 04             	sub    $0x4,%esp
  808c2b:	68 27 23 81 00       	push   $0x812327
  808c30:	68 0a 01 00 00       	push   $0x10a
  808c35:	68 52 23 81 00       	push   $0x812352
  808c3a:	e8 14 5a 00 00       	call   80e653 <_panic>
        pbuf_free(p);
  808c3f:	83 ec 0c             	sub    $0xc,%esp
  808c42:	56                   	push   %esi
  808c43:	e8 05 bc ff ff       	call   80484d <pbuf_free>
        goto end;
  808c48:	83 c4 10             	add    $0x10,%esp
  808c4b:	e9 1f fe ff ff       	jmp    808a6f <udp_input+0x64>
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  808c50:	83 ec 08             	sub    $0x8,%esp
  808c53:	ff 75 0c             	pushl  0xc(%ebp)
  808c56:	8d 47 10             	lea    0x10(%edi),%eax
  808c59:	50                   	push   %eax
  808c5a:	e8 de d8 ff ff       	call   80653d <ip_addr_isbroadcast>
  808c5f:	83 c4 10             	add    $0x10,%esp
  808c62:	84 c0                	test   %al,%al
  808c64:	75 60                	jne    808cc6 <udp_input+0x2bb>
          !ip_addr_ismulticast(&iphdr->dest)) {
  808c66:	8b 5f 10             	mov    0x10(%edi),%ebx
  808c69:	83 ec 0c             	sub    $0xc,%esp
  808c6c:	68 00 00 00 f0       	push   $0xf0000000
  808c71:	e8 44 ed ff ff       	call   8079ba <ntohl>
  808c76:	21 c3                	and    %eax,%ebx
  808c78:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  808c7f:	e8 36 ed ff ff       	call   8079ba <ntohl>
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  808c84:	83 c4 10             	add    $0x10,%esp
  808c87:	39 c3                	cmp    %eax,%ebx
  808c89:	74 3b                	je     808cc6 <udp_input+0x2bb>
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
  808c8b:	83 ec 0c             	sub    $0xc,%esp
  808c8e:	0f b7 07             	movzwl (%edi),%eax
  808c91:	50                   	push   %eax
  808c92:	e8 f8 ea ff ff       	call   80778f <ntohs>
  808c97:	83 c4 08             	add    $0x8,%esp
  808c9a:	66 c1 e8 08          	shr    $0x8,%ax
  808c9e:	83 e0 0f             	and    $0xf,%eax
  808ca1:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
  808ca8:	98                   	cwtl   
  808ca9:	50                   	push   %eax
  808caa:	56                   	push   %esi
  808cab:	e8 c9 ba ff ff       	call   804779 <pbuf_header>
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
  808cb0:	83 c4 10             	add    $0x10,%esp
  808cb3:	3b 7e 04             	cmp    0x4(%esi),%edi
  808cb6:	75 1f                	jne    808cd7 <udp_input+0x2cc>
        icmp_dest_unreach(p, ICMP_DUR_PORT);
  808cb8:	83 ec 08             	sub    $0x8,%esp
  808cbb:	6a 03                	push   $0x3
  808cbd:	56                   	push   %esi
  808cbe:	e8 6a 57 00 00       	call   80e42d <icmp_dest_unreach>
  808cc3:	83 c4 10             	add    $0x10,%esp
      pbuf_free(p);
  808cc6:	83 ec 0c             	sub    $0xc,%esp
  808cc9:	56                   	push   %esi
  808cca:	e8 7e bb ff ff       	call   80484d <pbuf_free>
  808ccf:	83 c4 10             	add    $0x10,%esp
  808cd2:	e9 98 fd ff ff       	jmp    808a6f <udp_input+0x64>
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
  808cd7:	83 ec 04             	sub    $0x4,%esp
  808cda:	68 66 23 81 00       	push   $0x812366
  808cdf:	68 25 01 00 00       	push   $0x125
  808ce4:	68 52 23 81 00       	push   $0x812352
  808ce9:	e8 65 59 00 00       	call   80e653 <_panic>
    pbuf_free(p);
  808cee:	83 ec 0c             	sub    $0xc,%esp
  808cf1:	56                   	push   %esi
  808cf2:	e8 56 bb ff ff       	call   80484d <pbuf_free>
  808cf7:	83 c4 10             	add    $0x10,%esp
}
  808cfa:	e9 70 fd ff ff       	jmp    808a6f <udp_input+0x64>

00808cff <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  808cff:	55                   	push   %ebp
  808d00:	89 e5                	mov    %esp,%ebp
  808d02:	57                   	push   %edi
  808d03:	56                   	push   %esi
  808d04:	53                   	push   %ebx
  808d05:	83 ec 0c             	sub    $0xc,%esp
  808d08:	8b 55 08             	mov    0x8(%ebp),%edx
  808d0b:	8b 7d 10             	mov    0x10(%ebp),%edi
  808d0e:	89 f9                	mov    %edi,%ecx
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808d10:	a1 54 b2 b3 00       	mov    0xb3b254,%eax
  rebind = 0;
  808d15:	bb 00 00 00 00       	mov    $0x0,%ebx
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
      /* pcb already in list, just rebind */
      rebind = 1;
  808d1a:	be 01 00 00 00       	mov    $0x1,%esi
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808d1f:	eb 1a                	jmp    808d3b <udp_bind+0x3c>
      LWIP_ASSERT("rebind == 0", rebind == 0);
  808d21:	83 ec 04             	sub    $0x4,%esp
  808d24:	68 7a 23 81 00       	push   $0x81237a
  808d29:	68 41 02 00 00       	push   $0x241
  808d2e:	68 52 23 81 00       	push   $0x812352
  808d33:	e8 1b 59 00 00       	call   80e653 <_panic>
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808d38:	8b 40 0c             	mov    0xc(%eax),%eax
  808d3b:	85 c0                	test   %eax,%eax
  808d3d:	74 0c                	je     808d4b <udp_bind+0x4c>
    if (pcb == ipcb) {
  808d3f:	39 d0                	cmp    %edx,%eax
  808d41:	75 f5                	jne    808d38 <udp_bind+0x39>
      LWIP_ASSERT("rebind == 0", rebind == 0);
  808d43:	84 db                	test   %bl,%bl
  808d45:	75 da                	jne    808d21 <udp_bind+0x22>
      rebind = 1;
  808d47:	89 f3                	mov    %esi,%ebx
  808d49:	eb ed                	jmp    808d38 <udp_bind+0x39>
        return ERR_USE;
      }
#endif
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
  808d4b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  808d4f:	74 05                	je     808d56 <udp_bind+0x57>
  808d51:	8b 45 0c             	mov    0xc(%ebp),%eax
  808d54:	8b 00                	mov    (%eax),%eax
  808d56:	89 02                	mov    %eax,(%edx)

  /* no port specified? */
  if (port == 0) {
  808d58:	66 85 ff             	test   %di,%di
  808d5b:	75 2e                	jne    808d8b <udp_bind+0x8c>
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
  808d5d:	8b 35 54 b2 b3 00    	mov    0xb3b254,%esi
  808d63:	89 f0                	mov    %esi,%eax
    port = UDP_LOCAL_PORT_RANGE_START;
  808d65:	b9 00 10 00 00       	mov    $0x1000,%ecx
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  808d6a:	eb 05                	jmp    808d71 <udp_bind+0x72>
      if (ipcb->local_port == port) {
        /* port is already used by another udp_pcb */
        port++;
  808d6c:	83 c1 01             	add    $0x1,%ecx
        /* restart scanning all udp pcbs */
        ipcb = udp_pcbs;
  808d6f:	89 f0                	mov    %esi,%eax
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  808d71:	85 c0                	test   %eax,%eax
  808d73:	74 12                	je     808d87 <udp_bind+0x88>
  808d75:	66 81 f9 ff 7f       	cmp    $0x7fff,%cx
  808d7a:	74 0b                	je     808d87 <udp_bind+0x88>
      if (ipcb->local_port == port) {
  808d7c:	66 39 48 12          	cmp    %cx,0x12(%eax)
  808d80:	74 ea                	je     808d6c <udp_bind+0x6d>
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
  808d82:	8b 40 0c             	mov    0xc(%eax),%eax
  808d85:	eb ea                	jmp    808d71 <udp_bind+0x72>
    }
    if (ipcb != NULL) {
  808d87:	85 c0                	test   %eax,%eax
  808d89:	75 28                	jne    808db3 <udp_bind+0xb4>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
    }
  }
  pcb->local_port = port;
  808d8b:	66 89 4a 12          	mov    %cx,0x12(%edx)
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
  808d8f:	b8 00 00 00 00       	mov    $0x0,%eax
  if (rebind == 0) {
  808d94:	84 db                	test   %bl,%bl
  808d96:	75 13                	jne    808dab <udp_bind+0xac>
    pcb->next = udp_pcbs;
  808d98:	a1 54 b2 b3 00       	mov    0xb3b254,%eax
  808d9d:	89 42 0c             	mov    %eax,0xc(%edx)
    udp_pcbs = pcb;
  808da0:	89 15 54 b2 b3 00    	mov    %edx,0xb3b254
  return ERR_OK;
  808da6:	b8 00 00 00 00       	mov    $0x0,%eax
}
  808dab:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808dae:	5b                   	pop    %ebx
  808daf:	5e                   	pop    %esi
  808db0:	5f                   	pop    %edi
  808db1:	5d                   	pop    %ebp
  808db2:	c3                   	ret    
      return ERR_USE;
  808db3:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  808db8:	eb f1                	jmp    808dab <udp_bind+0xac>

00808dba <udp_sendto_if>:
{
  808dba:	55                   	push   %ebp
  808dbb:	89 e5                	mov    %esp,%ebp
  808dbd:	57                   	push   %edi
  808dbe:	56                   	push   %esi
  808dbf:	53                   	push   %ebx
  808dc0:	83 ec 1c             	sub    $0x1c,%esp
  808dc3:	8b 5d 08             	mov    0x8(%ebp),%ebx
  808dc6:	8b 45 14             	mov    0x14(%ebp),%eax
  808dc9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if (pcb->local_port == 0) {
  808dcc:	66 83 7b 12 00       	cmpw   $0x0,0x12(%ebx)
  808dd1:	75 19                	jne    808dec <udp_sendto_if+0x32>
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  808dd3:	83 ec 04             	sub    $0x4,%esp
  808dd6:	6a 00                	push   $0x0
  808dd8:	53                   	push   %ebx
  808dd9:	53                   	push   %ebx
  808dda:	e8 20 ff ff ff       	call   808cff <udp_bind>
  808ddf:	89 c7                	mov    %eax,%edi
    if (err != ERR_OK) {
  808de1:	83 c4 10             	add    $0x10,%esp
  808de4:	84 c0                	test   %al,%al
  808de6:	0f 85 be 00 00 00    	jne    808eaa <udp_sendto_if+0xf0>
  if (pbuf_header(p, UDP_HLEN)) {
  808dec:	83 ec 08             	sub    $0x8,%esp
  808def:	6a 08                	push   $0x8
  808df1:	ff 75 0c             	pushl  0xc(%ebp)
  808df4:	e8 80 b9 ff ff       	call   804779 <pbuf_header>
  808df9:	83 c4 10             	add    $0x10,%esp
    q = p;
  808dfc:	8b 75 0c             	mov    0xc(%ebp),%esi
  if (pbuf_header(p, UDP_HLEN)) {
  808dff:	84 c0                	test   %al,%al
  808e01:	0f 85 ad 00 00 00    	jne    808eb4 <udp_sendto_if+0xfa>
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
  808e07:	66 83 7e 0a 07       	cmpw   $0x7,0xa(%esi)
  808e0c:	0f 86 cd 00 00 00    	jbe    808edf <udp_sendto_if+0x125>
  udphdr = q->payload;
  808e12:	8b 7e 04             	mov    0x4(%esi),%edi
  udphdr->src = htons(pcb->local_port);
  808e15:	83 ec 0c             	sub    $0xc,%esp
  808e18:	0f b7 43 12          	movzwl 0x12(%ebx),%eax
  808e1c:	50                   	push   %eax
  808e1d:	e8 60 e9 ff ff       	call   807782 <htons>
  808e22:	66 89 07             	mov    %ax,(%edi)
  udphdr->dest = htons(dst_port);
  808e25:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  808e29:	89 04 24             	mov    %eax,(%esp)
  808e2c:	e8 51 e9 ff ff       	call   807782 <htons>
  808e31:	66 89 47 02          	mov    %ax,0x2(%edi)
  udphdr->chksum = 0x0000; 
  808e35:	66 c7 47 06 00 00    	movw   $0x0,0x6(%edi)
  if (ip_addr_isany(&pcb->local_ip)) {
  808e3b:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  808e3e:	83 c4 10             	add    $0x10,%esp
  808e41:	85 db                	test   %ebx,%ebx
  808e43:	74 0a                	je     808e4f <udp_sendto_if+0x95>
  808e45:	8b 03                	mov    (%ebx),%eax
  808e47:	85 c0                	test   %eax,%eax
  808e49:	0f 85 a7 00 00 00    	jne    808ef6 <udp_sendto_if+0x13c>
    src_ip = &(netif->ip_addr);
  808e4f:	8b 45 18             	mov    0x18(%ebp),%eax
  808e52:	83 c0 04             	add    $0x4,%eax
  808e55:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    udphdr->len = htons(q->tot_len);
  808e58:	83 ec 0c             	sub    $0xc,%esp
  808e5b:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  808e5f:	50                   	push   %eax
  808e60:	e8 1d e9 ff ff       	call   807782 <htons>
  808e65:	66 89 47 04          	mov    %ax,0x4(%edi)
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
  808e69:	83 c4 10             	add    $0x10,%esp
  808e6c:	f6 43 10 01          	testb  $0x1,0x10(%ebx)
  808e70:	0f 84 a4 00 00 00    	je     808f1a <udp_sendto_if+0x160>
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);    
  808e76:	83 ec 04             	sub    $0x4,%esp
  808e79:	ff 75 18             	pushl  0x18(%ebp)
  808e7c:	6a 11                	push   $0x11
  808e7e:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  808e82:	50                   	push   %eax
  808e83:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  808e87:	50                   	push   %eax
  808e88:	ff 75 10             	pushl  0x10(%ebp)
  808e8b:	ff 75 e4             	pushl  -0x1c(%ebp)
  808e8e:	56                   	push   %esi
  808e8f:	e8 5e da ff ff       	call   8068f2 <ip_output_if>
  808e94:	89 c7                	mov    %eax,%edi
  if (q != p) {
  808e96:	83 c4 20             	add    $0x20,%esp
  808e99:	3b 75 0c             	cmp    0xc(%ebp),%esi
  808e9c:	74 0c                	je     808eaa <udp_sendto_if+0xf0>
    pbuf_free(q);
  808e9e:	83 ec 0c             	sub    $0xc,%esp
  808ea1:	56                   	push   %esi
  808ea2:	e8 a6 b9 ff ff       	call   80484d <pbuf_free>
  808ea7:	83 c4 10             	add    $0x10,%esp
}
  808eaa:	89 f8                	mov    %edi,%eax
  808eac:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808eaf:	5b                   	pop    %ebx
  808eb0:	5e                   	pop    %esi
  808eb1:	5f                   	pop    %edi
  808eb2:	5d                   	pop    %ebp
  808eb3:	c3                   	ret    
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
  808eb4:	83 ec 04             	sub    $0x4,%esp
  808eb7:	6a 00                	push   $0x0
  808eb9:	6a 08                	push   $0x8
  808ebb:	6a 01                	push   $0x1
  808ebd:	e8 51 ba ff ff       	call   804913 <pbuf_alloc>
  808ec2:	89 c6                	mov    %eax,%esi
    if (q == NULL) {
  808ec4:	83 c4 10             	add    $0x10,%esp
  808ec7:	85 c0                	test   %eax,%eax
  808ec9:	74 7c                	je     808f47 <udp_sendto_if+0x18d>
    pbuf_chain(q, p);
  808ecb:	83 ec 08             	sub    $0x8,%esp
  808ece:	ff 75 0c             	pushl  0xc(%ebp)
  808ed1:	50                   	push   %eax
  808ed2:	e8 4e be ff ff       	call   804d25 <pbuf_chain>
  808ed7:	83 c4 10             	add    $0x10,%esp
  808eda:	e9 28 ff ff ff       	jmp    808e07 <udp_sendto_if+0x4d>
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
  808edf:	83 ec 04             	sub    $0x4,%esp
  808ee2:	68 88 23 81 00       	push   $0x812388
  808ee7:	68 b2 01 00 00       	push   $0x1b2
  808eec:	68 52 23 81 00       	push   $0x812352
  808ef1:	e8 5d 57 00 00       	call   80e653 <_panic>
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  808ef6:	8b 4d 18             	mov    0x18(%ebp),%ecx
  808ef9:	3b 41 04             	cmp    0x4(%ecx),%eax
  808efc:	0f 84 56 ff ff ff    	je     808e58 <udp_sendto_if+0x9e>
      return ERR_VAL;
  808f02:	bf f7 ff ff ff       	mov    $0xfffffff7,%edi
      if (q != p) {
  808f07:	3b 75 0c             	cmp    0xc(%ebp),%esi
  808f0a:	74 9e                	je     808eaa <udp_sendto_if+0xf0>
        pbuf_free(q);
  808f0c:	83 ec 0c             	sub    $0xc,%esp
  808f0f:	56                   	push   %esi
  808f10:	e8 38 b9 ff ff       	call   80484d <pbuf_free>
  808f15:	83 c4 10             	add    $0x10,%esp
  808f18:	eb 90                	jmp    808eaa <udp_sendto_if+0xf0>
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
  808f1a:	83 ec 0c             	sub    $0xc,%esp
  808f1d:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  808f21:	50                   	push   %eax
  808f22:	6a 11                	push   $0x11
  808f24:	ff 75 10             	pushl  0x10(%ebp)
  808f27:	ff 75 e4             	pushl  -0x1c(%ebp)
  808f2a:	56                   	push   %esi
  808f2b:	e8 38 e5 ff ff       	call   807468 <inet_chksum_pseudo>
      if (udphdr->chksum == 0x0000) udphdr->chksum = 0xffff;
  808f30:	83 c4 20             	add    $0x20,%esp
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
  808f33:	66 85 c0             	test   %ax,%ax
  808f36:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  808f3b:	0f 44 c2             	cmove  %edx,%eax
  808f3e:	66 89 47 06          	mov    %ax,0x6(%edi)
  808f42:	e9 2f ff ff ff       	jmp    808e76 <udp_sendto_if+0xbc>
      return ERR_MEM;
  808f47:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  808f4c:	e9 59 ff ff ff       	jmp    808eaa <udp_sendto_if+0xf0>

00808f51 <udp_sendto>:
{
  808f51:	55                   	push   %ebp
  808f52:	89 e5                	mov    %esp,%ebp
  808f54:	56                   	push   %esi
  808f55:	53                   	push   %ebx
  808f56:	8b 75 10             	mov    0x10(%ebp),%esi
  808f59:	8b 5d 14             	mov    0x14(%ebp),%ebx
  netif = ip_route(dst_ip);
  808f5c:	83 ec 0c             	sub    $0xc,%esp
  808f5f:	56                   	push   %esi
  808f60:	e8 18 d6 ff ff       	call   80657d <ip_route>
  if (netif == NULL) {
  808f65:	83 c4 10             	add    $0x10,%esp
  808f68:	85 c0                	test   %eax,%eax
  808f6a:	74 1e                	je     808f8a <udp_sendto+0x39>
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
  808f6c:	83 ec 0c             	sub    $0xc,%esp
  808f6f:	50                   	push   %eax
  808f70:	0f b7 db             	movzwl %bx,%ebx
  808f73:	53                   	push   %ebx
  808f74:	56                   	push   %esi
  808f75:	ff 75 0c             	pushl  0xc(%ebp)
  808f78:	ff 75 08             	pushl  0x8(%ebp)
  808f7b:	e8 3a fe ff ff       	call   808dba <udp_sendto_if>
  808f80:	83 c4 20             	add    $0x20,%esp
}
  808f83:	8d 65 f8             	lea    -0x8(%ebp),%esp
  808f86:	5b                   	pop    %ebx
  808f87:	5e                   	pop    %esi
  808f88:	5d                   	pop    %ebp
  808f89:	c3                   	ret    
    return ERR_RTE;
  808f8a:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  808f8f:	eb f2                	jmp    808f83 <udp_sendto+0x32>

00808f91 <udp_send>:
{
  808f91:	55                   	push   %ebp
  808f92:	89 e5                	mov    %esp,%ebp
  808f94:	83 ec 08             	sub    $0x8,%esp
  808f97:	8b 45 08             	mov    0x8(%ebp),%eax
  return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
  808f9a:	0f b7 50 14          	movzwl 0x14(%eax),%edx
  808f9e:	52                   	push   %edx
  808f9f:	8d 50 04             	lea    0x4(%eax),%edx
  808fa2:	52                   	push   %edx
  808fa3:	ff 75 0c             	pushl  0xc(%ebp)
  808fa6:	50                   	push   %eax
  808fa7:	e8 a5 ff ff ff       	call   808f51 <udp_sendto>
}
  808fac:	c9                   	leave  
  808fad:	c3                   	ret    

00808fae <udp_connect>:
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  808fae:	55                   	push   %ebp
  808faf:	89 e5                	mov    %esp,%ebp
  808fb1:	57                   	push   %edi
  808fb2:	56                   	push   %esi
  808fb3:	53                   	push   %ebx
  808fb4:	83 ec 0c             	sub    $0xc,%esp
  808fb7:	8b 5d 08             	mov    0x8(%ebp),%ebx
  808fba:	8b 75 0c             	mov    0xc(%ebp),%esi
  808fbd:	8b 7d 10             	mov    0x10(%ebp),%edi
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
  808fc0:	66 83 7b 12 00       	cmpw   $0x0,0x12(%ebx)
  808fc5:	74 2b                	je     808ff2 <udp_connect+0x44>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
    if (err != ERR_OK)
      return err;
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
  808fc7:	b8 00 00 00 00       	mov    $0x0,%eax
  808fcc:	85 f6                	test   %esi,%esi
  808fce:	74 02                	je     808fd2 <udp_connect+0x24>
  808fd0:	8b 06                	mov    (%esi),%eax
  808fd2:	89 43 04             	mov    %eax,0x4(%ebx)
  pcb->remote_port = port;
  808fd5:	66 89 7b 14          	mov    %di,0x14(%ebx)
  pcb->flags |= UDP_FLAGS_CONNECTED;
  808fd9:	80 4b 10 04          	orb    $0x4,0x10(%ebx)
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808fdd:	8b 15 54 b2 b3 00    	mov    0xb3b254,%edx
  808fe3:	89 d0                	mov    %edx,%eax
  808fe5:	85 c0                	test   %eax,%eax
  808fe7:	74 1e                	je     809007 <udp_connect+0x59>
    if (pcb == ipcb) {
  808fe9:	39 d8                	cmp    %ebx,%eax
  808feb:	74 2b                	je     809018 <udp_connect+0x6a>
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808fed:	8b 40 0c             	mov    0xc(%eax),%eax
  808ff0:	eb f3                	jmp    808fe5 <udp_connect+0x37>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  808ff2:	83 ec 04             	sub    $0x4,%esp
  808ff5:	6a 00                	push   $0x0
  808ff7:	53                   	push   %ebx
  808ff8:	53                   	push   %ebx
  808ff9:	e8 01 fd ff ff       	call   808cff <udp_bind>
    if (err != ERR_OK)
  808ffe:	83 c4 10             	add    $0x10,%esp
  809001:	84 c0                	test   %al,%al
  809003:	74 c2                	je     808fc7 <udp_connect+0x19>
  809005:	eb 09                	jmp    809010 <udp_connect+0x62>
      /* already on the list, just return */
      return ERR_OK;
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
  809007:	89 53 0c             	mov    %edx,0xc(%ebx)
  udp_pcbs = pcb;
  80900a:	89 1d 54 b2 b3 00    	mov    %ebx,0xb3b254
  return ERR_OK;
}
  809010:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809013:	5b                   	pop    %ebx
  809014:	5e                   	pop    %esi
  809015:	5f                   	pop    %edi
  809016:	5d                   	pop    %ebp
  809017:	c3                   	ret    
      return ERR_OK;
  809018:	b8 00 00 00 00       	mov    $0x0,%eax
  80901d:	eb f1                	jmp    809010 <udp_connect+0x62>

0080901f <udp_disconnect>:
 *
 * @param pcb the udp pcb to disconnect.
 */
void
udp_disconnect(struct udp_pcb *pcb)
{
  80901f:	55                   	push   %ebp
  809020:	89 e5                	mov    %esp,%ebp
  809022:	8b 45 08             	mov    0x8(%ebp),%eax
  /* reset remote address association */
  ip_addr_set(&pcb->remote_ip, IP_ADDR_ANY);
  809025:	8b 15 c4 1f 81 00    	mov    0x811fc4,%edx
  80902b:	89 50 04             	mov    %edx,0x4(%eax)
  pcb->remote_port = 0;
  80902e:	66 c7 40 14 00 00    	movw   $0x0,0x14(%eax)
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
  809034:	80 60 10 fb          	andb   $0xfb,0x10(%eax)
}
  809038:	5d                   	pop    %ebp
  809039:	c3                   	ret    

0080903a <udp_recv>:
void
udp_recv(struct udp_pcb *pcb,
         void (* recv)(void *arg, struct udp_pcb *upcb, struct pbuf *p,
                       struct ip_addr *addr, u16_t port),
         void *recv_arg)
{
  80903a:	55                   	push   %ebp
  80903b:	89 e5                	mov    %esp,%ebp
  80903d:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  809040:	8b 55 0c             	mov    0xc(%ebp),%edx
  809043:	89 50 18             	mov    %edx,0x18(%eax)
  pcb->recv_arg = recv_arg;
  809046:	8b 55 10             	mov    0x10(%ebp),%edx
  809049:	89 50 1c             	mov    %edx,0x1c(%eax)
}
  80904c:	5d                   	pop    %ebp
  80904d:	c3                   	ret    

0080904e <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
  80904e:	55                   	push   %ebp
  80904f:	89 e5                	mov    %esp,%ebp
  809051:	83 ec 08             	sub    $0x8,%esp
  809054:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
  809057:	a1 54 b2 b3 00       	mov    0xb3b254,%eax
  80905c:	39 c8                	cmp    %ecx,%eax
  80905e:	75 1b                	jne    80907b <udp_remove+0x2d>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
  809060:	8b 40 0c             	mov    0xc(%eax),%eax
  809063:	a3 54 b2 b3 00       	mov    %eax,0xb3b254
      if (pcb2->next != NULL && pcb2->next == pcb) {
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  memp_free(MEMP_UDP_PCB, pcb);
  809068:	83 ec 08             	sub    $0x8,%esp
  80906b:	51                   	push   %ecx
  80906c:	6a 01                	push   $0x1
  80906e:	e8 6b b4 ff ff       	call   8044de <memp_free>
}
  809073:	83 c4 10             	add    $0x10,%esp
  809076:	c9                   	leave  
  809077:	c3                   	ret    
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  809078:	8b 40 0c             	mov    0xc(%eax),%eax
  80907b:	85 c0                	test   %eax,%eax
  80907d:	74 e9                	je     809068 <udp_remove+0x1a>
      if (pcb2->next != NULL && pcb2->next == pcb) {
  80907f:	8b 50 0c             	mov    0xc(%eax),%edx
  809082:	39 ca                	cmp    %ecx,%edx
  809084:	75 f2                	jne    809078 <udp_remove+0x2a>
  809086:	85 d2                	test   %edx,%edx
  809088:	74 ee                	je     809078 <udp_remove+0x2a>
        pcb2->next = pcb->next;
  80908a:	8b 51 0c             	mov    0xc(%ecx),%edx
  80908d:	89 50 0c             	mov    %edx,0xc(%eax)
  809090:	eb e6                	jmp    809078 <udp_remove+0x2a>

00809092 <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
  809092:	55                   	push   %ebp
  809093:	89 e5                	mov    %esp,%ebp
  809095:	53                   	push   %ebx
  809096:	83 ec 10             	sub    $0x10,%esp
  struct udp_pcb *pcb;
  pcb = memp_malloc(MEMP_UDP_PCB);
  809099:	6a 01                	push   $0x1
  80909b:	e8 e8 b3 ff ff       	call   804488 <memp_malloc>
  8090a0:	89 c3                	mov    %eax,%ebx
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
  8090a2:	83 c4 10             	add    $0x10,%esp
  8090a5:	85 c0                	test   %eax,%eax
  8090a7:	74 14                	je     8090bd <udp_new+0x2b>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
  8090a9:	83 ec 04             	sub    $0x4,%esp
  8090ac:	6a 20                	push   $0x20
  8090ae:	6a 00                	push   $0x0
  8090b0:	50                   	push   %eax
  8090b1:	e8 56 5e 00 00       	call   80ef0c <memset>
    pcb->ttl = UDP_TTL;
  8090b6:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
  8090ba:	83 c4 10             	add    $0x10,%esp
  }
  return pcb;
}
  8090bd:	89 d8                	mov    %ebx,%eax
  8090bf:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8090c2:	c9                   	leave  
  8090c3:	c3                   	ret    

008090c4 <free_etharp_q>:
 *
 * @param q a qeueue of etharp_q_entry's to free
 */
static void
free_etharp_q(struct etharp_q_entry *q)
{
  8090c4:	55                   	push   %ebp
  8090c5:	89 e5                	mov    %esp,%ebp
  8090c7:	56                   	push   %esi
  8090c8:	53                   	push   %ebx
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  8090c9:	85 c0                	test   %eax,%eax
  8090cb:	74 35                	je     809102 <free_etharp_q+0x3e>
  8090cd:	89 c3                	mov    %eax,%ebx
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  8090cf:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  8090d3:	74 44                	je     809119 <free_etharp_q+0x55>
  while (q) {
    r = q;
    q = q->next;
  8090d5:	8b 33                	mov    (%ebx),%esi
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
  8090d7:	8b 43 04             	mov    0x4(%ebx),%eax
  8090da:	85 c0                	test   %eax,%eax
  8090dc:	74 52                	je     809130 <free_etharp_q+0x6c>
    pbuf_free(r->p);
  8090de:	83 ec 0c             	sub    $0xc,%esp
  8090e1:	50                   	push   %eax
  8090e2:	e8 66 b7 ff ff       	call   80484d <pbuf_free>
    memp_free(MEMP_ARP_QUEUE, r);
  8090e7:	83 c4 08             	add    $0x8,%esp
  8090ea:	53                   	push   %ebx
  8090eb:	6a 0a                	push   $0xa
  8090ed:	e8 ec b3 ff ff       	call   8044de <memp_free>
    q = q->next;
  8090f2:	89 f3                	mov    %esi,%ebx
  while (q) {
  8090f4:	83 c4 10             	add    $0x10,%esp
  8090f7:	85 f6                	test   %esi,%esi
  8090f9:	75 da                	jne    8090d5 <free_etharp_q+0x11>
  }
}
  8090fb:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8090fe:	5b                   	pop    %ebx
  8090ff:	5e                   	pop    %esi
  809100:	5d                   	pop    %ebp
  809101:	c3                   	ret    
  LWIP_ASSERT("q != NULL", q != NULL);
  809102:	83 ec 04             	sub    $0x4,%esp
  809105:	68 c8 1a 81 00       	push   $0x811ac8
  80910a:	68 93 00 00 00       	push   $0x93
  80910f:	68 b6 23 81 00       	push   $0x8123b6
  809114:	e8 3a 55 00 00       	call   80e653 <_panic>
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  809119:	83 ec 04             	sub    $0x4,%esp
  80911c:	68 ce 23 81 00       	push   $0x8123ce
  809121:	68 94 00 00 00       	push   $0x94
  809126:	68 b6 23 81 00       	push   $0x8123b6
  80912b:	e8 23 55 00 00       	call   80e653 <_panic>
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
  809130:	83 ec 04             	sub    $0x4,%esp
  809133:	68 db 23 81 00       	push   $0x8123db
  809138:	68 98 00 00 00       	push   $0x98
  80913d:	68 b6 23 81 00       	push   $0x8123b6
  809142:	e8 0c 55 00 00       	call   80e653 <_panic>

00809147 <find_entry>:
#if LWIP_NETIF_HWADDRHINT
find_entry(struct ip_addr *ipaddr, u8_t flags, struct netif *netif)
#else /* LWIP_NETIF_HWADDRHINT */
find_entry(struct ip_addr *ipaddr, u8_t flags)
#endif /* LWIP_NETIF_HWADDRHINT */
{
  809147:	55                   	push   %ebp
  809148:	89 e5                	mov    %esp,%ebp
  80914a:	57                   	push   %edi
  80914b:	56                   	push   %esi
  80914c:	53                   	push   %ebx
  80914d:	83 ec 1c             	sub    $0x1c,%esp
  u8_t age_queue = 0;
#endif

  /* First, test if the last call to this function asked for the
   * same address. If so, we're really fast! */
  if (ipaddr) {
  809150:	85 c0                	test   %eax,%eax
  809152:	0f 84 db 00 00 00    	je     809233 <find_entry+0xec>
          return per_pcb_cache;
        }
      }
    }
#else /* #if LWIP_NETIF_HWADDRHINT */
    if (arp_table[etharp_cached_entry].state == ETHARP_STATE_STABLE) {
  809158:	0f b6 0d 00 4a b3 00 	movzbl 0xb34a00,%ecx
  80915f:	0f b6 d9             	movzbl %cl,%ebx
  809162:	6b f3 1c             	imul   $0x1c,%ebx,%esi
  809165:	83 be 30 4a b3 00 02 	cmpl   $0x2,0xb34a30(%esi)
  80916c:	0f 84 8e 00 00 00    	je     809200 <find_entry+0xb9>
  809172:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  809176:	c6 45 e3 0a          	movb   $0xa,-0x1d(%ebp)
  80917a:	c6 45 e6 00          	movb   $0x0,-0x1a(%ebp)
  80917e:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  809182:	c6 45 e2 0a          	movb   $0xa,-0x1e(%ebp)
  809186:	c6 45 e5 0a          	movb   $0xa,-0x1b(%ebp)
  80918a:	b9 00 00 00 00       	mov    $0x0,%ecx
  80918f:	89 55 dc             	mov    %edx,-0x24(%ebp)
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
  809192:	0f b6 d9             	movzbl %cl,%ebx
  809195:	6b db 1c             	imul   $0x1c,%ebx,%ebx
  809198:	83 bb 30 4a b3 00 00 	cmpl   $0x0,0xb34a30(%ebx)
  80919f:	0f 85 b0 00 00 00    	jne    809255 <find_entry+0x10e>
      LWIP_DEBUGF(ETHARP_DEBUG, ("find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
  8091a5:	89 cb                	mov    %ecx,%ebx
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  8091a7:	83 c1 01             	add    $0x1,%ecx
  8091aa:	80 f9 09             	cmp    $0x9,%cl
  8091ad:	0f 87 1a 01 00 00    	ja     8092cd <find_entry+0x186>
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
  8091b3:	80 fb 0a             	cmp    $0xa,%bl
  8091b6:	74 da                	je     809192 <find_entry+0x4b>
    }
    /* pending entry? */
    else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  8091b8:	0f b6 f1             	movzbl %cl,%esi
  8091bb:	6b fe 1c             	imul   $0x1c,%esi,%edi
  8091be:	8b bf 30 4a b3 00    	mov    0xb34a30(%edi),%edi
  8091c4:	83 ff 01             	cmp    $0x1,%edi
  8091c7:	0f 84 92 00 00 00    	je     80925f <find_entry+0x118>
          age_pending = arp_table[i].ctime;
        }
      }        
    }
    /* stable entry? */
    else if (arp_table[i].state == ETHARP_STATE_STABLE) {
  8091cd:	83 ff 02             	cmp    $0x2,%edi
  8091d0:	75 d5                	jne    8091a7 <find_entry+0x60>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  8091d2:	85 c0                	test   %eax,%eax
  8091d4:	74 11                	je     8091e7 <find_entry+0xa0>
  8091d6:	6b fe 1c             	imul   $0x1c,%esi,%edi
  8091d9:	8b 97 24 4a b3 00    	mov    0xb34a24(%edi),%edx
  8091df:	39 10                	cmp    %edx,(%eax)
  8091e1:	0f 84 dc 00 00 00    	je     8092c3 <find_entry+0x17c>
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
      /* remember entry with oldest stable entry in oldest, its age in maxtime */
      } else if (arp_table[i].ctime >= age_stable) {
  8091e7:	6b f6 1c             	imul   $0x1c,%esi,%esi
  8091ea:	0f b6 b6 34 4a b3 00 	movzbl 0xb34a34(%esi),%esi
  8091f1:	89 f2                	mov    %esi,%edx
  8091f3:	3a 55 e6             	cmp    -0x1a(%ebp),%dl
  8091f6:	72 af                	jb     8091a7 <find_entry+0x60>
        old_stable = i;
  8091f8:	88 4d e5             	mov    %cl,-0x1b(%ebp)
        age_stable = arp_table[i].ctime;
  8091fb:	88 55 e6             	mov    %dl,-0x1a(%ebp)
  8091fe:	eb a7                	jmp    8091a7 <find_entry+0x60>
      if (ip_addr_cmp(ipaddr, &arp_table[etharp_cached_entry].ipaddr)) {
  809200:	8b 9e 24 4a b3 00    	mov    0xb34a24(%esi),%ebx
  809206:	39 18                	cmp    %ebx,(%eax)
  809208:	74 22                	je     80922c <find_entry+0xe5>
  80920a:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  80920e:	c6 45 e3 0a          	movb   $0xa,-0x1d(%ebp)
  809212:	c6 45 e6 00          	movb   $0x0,-0x1a(%ebp)
  809216:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  80921a:	c6 45 e2 0a          	movb   $0xa,-0x1e(%ebp)
  80921e:	c6 45 e5 0a          	movb   $0xa,-0x1b(%ebp)
  809222:	b9 00 00 00 00       	mov    $0x0,%ecx
  809227:	e9 63 ff ff ff       	jmp    80918f <find_entry+0x48>
        return etharp_cached_entry;
  80922c:	89 c8                	mov    %ecx,%eax
  80922e:	e9 e9 00 00 00       	jmp    80931c <find_entry+0x1d5>
  809233:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  809237:	c6 45 e3 0a          	movb   $0xa,-0x1d(%ebp)
  80923b:	c6 45 e6 00          	movb   $0x0,-0x1a(%ebp)
  80923f:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  809243:	c6 45 e2 0a          	movb   $0xa,-0x1e(%ebp)
  809247:	c6 45 e5 0a          	movb   $0xa,-0x1b(%ebp)
  80924b:	b9 00 00 00 00       	mov    $0x0,%ecx
  809250:	e9 3a ff ff ff       	jmp    80918f <find_entry+0x48>
  809255:	bb 0a 00 00 00       	mov    $0xa,%ebx
  80925a:	e9 59 ff ff ff       	jmp    8091b8 <find_entry+0x71>
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  80925f:	85 c0                	test   %eax,%eax
  809261:	74 0d                	je     809270 <find_entry+0x129>
  809263:	6b fe 1c             	imul   $0x1c,%esi,%edi
  809266:	8b 97 24 4a b3 00    	mov    0xb34a24(%edi),%edx
  80926c:	39 10                	cmp    %edx,(%eax)
  80926e:	74 29                	je     809299 <find_entry+0x152>
      } else if (arp_table[i].q != NULL) {
  809270:	6b fe 1c             	imul   $0x1c,%esi,%edi
  809273:	83 bf 20 4a b3 00 00 	cmpl   $0x0,0xb34a20(%edi)
  80927a:	74 27                	je     8092a3 <find_entry+0x15c>
        if (arp_table[i].ctime >= age_queue) {
  80927c:	0f b6 b7 34 4a b3 00 	movzbl 0xb34a34(%edi),%esi
  809283:	89 f2                	mov    %esi,%edx
  809285:	3a 55 e7             	cmp    -0x19(%ebp),%dl
  809288:	0f 82 19 ff ff ff    	jb     8091a7 <find_entry+0x60>
          old_queue = i;
  80928e:	88 4d e3             	mov    %cl,-0x1d(%ebp)
          age_queue = arp_table[i].ctime;
  809291:	88 55 e7             	mov    %dl,-0x19(%ebp)
  809294:	e9 0e ff ff ff       	jmp    8091a7 <find_entry+0x60>
        etharp_cached_entry = i;
  809299:	88 0d 00 4a b3 00    	mov    %cl,0xb34a00
        return i;
  80929f:	89 c8                	mov    %ecx,%eax
  8092a1:	eb 79                	jmp    80931c <find_entry+0x1d5>
        if (arp_table[i].ctime >= age_pending) {
  8092a3:	6b f6 1c             	imul   $0x1c,%esi,%esi
  8092a6:	0f b6 b6 34 4a b3 00 	movzbl 0xb34a34(%esi),%esi
  8092ad:	89 f2                	mov    %esi,%edx
  8092af:	3a 55 e4             	cmp    -0x1c(%ebp),%dl
  8092b2:	0f 82 ef fe ff ff    	jb     8091a7 <find_entry+0x60>
          old_pending = i;
  8092b8:	88 4d e2             	mov    %cl,-0x1e(%ebp)
          age_pending = arp_table[i].ctime;
  8092bb:	88 55 e4             	mov    %dl,-0x1c(%ebp)
  8092be:	e9 e4 fe ff ff       	jmp    8091a7 <find_entry+0x60>
        etharp_cached_entry = i;
  8092c3:	88 0d 00 4a b3 00    	mov    %cl,0xb34a00
        return i;
  8092c9:	89 c8                	mov    %ecx,%eax
  8092cb:	eb 4f                	jmp    80931c <find_entry+0x1d5>
  8092cd:	8b 55 dc             	mov    -0x24(%ebp),%edx
  8092d0:	89 c6                	mov    %eax,%esi
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
  8092d2:	80 fb 0a             	cmp    $0xa,%bl
  8092d5:	74 4d                	je     809324 <find_entry+0x1dd>
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
  8092d7:	f6 c2 02             	test   $0x2,%dl
  8092da:	0f 85 de 00 00 00    	jne    8093be <find_entry+0x277>
   * 
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
  8092e0:	80 fb 09             	cmp    $0x9,%bl
  8092e3:	7f 51                	jg     809336 <find_entry+0x1ef>
  } else {
    return (s8_t)ERR_MEM;
  }

  /* { empty or recyclable entry found } */
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  8092e5:	80 fb 09             	cmp    $0x9,%bl
  8092e8:	0f 87 af 00 00 00    	ja     80939d <find_entry+0x256>

  if (arp_table[i].state != ETHARP_STATE_EMPTY)
  8092ee:	0f b6 c3             	movzbl %bl,%eax
  {
    snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  }
  /* recycle entry (no-op for an already empty entry) */
  arp_table[i].state = ETHARP_STATE_EMPTY;
  8092f1:	6b d0 1c             	imul   $0x1c,%eax,%edx
  8092f4:	c7 82 30 4a b3 00 00 	movl   $0x0,0xb34a30(%edx)
  8092fb:	00 00 00 

  /* IP address given? */
  if (ipaddr != NULL) {
  8092fe:	85 f6                	test   %esi,%esi
  809300:	74 08                	je     80930a <find_entry+0x1c3>
    /* set IP address */
    ip_addr_set(&arp_table[i].ipaddr, ipaddr);
  809302:	8b 0e                	mov    (%esi),%ecx
  809304:	89 8a 24 4a b3 00    	mov    %ecx,0xb34a24(%edx)
  }
  arp_table[i].ctime = 0;
  80930a:	6b c0 1c             	imul   $0x1c,%eax,%eax
  80930d:	c6 80 34 4a b3 00 00 	movb   $0x0,0xb34a34(%eax)
#if LWIP_NETIF_HWADDRHINT
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
  809314:	88 1d 00 4a b3 00    	mov    %bl,0xb34a00
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
  80931a:	89 d8                	mov    %ebx,%eax
}
  80931c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80931f:	5b                   	pop    %ebx
  809320:	5e                   	pop    %esi
  809321:	5f                   	pop    %edi
  809322:	5d                   	pop    %ebp
  809323:	c3                   	ret    
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
  809324:	f6 c2 01             	test   $0x1,%dl
  809327:	0f 84 87 00 00 00    	je     8093b4 <find_entry+0x26d>
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
  80932d:	f6 c2 02             	test   $0x2,%dl
  809330:	0f 85 9c 00 00 00    	jne    8093d2 <find_entry+0x28b>
  else if (old_stable < ARP_TABLE_SIZE) {
  809336:	0f b6 45 e5          	movzbl -0x1b(%ebp),%eax
  80933a:	3c 09                	cmp    $0x9,%al
  80933c:	7f 28                	jg     809366 <find_entry+0x21f>
    i = old_stable;
  80933e:	89 c3                	mov    %eax,%ebx
    LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
  809340:	0f b6 c0             	movzbl %al,%eax
  809343:	6b c0 1c             	imul   $0x1c,%eax,%eax
  809346:	83 b8 20 4a b3 00 00 	cmpl   $0x0,0xb34a20(%eax)
  80934d:	74 96                	je     8092e5 <find_entry+0x19e>
  80934f:	83 ec 04             	sub    $0x4,%esp
  809352:	68 e8 23 81 00       	push   $0x8123e8
  809357:	68 75 01 00 00       	push   $0x175
  80935c:	68 b6 23 81 00       	push   $0x8123b6
  809361:	e8 ed 52 00 00       	call   80e653 <_panic>
  } else if (old_pending < ARP_TABLE_SIZE) {
  809366:	0f b6 5d e2          	movzbl -0x1e(%ebp),%ebx
  80936a:	80 fb 09             	cmp    $0x9,%bl
  80936d:	0f 8e 72 ff ff ff    	jle    8092e5 <find_entry+0x19e>
  } else if (old_queue < ARP_TABLE_SIZE) {
  809373:	0f b6 45 e3          	movzbl -0x1d(%ebp),%eax
  809377:	3c 09                	cmp    $0x9,%al
  809379:	7f 4d                	jg     8093c8 <find_entry+0x281>
    i = old_queue;
  80937b:	89 c3                	mov    %eax,%ebx
    free_etharp_q(arp_table[i].q);
  80937d:	0f b6 f8             	movzbl %al,%edi
  809380:	6b ff 1c             	imul   $0x1c,%edi,%edi
  809383:	8b 87 20 4a b3 00    	mov    0xb34a20(%edi),%eax
  809389:	e8 36 fd ff ff       	call   8090c4 <free_etharp_q>
    arp_table[i].q = NULL;
  80938e:	c7 87 20 4a b3 00 00 	movl   $0x0,0xb34a20(%edi)
  809395:	00 00 00 
  809398:	e9 48 ff ff ff       	jmp    8092e5 <find_entry+0x19e>
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  80939d:	83 ec 04             	sub    $0x4,%esp
  8093a0:	68 ff 23 81 00       	push   $0x8123ff
  8093a5:	68 8b 01 00 00       	push   $0x18b
  8093aa:	68 b6 23 81 00       	push   $0x8123b6
  8093af:	e8 9f 52 00 00       	call   80e653 <_panic>
    return (s8_t)ERR_MEM;
  8093b4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8093b9:	e9 5e ff ff ff       	jmp    80931c <find_entry+0x1d5>
  8093be:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8093c3:	e9 54 ff ff ff       	jmp    80931c <find_entry+0x1d5>
    return (s8_t)ERR_MEM;
  8093c8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8093cd:	e9 4a ff ff ff       	jmp    80931c <find_entry+0x1d5>
    return (s8_t)ERR_MEM;
  8093d2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8093d7:	e9 40 ff ff ff       	jmp    80931c <find_entry+0x1d5>

008093dc <etharp_send_ip>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
  8093dc:	55                   	push   %ebp
  8093dd:	89 e5                	mov    %esp,%ebp
  8093df:	57                   	push   %edi
  8093e0:	56                   	push   %esi
  8093e1:	53                   	push   %ebx
  8093e2:	83 ec 1c             	sub    $0x1c,%esp
  8093e5:	89 d7                	mov    %edx,%edi
  8093e7:	8b 55 08             	mov    0x8(%ebp),%edx
  struct eth_hdr *ethhdr = p->payload;
  8093ea:	8b 5f 04             	mov    0x4(%edi),%ebx
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  8093ed:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  8093f1:	75 45                	jne    809438 <etharp_send_ip+0x5c>
  8093f3:	89 c6                	mov    %eax,%esi
  8093f5:	b8 05 00 00 00       	mov    $0x5,%eax
  8093fa:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
    k--;
    ethhdr->dest.addr[k] = dst->addr[k];
  8093fd:	0f b6 0c 02          	movzbl (%edx,%eax,1),%ecx
  809401:	88 0c 03             	mov    %cl,(%ebx,%eax,1)
    ethhdr->src.addr[k]  = src->addr[k];
  809404:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  809407:	0f b6 0c 01          	movzbl (%ecx,%eax,1),%ecx
  80940b:	88 4c 03 06          	mov    %cl,0x6(%ebx,%eax,1)
  80940f:	83 e8 01             	sub    $0x1,%eax
  while(k > 0) {
  809412:	83 f8 ff             	cmp    $0xffffffff,%eax
  809415:	75 e6                	jne    8093fd <etharp_send_ip+0x21>
  }
  ethhdr->type = htons(ETHTYPE_IP);
  809417:	83 ec 0c             	sub    $0xc,%esp
  80941a:	68 00 08 00 00       	push   $0x800
  80941f:	e8 5e e3 ff ff       	call   807782 <htons>
  809424:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
  809428:	83 c4 08             	add    $0x8,%esp
  80942b:	57                   	push   %edi
  80942c:	56                   	push   %esi
  80942d:	ff 56 18             	call   *0x18(%esi)
}
  809430:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809433:	5b                   	pop    %ebx
  809434:	5e                   	pop    %esi
  809435:	5f                   	pop    %edi
  809436:	5d                   	pop    %ebp
  809437:	c3                   	ret    
  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  809438:	83 ec 04             	sub    $0x4,%esp
  80943b:	68 2c 24 81 00       	push   $0x81242c
  809440:	68 b3 01 00 00       	push   $0x1b3
  809445:	68 b6 23 81 00       	push   $0x8123b6
  80944a:	e8 04 52 00 00       	call   80e653 <_panic>

0080944f <update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
update_arp_entry(struct netif *netif, struct ip_addr *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
  80944f:	55                   	push   %ebp
  809450:	89 e5                	mov    %esp,%ebp
  809452:	57                   	push   %edi
  809453:	56                   	push   %esi
  809454:	53                   	push   %ebx
  809455:	83 ec 1c             	sub    $0x1c,%esp
  809458:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80945b:	89 cb                	mov    %ecx,%ebx
  80945d:	8b 4d 08             	mov    0x8(%ebp),%ecx
  809460:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  s8_t i;
  u8_t k;
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 3, ("update_arp_entry()\n"));
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
  809463:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  809467:	0f 85 ae 00 00 00    	jne    80951b <update_arp_entry+0xcc>
  80946d:	89 d6                	mov    %edx,%esi
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  80946f:	85 d2                	test   %edx,%edx
  809471:	0f 84 fe 00 00 00    	je     809575 <update_arp_entry+0x126>
  809477:	83 3a 00             	cmpl   $0x0,(%edx)
  80947a:	0f 84 fc 00 00 00    	je     80957c <update_arp_entry+0x12d>
      ip_addr_isbroadcast(ipaddr, netif) ||
  809480:	83 ec 08             	sub    $0x8,%esp
  809483:	ff 75 e4             	pushl  -0x1c(%ebp)
  809486:	52                   	push   %edx
  809487:	e8 b1 d0 ff ff       	call   80653d <ip_addr_isbroadcast>
  if (ip_addr_isany(ipaddr) ||
  80948c:	83 c4 10             	add    $0x10,%esp
  80948f:	84 c0                	test   %al,%al
  809491:	0f 85 ec 00 00 00    	jne    809583 <update_arp_entry+0x134>
      ip_addr_ismulticast(ipaddr)) {
  809497:	8b 3e                	mov    (%esi),%edi
  809499:	83 ec 0c             	sub    $0xc,%esp
  80949c:	68 00 00 00 f0       	push   $0xf0000000
  8094a1:	e8 14 e5 ff ff       	call   8079ba <ntohl>
  8094a6:	21 c7                	and    %eax,%edi
  8094a8:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  8094af:	e8 06 e5 ff ff       	call   8079ba <ntohl>
      ip_addr_isbroadcast(ipaddr, netif) ||
  8094b4:	83 c4 10             	add    $0x10,%esp
  8094b7:	39 c7                	cmp    %eax,%edi
  8094b9:	0f 84 cb 00 00 00    	je     80958a <update_arp_entry+0x13b>
  }
  /* find or create ARP entry */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, flags, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, flags);
  8094bf:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
  8094c3:	89 f0                	mov    %esi,%eax
  8094c5:	e8 7d fc ff ff       	call   809147 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */
  /* bail out if no entry could be found */
  if (i < 0)
  8094ca:	84 c0                	test   %al,%al
  8094cc:	0f 88 9b 00 00 00    	js     80956d <update_arp_entry+0x11e>
    return (err_t)i;
  
  /* mark it stable */
  arp_table[i].state = ETHARP_STATE_STABLE;
  8094d2:	0f be c0             	movsbl %al,%eax
  8094d5:	6b f0 1c             	imul   $0x1c,%eax,%esi
  8094d8:	c7 86 30 4a b3 00 02 	movl   $0x2,0xb34a30(%esi)
  8094df:	00 00 00 
  /* record network interface */
  arp_table[i].netif = netif;
  8094e2:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8094e5:	89 8e 38 4a b3 00    	mov    %ecx,0xb34a38(%esi)
  8094eb:	ba 00 00 00 00       	mov    $0x0,%edx
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  while (k > 0) {
    k--;
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  8094f0:	0f b6 4c 13 05       	movzbl 0x5(%ebx,%edx,1),%ecx
  8094f5:	88 8c 16 2d 4a b3 00 	mov    %cl,0xb34a2d(%esi,%edx,1)
  8094fc:	83 ea 01             	sub    $0x1,%edx
  while (k > 0) {
  8094ff:	83 fa fa             	cmp    $0xfffffffa,%edx
  809502:	75 ec                	jne    8094f0 <update_arp_entry+0xa1>
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
  809504:	6b d0 1c             	imul   $0x1c,%eax,%edx
  809507:	c6 82 34 4a b3 00 00 	movb   $0x0,0xb34a34(%edx)
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  80950e:	89 d6                	mov    %edx,%esi
    /* get the packet pointer */
    p = q->p;
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  809510:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  809513:	83 c0 25             	add    $0x25,%eax
  809516:	89 45 e0             	mov    %eax,-0x20(%ebp)
  while (arp_table[i].q != NULL) {
  809519:	eb 48                	jmp    809563 <update_arp_entry+0x114>
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
  80951b:	83 ec 04             	sub    $0x4,%esp
  80951e:	68 70 24 81 00       	push   $0x812470
  809523:	68 d9 01 00 00       	push   $0x1d9
  809528:	68 b6 23 81 00       	push   $0x8123b6
  80952d:	e8 21 51 00 00       	call   80e653 <_panic>
    arp_table[i].q = q->next;
  809532:	8b 10                	mov    (%eax),%edx
  809534:	89 96 20 4a b3 00    	mov    %edx,0xb34a20(%esi)
    p = q->p;
  80953a:	8b 78 04             	mov    0x4(%eax),%edi
    memp_free(MEMP_ARP_QUEUE, q);
  80953d:	83 ec 08             	sub    $0x8,%esp
  809540:	50                   	push   %eax
  809541:	6a 0a                	push   $0xa
  809543:	e8 96 af ff ff       	call   8044de <memp_free>
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  809548:	89 1c 24             	mov    %ebx,(%esp)
  80954b:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80954e:	89 fa                	mov    %edi,%edx
  809550:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  809553:	e8 84 fe ff ff       	call   8093dc <etharp_send_ip>
    /* free the queued IP packet */
    pbuf_free(p);
  809558:	89 3c 24             	mov    %edi,(%esp)
  80955b:	e8 ed b2 ff ff       	call   80484d <pbuf_free>
  809560:	83 c4 10             	add    $0x10,%esp
  while (arp_table[i].q != NULL) {
  809563:	8b 86 20 4a b3 00    	mov    0xb34a20(%esi),%eax
  809569:	85 c0                	test   %eax,%eax
  80956b:	75 c5                	jne    809532 <update_arp_entry+0xe3>
  }
#endif
  return ERR_OK;
}
  80956d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809570:	5b                   	pop    %ebx
  809571:	5e                   	pop    %esi
  809572:	5f                   	pop    %edi
  809573:	5d                   	pop    %ebp
  809574:	c3                   	ret    
    return ERR_ARG;
  809575:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  80957a:	eb f1                	jmp    80956d <update_arp_entry+0x11e>
  80957c:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  809581:	eb ea                	jmp    80956d <update_arp_entry+0x11e>
  809583:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  809588:	eb e3                	jmp    80956d <update_arp_entry+0x11e>
  80958a:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  80958f:	eb dc                	jmp    80956d <update_arp_entry+0x11e>

00809591 <etharp_tmr>:
{
  809591:	55                   	push   %ebp
  809592:	89 e5                	mov    %esp,%ebp
  809594:	57                   	push   %edi
  809595:	56                   	push   %esi
  809596:	53                   	push   %ebx
  809597:	83 ec 0c             	sub    $0xc,%esp
  80959a:	bb 20 4a b3 00       	mov    $0xb34a20,%ebx
  80959f:	bf 38 4b b3 00       	mov    $0xb34b38,%edi
  8095a4:	eb 1f                	jmp    8095c5 <etharp_tmr+0x34>
      if (arp_table[i].q != NULL) {
  8095a6:	8b 06                	mov    (%esi),%eax
  8095a8:	85 c0                	test   %eax,%eax
  8095aa:	74 0b                	je     8095b7 <etharp_tmr+0x26>
        free_etharp_q(arp_table[i].q);
  8095ac:	e8 13 fb ff ff       	call   8090c4 <free_etharp_q>
        arp_table[i].q = NULL;
  8095b1:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
      arp_table[i].state = ETHARP_STATE_EMPTY;
  8095b7:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
  8095be:	83 c3 1c             	add    $0x1c,%ebx
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  8095c1:	39 fb                	cmp    %edi,%ebx
  8095c3:	74 23                	je     8095e8 <etharp_tmr+0x57>
  8095c5:	89 de                	mov    %ebx,%esi
    arp_table[i].ctime++;
  8095c7:	0f b6 43 14          	movzbl 0x14(%ebx),%eax
  8095cb:	83 c0 01             	add    $0x1,%eax
  8095ce:	88 43 14             	mov    %al,0x14(%ebx)
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
  8095d1:	8b 53 10             	mov    0x10(%ebx),%edx
  8095d4:	3c ef                	cmp    $0xef,%al
  8095d6:	76 05                	jbe    8095dd <etharp_tmr+0x4c>
  8095d8:	83 fa 02             	cmp    $0x2,%edx
  8095db:	74 c9                	je     8095a6 <etharp_tmr+0x15>
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
  8095dd:	3c 01                	cmp    $0x1,%al
  8095df:	76 dd                	jbe    8095be <etharp_tmr+0x2d>
  8095e1:	83 fa 01             	cmp    $0x1,%edx
  8095e4:	75 d8                	jne    8095be <etharp_tmr+0x2d>
  8095e6:	eb be                	jmp    8095a6 <etharp_tmr+0x15>
}
  8095e8:	83 c4 0c             	add    $0xc,%esp
  8095eb:	5b                   	pop    %ebx
  8095ec:	5e                   	pop    %esi
  8095ed:	5f                   	pop    %edi
  8095ee:	5d                   	pop    %ebp
  8095ef:	c3                   	ret    

008095f0 <etharp_find_addr>:
 * @return table index if found, -1 otherwise
 */
s8_t
etharp_find_addr(struct netif *netif, struct ip_addr *ipaddr,
         struct eth_addr **eth_ret, struct ip_addr **ip_ret)
{
  8095f0:	55                   	push   %ebp
  8095f1:	89 e5                	mov    %esp,%ebp
  8095f3:	53                   	push   %ebx
  8095f4:	83 ec 04             	sub    $0x4,%esp
  LWIP_UNUSED_ARG(netif);

#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_FIND_ONLY, NULL);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_FIND_ONLY);
  8095f7:	ba 02 00 00 00       	mov    $0x2,%edx
  8095fc:	8b 45 0c             	mov    0xc(%ebp),%eax
  8095ff:	e8 43 fb ff ff       	call   809147 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */
  if((i >= 0) && arp_table[i].state == ETHARP_STATE_STABLE) {
  809604:	84 c0                	test   %al,%al
  809606:	78 31                	js     809639 <etharp_find_addr+0x49>
  809608:	0f be d0             	movsbl %al,%edx
  80960b:	6b d2 1c             	imul   $0x1c,%edx,%edx
  80960e:	83 ba 30 4a b3 00 02 	cmpl   $0x2,0xb34a30(%edx)
  809615:	75 29                	jne    809640 <etharp_find_addr+0x50>
  809617:	0f be d0             	movsbl %al,%edx
  80961a:	6b d2 1c             	imul   $0x1c,%edx,%edx
      *eth_ret = &arp_table[i].ethaddr;
  80961d:	8d 9a 28 4a b3 00    	lea    0xb34a28(%edx),%ebx
  809623:	8b 4d 10             	mov    0x10(%ebp),%ecx
  809626:	89 19                	mov    %ebx,(%ecx)
      *ip_ret = &arp_table[i].ipaddr;
  809628:	81 c2 24 4a b3 00    	add    $0xb34a24,%edx
  80962e:	8b 4d 14             	mov    0x14(%ebp),%ecx
  809631:	89 11                	mov    %edx,(%ecx)
      return i;
  }
  return -1;
}
  809633:	83 c4 04             	add    $0x4,%esp
  809636:	5b                   	pop    %ebx
  809637:	5d                   	pop    %ebp
  809638:	c3                   	ret    
  return -1;
  809639:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80963e:	eb f3                	jmp    809633 <etharp_find_addr+0x43>
  809640:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809645:	eb ec                	jmp    809633 <etharp_find_addr+0x43>

00809647 <etharp_ip_input>:
 *
 * @see pbuf_free()
 */
void
etharp_ip_input(struct netif *netif, struct pbuf *p)
{
  809647:	55                   	push   %ebp
  809648:	89 e5                	mov    %esp,%ebp
  80964a:	83 ec 08             	sub    $0x8,%esp
  80964d:	8b 45 08             	mov    0x8(%ebp),%eax
  struct ethip_hdr *hdr;
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  809650:	85 c0                	test   %eax,%eax
  809652:	74 13                	je     809667 <etharp_ip_input+0x20>
  /* Only insert an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  hdr = p->payload;
  809654:	8b 55 0c             	mov    0xc(%ebp),%edx
  809657:	8b 52 04             	mov    0x4(%edx),%edx
  /* source is not on the local network? */
  if (!ip_addr_netcmp(&(hdr->ip.src), &(netif->ip_addr), &(netif->netmask))) {
  80965a:	8b 4a 1c             	mov    0x1c(%edx),%ecx
  80965d:	33 48 04             	xor    0x4(%eax),%ecx
  809660:	85 48 08             	test   %ecx,0x8(%eax)
  809663:	74 19                	je     80967e <etharp_ip_input+0x37>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update ARP table */
  /* @todo We could use ETHARP_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
}
  809665:	c9                   	leave  
  809666:	c3                   	ret    
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  809667:	83 ec 04             	sub    $0x4,%esp
  80966a:	68 22 17 81 00       	push   $0x811722
  80966f:	68 48 02 00 00       	push   $0x248
  809674:	68 b6 23 81 00       	push   $0x8123b6
  809679:	e8 d5 4f 00 00       	call   80e653 <_panic>
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
  80967e:	8d 4a 06             	lea    0x6(%edx),%ecx
  809681:	83 c2 1c             	add    $0x1c,%edx
  809684:	83 ec 0c             	sub    $0xc,%esp
  809687:	6a 00                	push   $0x0
  809689:	e8 c1 fd ff ff       	call   80944f <update_arp_entry>
  80968e:	83 c4 10             	add    $0x10,%esp
  809691:	eb d2                	jmp    809665 <etharp_ip_input+0x1e>

00809693 <etharp_arp_input>:
 *
 * @see pbuf_free()
 */
void
etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
{
  809693:	55                   	push   %ebp
  809694:	89 e5                	mov    %esp,%ebp
  809696:	57                   	push   %edi
  809697:	56                   	push   %esi
  809698:	53                   	push   %ebx
  809699:	83 ec 1c             	sub    $0x1c,%esp
  80969c:	8b 5d 10             	mov    0x10(%ebp),%ebx
  u8_t for_us;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  80969f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  8096a3:	74 1b                	je     8096c0 <etharp_arp_input+0x2d>
  
  /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < sizeof(struct etharp_hdr)) {
  8096a5:	66 83 7b 0a 29       	cmpw   $0x29,0xa(%ebx)
  8096aa:	77 2b                	ja     8096d7 <etharp_arp_input+0x44>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1, ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len, (s16_t)sizeof(struct etharp_hdr)));
    ETHARP_STATS_INC(etharp.lenerr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  8096ac:	83 ec 0c             	sub    $0xc,%esp
  8096af:	53                   	push   %ebx
  8096b0:	e8 98 b1 ff ff       	call   80484d <pbuf_free>
    return;
  8096b5:	83 c4 10             	add    $0x10,%esp
    ETHARP_STATS_INC(etharp.err);
    break;
  }
  /* free ARP packet */
  pbuf_free(p);
}
  8096b8:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8096bb:	5b                   	pop    %ebx
  8096bc:	5e                   	pop    %esi
  8096bd:	5f                   	pop    %edi
  8096be:	5d                   	pop    %ebp
  8096bf:	c3                   	ret    
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  8096c0:	83 ec 04             	sub    $0x4,%esp
  8096c3:	68 22 17 81 00       	push   $0x811722
  8096c8:	68 75 02 00 00       	push   $0x275
  8096cd:	68 b6 23 81 00       	push   $0x8123b6
  8096d2:	e8 7c 4f 00 00       	call   80e653 <_panic>
  hdr = p->payload;
  8096d7:	8b 73 04             	mov    0x4(%ebx),%esi
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  8096da:	0f b7 7e 0e          	movzwl 0xe(%esi),%edi
  8096de:	83 ec 0c             	sub    $0xc,%esp
  8096e1:	6a 01                	push   $0x1
  8096e3:	e8 9a e0 ff ff       	call   807782 <htons>
  8096e8:	83 c4 10             	add    $0x10,%esp
  8096eb:	66 39 c7             	cmp    %ax,%di
  8096ee:	74 0e                	je     8096fe <etharp_arp_input+0x6b>
    pbuf_free(p);
  8096f0:	83 ec 0c             	sub    $0xc,%esp
  8096f3:	53                   	push   %ebx
  8096f4:	e8 54 b1 ff ff       	call   80484d <pbuf_free>
    return;
  8096f9:	83 c4 10             	add    $0x10,%esp
  8096fc:	eb ba                	jmp    8096b8 <etharp_arp_input+0x25>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  8096fe:	0f b7 7e 12          	movzwl 0x12(%esi),%edi
  809702:	83 ec 0c             	sub    $0xc,%esp
  809705:	68 04 06 00 00       	push   $0x604
  80970a:	e8 73 e0 ff ff       	call   807782 <htons>
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  80970f:	83 c4 10             	add    $0x10,%esp
  809712:	66 39 c7             	cmp    %ax,%di
  809715:	75 d9                	jne    8096f0 <etharp_arp_input+0x5d>
      (hdr->proto != htons(ETHTYPE_IP)) ||
  809717:	0f b7 7e 10          	movzwl 0x10(%esi),%edi
  80971b:	83 ec 0c             	sub    $0xc,%esp
  80971e:	68 00 08 00 00       	push   $0x800
  809723:	e8 5a e0 ff ff       	call   807782 <htons>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  809728:	83 c4 10             	add    $0x10,%esp
  80972b:	66 39 c7             	cmp    %ax,%di
  80972e:	75 c0                	jne    8096f0 <etharp_arp_input+0x5d>
      (hdr->ethhdr.type != htons(ETHTYPE_ARP)))  {
  809730:	0f b7 7e 0c          	movzwl 0xc(%esi),%edi
  809734:	83 ec 0c             	sub    $0xc,%esp
  809737:	68 06 08 00 00       	push   $0x806
  80973c:	e8 41 e0 ff ff       	call   807782 <htons>
      (hdr->proto != htons(ETHTYPE_IP)) ||
  809741:	83 c4 10             	add    $0x10,%esp
  809744:	66 39 c7             	cmp    %ax,%di
  809747:	75 a7                	jne    8096f0 <etharp_arp_input+0x5d>
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
  809749:	83 ec 04             	sub    $0x4,%esp
  80974c:	6a 04                	push   $0x4
  80974e:	8d 46 1c             	lea    0x1c(%esi),%eax
  809751:	50                   	push   %eax
  809752:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  809755:	50                   	push   %eax
  809756:	e8 66 58 00 00       	call   80efc1 <memcpy>
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));
  80975b:	83 c4 0c             	add    $0xc,%esp
  80975e:	6a 04                	push   $0x4
  809760:	8d 46 26             	lea    0x26(%esi),%eax
  809763:	50                   	push   %eax
  809764:	8d 45 e0             	lea    -0x20(%ebp),%eax
  809767:	50                   	push   %eax
  809768:	e8 54 58 00 00       	call   80efc1 <memcpy>
  if (netif->ip_addr.addr == 0) {
  80976d:	8b 45 08             	mov    0x8(%ebp),%eax
  809770:	8b 40 04             	mov    0x4(%eax),%eax
  809773:	83 c4 10             	add    $0x10,%esp
  809776:	85 c0                	test   %eax,%eax
  809778:	74 05                	je     80977f <etharp_arp_input+0xec>
  if (for_us) {
  80977a:	3b 45 e0             	cmp    -0x20(%ebp),%eax
  80977d:	74 39                	je     8097b8 <etharp_arp_input+0x125>
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), 0);
  80977f:	8d 4e 16             	lea    0x16(%esi),%ecx
  809782:	83 ec 0c             	sub    $0xc,%esp
  809785:	6a 00                	push   $0x0
  809787:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  80978a:	8b 45 08             	mov    0x8(%ebp),%eax
  80978d:	e8 bd fc ff ff       	call   80944f <update_arp_entry>
  switch (htons(hdr->opcode)) {
  809792:	0f b7 46 14          	movzwl 0x14(%esi),%eax
  809796:	89 04 24             	mov    %eax,(%esp)
  809799:	e8 e4 df ff ff       	call   807782 <htons>
  80979e:	83 c4 10             	add    $0x10,%esp
  8097a1:	66 83 f8 02          	cmp    $0x2,%ax
  8097a5:	74 3f                	je     8097e6 <etharp_arp_input+0x153>
  pbuf_free(p);
  8097a7:	83 ec 0c             	sub    $0xc,%esp
  8097aa:	53                   	push   %ebx
  8097ab:	e8 9d b0 ff ff       	call   80484d <pbuf_free>
  8097b0:	83 c4 10             	add    $0x10,%esp
  8097b3:	e9 00 ff ff ff       	jmp    8096b8 <etharp_arp_input+0x25>
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
  8097b8:	8d 4e 16             	lea    0x16(%esi),%ecx
  8097bb:	83 ec 0c             	sub    $0xc,%esp
  8097be:	6a 01                	push   $0x1
  8097c0:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  8097c3:	8b 45 08             	mov    0x8(%ebp),%eax
  8097c6:	e8 84 fc ff ff       	call   80944f <update_arp_entry>
  switch (htons(hdr->opcode)) {
  8097cb:	0f b7 46 14          	movzwl 0x14(%esi),%eax
  8097cf:	89 04 24             	mov    %eax,(%esp)
  8097d2:	e8 ab df ff ff       	call   807782 <htons>
  8097d7:	83 c4 10             	add    $0x10,%esp
  8097da:	66 83 f8 01          	cmp    $0x1,%ax
  8097de:	74 1a                	je     8097fa <etharp_arp_input+0x167>
  8097e0:	66 83 f8 02          	cmp    $0x2,%ax
  8097e4:	75 c1                	jne    8097a7 <etharp_arp_input+0x114>
    dhcp_arp_reply(netif, &sipaddr);
  8097e6:	83 ec 08             	sub    $0x8,%esp
  8097e9:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8097ec:	50                   	push   %eax
  8097ed:	ff 75 08             	pushl  0x8(%ebp)
  8097f0:	e8 ae a0 ff ff       	call   8038a3 <dhcp_arp_reply>
    break;
  8097f5:	83 c4 10             	add    $0x10,%esp
  8097f8:	eb ad                	jmp    8097a7 <etharp_arp_input+0x114>
      hdr->opcode = htons(ARP_REPLY);
  8097fa:	83 ec 0c             	sub    $0xc,%esp
  8097fd:	6a 02                	push   $0x2
  8097ff:	e8 7e df ff ff       	call   807782 <htons>
  809804:	66 89 46 14          	mov    %ax,0x14(%esi)
      hdr->dipaddr = hdr->sipaddr;
  809808:	8b 46 1c             	mov    0x1c(%esi),%eax
  80980b:	89 46 26             	mov    %eax,0x26(%esi)
      hdr->sipaddr = *(struct ip_addr2 *)&netif->ip_addr;
  80980e:	8b 45 08             	mov    0x8(%ebp),%eax
  809811:	8b 40 04             	mov    0x4(%eax),%eax
  809814:	89 46 1c             	mov    %eax,0x1c(%esi)
      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  809817:	83 c4 10             	add    $0x10,%esp
  80981a:	8b 45 08             	mov    0x8(%ebp),%eax
  80981d:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  809821:	75 40                	jne    809863 <etharp_arp_input+0x1d0>
  809823:	8d 46 05             	lea    0x5(%esi),%eax
  809826:	8b 55 0c             	mov    0xc(%ebp),%edx
  809829:	83 c2 05             	add    $0x5,%edx
  80982c:	83 ee 01             	sub    $0x1,%esi
        hdr->dhwaddr.addr[i] = hdr->shwaddr.addr[i];
  80982f:	0f b6 48 16          	movzbl 0x16(%eax),%ecx
  809833:	88 48 20             	mov    %cl,0x20(%eax)
        hdr->ethhdr.dest.addr[i] = hdr->shwaddr.addr[i];
  809836:	88 08                	mov    %cl,(%eax)
        hdr->shwaddr.addr[i] = ethaddr->addr[i];
  809838:	0f b6 0a             	movzbl (%edx),%ecx
  80983b:	88 48 16             	mov    %cl,0x16(%eax)
        hdr->ethhdr.src.addr[i] = ethaddr->addr[i];
  80983e:	0f b6 0a             	movzbl (%edx),%ecx
  809841:	88 48 06             	mov    %cl,0x6(%eax)
  809844:	83 e8 01             	sub    $0x1,%eax
  809847:	83 ea 01             	sub    $0x1,%edx
      while(i > 0) {
  80984a:	39 f0                	cmp    %esi,%eax
  80984c:	75 e1                	jne    80982f <etharp_arp_input+0x19c>
      netif->linkoutput(netif, p);
  80984e:	83 ec 08             	sub    $0x8,%esp
  809851:	53                   	push   %ebx
  809852:	ff 75 08             	pushl  0x8(%ebp)
  809855:	8b 45 08             	mov    0x8(%ebp),%eax
  809858:	ff 50 18             	call   *0x18(%eax)
  80985b:	83 c4 10             	add    $0x10,%esp
  80985e:	e9 44 ff ff ff       	jmp    8097a7 <etharp_arp_input+0x114>
      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  809863:	83 ec 04             	sub    $0x4,%esp
  809866:	68 2c 24 81 00       	push   $0x81242c
  80986b:	68 c7 02 00 00       	push   $0x2c7
  809870:	68 b6 23 81 00       	push   $0x8123b6
  809875:	e8 d9 4d 00 00       	call   80e653 <_panic>

0080987a <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
  80987a:	55                   	push   %ebp
  80987b:	89 e5                	mov    %esp,%ebp
  80987d:	57                   	push   %edi
  80987e:	56                   	push   %esi
  80987f:	53                   	push   %ebx
  809880:	83 ec 10             	sub    $0x10,%esp
  809883:	8b 75 08             	mov    0x8(%ebp),%esi
  p = pbuf_alloc(PBUF_LINK, sizeof(struct etharp_hdr), PBUF_RAM);
  809886:	6a 00                	push   $0x0
  809888:	6a 2a                	push   $0x2a
  80988a:	6a 02                	push   $0x2
  80988c:	e8 82 b0 ff ff       	call   804913 <pbuf_alloc>
  if (p == NULL) {
  809891:	83 c4 10             	add    $0x10,%esp
  809894:	85 c0                	test   %eax,%eax
  809896:	0f 84 f8 00 00 00    	je     809994 <etharp_request+0x11a>
  80989c:	89 c7                	mov    %eax,%edi
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
  80989e:	66 83 78 0a 29       	cmpw   $0x29,0xa(%eax)
  8098a3:	0f 86 bd 00 00 00    	jbe    809966 <etharp_request+0xec>
  hdr = p->payload;
  8098a9:	8b 58 04             	mov    0x4(%eax),%ebx
  hdr->opcode = htons(opcode);
  8098ac:	83 ec 0c             	sub    $0xc,%esp
  8098af:	6a 01                	push   $0x1
  8098b1:	e8 cc de ff ff       	call   807782 <htons>
  8098b6:	66 89 43 14          	mov    %ax,0x14(%ebx)
  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  8098ba:	83 c4 10             	add    $0x10,%esp
  8098bd:	80 7e 24 06          	cmpb   $0x6,0x24(%esi)
  8098c1:	0f 85 b6 00 00 00    	jne    80997d <etharp_request+0x103>
  8098c7:	b8 05 00 00 00       	mov    $0x5,%eax
    hdr->shwaddr.addr[k] = hwsrc_addr->addr[k];
  8098cc:	0f b6 54 06 25       	movzbl 0x25(%esi,%eax,1),%edx
  8098d1:	88 54 03 16          	mov    %dl,0x16(%ebx,%eax,1)
    hdr->dhwaddr.addr[k] = hwdst_addr->addr[k];
  8098d5:	0f b6 90 18 25 81 00 	movzbl 0x812518(%eax),%edx
  8098dc:	88 54 03 20          	mov    %dl,0x20(%ebx,%eax,1)
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
  8098e0:	0f b6 90 20 25 81 00 	movzbl 0x812520(%eax),%edx
  8098e7:	88 14 03             	mov    %dl,(%ebx,%eax,1)
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  8098ea:	0f b6 54 06 25       	movzbl 0x25(%esi,%eax,1),%edx
  8098ef:	88 54 03 06          	mov    %dl,0x6(%ebx,%eax,1)
  8098f3:	83 e8 01             	sub    $0x1,%eax
  while(k > 0) {
  8098f6:	83 f8 ff             	cmp    $0xffffffff,%eax
  8098f9:	75 d1                	jne    8098cc <etharp_request+0x52>
  hdr->sipaddr = *(struct ip_addr2 *)ipsrc_addr;
  8098fb:	8b 46 04             	mov    0x4(%esi),%eax
  8098fe:	89 43 1c             	mov    %eax,0x1c(%ebx)
  hdr->dipaddr = *(struct ip_addr2 *)ipdst_addr;
  809901:	8b 45 0c             	mov    0xc(%ebp),%eax
  809904:	8b 00                	mov    (%eax),%eax
  809906:	89 43 26             	mov    %eax,0x26(%ebx)
  hdr->hwtype = htons(HWTYPE_ETHERNET);
  809909:	83 ec 0c             	sub    $0xc,%esp
  80990c:	6a 01                	push   $0x1
  80990e:	e8 6f de ff ff       	call   807782 <htons>
  809913:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  hdr->proto = htons(ETHTYPE_IP);
  809917:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  80991e:	e8 5f de ff ff       	call   807782 <htons>
  809923:	66 89 43 10          	mov    %ax,0x10(%ebx)
  hdr->_hwlen_protolen = htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr));
  809927:	c7 04 24 04 06 00 00 	movl   $0x604,(%esp)
  80992e:	e8 4f de ff ff       	call   807782 <htons>
  809933:	66 89 43 12          	mov    %ax,0x12(%ebx)
  hdr->ethhdr.type = htons(ETHTYPE_ARP);
  809937:	c7 04 24 06 08 00 00 	movl   $0x806,(%esp)
  80993e:	e8 3f de ff ff       	call   807782 <htons>
  809943:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  result = netif->linkoutput(netif, p);
  809947:	83 c4 08             	add    $0x8,%esp
  80994a:	57                   	push   %edi
  80994b:	56                   	push   %esi
  80994c:	ff 56 18             	call   *0x18(%esi)
  80994f:	89 c3                	mov    %eax,%ebx
  pbuf_free(p);
  809951:	89 3c 24             	mov    %edi,(%esp)
  809954:	e8 f4 ae ff ff       	call   80484d <pbuf_free>
  809959:	83 c4 10             	add    $0x10,%esp
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
  80995c:	89 d8                	mov    %ebx,%eax
  80995e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809961:	5b                   	pop    %ebx
  809962:	5e                   	pop    %esi
  809963:	5f                   	pop    %edi
  809964:	5d                   	pop    %ebp
  809965:	c3                   	ret    
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
  809966:	83 ec 04             	sub    $0x4,%esp
  809969:	68 98 24 81 00       	push   $0x812498
  80996e:	68 1c 04 00 00       	push   $0x41c
  809973:	68 b6 23 81 00       	push   $0x8123b6
  809978:	e8 d6 4c 00 00       	call   80e653 <_panic>
  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  80997d:	83 ec 04             	sub    $0x4,%esp
  809980:	68 2c 24 81 00       	push   $0x81242c
  809985:	68 23 04 00 00       	push   $0x423
  80998a:	68 b6 23 81 00       	push   $0x8123b6
  80998f:	e8 bf 4c 00 00       	call   80e653 <_panic>
    return ERR_MEM;
  809994:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
  809999:	eb c1                	jmp    80995c <etharp_request+0xe2>

0080999b <etharp_query>:
{
  80999b:	55                   	push   %ebp
  80999c:	89 e5                	mov    %esp,%ebp
  80999e:	57                   	push   %edi
  80999f:	56                   	push   %esi
  8099a0:	53                   	push   %ebx
  8099a1:	83 ec 14             	sub    $0x14,%esp
  8099a4:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  8099a7:	ff 75 08             	pushl  0x8(%ebp)
  8099aa:	53                   	push   %ebx
  8099ab:	e8 8d cb ff ff       	call   80653d <ip_addr_isbroadcast>
  8099b0:	83 c4 10             	add    $0x10,%esp
  8099b3:	84 c0                	test   %al,%al
  8099b5:	0f 85 a7 01 00 00    	jne    809b62 <etharp_query+0x1c7>
      ip_addr_ismulticast(ipaddr) ||
  8099bb:	8b 33                	mov    (%ebx),%esi
  8099bd:	83 ec 0c             	sub    $0xc,%esp
  8099c0:	68 00 00 00 f0       	push   $0xf0000000
  8099c5:	e8 f0 df ff ff       	call   8079ba <ntohl>
  8099ca:	21 c6                	and    %eax,%esi
  8099cc:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  8099d3:	e8 e2 df ff ff       	call   8079ba <ntohl>
  8099d8:	83 c4 10             	add    $0x10,%esp
  8099db:	85 db                	test   %ebx,%ebx
  8099dd:	0f 84 86 01 00 00    	je     809b69 <etharp_query+0x1ce>
  8099e3:	39 c6                	cmp    %eax,%esi
  8099e5:	0f 84 7e 01 00 00    	je     809b69 <etharp_query+0x1ce>
      ip_addr_isany(ipaddr)) {
  8099eb:	83 3b 00             	cmpl   $0x0,(%ebx)
  8099ee:	0f 84 7c 01 00 00    	je     809b70 <etharp_query+0x1d5>
  i = find_entry(ipaddr, ETHARP_TRY_HARD);
  8099f4:	ba 01 00 00 00       	mov    $0x1,%edx
  8099f9:	89 d8                	mov    %ebx,%eax
  8099fb:	e8 47 f7 ff ff       	call   809147 <find_entry>
  809a00:	89 c6                	mov    %eax,%esi
  if (i < 0) {
  809a02:	84 c0                	test   %al,%al
  809a04:	0f 88 6d 01 00 00    	js     809b77 <etharp_query+0x1dc>
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
  809a0a:	0f be f8             	movsbl %al,%edi
  809a0d:	6b c7 1c             	imul   $0x1c,%edi,%eax
  809a10:	8b 80 30 4a b3 00    	mov    0xb34a30(%eax),%eax
  809a16:	85 c0                	test   %eax,%eax
  809a18:	75 20                	jne    809a3a <etharp_query+0x9f>
    arp_table[i].state = ETHARP_STATE_PENDING;
  809a1a:	6b c7 1c             	imul   $0x1c,%edi,%eax
  809a1d:	c7 80 30 4a b3 00 01 	movl   $0x1,0xb34a30(%eax)
  809a24:	00 00 00 
    result = etharp_request(netif, ipaddr);
  809a27:	83 ec 08             	sub    $0x8,%esp
  809a2a:	53                   	push   %ebx
  809a2b:	ff 75 08             	pushl  0x8(%ebp)
  809a2e:	e8 47 fe ff ff       	call   80987a <etharp_request>
  809a33:	89 c3                	mov    %eax,%ebx
  809a35:	83 c4 10             	add    $0x10,%esp
  809a38:	eb 18                	jmp    809a52 <etharp_query+0xb7>
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  809a3a:	8d 50 ff             	lea    -0x1(%eax),%edx
  809a3d:	83 fa 01             	cmp    $0x1,%edx
  809a40:	77 39                	ja     809a7b <etharp_query+0xe0>
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
  809a42:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  809a46:	74 df                	je     809a27 <etharp_query+0x8c>
  809a48:	83 f8 01             	cmp    $0x1,%eax
  809a4b:	74 da                	je     809a27 <etharp_query+0x8c>
  err_t result = ERR_MEM;
  809a4d:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  if (q != NULL) {
  809a52:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  809a56:	0f 84 1d 01 00 00    	je     809b79 <etharp_query+0x1de>
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
  809a5c:	6b c7 1c             	imul   $0x1c,%edi,%eax
  809a5f:	8b 80 30 4a b3 00    	mov    0xb34a30(%eax),%eax
  809a65:	83 f8 02             	cmp    $0x2,%eax
  809a68:	74 28                	je     809a92 <etharp_query+0xf7>
    } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  809a6a:	83 f8 01             	cmp    $0x1,%eax
  809a6d:	0f 85 06 01 00 00    	jne    809b79 <etharp_query+0x1de>
      p = q;
  809a73:	8b 45 10             	mov    0x10(%ebp),%eax
  809a76:	e9 b4 00 00 00       	jmp    809b2f <etharp_query+0x194>
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  809a7b:	83 ec 04             	sub    $0x4,%esp
  809a7e:	68 cc 24 81 00       	push   $0x8124cc
  809a83:	68 92 03 00 00       	push   $0x392
  809a88:	68 b6 23 81 00       	push   $0x8123b6
  809a8d:	e8 c1 4b 00 00       	call   80e653 <_panic>
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  809a92:	8b 45 08             	mov    0x8(%ebp),%eax
  809a95:	8d 48 25             	lea    0x25(%eax),%ecx
      result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
  809a98:	83 ec 0c             	sub    $0xc,%esp
  809a9b:	89 f0                	mov    %esi,%eax
  809a9d:	0f be c0             	movsbl %al,%eax
  809aa0:	6b c0 1c             	imul   $0x1c,%eax,%eax
  809aa3:	05 28 4a b3 00       	add    $0xb34a28,%eax
  809aa8:	50                   	push   %eax
  809aa9:	8b 55 10             	mov    0x10(%ebp),%edx
  809aac:	8b 45 08             	mov    0x8(%ebp),%eax
  809aaf:	e8 28 f9 ff ff       	call   8093dc <etharp_send_ip>
  809ab4:	89 c3                	mov    %eax,%ebx
  809ab6:	83 c4 10             	add    $0x10,%esp
  809ab9:	e9 bb 00 00 00       	jmp    809b79 <etharp_query+0x1de>
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
  809abe:	83 38 00             	cmpl   $0x0,(%eax)
  809ac1:	75 4f                	jne    809b12 <etharp_query+0x177>
        if(p->type != PBUF_ROM) {
  809ac3:	80 78 0c 01          	cmpb   $0x1,0xc(%eax)
  809ac7:	0f 84 b6 00 00 00    	je     809b83 <etharp_query+0x1e8>
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  809acd:	83 ec 04             	sub    $0x4,%esp
  809ad0:	6a 00                	push   $0x0
  809ad2:	0f b7 d2             	movzwl %dx,%edx
  809ad5:	52                   	push   %edx
  809ad6:	6a 03                	push   $0x3
  809ad8:	e8 36 ae ff ff       	call   804913 <pbuf_alloc>
  809add:	89 c6                	mov    %eax,%esi
        if(p != NULL) {
  809adf:	83 c4 10             	add    $0x10,%esp
  809ae2:	85 c0                	test   %eax,%eax
  809ae4:	0f 84 8f 00 00 00    	je     809b79 <etharp_query+0x1de>
          if (pbuf_copy(p, q) != ERR_OK) {
  809aea:	83 ec 08             	sub    $0x8,%esp
  809aed:	ff 75 10             	pushl  0x10(%ebp)
  809af0:	56                   	push   %esi
  809af1:	e8 f6 b2 ff ff       	call   804dec <pbuf_copy>
  809af6:	83 c4 10             	add    $0x10,%esp
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  809af9:	89 75 10             	mov    %esi,0x10(%ebp)
          if (pbuf_copy(p, q) != ERR_OK) {
  809afc:	84 c0                	test   %al,%al
  809afe:	0f 84 8d 00 00 00    	je     809b91 <etharp_query+0x1f6>
            pbuf_free(p);
  809b04:	83 ec 0c             	sub    $0xc,%esp
  809b07:	56                   	push   %esi
  809b08:	e8 40 ad ff ff       	call   80484d <pbuf_free>
  809b0d:	83 c4 10             	add    $0x10,%esp
  809b10:	eb 67                	jmp    809b79 <etharp_query+0x1de>
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
  809b12:	83 ec 04             	sub    $0x4,%esp
  809b15:	68 12 24 81 00       	push   $0x812412
  809b1a:	68 b1 03 00 00       	push   $0x3b1
  809b1f:	68 b6 23 81 00       	push   $0x8123b6
  809b24:	e8 2a 4b 00 00       	call   80e653 <_panic>
        p = p->next;
  809b29:	8b 00                	mov    (%eax),%eax
      while (p) {
  809b2b:	85 c0                	test   %eax,%eax
  809b2d:	74 54                	je     809b83 <etharp_query+0x1e8>
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
  809b2f:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  809b33:	66 39 50 0a          	cmp    %dx,0xa(%eax)
  809b37:	74 85                	je     809abe <etharp_query+0x123>
        if(p->type != PBUF_ROM) {
  809b39:	80 78 0c 01          	cmpb   $0x1,0xc(%eax)
  809b3d:	74 ea                	je     809b29 <etharp_query+0x18e>
  809b3f:	eb 8c                	jmp    809acd <etharp_query+0x132>
              r = r->next;
  809b41:	89 d1                	mov    %edx,%ecx
            while (r->next != NULL) {
  809b43:	8b 11                	mov    (%ecx),%edx
  809b45:	85 d2                	test   %edx,%edx
  809b47:	75 f8                	jne    809b41 <etharp_query+0x1a6>
            r->next = new_entry;
  809b49:	89 01                	mov    %eax,(%ecx)
          result = ERR_OK;
  809b4b:	bb 00 00 00 00       	mov    $0x0,%ebx
  809b50:	eb 27                	jmp    809b79 <etharp_query+0x1de>
          pbuf_free(p);
  809b52:	83 ec 0c             	sub    $0xc,%esp
  809b55:	ff 75 10             	pushl  0x10(%ebp)
  809b58:	e8 f0 ac ff ff       	call   80484d <pbuf_free>
  809b5d:	83 c4 10             	add    $0x10,%esp
  809b60:	eb 17                	jmp    809b79 <etharp_query+0x1de>
    return ERR_ARG;
  809b62:	bb f6 ff ff ff       	mov    $0xfffffff6,%ebx
  809b67:	eb 10                	jmp    809b79 <etharp_query+0x1de>
  809b69:	bb f6 ff ff ff       	mov    $0xfffffff6,%ebx
  809b6e:	eb 09                	jmp    809b79 <etharp_query+0x1de>
  809b70:	bb f6 ff ff ff       	mov    $0xfffffff6,%ebx
  809b75:	eb 02                	jmp    809b79 <etharp_query+0x1de>
    return (err_t)i;
  809b77:	89 c3                	mov    %eax,%ebx
}
  809b79:	89 d8                	mov    %ebx,%eax
  809b7b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809b7e:	5b                   	pop    %ebx
  809b7f:	5e                   	pop    %esi
  809b80:	5f                   	pop    %edi
  809b81:	5d                   	pop    %ebp
  809b82:	c3                   	ret    
        pbuf_ref(p);
  809b83:	83 ec 0c             	sub    $0xc,%esp
  809b86:	ff 75 10             	pushl  0x10(%ebp)
  809b89:	e8 1a b1 ff ff       	call   804ca8 <pbuf_ref>
  809b8e:	83 c4 10             	add    $0x10,%esp
        new_entry = memp_malloc(MEMP_ARP_QUEUE);
  809b91:	83 ec 0c             	sub    $0xc,%esp
  809b94:	6a 0a                	push   $0xa
  809b96:	e8 ed a8 ff ff       	call   804488 <memp_malloc>
        if (new_entry != NULL) {
  809b9b:	83 c4 10             	add    $0x10,%esp
  809b9e:	85 c0                	test   %eax,%eax
  809ba0:	74 b0                	je     809b52 <etharp_query+0x1b7>
          new_entry->next = 0;
  809ba2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          new_entry->p = p;
  809ba8:	8b 4d 10             	mov    0x10(%ebp),%ecx
  809bab:	89 48 04             	mov    %ecx,0x4(%eax)
          if(arp_table[i].q != NULL) {
  809bae:	6b d7 1c             	imul   $0x1c,%edi,%edx
  809bb1:	8b 8a 20 4a b3 00    	mov    0xb34a20(%edx),%ecx
  809bb7:	85 c9                	test   %ecx,%ecx
  809bb9:	75 88                	jne    809b43 <etharp_query+0x1a8>
            arp_table[i].q = new_entry;
  809bbb:	6b ff 1c             	imul   $0x1c,%edi,%edi
  809bbe:	89 87 20 4a b3 00    	mov    %eax,0xb34a20(%edi)
          result = ERR_OK;
  809bc4:	bb 00 00 00 00       	mov    $0x0,%ebx
  809bc9:	eb ae                	jmp    809b79 <etharp_query+0x1de>

00809bcb <etharp_output>:
{
  809bcb:	55                   	push   %ebp
  809bcc:	89 e5                	mov    %esp,%ebp
  809bce:	57                   	push   %edi
  809bcf:	56                   	push   %esi
  809bd0:	53                   	push   %ebx
  809bd1:	83 ec 24             	sub    $0x24,%esp
  809bd4:	8b 5d 08             	mov    0x8(%ebp),%ebx
  809bd7:	8b 75 10             	mov    0x10(%ebp),%esi
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
  809bda:	6a 0e                	push   $0xe
  809bdc:	ff 75 0c             	pushl  0xc(%ebp)
  809bdf:	e8 95 ab ff ff       	call   804779 <pbuf_header>
  809be4:	83 c4 10             	add    $0x10,%esp
  809be7:	84 c0                	test   %al,%al
  809be9:	0f 85 c0 00 00 00    	jne    809caf <etharp_output+0xe4>
  if (ip_addr_isbroadcast(ipaddr, netif)) {
  809bef:	83 ec 08             	sub    $0x8,%esp
  809bf2:	53                   	push   %ebx
  809bf3:	56                   	push   %esi
  809bf4:	e8 44 c9 ff ff       	call   80653d <ip_addr_isbroadcast>
  809bf9:	83 c4 10             	add    $0x10,%esp
  809bfc:	84 c0                	test   %al,%al
  809bfe:	0f 85 8a 00 00 00    	jne    809c8e <etharp_output+0xc3>
  } else if (ip_addr_ismulticast(ipaddr)) {
  809c04:	8b 3e                	mov    (%esi),%edi
  809c06:	83 ec 0c             	sub    $0xc,%esp
  809c09:	68 00 00 00 f0       	push   $0xf0000000
  809c0e:	e8 a7 dd ff ff       	call   8079ba <ntohl>
  809c13:	21 c7                	and    %eax,%edi
  809c15:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  809c1c:	e8 99 dd ff ff       	call   8079ba <ntohl>
  809c21:	83 c4 10             	add    $0x10,%esp
  809c24:	39 c7                	cmp    %eax,%edi
  809c26:	74 25                	je     809c4d <etharp_output+0x82>
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask))) {
  809c28:	8b 06                	mov    (%esi),%eax
  809c2a:	33 43 04             	xor    0x4(%ebx),%eax
  809c2d:	85 43 08             	test   %eax,0x8(%ebx)
  809c30:	74 09                	je     809c3b <etharp_output+0x70>
      if (netif->gw.addr != 0) {
  809c32:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
  809c36:	74 7e                	je     809cb6 <etharp_output+0xeb>
        ipaddr = &(netif->gw);
  809c38:	8d 73 0c             	lea    0xc(%ebx),%esi
    return etharp_query(netif, ipaddr, q);
  809c3b:	83 ec 04             	sub    $0x4,%esp
  809c3e:	ff 75 0c             	pushl  0xc(%ebp)
  809c41:	56                   	push   %esi
  809c42:	53                   	push   %ebx
  809c43:	e8 53 fd ff ff       	call   80999b <etharp_query>
  809c48:	83 c4 10             	add    $0x10,%esp
  809c4b:	eb 5a                	jmp    809ca7 <etharp_output+0xdc>
    mcastaddr.addr[0] = 0x01;
  809c4d:	c6 45 e2 01          	movb   $0x1,-0x1e(%ebp)
    mcastaddr.addr[1] = 0x00;
  809c51:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
    mcastaddr.addr[2] = 0x5e;
  809c55:	c6 45 e4 5e          	movb   $0x5e,-0x1c(%ebp)
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
  809c59:	83 ec 0c             	sub    $0xc,%esp
  809c5c:	ff 36                	pushl  (%esi)
  809c5e:	e8 57 dd ff ff       	call   8079ba <ntohl>
  809c63:	c1 e8 10             	shr    $0x10,%eax
  809c66:	83 e0 7f             	and    $0x7f,%eax
  809c69:	88 45 e5             	mov    %al,-0x1b(%ebp)
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
  809c6c:	83 c4 04             	add    $0x4,%esp
  809c6f:	ff 36                	pushl  (%esi)
  809c71:	e8 44 dd ff ff       	call   8079ba <ntohl>
  809c76:	88 65 e6             	mov    %ah,-0x1a(%ebp)
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
  809c79:	83 c4 04             	add    $0x4,%esp
  809c7c:	ff 36                	pushl  (%esi)
  809c7e:	e8 37 dd ff ff       	call   8079ba <ntohl>
  809c83:	88 45 e7             	mov    %al,-0x19(%ebp)
  809c86:	83 c4 10             	add    $0x10,%esp
    dest = &mcastaddr;
  809c89:	8d 45 e2             	lea    -0x1e(%ebp),%eax
  809c8c:	eb 05                	jmp    809c93 <etharp_output+0xc8>
    dest = (struct eth_addr *)&ethbroadcast;
  809c8e:	b8 20 25 81 00       	mov    $0x812520,%eax
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
  809c93:	8d 4b 25             	lea    0x25(%ebx),%ecx
  809c96:	83 ec 0c             	sub    $0xc,%esp
  809c99:	50                   	push   %eax
  809c9a:	8b 55 0c             	mov    0xc(%ebp),%edx
  809c9d:	89 d8                	mov    %ebx,%eax
  809c9f:	e8 38 f7 ff ff       	call   8093dc <etharp_send_ip>
  809ca4:	83 c4 10             	add    $0x10,%esp
}
  809ca7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809caa:	5b                   	pop    %ebx
  809cab:	5e                   	pop    %esi
  809cac:	5f                   	pop    %edi
  809cad:	5d                   	pop    %ebp
  809cae:	c3                   	ret    
    return ERR_BUF;
  809caf:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  809cb4:	eb f1                	jmp    809ca7 <etharp_output+0xdc>
        return ERR_RTE;
  809cb6:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  809cbb:	eb ea                	jmp    809ca7 <etharp_output+0xdc>

00809cbd <ethernet_input>:
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
  809cbd:	55                   	push   %ebp
  809cbe:	89 e5                	mov    %esp,%ebp
  809cc0:	56                   	push   %esi
  809cc1:	53                   	push   %ebx
  809cc2:	8b 5d 08             	mov    0x8(%ebp),%ebx
  809cc5:	8b 75 0c             	mov    0xc(%ebp),%esi
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
     (unsigned)htons(ethhdr->type)));

  switch (htons(ethhdr->type)) {
  809cc8:	83 ec 0c             	sub    $0xc,%esp
  809ccb:	8b 43 04             	mov    0x4(%ebx),%eax
  809cce:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  809cd2:	50                   	push   %eax
  809cd3:	e8 aa da ff ff       	call   807782 <htons>
  809cd8:	83 c4 10             	add    $0x10,%esp
  809cdb:	66 3d 00 08          	cmp    $0x800,%ax
  809cdf:	74 14                	je     809cf5 <ethernet_input+0x38>
  809ce1:	66 3d 06 08          	cmp    $0x806,%ax
  809ce5:	74 50                	je     809d37 <ethernet_input+0x7a>
#endif /* PPPOE_SUPPORT */

    default:
      ETHARP_STATS_INC(etharp.proterr);
      ETHARP_STATS_INC(etharp.drop);
      pbuf_free(p);
  809ce7:	83 ec 0c             	sub    $0xc,%esp
  809cea:	53                   	push   %ebx
  809ceb:	e8 5d ab ff ff       	call   80484d <pbuf_free>
      p = NULL;
      break;
  809cf0:	83 c4 10             	add    $0x10,%esp
  809cf3:	eb 53                	jmp    809d48 <ethernet_input+0x8b>
      etharp_ip_input(netif, p);
  809cf5:	83 ec 08             	sub    $0x8,%esp
  809cf8:	53                   	push   %ebx
  809cf9:	56                   	push   %esi
  809cfa:	e8 48 f9 ff ff       	call   809647 <etharp_ip_input>
      if(pbuf_header(p, -(s16_t)sizeof(struct eth_hdr))) {
  809cff:	83 c4 08             	add    $0x8,%esp
  809d02:	6a f2                	push   $0xfffffff2
  809d04:	53                   	push   %ebx
  809d05:	e8 6f aa ff ff       	call   804779 <pbuf_header>
  809d0a:	83 c4 10             	add    $0x10,%esp
  809d0d:	84 c0                	test   %al,%al
  809d0f:	75 0f                	jne    809d20 <ethernet_input+0x63>
        ip_input(p, netif);
  809d11:	83 ec 08             	sub    $0x8,%esp
  809d14:	56                   	push   %esi
  809d15:	53                   	push   %ebx
  809d16:	e8 bf c8 ff ff       	call   8065da <ip_input>
      break;
  809d1b:	83 c4 10             	add    $0x10,%esp
  809d1e:	eb 28                	jmp    809d48 <ethernet_input+0x8b>
        LWIP_ASSERT("Can't move over header in packet", 0);
  809d20:	83 ec 04             	sub    $0x4,%esp
  809d23:	68 f4 24 81 00       	push   $0x8124f4
  809d28:	68 7e 04 00 00       	push   $0x47e
  809d2d:	68 b6 23 81 00       	push   $0x8123b6
  809d32:	e8 1c 49 00 00       	call   80e653 <_panic>
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
  809d37:	83 ec 04             	sub    $0x4,%esp
  809d3a:	53                   	push   %ebx
  809d3b:	8d 46 25             	lea    0x25(%esi),%eax
  809d3e:	50                   	push   %eax
  809d3f:	56                   	push   %esi
  809d40:	e8 4e f9 ff ff       	call   809693 <etharp_arp_input>
      break;
  809d45:	83 c4 10             	add    $0x10,%esp
  }

  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;
}
  809d48:	b8 00 00 00 00       	mov    $0x0,%eax
  809d4d:	8d 65 f8             	lea    -0x8(%ebp),%esp
  809d50:	5b                   	pop    %ebx
  809d51:	5e                   	pop    %esi
  809d52:	5d                   	pop    %ebp
  809d53:	c3                   	ret    

00809d54 <lwip_thread_entry>:
    void *arg;
};

static void
lwip_thread_entry(uint32_t arg)
{
  809d54:	55                   	push   %ebp
  809d55:	89 e5                	mov    %esp,%ebp
  809d57:	53                   	push   %ebx
  809d58:	83 ec 10             	sub    $0x10,%esp
  809d5b:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct lwip_thread *lt = (struct lwip_thread *)arg;
    lwip_core_lock();
    lt->func(lt->arg);
  809d5e:	ff 73 04             	pushl  0x4(%ebx)
  809d61:	ff 13                	call   *(%ebx)
    lwip_core_unlock();
    free(lt);
  809d63:	89 1c 24             	mov    %ebx,(%esp)
  809d66:	e8 72 6a 00 00       	call   8107dd <free>
}
  809d6b:	83 c4 10             	add    $0x10,%esp
  809d6e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  809d71:	c9                   	leave  
  809d72:	c3                   	ret    

00809d73 <timeout_cleanup>:
    return tid;
}

static void
timeout_cleanup(thread_id_t tid)
{
  809d73:	55                   	push   %ebp
  809d74:	89 e5                	mov    %esp,%ebp
  809d76:	83 ec 08             	sub    $0x8,%esp
  809d79:	8b 4d 08             	mov    0x8(%ebp),%ecx
    lwip_core_lock();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  809d7c:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  809d81:	89 c8                	mov    %ecx,%eax
  809d83:	f7 e2                	mul    %edx
  809d85:	c1 ea 08             	shr    $0x8,%edx
  809d88:	89 d0                	mov    %edx,%eax
  809d8a:	c1 e0 08             	shl    $0x8,%eax
  809d8d:	01 c2                	add    %eax,%edx
  809d8f:	89 c8                	mov    %ecx,%eax
  809d91:	29 d0                	sub    %edx,%eax
  809d93:	8b 04 85 40 4b b3 00 	mov    0xb34b40(,%eax,4),%eax
  809d9a:	85 c0                	test   %eax,%eax
  809d9c:	74 2a                	je     809dc8 <timeout_cleanup+0x55>
	if (t->tid == tid) {
  809d9e:	39 08                	cmp    %ecx,(%eax)
  809da0:	74 05                	je     809da7 <timeout_cleanup+0x34>
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  809da2:	8b 40 08             	mov    0x8(%eax),%eax
  809da5:	eb f3                	jmp    809d9a <timeout_cleanup+0x27>
	    LIST_REMOVE(t, link);
  809da7:	8b 50 08             	mov    0x8(%eax),%edx
  809daa:	85 d2                	test   %edx,%edx
  809dac:	74 06                	je     809db4 <timeout_cleanup+0x41>
  809dae:	8b 48 0c             	mov    0xc(%eax),%ecx
  809db1:	89 4a 0c             	mov    %ecx,0xc(%edx)
  809db4:	8b 50 0c             	mov    0xc(%eax),%edx
  809db7:	8b 48 08             	mov    0x8(%eax),%ecx
  809dba:	89 0a                	mov    %ecx,(%edx)
	    free(t);
  809dbc:	83 ec 0c             	sub    $0xc,%esp
  809dbf:	50                   	push   %eax
  809dc0:	e8 18 6a 00 00       	call   8107dd <free>
	    goto done;
  809dc5:	83 c4 10             	add    $0x10,%esp
	}

    if (debug) cprintf("timeout_cleanup: bogus tid %ld\n", tid);
 done:
    lwip_core_unlock();
}
  809dc8:	c9                   	leave  
  809dc9:	c3                   	ret    

00809dca <sys_init>:
{
  809dca:	55                   	push   %ebp
  809dcb:	89 e5                	mov    %esp,%ebp
  809dcd:	56                   	push   %esi
  809dce:	53                   	push   %ebx
  809dcf:	8b 15 60 9d b3 00    	mov    0xb39d60,%edx
  809dd5:	b8 80 9d b3 00       	mov    $0xb39d80,%eax
  809dda:	be 80 b1 b3 00       	mov    $0xb3b180,%esi
  809ddf:	eb 10                	jmp    809df1 <sys_init+0x27>
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
  809de1:	c7 41 10 60 9d b3 00 	movl   $0xb39d60,0x10(%ecx)
  809de8:	83 c0 14             	add    $0x14,%eax
  809deb:	89 ca                	mov    %ecx,%edx
    for (i = 0; i < NSEM; i++) {
  809ded:	39 f0                	cmp    %esi,%eax
  809def:	74 17                	je     809e08 <sys_init+0x3e>
  809df1:	89 c1                	mov    %eax,%ecx
	sems[i].freed = 1;
  809df3:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
  809df9:	89 50 0c             	mov    %edx,0xc(%eax)
  809dfc:	85 d2                	test   %edx,%edx
  809dfe:	74 e1                	je     809de1 <sys_init+0x17>
  809e00:	8d 58 0c             	lea    0xc(%eax),%ebx
  809e03:	89 5a 10             	mov    %ebx,0x10(%edx)
  809e06:	eb d9                	jmp    809de1 <sys_init+0x17>
  809e08:	c7 05 60 9d b3 00 6c 	movl   $0xb3b16c,0xb39d60
  809e0f:	b1 b3 00 
  809e12:	8b 15 44 4f b3 00    	mov    0xb34f44,%edx
  809e18:	b8 60 4f b3 00       	mov    $0xb34f60,%eax
  809e1d:	be 60 9d b3 00       	mov    $0xb39d60,%esi
  809e22:	eb 15                	jmp    809e39 <sys_init+0x6f>
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
  809e24:	c7 81 98 00 00 00 44 	movl   $0xb34f44,0x98(%ecx)
  809e2b:	4f b3 00 
  809e2e:	05 9c 00 00 00       	add    $0x9c,%eax
  809e33:	89 ca                	mov    %ecx,%edx
    for (i = 0; i < NMBOX; i++) {
  809e35:	39 f0                	cmp    %esi,%eax
  809e37:	74 20                	je     809e59 <sys_init+0x8f>
  809e39:	89 c1                	mov    %eax,%ecx
	mboxes[i].freed = 1;
  809e3b:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
  809e41:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
  809e47:	85 d2                	test   %edx,%edx
  809e49:	74 d9                	je     809e24 <sys_init+0x5a>
  809e4b:	8d 98 94 00 00 00    	lea    0x94(%eax),%ebx
  809e51:	89 9a 98 00 00 00    	mov    %ebx,0x98(%edx)
  809e57:	eb cb                	jmp    809e24 <sys_init+0x5a>
  809e59:	c7 05 44 4f b3 00 c4 	movl   $0xb39cc4,0xb34f44
  809e60:	9c b3 00 
}
  809e63:	5b                   	pop    %ebx
  809e64:	5e                   	pop    %esi
  809e65:	5d                   	pop    %ebp
  809e66:	c3                   	ret    

00809e67 <sys_sem_new>:
{
  809e67:	55                   	push   %ebp
  809e68:	89 e5                	mov    %esp,%ebp
  809e6a:	53                   	push   %ebx
  809e6b:	83 ec 04             	sub    $0x4,%esp
  809e6e:	8b 55 08             	mov    0x8(%ebp),%edx
    struct sys_sem_entry *se = LIST_FIRST(&sem_free);
  809e71:	a1 60 9d b3 00       	mov    0xb39d60,%eax
    if (!se) {
  809e76:	85 c0                	test   %eax,%eax
  809e78:	74 3e                	je     809eb8 <sys_sem_new+0x51>
    LIST_REMOVE(se, link);
  809e7a:	8b 48 0c             	mov    0xc(%eax),%ecx
  809e7d:	85 c9                	test   %ecx,%ecx
  809e7f:	74 06                	je     809e87 <sys_sem_new+0x20>
  809e81:	8b 58 10             	mov    0x10(%eax),%ebx
  809e84:	89 59 10             	mov    %ebx,0x10(%ecx)
  809e87:	8b 48 10             	mov    0x10(%eax),%ecx
  809e8a:	8b 58 0c             	mov    0xc(%eax),%ebx
  809e8d:	89 19                	mov    %ebx,(%ecx)
    assert(se->freed);
  809e8f:	83 38 00             	cmpl   $0x0,(%eax)
  809e92:	74 3b                	je     809ecf <sys_sem_new+0x68>
    se->freed = 0;
  809e94:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    se->counter = count;
  809e9a:	0f b6 d2             	movzbl %dl,%edx
  809e9d:	66 89 50 08          	mov    %dx,0x8(%eax)
    se->gen++;
  809ea1:	83 40 04 01          	addl   $0x1,0x4(%eax)
    return se - &sems[0];
  809ea5:	2d 80 9d b3 00       	sub    $0xb39d80,%eax
  809eaa:	c1 f8 02             	sar    $0x2,%eax
  809ead:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
}
  809eb3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  809eb6:	c9                   	leave  
  809eb7:	c3                   	ret    
	cprintf("lwip: sys_sem_new: out of semaphores\n");
  809eb8:	83 ec 0c             	sub    $0xc,%esp
  809ebb:	68 28 25 81 00       	push   $0x812528
  809ec0:	e8 69 48 00 00       	call   80e72e <cprintf>
	return SYS_SEM_NULL;
  809ec5:	83 c4 10             	add    $0x10,%esp
  809ec8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809ecd:	eb e4                	jmp    809eb3 <sys_sem_new+0x4c>
    assert(se->freed);
  809ecf:	68 9d 26 81 00       	push   $0x81269d
  809ed4:	68 a7 26 81 00       	push   $0x8126a7
  809ed9:	68 8d 00 00 00       	push   $0x8d
  809ede:	68 bc 26 81 00       	push   $0x8126bc
  809ee3:	e8 6b 47 00 00       	call   80e653 <_panic>

00809ee8 <sys_sem_free>:
{
  809ee8:	55                   	push   %ebp
  809ee9:	89 e5                	mov    %esp,%ebp
  809eeb:	83 ec 08             	sub    $0x8,%esp
  809eee:	8b 45 08             	mov    0x8(%ebp),%eax
    assert(!sems[sem].freed);
  809ef1:	8d 14 80             	lea    (%eax,%eax,4),%edx
  809ef4:	83 3c 95 80 9d b3 00 	cmpl   $0x0,0xb39d80(,%edx,4)
  809efb:	00 
  809efc:	75 5a                	jne    809f58 <sys_sem_free+0x70>
    sems[sem].freed = 1;
  809efe:	8d 14 80             	lea    (%eax,%eax,4),%edx
  809f01:	c1 e2 02             	shl    $0x2,%edx
  809f04:	8d 8a 80 9d b3 00    	lea    0xb39d80(%edx),%ecx
  809f0a:	c7 82 80 9d b3 00 01 	movl   $0x1,0xb39d80(%edx)
  809f11:	00 00 00 
    sems[sem].gen++;
  809f14:	83 41 04 01          	addl   $0x1,0x4(%ecx)
    LIST_INSERT_HEAD(&sem_free, &sems[sem], link);
  809f18:	8b 15 60 9d b3 00    	mov    0xb39d60,%edx
  809f1e:	89 51 0c             	mov    %edx,0xc(%ecx)
  809f21:	85 d2                	test   %edx,%edx
  809f23:	74 0d                	je     809f32 <sys_sem_free+0x4a>
  809f25:	8d 0c 80             	lea    (%eax,%eax,4),%ecx
  809f28:	8d 0c 8d 8c 9d b3 00 	lea    0xb39d8c(,%ecx,4),%ecx
  809f2f:	89 4a 10             	mov    %ecx,0x10(%edx)
  809f32:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  809f39:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  809f3c:	8d 0c 8d 80 9d b3 00 	lea    0xb39d80(,%ecx,4),%ecx
  809f43:	89 0d 60 9d b3 00    	mov    %ecx,0xb39d60
  809f49:	01 d0                	add    %edx,%eax
  809f4b:	c7 04 85 90 9d b3 00 	movl   $0xb39d60,0xb39d90(,%eax,4)
  809f52:	60 9d b3 00 
}
  809f56:	c9                   	leave  
  809f57:	c3                   	ret    
    assert(!sems[sem].freed);
  809f58:	68 d9 26 81 00       	push   $0x8126d9
  809f5d:	68 a7 26 81 00       	push   $0x8126a7
  809f62:	68 98 00 00 00       	push   $0x98
  809f67:	68 bc 26 81 00       	push   $0x8126bc
  809f6c:	e8 e2 46 00 00       	call   80e653 <_panic>

00809f71 <sys_mbox_free>:
{
  809f71:	55                   	push   %ebp
  809f72:	89 e5                	mov    %esp,%ebp
  809f74:	56                   	push   %esi
  809f75:	53                   	push   %ebx
  809f76:	8b 5d 08             	mov    0x8(%ebp),%ebx
    assert(!mboxes[mbox].freed);
  809f79:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  809f7f:	83 b8 60 4f b3 00 00 	cmpl   $0x0,0xb34f60(%eax)
  809f86:	75 72                	jne    809ffa <sys_mbox_free+0x89>
    sys_sem_free(mboxes[mbox].queued_msg);
  809f88:	83 ec 0c             	sub    $0xc,%esp
  809f8b:	69 f3 9c 00 00 00    	imul   $0x9c,%ebx,%esi
  809f91:	ff b6 ec 4f b3 00    	pushl  0xb34fec(%esi)
  809f97:	e8 4c ff ff ff       	call   809ee8 <sys_sem_free>
    sys_sem_free(mboxes[mbox].free_msg);
  809f9c:	83 c4 04             	add    $0x4,%esp
  809f9f:	ff b6 f0 4f b3 00    	pushl  0xb34ff0(%esi)
  809fa5:	e8 3e ff ff ff       	call   809ee8 <sys_sem_free>
    LIST_INSERT_HEAD(&mbox_free, &mboxes[mbox], link);
  809faa:	a1 44 4f b3 00       	mov    0xb34f44,%eax
  809faf:	89 86 f4 4f b3 00    	mov    %eax,0xb34ff4(%esi)
  809fb5:	83 c4 10             	add    $0x10,%esp
  809fb8:	85 c0                	test   %eax,%eax
  809fba:	74 12                	je     809fce <sys_mbox_free+0x5d>
  809fbc:	69 d3 9c 00 00 00    	imul   $0x9c,%ebx,%edx
  809fc2:	81 c2 f4 4f b3 00    	add    $0xb34ff4,%edx
  809fc8:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  809fce:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  809fd4:	8d 83 60 4f b3 00    	lea    0xb34f60(%ebx),%eax
  809fda:	a3 44 4f b3 00       	mov    %eax,0xb34f44
  809fdf:	c7 83 f8 4f b3 00 44 	movl   $0xb34f44,0xb34ff8(%ebx)
  809fe6:	4f b3 00 
    mboxes[mbox].freed = 1;
  809fe9:	c7 83 60 4f b3 00 01 	movl   $0x1,0xb34f60(%ebx)
  809ff0:	00 00 00 
}
  809ff3:	8d 65 f8             	lea    -0x8(%ebp),%esp
  809ff6:	5b                   	pop    %ebx
  809ff7:	5e                   	pop    %esi
  809ff8:	5d                   	pop    %ebp
  809ff9:	c3                   	ret    
    assert(!mboxes[mbox].freed);
  809ffa:	68 ea 26 81 00       	push   $0x8126ea
  809fff:	68 a7 26 81 00       	push   $0x8126a7
  80a004:	6a 62                	push   $0x62
  80a006:	68 bc 26 81 00       	push   $0x8126bc
  80a00b:	e8 43 46 00 00       	call   80e653 <_panic>

0080a010 <sys_mbox_new>:
{
  80a010:	55                   	push   %ebp
  80a011:	89 e5                	mov    %esp,%ebp
  80a013:	57                   	push   %edi
  80a014:	56                   	push   %esi
  80a015:	53                   	push   %ebx
  80a016:	83 ec 0c             	sub    $0xc,%esp
    assert(size < MBOXSLOTS);
  80a019:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
  80a01d:	0f 8f 9f 00 00 00    	jg     80a0c2 <sys_mbox_new+0xb2>
    struct sys_mbox_entry *mbe = LIST_FIRST(&mbox_free);
  80a023:	8b 1d 44 4f b3 00    	mov    0xb34f44,%ebx
    if (!mbe) {
  80a029:	85 db                	test   %ebx,%ebx
  80a02b:	0f 84 a7 00 00 00    	je     80a0d8 <sys_mbox_new+0xc8>
    LIST_REMOVE(mbe, link);
  80a031:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  80a037:	85 c0                	test   %eax,%eax
  80a039:	74 0c                	je     80a047 <sys_mbox_new+0x37>
  80a03b:	8b 93 98 00 00 00    	mov    0x98(%ebx),%edx
  80a041:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  80a047:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  80a04d:	8b 93 94 00 00 00    	mov    0x94(%ebx),%edx
  80a053:	89 10                	mov    %edx,(%eax)
    assert(mbe->freed);
  80a055:	83 3b 00             	cmpl   $0x0,(%ebx)
  80a058:	0f 84 91 00 00 00    	je     80a0ef <sys_mbox_new+0xdf>
    mbe->freed = 0;
  80a05e:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    int i = mbe - &mboxes[0];
  80a064:	89 de                	mov    %ebx,%esi
  80a066:	81 ee 60 4f b3 00    	sub    $0xb34f60,%esi
  80a06c:	c1 fe 02             	sar    $0x2,%esi
  80a06f:	69 f6 97 6f f9 96    	imul   $0x96f96f97,%esi,%esi
  80a075:	89 f7                	mov    %esi,%edi
    mbe->head = -1;
  80a077:	c7 43 04 ff ff ff ff 	movl   $0xffffffff,0x4(%ebx)
    mbe->nextq = 0;
  80a07e:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mbe->queued_msg = sys_sem_new(0);
  80a085:	83 ec 0c             	sub    $0xc,%esp
  80a088:	6a 00                	push   $0x0
  80a08a:	e8 d8 fd ff ff       	call   809e67 <sys_sem_new>
  80a08f:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
    mbe->free_msg = sys_sem_new(MBOXSLOTS);
  80a095:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  80a09c:	e8 c6 fd ff ff       	call   809e67 <sys_sem_new>
  80a0a1:	89 83 90 00 00 00    	mov    %eax,0x90(%ebx)
    if (mbe->queued_msg == SYS_SEM_NULL ||
  80a0a7:	83 c4 10             	add    $0x10,%esp
  80a0aa:	83 bb 8c 00 00 00 ff 	cmpl   $0xffffffff,0x8c(%ebx)
  80a0b1:	74 52                	je     80a105 <sys_mbox_new+0xf5>
  80a0b3:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a0b6:	74 4d                	je     80a105 <sys_mbox_new+0xf5>
}
  80a0b8:	89 f8                	mov    %edi,%eax
  80a0ba:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a0bd:	5b                   	pop    %ebx
  80a0be:	5e                   	pop    %esi
  80a0bf:	5f                   	pop    %edi
  80a0c0:	5d                   	pop    %ebp
  80a0c1:	c3                   	ret    
    assert(size < MBOXSLOTS);
  80a0c2:	68 fe 26 81 00       	push   $0x8126fe
  80a0c7:	68 a7 26 81 00       	push   $0x8126a7
  80a0cc:	6a 45                	push   $0x45
  80a0ce:	68 bc 26 81 00       	push   $0x8126bc
  80a0d3:	e8 7b 45 00 00       	call   80e653 <_panic>
	cprintf("lwip: sys_mbox_new: out of mailboxes\n");
  80a0d8:	83 ec 0c             	sub    $0xc,%esp
  80a0db:	68 50 25 81 00       	push   $0x812550
  80a0e0:	e8 49 46 00 00       	call   80e72e <cprintf>
	return SYS_MBOX_NULL;
  80a0e5:	83 c4 10             	add    $0x10,%esp
  80a0e8:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  80a0ed:	eb c9                	jmp    80a0b8 <sys_mbox_new+0xa8>
    assert(mbe->freed);
  80a0ef:	68 0f 27 81 00       	push   $0x81270f
  80a0f4:	68 a7 26 81 00       	push   $0x8126a7
  80a0f9:	6a 4c                	push   $0x4c
  80a0fb:	68 bc 26 81 00       	push   $0x8126bc
  80a100:	e8 4e 45 00 00       	call   80e653 <_panic>
	sys_mbox_free(i);
  80a105:	83 ec 0c             	sub    $0xc,%esp
  80a108:	56                   	push   %esi
  80a109:	e8 63 fe ff ff       	call   809f71 <sys_mbox_free>
	cprintf("lwip: sys_mbox_new: can't get semaphore\n");
  80a10e:	c7 04 24 78 25 81 00 	movl   $0x812578,(%esp)
  80a115:	e8 14 46 00 00       	call   80e72e <cprintf>
	return SYS_MBOX_NULL;
  80a11a:	83 c4 10             	add    $0x10,%esp
  80a11d:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  80a122:	eb 94                	jmp    80a0b8 <sys_mbox_new+0xa8>

0080a124 <sys_sem_signal>:
{
  80a124:	55                   	push   %ebp
  80a125:	89 e5                	mov    %esp,%ebp
  80a127:	83 ec 08             	sub    $0x8,%esp
  80a12a:	8b 45 08             	mov    0x8(%ebp),%eax
    assert(!sems[sem].freed);
  80a12d:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a130:	83 3c 95 80 9d b3 00 	cmpl   $0x0,0xb39d80(,%edx,4)
  80a137:	00 
  80a138:	75 18                	jne    80a152 <sys_sem_signal+0x2e>
    sems[sem].counter++;
  80a13a:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a13d:	8d 14 95 80 9d b3 00 	lea    0xb39d80(,%edx,4),%edx
  80a144:	66 83 42 08 01       	addw   $0x1,0x8(%edx)
    if (sems[sem].waiters) {
  80a149:	66 83 7a 0a 00       	cmpw   $0x0,0xa(%edx)
  80a14e:	75 1b                	jne    80a16b <sys_sem_signal+0x47>
}
  80a150:	c9                   	leave  
  80a151:	c3                   	ret    
    assert(!sems[sem].freed);
  80a152:	68 d9 26 81 00       	push   $0x8126d9
  80a157:	68 a7 26 81 00       	push   $0x8126a7
  80a15c:	68 a1 00 00 00       	push   $0xa1
  80a161:	68 bc 26 81 00       	push   $0x8126bc
  80a166:	e8 e8 44 00 00       	call   80e653 <_panic>
	sems[sem].waiters = 0;
  80a16b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  80a172:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  80a175:	66 c7 04 8d 8a 9d b3 	movw   $0x0,0xb39d8a(,%ecx,4)
  80a17c:	00 00 00 
	thread_wakeup(&sems[sem].v);
  80a17f:	83 ec 0c             	sub    $0xc,%esp
  80a182:	8d 04 8d 88 9d b3 00 	lea    0xb39d88(,%ecx,4),%eax
  80a189:	50                   	push   %eax
  80a18a:	e8 bb 04 00 00       	call   80a64a <thread_wakeup>
  80a18f:	83 c4 10             	add    $0x10,%esp
}
  80a192:	eb bc                	jmp    80a150 <sys_sem_signal+0x2c>

0080a194 <sys_arch_sem_wait>:
{
  80a194:	55                   	push   %ebp
  80a195:	89 e5                	mov    %esp,%ebp
  80a197:	57                   	push   %edi
  80a198:	56                   	push   %esi
  80a199:	53                   	push   %ebx
  80a19a:	83 ec 1c             	sub    $0x1c,%esp
  80a19d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    assert(!sems[sem].freed);
  80a1a0:	8b 45 08             	mov    0x8(%ebp),%eax
  80a1a3:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80a1a6:	83 3c 85 80 9d b3 00 	cmpl   $0x0,0xb39d80(,%eax,4)
  80a1ad:	00 
  80a1ae:	75 2c                	jne    80a1dc <sys_arch_sem_wait+0x48>
    int gen = sems[sem].gen;
  80a1b0:	8b 45 08             	mov    0x8(%ebp),%eax
  80a1b3:	c1 e0 02             	shl    $0x2,%eax
  80a1b6:	89 c2                	mov    %eax,%edx
  80a1b8:	03 55 08             	add    0x8(%ebp),%edx
  80a1bb:	8b 3c 95 84 9d b3 00 	mov    0xb39d84(,%edx,4),%edi
  80a1c2:	89 7d d8             	mov    %edi,-0x28(%ebp)
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  80a1c5:	8d 04 95 88 9d b3 00 	lea    0xb39d88(,%edx,4),%eax
  80a1cc:	89 45 dc             	mov    %eax,-0x24(%ebp)
    u32_t waited = 0;
  80a1cf:	bf 00 00 00 00       	mov    $0x0,%edi
	if (sems[sem].counter > 0) {
  80a1d4:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    while (tm_msec == 0 || waited < tm_msec) {
  80a1d7:	e9 80 00 00 00       	jmp    80a25c <sys_arch_sem_wait+0xc8>
    assert(!sems[sem].freed);
  80a1dc:	68 d9 26 81 00       	push   $0x8126d9
  80a1e1:	68 a7 26 81 00       	push   $0x8126a7
  80a1e6:	68 ac 00 00 00       	push   $0xac
  80a1eb:	68 bc 26 81 00       	push   $0x8126bc
  80a1f0:	e8 5e 44 00 00       	call   80e653 <_panic>
	if (sems[sem].counter > 0) {
  80a1f5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80a1f8:	0f b7 04 85 88 9d b3 	movzwl 0xb39d88(,%eax,4),%eax
  80a1ff:	00 
  80a200:	66 85 c0             	test   %ax,%ax
  80a203:	75 6e                	jne    80a273 <sys_arch_sem_wait+0xdf>
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
  80a205:	83 fb fe             	cmp    $0xfffffffe,%ebx
  80a208:	0f 84 8f 00 00 00    	je     80a29d <sys_arch_sem_wait+0x109>
	    uint32_t a = sys_time_msec();
  80a20e:	e8 a2 51 00 00       	call   80f3b5 <sys_time_msec>
  80a213:	89 c1                	mov    %eax,%ecx
  80a215:	89 45 e0             	mov    %eax,-0x20(%ebp)
	    uint32_t sleep_until = tm_msec ? a + (tm_msec - waited) : ~0;
  80a218:	89 d8                	mov    %ebx,%eax
  80a21a:	29 f8                	sub    %edi,%eax
  80a21c:	01 c8                	add    %ecx,%eax
  80a21e:	85 db                	test   %ebx,%ebx
  80a220:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  80a225:	0f 44 c2             	cmove  %edx,%eax
	    sems[sem].waiters = 1;
  80a228:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80a22b:	8d 34 95 80 9d b3 00 	lea    0xb39d80(,%edx,4),%esi
  80a232:	66 c7 46 0a 01 00    	movw   $0x1,0xa(%esi)
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  80a238:	83 ec 04             	sub    $0x4,%esp
  80a23b:	50                   	push   %eax
  80a23c:	ff 76 08             	pushl  0x8(%esi)
  80a23f:	ff 75 dc             	pushl  -0x24(%ebp)
  80a242:	e8 1d 06 00 00       	call   80a864 <thread_wait>
	    if (gen != sems[sem].gen) {
  80a247:	83 c4 10             	add    $0x10,%esp
  80a24a:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80a24d:	39 46 04             	cmp    %eax,0x4(%esi)
  80a250:	75 34                	jne    80a286 <sys_arch_sem_wait+0xf2>
	    uint32_t b = sys_time_msec();
  80a252:	e8 5e 51 00 00       	call   80f3b5 <sys_time_msec>
	    waited += (b - a);
  80a257:	2b 45 e0             	sub    -0x20(%ebp),%eax
  80a25a:	01 c7                	add    %eax,%edi
    while (tm_msec == 0 || waited < tm_msec) {
  80a25c:	85 db                	test   %ebx,%ebx
  80a25e:	74 95                	je     80a1f5 <sys_arch_sem_wait+0x61>
  80a260:	39 df                	cmp    %ebx,%edi
  80a262:	72 91                	jb     80a1f5 <sys_arch_sem_wait+0x61>
    return SYS_ARCH_TIMEOUT;
  80a264:	bf ff ff ff ff       	mov    $0xffffffff,%edi
}
  80a269:	89 f8                	mov    %edi,%eax
  80a26b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a26e:	5b                   	pop    %ebx
  80a26f:	5e                   	pop    %esi
  80a270:	5f                   	pop    %edi
  80a271:	5d                   	pop    %ebp
  80a272:	c3                   	ret    
	    sems[sem].counter--;
  80a273:	8b 55 08             	mov    0x8(%ebp),%edx
  80a276:	8d 14 92             	lea    (%edx,%edx,4),%edx
  80a279:	83 e8 01             	sub    $0x1,%eax
  80a27c:	66 89 04 95 88 9d b3 	mov    %ax,0xb39d88(,%edx,4)
  80a283:	00 
	    return waited;
  80a284:	eb e3                	jmp    80a269 <sys_arch_sem_wait+0xd5>
		cprintf("sys_arch_sem_wait: sem freed under waiter!\n");
  80a286:	83 ec 0c             	sub    $0xc,%esp
  80a289:	68 a4 25 81 00       	push   $0x8125a4
  80a28e:	e8 9b 44 00 00       	call   80e72e <cprintf>
		return SYS_ARCH_TIMEOUT;
  80a293:	83 c4 10             	add    $0x10,%esp
  80a296:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  80a29b:	eb cc                	jmp    80a269 <sys_arch_sem_wait+0xd5>
	    return SYS_ARCH_TIMEOUT;
  80a29d:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  80a2a2:	eb c5                	jmp    80a269 <sys_arch_sem_wait+0xd5>

0080a2a4 <sys_mbox_trypost>:
{
  80a2a4:	55                   	push   %ebp
  80a2a5:	89 e5                	mov    %esp,%ebp
  80a2a7:	57                   	push   %edi
  80a2a8:	56                   	push   %esi
  80a2a9:	53                   	push   %ebx
  80a2aa:	83 ec 0c             	sub    $0xc,%esp
  80a2ad:	8b 5d 08             	mov    0x8(%ebp),%ebx
    assert(!mboxes[mbox].freed);
  80a2b0:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a2b6:	83 b8 60 4f b3 00 00 	cmpl   $0x0,0xb34f60(%eax)
  80a2bd:	75 7f                	jne    80a33e <sys_mbox_trypost+0x9a>
    sys_arch_sem_wait(mboxes[mbox].free_msg, 0);
  80a2bf:	83 ec 08             	sub    $0x8,%esp
  80a2c2:	6a 00                	push   $0x0
  80a2c4:	69 f3 9c 00 00 00    	imul   $0x9c,%ebx,%esi
  80a2ca:	ff b6 f0 4f b3 00    	pushl  0xb34ff0(%esi)
  80a2d0:	e8 bf fe ff ff       	call   80a194 <sys_arch_sem_wait>
    if (mboxes[mbox].nextq == mboxes[mbox].head)
  80a2d5:	8b 96 68 4f b3 00    	mov    0xb34f68(%esi),%edx
  80a2db:	8b 8e 64 4f b3 00    	mov    0xb34f64(%esi),%ecx
  80a2e1:	83 c4 10             	add    $0x10,%esp
  80a2e4:	39 ca                	cmp    %ecx,%edx
  80a2e6:	74 7a                	je     80a362 <sys_mbox_trypost+0xbe>
    mboxes[mbox].nextq = (slot + 1) % MBOXSLOTS;
  80a2e8:	69 f3 9c 00 00 00    	imul   $0x9c,%ebx,%esi
  80a2ee:	8d 42 01             	lea    0x1(%edx),%eax
  80a2f1:	89 c7                	mov    %eax,%edi
  80a2f3:	c1 ff 1f             	sar    $0x1f,%edi
  80a2f6:	c1 ef 1b             	shr    $0x1b,%edi
  80a2f9:	01 f8                	add    %edi,%eax
  80a2fb:	83 e0 1f             	and    $0x1f,%eax
  80a2fe:	29 f8                	sub    %edi,%eax
  80a300:	89 86 68 4f b3 00    	mov    %eax,0xb34f68(%esi)
    mboxes[mbox].msg[slot] = msg;
  80a306:	6b c3 27             	imul   $0x27,%ebx,%eax
  80a309:	01 d0                	add    %edx,%eax
  80a30b:	8b 75 0c             	mov    0xc(%ebp),%esi
  80a30e:	89 34 85 6c 4f b3 00 	mov    %esi,0xb34f6c(,%eax,4)
    if (mboxes[mbox].head == -1)
  80a315:	83 f9 ff             	cmp    $0xffffffff,%ecx
  80a318:	74 3a                	je     80a354 <sys_mbox_trypost+0xb0>
    sys_sem_signal(mboxes[mbox].queued_msg);
  80a31a:	83 ec 0c             	sub    $0xc,%esp
  80a31d:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  80a323:	ff b3 ec 4f b3 00    	pushl  0xb34fec(%ebx)
  80a329:	e8 f6 fd ff ff       	call   80a124 <sys_sem_signal>
    return ERR_OK;
  80a32e:	83 c4 10             	add    $0x10,%esp
  80a331:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80a336:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a339:	5b                   	pop    %ebx
  80a33a:	5e                   	pop    %esi
  80a33b:	5f                   	pop    %edi
  80a33c:	5d                   	pop    %ebp
  80a33d:	c3                   	ret    
    assert(!mboxes[mbox].freed);
  80a33e:	68 ea 26 81 00       	push   $0x8126ea
  80a343:	68 a7 26 81 00       	push   $0x8126a7
  80a348:	6a 72                	push   $0x72
  80a34a:	68 bc 26 81 00       	push   $0x8126bc
  80a34f:	e8 ff 42 00 00       	call   80e653 <_panic>
	mboxes[mbox].head = slot;
  80a354:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a35a:	89 90 64 4f b3 00    	mov    %edx,0xb34f64(%eax)
  80a360:	eb b8                	jmp    80a31a <sys_mbox_trypost+0x76>
	return ERR_MEM;
  80a362:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80a367:	eb cd                	jmp    80a336 <sys_mbox_trypost+0x92>

0080a369 <sys_mbox_post>:
{
  80a369:	55                   	push   %ebp
  80a36a:	89 e5                	mov    %esp,%ebp
  80a36c:	83 ec 10             	sub    $0x10,%esp
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
  80a36f:	ff 75 0c             	pushl  0xc(%ebp)
  80a372:	ff 75 08             	pushl  0x8(%ebp)
  80a375:	e8 2a ff ff ff       	call   80a2a4 <sys_mbox_trypost>
  80a37a:	83 c4 10             	add    $0x10,%esp
  80a37d:	84 c0                	test   %al,%al
  80a37f:	75 02                	jne    80a383 <sys_mbox_post+0x1a>
}
  80a381:	c9                   	leave  
  80a382:	c3                   	ret    
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
  80a383:	68 d0 25 81 00       	push   $0x8125d0
  80a388:	68 a7 26 81 00       	push   $0x8126a7
  80a38d:	6a 6c                	push   $0x6c
  80a38f:	68 bc 26 81 00       	push   $0x8126bc
  80a394:	e8 ba 42 00 00       	call   80e653 <_panic>

0080a399 <sys_arch_mbox_fetch>:
{
  80a399:	55                   	push   %ebp
  80a39a:	89 e5                	mov    %esp,%ebp
  80a39c:	57                   	push   %edi
  80a39d:	56                   	push   %esi
  80a39e:	53                   	push   %ebx
  80a39f:	83 ec 0c             	sub    $0xc,%esp
  80a3a2:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80a3a5:	8b 7d 0c             	mov    0xc(%ebp),%edi
    assert(!mboxes[mbox].freed);
  80a3a8:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a3ae:	83 b8 60 4f b3 00 00 	cmpl   $0x0,0xb34f60(%eax)
  80a3b5:	0f 85 8a 00 00 00    	jne    80a445 <sys_arch_mbox_fetch+0xac>
    u32_t waited = sys_arch_sem_wait(mboxes[mbox].queued_msg, tm_msec);
  80a3bb:	83 ec 08             	sub    $0x8,%esp
  80a3be:	ff 75 10             	pushl  0x10(%ebp)
  80a3c1:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a3c7:	ff b0 ec 4f b3 00    	pushl  0xb34fec(%eax)
  80a3cd:	e8 c2 fd ff ff       	call   80a194 <sys_arch_sem_wait>
  80a3d2:	89 c6                	mov    %eax,%esi
    if (waited == SYS_ARCH_TIMEOUT)
  80a3d4:	83 c4 10             	add    $0x10,%esp
  80a3d7:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a3da:	74 5f                	je     80a43b <sys_arch_mbox_fetch+0xa2>
    int slot = mboxes[mbox].head;
  80a3dc:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a3e2:	8b 80 64 4f b3 00    	mov    0xb34f64(%eax),%eax
    if (slot == -1)
  80a3e8:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a3eb:	74 71                	je     80a45e <sys_arch_mbox_fetch+0xc5>
    if (msg)
  80a3ed:	85 ff                	test   %edi,%edi
  80a3ef:	74 0e                	je     80a3ff <sys_arch_mbox_fetch+0x66>
	*msg = mboxes[mbox].msg[slot];
  80a3f1:	6b d3 27             	imul   $0x27,%ebx,%edx
  80a3f4:	01 c2                	add    %eax,%edx
  80a3f6:	8b 14 95 6c 4f b3 00 	mov    0xb34f6c(,%edx,4),%edx
  80a3fd:	89 17                	mov    %edx,(%edi)
    mboxes[mbox].head = (slot + 1) % MBOXSLOTS;
  80a3ff:	83 c0 01             	add    $0x1,%eax
  80a402:	99                   	cltd   
  80a403:	c1 ea 1b             	shr    $0x1b,%edx
  80a406:	01 d0                	add    %edx,%eax
  80a408:	83 e0 1f             	and    $0x1f,%eax
  80a40b:	29 d0                	sub    %edx,%eax
  80a40d:	69 d3 9c 00 00 00    	imul   $0x9c,%ebx,%edx
  80a413:	89 82 64 4f b3 00    	mov    %eax,0xb34f64(%edx)
  80a419:	81 c2 60 4f b3 00    	add    $0xb34f60,%edx
    if (mboxes[mbox].head == mboxes[mbox].nextq)
  80a41f:	3b 42 08             	cmp    0x8(%edx),%eax
  80a422:	74 51                	je     80a475 <sys_arch_mbox_fetch+0xdc>
    sys_sem_signal(mboxes[mbox].free_msg);
  80a424:	83 ec 0c             	sub    $0xc,%esp
  80a427:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  80a42d:	ff b3 f0 4f b3 00    	pushl  0xb34ff0(%ebx)
  80a433:	e8 ec fc ff ff       	call   80a124 <sys_sem_signal>
    return waited;
  80a438:	83 c4 10             	add    $0x10,%esp
}
  80a43b:	89 f0                	mov    %esi,%eax
  80a43d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a440:	5b                   	pop    %ebx
  80a441:	5e                   	pop    %esi
  80a442:	5f                   	pop    %edi
  80a443:	5d                   	pop    %ebp
  80a444:	c3                   	ret    
    assert(!mboxes[mbox].freed);
  80a445:	68 ea 26 81 00       	push   $0x8126ea
  80a44a:	68 a7 26 81 00       	push   $0x8126a7
  80a44f:	68 ce 00 00 00       	push   $0xce
  80a454:	68 bc 26 81 00       	push   $0x8126bc
  80a459:	e8 f5 41 00 00       	call   80e653 <_panic>
	panic("lwip: sys_arch_mbox_fetch: no message");
  80a45e:	83 ec 04             	sub    $0x4,%esp
  80a461:	68 f8 25 81 00       	push   $0x8125f8
  80a466:	68 d6 00 00 00       	push   $0xd6
  80a46b:	68 bc 26 81 00       	push   $0x8126bc
  80a470:	e8 de 41 00 00       	call   80e653 <_panic>
	mboxes[mbox].head = -1;
  80a475:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a47b:	c7 80 64 4f b3 00 ff 	movl   $0xffffffff,0xb34f64(%eax)
  80a482:	ff ff ff 
  80a485:	eb 9d                	jmp    80a424 <sys_arch_mbox_fetch+0x8b>

0080a487 <sys_arch_mbox_tryfetch>:
{
  80a487:	55                   	push   %ebp
  80a488:	89 e5                	mov    %esp,%ebp
  80a48a:	83 ec 0c             	sub    $0xc,%esp
    return sys_arch_mbox_fetch(mbox, msg, SYS_ARCH_NOWAIT);
  80a48d:	6a fe                	push   $0xfffffffe
  80a48f:	ff 75 0c             	pushl  0xc(%ebp)
  80a492:	ff 75 08             	pushl  0x8(%ebp)
  80a495:	e8 ff fe ff ff       	call   80a399 <sys_arch_mbox_fetch>
}
  80a49a:	c9                   	leave  
  80a49b:	c3                   	ret    

0080a49c <sys_thread_new>:
{
  80a49c:	55                   	push   %ebp
  80a49d:	89 e5                	mov    %esp,%ebp
  80a49f:	83 ec 24             	sub    $0x24,%esp
    struct lwip_thread *lt = malloc(sizeof(*lt));
  80a4a2:	6a 08                	push   $0x8
  80a4a4:	e8 e2 63 00 00       	call   81088b <malloc>
    if (lt == 0)
  80a4a9:	83 c4 10             	add    $0x10,%esp
  80a4ac:	85 c0                	test   %eax,%eax
  80a4ae:	74 32                	je     80a4e2 <sys_thread_new+0x46>
    if (stacksize > PGSIZE)
  80a4b0:	81 7d 14 00 10 00 00 	cmpl   $0x1000,0x14(%ebp)
  80a4b7:	7f 40                	jg     80a4f9 <sys_thread_new+0x5d>
    lt->func = thread;
  80a4b9:	8b 55 0c             	mov    0xc(%ebp),%edx
  80a4bc:	89 10                	mov    %edx,(%eax)
    lt->arg = arg;
  80a4be:	8b 55 10             	mov    0x10(%ebp),%edx
  80a4c1:	89 50 04             	mov    %edx,0x4(%eax)
    int r = thread_create(&tid, name, lwip_thread_entry, (uint32_t)lt);
  80a4c4:	50                   	push   %eax
  80a4c5:	68 54 9d 80 00       	push   $0x809d54
  80a4ca:	ff 75 08             	pushl  0x8(%ebp)
  80a4cd:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80a4d0:	50                   	push   %eax
  80a4d1:	e8 e2 01 00 00       	call   80a6b8 <thread_create>
    if (r < 0)
  80a4d6:	83 c4 10             	add    $0x10,%esp
  80a4d9:	85 c0                	test   %eax,%eax
  80a4db:	78 33                	js     80a510 <sys_thread_new+0x74>
}
  80a4dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80a4e0:	c9                   	leave  
  80a4e1:	c3                   	ret    
	panic("sys_thread_new: cannot allocate thread struct");
  80a4e2:	83 ec 04             	sub    $0x4,%esp
  80a4e5:	68 20 26 81 00       	push   $0x812620
  80a4ea:	68 fd 00 00 00       	push   $0xfd
  80a4ef:	68 bc 26 81 00       	push   $0x8126bc
  80a4f4:	e8 5a 41 00 00       	call   80e653 <_panic>
	panic("large stack %d", stacksize);
  80a4f9:	ff 75 14             	pushl  0x14(%ebp)
  80a4fc:	68 1a 27 81 00       	push   $0x81271a
  80a501:	68 00 01 00 00       	push   $0x100
  80a506:	68 bc 26 81 00       	push   $0x8126bc
  80a50b:	e8 43 41 00 00       	call   80e653 <_panic>
	panic("lwip: sys_thread_new: cannot create: %s\n", e2s(r));
  80a510:	83 ec 0c             	sub    $0xc,%esp
  80a513:	50                   	push   %eax
  80a514:	e8 d0 04 00 00       	call   80a9e9 <e2s>
  80a519:	50                   	push   %eax
  80a51a:	68 50 26 81 00       	push   $0x812650
  80a51f:	68 09 01 00 00       	push   $0x109
  80a524:	68 bc 26 81 00       	push   $0x8126bc
  80a529:	e8 25 41 00 00       	call   80e653 <_panic>

0080a52e <sys_arch_timeouts>:

struct sys_timeouts *
sys_arch_timeouts(void)
{
  80a52e:	55                   	push   %ebp
  80a52f:	89 e5                	mov    %esp,%ebp
  80a531:	57                   	push   %edi
  80a532:	56                   	push   %esi
  80a533:	53                   	push   %ebx
  80a534:	83 ec 0c             	sub    $0xc,%esp
    thread_id_t tid = thread_id();
  80a537:	e8 02 01 00 00       	call   80a63e <thread_id>
  80a53c:	89 c7                	mov    %eax,%edi

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80a53e:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  80a543:	f7 e2                	mul    %edx
  80a545:	c1 ea 08             	shr    $0x8,%edx
  80a548:	89 d6                	mov    %edx,%esi
  80a54a:	c1 e2 08             	shl    $0x8,%edx
  80a54d:	01 d6                	add    %edx,%esi
  80a54f:	89 f8                	mov    %edi,%eax
  80a551:	29 f0                	sub    %esi,%eax
  80a553:	89 c6                	mov    %eax,%esi
  80a555:	8b 1c 85 40 4b b3 00 	mov    0xb34b40(,%eax,4),%ebx
  80a55c:	85 db                	test   %ebx,%ebx
  80a55e:	74 09                	je     80a569 <sys_arch_timeouts+0x3b>
	if (t->tid == tid)
  80a560:	39 3b                	cmp    %edi,(%ebx)
  80a562:	74 6d                	je     80a5d1 <sys_arch_timeouts+0xa3>
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80a564:	8b 5b 08             	mov    0x8(%ebx),%ebx
  80a567:	eb f3                	jmp    80a55c <sys_arch_timeouts+0x2e>
	    goto out;

    t = malloc(sizeof(*t));
  80a569:	83 ec 0c             	sub    $0xc,%esp
  80a56c:	6a 10                	push   $0x10
  80a56e:	e8 18 63 00 00       	call   81088b <malloc>
  80a573:	89 c3                	mov    %eax,%ebx
    if (t == 0)
  80a575:	83 c4 10             	add    $0x10,%esp
  80a578:	85 c0                	test   %eax,%eax
  80a57a:	74 60                	je     80a5dc <sys_arch_timeouts+0xae>
	panic("sys_arch_timeouts: cannot malloc");

    int r = thread_onhalt(timeout_cleanup);
  80a57c:	83 ec 0c             	sub    $0xc,%esp
  80a57f:	68 73 9d 80 00       	push   $0x809d73
  80a584:	e8 05 01 00 00       	call   80a68e <thread_onhalt>
    if (r < 0)
  80a589:	83 c4 10             	add    $0x10,%esp
  80a58c:	85 c0                	test   %eax,%eax
  80a58e:	78 63                	js     80a5f3 <sys_arch_timeouts+0xc5>
	panic("thread_onhalt failed: %s", e2s(r));

    t->tid = tid;
  80a590:	89 3b                	mov    %edi,(%ebx)
    memset(&t->tmo, 0, sizeof(t->tmo));
  80a592:	83 ec 04             	sub    $0x4,%esp
  80a595:	6a 04                	push   $0x4
  80a597:	6a 00                	push   $0x0
  80a599:	8d 43 04             	lea    0x4(%ebx),%eax
  80a59c:	50                   	push   %eax
  80a59d:	e8 6a 49 00 00       	call   80ef0c <memset>
    LIST_INSERT_HEAD(&threads[tid % thread_hash_size], t, link);
  80a5a2:	8b 04 b5 40 4b b3 00 	mov    0xb34b40(,%esi,4),%eax
  80a5a9:	89 43 08             	mov    %eax,0x8(%ebx)
  80a5ac:	83 c4 10             	add    $0x10,%esp
  80a5af:	85 c0                	test   %eax,%eax
  80a5b1:	74 0d                	je     80a5c0 <sys_arch_timeouts+0x92>
  80a5b3:	8b 04 b5 40 4b b3 00 	mov    0xb34b40(,%esi,4),%eax
  80a5ba:	8d 53 08             	lea    0x8(%ebx),%edx
  80a5bd:	89 50 0c             	mov    %edx,0xc(%eax)
  80a5c0:	89 1c b5 40 4b b3 00 	mov    %ebx,0xb34b40(,%esi,4)
  80a5c7:	8d 04 b5 40 4b b3 00 	lea    0xb34b40(,%esi,4),%eax
  80a5ce:	89 43 0c             	mov    %eax,0xc(%ebx)

out:
    return &t->tmo;
  80a5d1:	8d 43 04             	lea    0x4(%ebx),%eax
}
  80a5d4:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a5d7:	5b                   	pop    %ebx
  80a5d8:	5e                   	pop    %esi
  80a5d9:	5f                   	pop    %edi
  80a5da:	5d                   	pop    %ebp
  80a5db:	c3                   	ret    
	panic("sys_arch_timeouts: cannot malloc");
  80a5dc:	83 ec 04             	sub    $0x4,%esp
  80a5df:	68 7c 26 81 00       	push   $0x81267c
  80a5e4:	68 2c 01 00 00       	push   $0x12c
  80a5e9:	68 bc 26 81 00       	push   $0x8126bc
  80a5ee:	e8 60 40 00 00       	call   80e653 <_panic>
	panic("thread_onhalt failed: %s", e2s(r));
  80a5f3:	83 ec 0c             	sub    $0xc,%esp
  80a5f6:	50                   	push   %eax
  80a5f7:	e8 ed 03 00 00       	call   80a9e9 <e2s>
  80a5fc:	50                   	push   %eax
  80a5fd:	68 29 27 81 00       	push   $0x812729
  80a602:	68 30 01 00 00       	push   $0x130
  80a607:	68 bc 26 81 00       	push   $0x8126bc
  80a60c:	e8 42 40 00 00       	call   80e653 <_panic>

0080a611 <lwip_core_lock>:

void
lwip_core_lock(void)
{
  80a611:	55                   	push   %ebp
  80a612:	89 e5                	mov    %esp,%ebp
}
  80a614:	5d                   	pop    %ebp
  80a615:	c3                   	ret    

0080a616 <lwip_core_unlock>:

void
lwip_core_unlock(void)
{
  80a616:	55                   	push   %ebp
  80a617:	89 e5                	mov    %esp,%ebp
}
  80a619:	5d                   	pop    %ebp
  80a61a:	c3                   	ret    

0080a61b <thread_init>:

static struct thread_queue thread_queue;
static struct thread_queue kill_queue;

void
thread_init(void) {
  80a61b:	55                   	push   %ebp
  80a61c:	89 e5                	mov    %esp,%ebp
};

static inline void 
threadq_init(struct thread_queue *tq)
{
    tq->tq_first = 0;
  80a61e:	c7 05 88 b1 b3 00 00 	movl   $0x0,0xb3b188
  80a625:	00 00 00 
    tq->tq_last = 0;
  80a628:	c7 05 8c b1 b3 00 00 	movl   $0x0,0xb3b18c
  80a62f:	00 00 00 
    threadq_init(&thread_queue);
    max_tid = 0;
  80a632:	c7 05 94 b1 b3 00 00 	movl   $0x0,0xb3b194
  80a639:	00 00 00 
}
  80a63c:	5d                   	pop    %ebp
  80a63d:	c3                   	ret    

0080a63e <thread_id>:

uint32_t
thread_id(void) {
  80a63e:	55                   	push   %ebp
  80a63f:	89 e5                	mov    %esp,%ebp
    return cur_tc->tc_tid;
  80a641:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a646:	8b 00                	mov    (%eax),%eax
}
  80a648:	5d                   	pop    %ebp
  80a649:	c3                   	ret    

0080a64a <thread_wakeup>:

void
thread_wakeup(volatile uint32_t *addr) {
  80a64a:	55                   	push   %ebp
  80a64b:	89 e5                	mov    %esp,%ebp
  80a64d:	8b 55 08             	mov    0x8(%ebp),%edx
    struct thread_context *tc = thread_queue.tq_first;
  80a650:	a1 88 b1 b3 00       	mov    0xb3b188,%eax
    while (tc) {
  80a655:	eb 03                	jmp    80a65a <thread_wakeup+0x10>
	if (tc->tc_wait_addr == addr)
	    tc->tc_wakeup = 1;
	tc = tc->tc_queue_link;
  80a657:	8b 40 64             	mov    0x64(%eax),%eax
    while (tc) {
  80a65a:	85 c0                	test   %eax,%eax
  80a65c:	74 0b                	je     80a669 <thread_wakeup+0x1f>
	if (tc->tc_wait_addr == addr)
  80a65e:	39 50 48             	cmp    %edx,0x48(%eax)
  80a661:	75 f4                	jne    80a657 <thread_wakeup+0xd>
	    tc->tc_wakeup = 1;
  80a663:	c6 40 4c 01          	movb   $0x1,0x4c(%eax)
  80a667:	eb ee                	jmp    80a657 <thread_wakeup+0xd>
    }
}
  80a669:	5d                   	pop    %ebp
  80a66a:	c3                   	ret    

0080a66b <thread_wakeups_pending>:
    cur_tc->tc_wakeup = 0;
}

int
thread_wakeups_pending(void)
{
  80a66b:	55                   	push   %ebp
  80a66c:	89 e5                	mov    %esp,%ebp
    struct thread_context *tc = thread_queue.tq_first;
  80a66e:	8b 15 88 b1 b3 00    	mov    0xb3b188,%edx
    int n = 0;
  80a674:	b8 00 00 00 00       	mov    $0x0,%eax
    while (tc) {
  80a679:	eb 0d                	jmp    80a688 <thread_wakeups_pending+0x1d>
	if (tc->tc_wakeup)
  80a67b:	0f b6 4a 4c          	movzbl 0x4c(%edx),%ecx
	    ++n;
  80a67f:	80 f9 01             	cmp    $0x1,%cl
  80a682:	83 d8 ff             	sbb    $0xffffffff,%eax
	tc = tc->tc_queue_link;
  80a685:	8b 52 64             	mov    0x64(%edx),%edx
    while (tc) {
  80a688:	85 d2                	test   %edx,%edx
  80a68a:	75 ef                	jne    80a67b <thread_wakeups_pending+0x10>
    }
    return n;
}
  80a68c:	5d                   	pop    %ebp
  80a68d:	c3                   	ret    

0080a68e <thread_onhalt>:

int
thread_onhalt(void (*fun)(thread_id_t)) {
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
  80a68e:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a693:	8b 50 60             	mov    0x60(%eax),%edx
  80a696:	83 fa 03             	cmp    $0x3,%edx
  80a699:	7f 17                	jg     80a6b2 <thread_onhalt+0x24>
thread_onhalt(void (*fun)(thread_id_t)) {
  80a69b:	55                   	push   %ebp
  80a69c:	89 e5                	mov    %esp,%ebp
	return -E_NO_MEM;

    cur_tc->tc_onhalt[cur_tc->tc_nonhalt++] = fun;
  80a69e:	8d 4a 01             	lea    0x1(%edx),%ecx
  80a6a1:	89 48 60             	mov    %ecx,0x60(%eax)
  80a6a4:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80a6a7:	89 4c 90 50          	mov    %ecx,0x50(%eax,%edx,4)
    return 0;
  80a6ab:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80a6b0:	5d                   	pop    %ebp
  80a6b1:	c3                   	ret    
	return -E_NO_MEM;
  80a6b2:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
}
  80a6b7:	c3                   	ret    

0080a6b8 <thread_create>:
    thread_halt();
}

int
thread_create(thread_id_t *tid, const char *name, 
		void (*entry)(uint32_t), uint32_t arg) {
  80a6b8:	55                   	push   %ebp
  80a6b9:	89 e5                	mov    %esp,%ebp
  80a6bb:	57                   	push   %edi
  80a6bc:	56                   	push   %esi
  80a6bd:	53                   	push   %ebx
  80a6be:	83 ec 18             	sub    $0x18,%esp
  80a6c1:	8b 75 08             	mov    0x8(%ebp),%esi
    struct thread_context *tc = malloc(sizeof(struct thread_context));
  80a6c4:	6a 68                	push   $0x68
  80a6c6:	e8 c0 61 00 00       	call   81088b <malloc>
    if (!tc)
  80a6cb:	83 c4 10             	add    $0x10,%esp
  80a6ce:	85 c0                	test   %eax,%eax
  80a6d0:	0f 84 04 01 00 00    	je     80a7da <thread_create+0x122>
  80a6d6:	89 c3                	mov    %eax,%ebx
	return -E_NO_MEM;

    memset(tc, 0, sizeof(struct thread_context));
  80a6d8:	83 ec 04             	sub    $0x4,%esp
  80a6db:	6a 68                	push   $0x68
  80a6dd:	6a 00                	push   $0x0
  80a6df:	50                   	push   %eax
  80a6e0:	e8 27 48 00 00       	call   80ef0c <memset>
    strncpy(tc->tc_name, name, name_size - 1);
  80a6e5:	83 c4 0c             	add    $0xc,%esp
  80a6e8:	6a 1f                	push   $0x1f
  80a6ea:	ff 75 0c             	pushl  0xc(%ebp)
  80a6ed:	8d 43 08             	lea    0x8(%ebx),%eax
  80a6f0:	50                   	push   %eax
  80a6f1:	e8 17 47 00 00       	call   80ee0d <strncpy>
    tc->tc_name[name_size - 1] = 0;
  80a6f6:	c6 43 27 00          	movb   $0x0,0x27(%ebx)
    int tid = max_tid++;
  80a6fa:	a1 94 b1 b3 00       	mov    0xb3b194,%eax
  80a6ff:	8d 50 01             	lea    0x1(%eax),%edx
  80a702:	89 15 94 b1 b3 00    	mov    %edx,0xb3b194
    if (max_tid == (uint32_t)~0)
  80a708:	83 c4 10             	add    $0x10,%esp
  80a70b:	83 fa ff             	cmp    $0xffffffff,%edx
  80a70e:	0f 84 91 00 00 00    	je     80a7a5 <thread_create+0xed>
    
    thread_set_name(tc, name);
    tc->tc_tid = alloc_tid();
  80a714:	89 03                	mov    %eax,(%ebx)

    tc->tc_stack_bottom = malloc(stack_size);
  80a716:	83 ec 0c             	sub    $0xc,%esp
  80a719:	68 00 10 00 00       	push   $0x1000
  80a71e:	e8 68 61 00 00       	call   81088b <malloc>
  80a723:	89 43 04             	mov    %eax,0x4(%ebx)
    if (!tc->tc_stack_bottom) {
  80a726:	83 c4 10             	add    $0x10,%esp
  80a729:	85 c0                	test   %eax,%eax
  80a72b:	0f 84 88 00 00 00    	je     80a7b9 <thread_create+0x101>
	return -E_NO_MEM;
    }

    void *stacktop = tc->tc_stack_bottom + stack_size;
    // Terminate stack unwinding
    stacktop = stacktop - 4;
  80a731:	8d b8 fc 0f 00 00    	lea    0xffc(%eax),%edi
    memset(stacktop, 0, 4);
  80a737:	83 ec 04             	sub    $0x4,%esp
  80a73a:	6a 04                	push   $0x4
  80a73c:	6a 00                	push   $0x0
  80a73e:	57                   	push   %edi
  80a73f:	e8 c8 47 00 00       	call   80ef0c <memset>
    
    memset(&tc->tc_jb, 0, sizeof(tc->tc_jb));
  80a744:	83 c4 0c             	add    $0xc,%esp
  80a747:	6a 18                	push   $0x18
  80a749:	6a 00                	push   $0x0
  80a74b:	8d 43 30             	lea    0x30(%ebx),%eax
  80a74e:	50                   	push   %eax
  80a74f:	e8 b8 47 00 00       	call   80ef0c <memset>
    tc->tc_jb.jb_esp = (uint32_t)stacktop;
  80a754:	89 7b 34             	mov    %edi,0x34(%ebx)
    tc->tc_jb.jb_eip = (uint32_t)&thread_entry;
  80a757:	c7 43 30 65 a9 80 00 	movl   $0x80a965,0x30(%ebx)
    tc->tc_entry = entry;
  80a75e:	8b 45 10             	mov    0x10(%ebp),%eax
  80a761:	89 43 28             	mov    %eax,0x28(%ebx)
    tc->tc_arg = arg;
  80a764:	8b 45 14             	mov    0x14(%ebp),%eax
  80a767:	89 43 2c             	mov    %eax,0x2c(%ebx)
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80a76a:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    if (!tq->tq_first) {
  80a771:	83 c4 10             	add    $0x10,%esp
  80a774:	83 3d 88 b1 b3 00 00 	cmpl   $0x0,0xb3b188
  80a77b:	74 4f                	je     80a7cc <thread_create+0x114>
	tq->tq_first = tc;
	tq->tq_last = tc;
    } else {
	tq->tq_last->tc_queue_link = tc;
  80a77d:	a1 8c b1 b3 00       	mov    0xb3b18c,%eax
  80a782:	89 58 64             	mov    %ebx,0x64(%eax)
	tq->tq_last = tc;
  80a785:	89 1d 8c b1 b3 00    	mov    %ebx,0xb3b18c

    threadq_push(&thread_queue, tc);

    if (tid)
	*tid = tc->tc_tid;
    return 0;
  80a78b:	b8 00 00 00 00       	mov    $0x0,%eax
    if (tid)
  80a790:	85 f6                	test   %esi,%esi
  80a792:	74 09                	je     80a79d <thread_create+0xe5>
	*tid = tc->tc_tid;
  80a794:	8b 03                	mov    (%ebx),%eax
  80a796:	89 06                	mov    %eax,(%esi)
    return 0;
  80a798:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80a79d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a7a0:	5b                   	pop    %ebx
  80a7a1:	5e                   	pop    %esi
  80a7a2:	5f                   	pop    %edi
  80a7a3:	5d                   	pop    %ebp
  80a7a4:	c3                   	ret    
	panic("alloc_tid: no more thread ids");
  80a7a5:	83 ec 04             	sub    $0x4,%esp
  80a7a8:	68 42 27 81 00       	push   $0x812742
  80a7ad:	6a 54                	push   $0x54
  80a7af:	68 60 27 81 00       	push   $0x812760
  80a7b4:	e8 9a 3e 00 00       	call   80e653 <_panic>
	free(tc);
  80a7b9:	83 ec 0c             	sub    $0xc,%esp
  80a7bc:	53                   	push   %ebx
  80a7bd:	e8 1b 60 00 00       	call   8107dd <free>
	return -E_NO_MEM;
  80a7c2:	83 c4 10             	add    $0x10,%esp
  80a7c5:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80a7ca:	eb d1                	jmp    80a79d <thread_create+0xe5>
	tq->tq_first = tc;
  80a7cc:	89 1d 88 b1 b3 00    	mov    %ebx,0xb3b188
	tq->tq_last = tc;
  80a7d2:	89 1d 8c b1 b3 00    	mov    %ebx,0xb3b18c
  80a7d8:	eb b1                	jmp    80a78b <thread_create+0xd3>
	return -E_NO_MEM;
  80a7da:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80a7df:	eb bc                	jmp    80a79d <thread_create+0xe5>

0080a7e1 <thread_yield>:
    // when yield has no thread to run, it will return here!
    exit();
}

void
thread_yield(void) {
  80a7e1:	55                   	push   %ebp
  80a7e2:	89 e5                	mov    %esp,%ebp
  80a7e4:	53                   	push   %ebx
  80a7e5:	83 ec 04             	sub    $0x4,%esp
}

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
    if (!tq->tq_first)
  80a7e8:	8b 1d 88 b1 b3 00    	mov    0xb3b188,%ebx
  80a7ee:	85 db                	test   %ebx,%ebx
  80a7f0:	74 2b                	je     80a81d <thread_yield+0x3c>
	return 0;

    struct thread_context *tc = tq->tq_first;
    tq->tq_first = tc->tc_queue_link;
  80a7f2:	8b 43 64             	mov    0x64(%ebx),%eax
  80a7f5:	a3 88 b1 b3 00       	mov    %eax,0xb3b188
    tc->tc_queue_link = 0;
  80a7fa:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    struct thread_context *next_tc = threadq_pop(&thread_queue);

    if (!next_tc)
	return;

    if (cur_tc) {
  80a801:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a806:	85 c0                	test   %eax,%eax
  80a808:	74 3b                	je     80a845 <thread_yield+0x64>
	if (jos_setjmp(&cur_tc->tc_jb) != 0)
  80a80a:	83 ec 0c             	sub    $0xc,%esp
  80a80d:	83 c0 30             	add    $0x30,%eax
  80a810:	50                   	push   %eax
  80a811:	e8 6a 01 00 00       	call   80a980 <jos_setjmp>
  80a816:	83 c4 10             	add    $0x10,%esp
  80a819:	85 c0                	test   %eax,%eax
  80a81b:	74 05                	je     80a822 <thread_yield+0x41>
	threadq_push(&thread_queue, cur_tc);
    }

    cur_tc = next_tc;
    jos_longjmp(&cur_tc->tc_jb, 1);
}
  80a81d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80a820:	c9                   	leave  
  80a821:	c3                   	ret    
	threadq_push(&thread_queue, cur_tc);
  80a822:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
    tc->tc_queue_link = 0;
  80a827:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
    if (!tq->tq_first) {
  80a82e:	83 3d 88 b1 b3 00 00 	cmpl   $0x0,0xb3b188
  80a835:	74 21                	je     80a858 <thread_yield+0x77>
	tq->tq_last->tc_queue_link = tc;
  80a837:	8b 15 8c b1 b3 00    	mov    0xb3b18c,%edx
  80a83d:	89 42 64             	mov    %eax,0x64(%edx)
	tq->tq_last = tc;
  80a840:	a3 8c b1 b3 00       	mov    %eax,0xb3b18c
    cur_tc = next_tc;
  80a845:	89 1d 90 b1 b3 00    	mov    %ebx,0xb3b190
    jos_longjmp(&cur_tc->tc_jb, 1);
  80a84b:	8d 43 30             	lea    0x30(%ebx),%eax
  80a84e:	ba 01 00 00 00       	mov    $0x1,%edx
  80a853:	e8 58 01 00 00       	call   80a9b0 <jos_longjmp>
	tq->tq_first = tc;
  80a858:	a3 88 b1 b3 00       	mov    %eax,0xb3b188
	tq->tq_last = tc;
  80a85d:	a3 8c b1 b3 00       	mov    %eax,0xb3b18c
  80a862:	eb e1                	jmp    80a845 <thread_yield+0x64>

0080a864 <thread_wait>:
thread_wait(volatile uint32_t *addr, uint32_t val, uint32_t msec) {
  80a864:	55                   	push   %ebp
  80a865:	89 e5                	mov    %esp,%ebp
  80a867:	57                   	push   %edi
  80a868:	56                   	push   %esi
  80a869:	53                   	push   %ebx
  80a86a:	83 ec 0c             	sub    $0xc,%esp
  80a86d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80a870:	8b 7d 10             	mov    0x10(%ebp),%edi
    uint32_t s = sys_time_msec();
  80a873:	e8 3d 4b 00 00       	call   80f3b5 <sys_time_msec>
  80a878:	89 c6                	mov    %eax,%esi
    cur_tc->tc_wait_addr = addr;
  80a87a:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a87f:	89 58 48             	mov    %ebx,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80a882:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)
    uint32_t p = s;
  80a886:	89 f0                	mov    %esi,%eax
    while (p < msec) {
  80a888:	eb 17                	jmp    80a8a1 <thread_wait+0x3d>
	if (cur_tc->tc_wakeup)
  80a88a:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a88f:	0f b6 40 4c          	movzbl 0x4c(%eax),%eax
  80a893:	84 c0                	test   %al,%al
  80a895:	75 1d                	jne    80a8b4 <thread_wait+0x50>
	thread_yield();
  80a897:	e8 45 ff ff ff       	call   80a7e1 <thread_yield>
	p = sys_time_msec();
  80a89c:	e8 14 4b 00 00       	call   80f3b5 <sys_time_msec>
	if (p < s)
  80a8a1:	39 f0                	cmp    %esi,%eax
  80a8a3:	72 0f                	jb     80a8b4 <thread_wait+0x50>
  80a8a5:	39 f8                	cmp    %edi,%eax
  80a8a7:	73 0b                	jae    80a8b4 <thread_wait+0x50>
	if (addr && *addr != val)
  80a8a9:	85 db                	test   %ebx,%ebx
  80a8ab:	74 dd                	je     80a88a <thread_wait+0x26>
  80a8ad:	8b 03                	mov    (%ebx),%eax
  80a8af:	3b 45 0c             	cmp    0xc(%ebp),%eax
  80a8b2:	74 d6                	je     80a88a <thread_wait+0x26>
    cur_tc->tc_wait_addr = 0;
  80a8b4:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a8b9:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80a8c0:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)
}
  80a8c4:	83 c4 0c             	add    $0xc,%esp
  80a8c7:	5b                   	pop    %ebx
  80a8c8:	5e                   	pop    %esi
  80a8c9:	5f                   	pop    %edi
  80a8ca:	5d                   	pop    %ebp
  80a8cb:	c3                   	ret    

0080a8cc <thread_halt>:
thread_halt() {
  80a8cc:	55                   	push   %ebp
  80a8cd:	89 e5                	mov    %esp,%ebp
  80a8cf:	56                   	push   %esi
  80a8d0:	53                   	push   %ebx
    if (!tq->tq_first)
  80a8d1:	8b 1d 80 b1 b3 00    	mov    0xb3b180,%ebx
  80a8d7:	85 db                	test   %ebx,%ebx
  80a8d9:	74 40                	je     80a91b <thread_halt+0x4f>
    tq->tq_first = tc->tc_queue_link;
  80a8db:	8b 43 64             	mov    0x64(%ebx),%eax
  80a8de:	a3 80 b1 b3 00       	mov    %eax,0xb3b180
    tc->tc_queue_link = 0;
  80a8e3:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    for (i = 0; i < tc->tc_nonhalt; i++)
  80a8ea:	be 00 00 00 00       	mov    $0x0,%esi
  80a8ef:	eb 0f                	jmp    80a900 <thread_halt+0x34>
	tc->tc_onhalt[i](tc->tc_tid);
  80a8f1:	83 ec 0c             	sub    $0xc,%esp
  80a8f4:	ff 33                	pushl  (%ebx)
  80a8f6:	ff 54 b3 50          	call   *0x50(%ebx,%esi,4)
    for (i = 0; i < tc->tc_nonhalt; i++)
  80a8fa:	83 c6 01             	add    $0x1,%esi
  80a8fd:	83 c4 10             	add    $0x10,%esp
  80a900:	3b 73 60             	cmp    0x60(%ebx),%esi
  80a903:	7c ec                	jl     80a8f1 <thread_halt+0x25>
    free(tc->tc_stack_bottom);
  80a905:	83 ec 0c             	sub    $0xc,%esp
  80a908:	ff 73 04             	pushl  0x4(%ebx)
  80a90b:	e8 cd 5e 00 00       	call   8107dd <free>
    free(tc);
  80a910:	89 1c 24             	mov    %ebx,(%esp)
  80a913:	e8 c5 5e 00 00       	call   8107dd <free>
  80a918:	83 c4 10             	add    $0x10,%esp
    threadq_push(&kill_queue, cur_tc);
  80a91b:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
    tc->tc_queue_link = 0;
  80a920:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
    if (!tq->tq_first) {
  80a927:	83 3d 80 b1 b3 00 00 	cmpl   $0x0,0xb3b180
  80a92e:	74 29                	je     80a959 <thread_halt+0x8d>
	tq->tq_last->tc_queue_link = tc;
  80a930:	8b 15 84 b1 b3 00    	mov    0xb3b184,%edx
  80a936:	89 42 64             	mov    %eax,0x64(%edx)
	tq->tq_last = tc;
  80a939:	a3 84 b1 b3 00       	mov    %eax,0xb3b184
    cur_tc = NULL;
  80a93e:	c7 05 90 b1 b3 00 00 	movl   $0x0,0xb3b190
  80a945:	00 00 00 
    thread_yield();
  80a948:	e8 94 fe ff ff       	call   80a7e1 <thread_yield>
    exit();
  80a94d:	e8 e7 3c 00 00       	call   80e639 <exit>
}
  80a952:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80a955:	5b                   	pop    %ebx
  80a956:	5e                   	pop    %esi
  80a957:	5d                   	pop    %ebp
  80a958:	c3                   	ret    
	tq->tq_first = tc;
  80a959:	a3 80 b1 b3 00       	mov    %eax,0xb3b180
	tq->tq_last = tc;
  80a95e:	a3 84 b1 b3 00       	mov    %eax,0xb3b184
  80a963:	eb d9                	jmp    80a93e <thread_halt+0x72>

0080a965 <thread_entry>:
thread_entry(void) {
  80a965:	55                   	push   %ebp
  80a966:	89 e5                	mov    %esp,%ebp
  80a968:	83 ec 14             	sub    $0x14,%esp
    cur_tc->tc_entry(cur_tc->tc_arg);
  80a96b:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a970:	ff 70 2c             	pushl  0x2c(%eax)
  80a973:	ff 50 28             	call   *0x28(%eax)
    thread_halt();
  80a976:	e8 51 ff ff ff       	call   80a8cc <thread_halt>
}
  80a97b:	83 c4 10             	add    $0x10,%esp
  80a97e:	c9                   	leave  
  80a97f:	c3                   	ret    

0080a980 <jos_setjmp>:
#define ENTRY(x) \
        .text; _ALIGN_TEXT; .globl x; .type x,@function; x:


ENTRY(jos_setjmp)
	movl	4(%esp), %ecx	// jos_jmp_buf
  80a980:	8b 4c 24 04          	mov    0x4(%esp),%ecx

	movl	0(%esp), %edx	// %eip as pushed by call
  80a984:	8b 14 24             	mov    (%esp),%edx
	movl	%edx,  0(%ecx)
  80a987:	89 11                	mov    %edx,(%ecx)

	leal	4(%esp), %edx	// where %esp will point when we return
  80a989:	8d 54 24 04          	lea    0x4(%esp),%edx
	movl	%edx,  4(%ecx)
  80a98d:	89 51 04             	mov    %edx,0x4(%ecx)

	movl	%ebp,  8(%ecx)
  80a990:	89 69 08             	mov    %ebp,0x8(%ecx)
	movl	%ebx, 12(%ecx)
  80a993:	89 59 0c             	mov    %ebx,0xc(%ecx)
	movl	%esi, 16(%ecx)
  80a996:	89 71 10             	mov    %esi,0x10(%ecx)
	movl	%edi, 20(%ecx)
  80a999:	89 79 14             	mov    %edi,0x14(%ecx)

	movl	$0, %eax
  80a99c:	b8 00 00 00 00       	mov    $0x0,%eax
	ret
  80a9a1:	c3                   	ret    
  80a9a2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  80a9a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0080a9b0 <jos_longjmp>:

ENTRY(jos_longjmp)
	// %eax is the jos_jmp_buf*
	// %edx is the return value

	movl	 0(%eax), %ecx	// %eip
  80a9b0:	8b 08                	mov    (%eax),%ecx
	movl	 4(%eax), %esp
  80a9b2:	8b 60 04             	mov    0x4(%eax),%esp
	movl	 8(%eax), %ebp
  80a9b5:	8b 68 08             	mov    0x8(%eax),%ebp
	movl	12(%eax), %ebx
  80a9b8:	8b 58 0c             	mov    0xc(%eax),%ebx
	movl	16(%eax), %esi
  80a9bb:	8b 70 10             	mov    0x10(%eax),%esi
	movl	20(%eax), %edi
  80a9be:	8b 78 14             	mov    0x14(%eax),%edi

	movl	%edx, %eax
  80a9c1:	89 d0                	mov    %edx,%eax
	jmp	*%ecx
  80a9c3:	ff e1                	jmp    *%ecx

0080a9c5 <perror>:
  [ENSRQUERYDOMAINTOOLONG] = "ENSRQUERYDOMAINTOOLONG",  /* Domain name is too long */
  [ENSRCNAMELOOP] = "ENSRCNAMELOOP" /* Domain name is too long */
};

void
perror(const char *s) {
  80a9c5:	55                   	push   %ebp
  80a9c6:	89 e5                	mov    %esp,%ebp
  80a9c8:	83 ec 0c             	sub    $0xc,%esp
	cprintf("%s: %s\n", s, e2s(err));
}

const char *
e2s(int err) {
	return sys_errlist[err];
  80a9cb:	a1 e0 b1 b3 00       	mov    0xb3b1e0,%eax
	cprintf("%s: %s\n", s, e2s(err));
  80a9d0:	ff 34 85 20 40 81 00 	pushl  0x814020(,%eax,4)
  80a9d7:	ff 75 08             	pushl  0x8(%ebp)
  80a9da:	68 7b 27 81 00       	push   $0x81277b
  80a9df:	e8 4a 3d 00 00       	call   80e72e <cprintf>
}
  80a9e4:	83 c4 10             	add    $0x10,%esp
  80a9e7:	c9                   	leave  
  80a9e8:	c3                   	ret    

0080a9e9 <e2s>:
e2s(int err) {
  80a9e9:	55                   	push   %ebp
  80a9ea:	89 e5                	mov    %esp,%ebp
	return sys_errlist[err];
  80a9ec:	8b 45 08             	mov    0x8(%ebp),%eax
  80a9ef:	8b 04 85 20 40 81 00 	mov    0x814020(,%eax,4),%eax
}
  80a9f6:	5d                   	pop    %ebp
  80a9f7:	c3                   	ret    

0080a9f8 <low_level_output>:
 * might be chained.
 *
 */
static err_t
low_level_output(struct netif *netif, struct pbuf *p)
{
  80a9f8:	55                   	push   %ebp
  80a9f9:	89 e5                	mov    %esp,%ebp
  80a9fb:	57                   	push   %edi
  80a9fc:	56                   	push   %esi
  80a9fd:	53                   	push   %ebx
  80a9fe:	83 ec 20             	sub    $0x20,%esp
  80aa01:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    int r = sys_page_alloc(0, (void *)PKTMAP, PTE_U|PTE_W|PTE_P);
  80aa04:	6a 07                	push   $0x7
  80aa06:	68 00 00 00 10       	push   $0x10000000
  80aa0b:	6a 00                	push   $0x0
  80aa0d:	e8 b2 47 00 00       	call   80f1c4 <sys_page_alloc>
    if (r < 0)
  80aa12:	83 c4 10             	add    $0x10,%esp
  80aa15:	85 c0                	test   %eax,%eax
  80aa17:	78 49                	js     80aa62 <low_level_output+0x6a>
	panic("jif: could not allocate page of memory");
    struct jif_pkt *pkt = (struct jif_pkt *)PKTMAP;

    struct jif *jif;
    jif = netif->state;
  80aa19:	8b 45 08             	mov    0x8(%ebp),%eax
  80aa1c:	8b 40 1c             	mov    0x1c(%eax),%eax
  80aa1f:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    char *txbuf = pkt->jp_data;
  80aa22:	bf 04 00 00 10       	mov    $0x10000004,%edi
    int txsize = 0;
  80aa27:	be 00 00 00 00       	mov    $0x0,%esi
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80aa2c:	85 db                	test   %ebx,%ebx
  80aa2e:	74 5c                	je     80aa8c <low_level_output+0x94>
	/* Send the data from the pbuf to the interface, one pbuf at a
	   time. The size of the data in each pbuf is kept in the ->len
	   variable. */

	if (txsize + q->len > 2000)
  80aa30:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80aa34:	0f b7 d0             	movzwl %ax,%edx
  80aa37:	8d 0c 32             	lea    (%edx,%esi,1),%ecx
  80aa3a:	81 f9 d0 07 00 00    	cmp    $0x7d0,%ecx
  80aa40:	7f 34                	jg     80aa76 <low_level_output+0x7e>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
	memcpy(&txbuf[txsize], q->payload, q->len);
  80aa42:	83 ec 04             	sub    $0x4,%esp
  80aa45:	0f b7 c0             	movzwl %ax,%eax
  80aa48:	50                   	push   %eax
  80aa49:	ff 73 04             	pushl  0x4(%ebx)
  80aa4c:	8d 04 37             	lea    (%edi,%esi,1),%eax
  80aa4f:	50                   	push   %eax
  80aa50:	e8 6c 45 00 00       	call   80efc1 <memcpy>
	txsize += q->len;
  80aa55:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80aa59:	01 c6                	add    %eax,%esi
    for (q = p; q != NULL; q = q->next) {
  80aa5b:	8b 1b                	mov    (%ebx),%ebx
  80aa5d:	83 c4 10             	add    $0x10,%esp
  80aa60:	eb ca                	jmp    80aa2c <low_level_output+0x34>
	panic("jif: could not allocate page of memory");
  80aa62:	83 ec 04             	sub    $0x4,%esp
  80aa65:	68 60 2c 81 00       	push   $0x812c60
  80aa6a:	6a 55                	push   $0x55
  80aa6c:	68 b1 2c 81 00       	push   $0x812cb1
  80aa71:	e8 dd 3b 00 00       	call   80e653 <_panic>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
  80aa76:	83 ec 0c             	sub    $0xc,%esp
  80aa79:	56                   	push   %esi
  80aa7a:	52                   	push   %edx
  80aa7b:	68 88 2c 81 00       	push   $0x812c88
  80aa80:	6a 64                	push   $0x64
  80aa82:	68 b1 2c 81 00       	push   $0x812cb1
  80aa87:	e8 c7 3b 00 00       	call   80e653 <_panic>
    }

    pkt->jp_len = txsize;
  80aa8c:	89 35 00 00 00 10    	mov    %esi,0x10000000

    ipc_send(jif->envid, NSREQ_OUTPUT, (void *)pkt, PTE_P|PTE_W|PTE_U);
  80aa92:	6a 07                	push   $0x7
  80aa94:	68 00 00 00 10       	push   $0x10000000
  80aa99:	6a 0b                	push   $0xb
  80aa9b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80aa9e:	ff 70 04             	pushl  0x4(%eax)
  80aaa1:	e8 c3 4c 00 00       	call   80f769 <ipc_send>
    sys_page_unmap(0, (void *)pkt);
  80aaa6:	83 c4 08             	add    $0x8,%esp
  80aaa9:	68 00 00 00 10       	push   $0x10000000
  80aaae:	6a 00                	push   $0x0
  80aab0:	e8 94 47 00 00       	call   80f249 <sys_page_unmap>

    return ERR_OK;
}
  80aab5:	b8 00 00 00 00       	mov    $0x0,%eax
  80aaba:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80aabd:	5b                   	pop    %ebx
  80aabe:	5e                   	pop    %esi
  80aabf:	5f                   	pop    %edi
  80aac0:	5d                   	pop    %ebp
  80aac1:	c3                   	ret    

0080aac2 <jif_output>:
 */

static err_t
jif_output(struct netif *netif, struct pbuf *p,
      struct ip_addr *ipaddr)
{
  80aac2:	55                   	push   %ebp
  80aac3:	89 e5                	mov    %esp,%ebp
  80aac5:	83 ec 0c             	sub    $0xc,%esp
    /* resolve hardware address, then send (or queue) packet */
    return etharp_output(netif, p, ipaddr);
  80aac8:	ff 75 10             	pushl  0x10(%ebp)
  80aacb:	ff 75 0c             	pushl  0xc(%ebp)
  80aace:	ff 75 08             	pushl  0x8(%ebp)
  80aad1:	e8 f5 f0 ff ff       	call   809bcb <etharp_output>
}
  80aad6:	c9                   	leave  
  80aad7:	c3                   	ret    

0080aad8 <jif_input>:
 *
 */

void
jif_input(struct netif *netif, void *va)
{
  80aad8:	55                   	push   %ebp
  80aad9:	89 e5                	mov    %esp,%ebp
  80aadb:	57                   	push   %edi
  80aadc:	56                   	push   %esi
  80aadd:	53                   	push   %ebx
  80aade:	83 ec 20             	sub    $0x20,%esp
  80aae1:	8b 75 0c             	mov    0xc(%ebp),%esi
    struct jif *jif;
    struct eth_hdr *ethhdr;
    struct pbuf *p;

    jif = netif->state;
  80aae4:	8b 45 08             	mov    0x8(%ebp),%eax
  80aae7:	8b 40 1c             	mov    0x1c(%eax),%eax
  80aaea:	89 45 d8             	mov    %eax,-0x28(%ebp)
    s16_t len = pkt->jp_len;
  80aaed:	8b 06                	mov    (%esi),%eax
  80aaef:	89 c3                	mov    %eax,%ebx
    struct pbuf *p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
  80aaf1:	6a 03                	push   $0x3
  80aaf3:	0f b7 c0             	movzwl %ax,%eax
  80aaf6:	50                   	push   %eax
  80aaf7:	6a 03                	push   $0x3
  80aaf9:	e8 15 9e ff ff       	call   804913 <pbuf_alloc>
  80aafe:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if (p == 0)
  80ab01:	83 c4 10             	add    $0x10,%esp
  80ab04:	85 c0                	test   %eax,%eax
  80ab06:	0f 84 9a 00 00 00    	je     80aba6 <jif_input+0xce>
    void *rxbuf = (void *) pkt->jp_data;
  80ab0c:	8d 56 04             	lea    0x4(%esi),%edx
  80ab0f:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    for (q = p; q != NULL; q = q->next) {
  80ab12:	89 c6                	mov    %eax,%esi
    int copied = 0;
  80ab14:	bf 00 00 00 00       	mov    $0x0,%edi
	if (bytes > (len - copied))
  80ab19:	0f bf c3             	movswl %bx,%eax
  80ab1c:	89 45 e0             	mov    %eax,-0x20(%ebp)
	int bytes = q->len;
  80ab1f:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
	if (bytes > (len - copied))
  80ab23:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80ab26:	29 fb                	sub    %edi,%ebx
  80ab28:	39 c3                	cmp    %eax,%ebx
  80ab2a:	0f 4f d8             	cmovg  %eax,%ebx
	memcpy(q->payload, rxbuf + copied, bytes);
  80ab2d:	83 ec 04             	sub    $0x4,%esp
  80ab30:	53                   	push   %ebx
  80ab31:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80ab34:	01 f8                	add    %edi,%eax
  80ab36:	50                   	push   %eax
  80ab37:	ff 76 04             	pushl  0x4(%esi)
  80ab3a:	e8 82 44 00 00       	call   80efc1 <memcpy>
	copied += bytes;
  80ab3f:	01 df                	add    %ebx,%edi
    for (q = p; q != NULL; q = q->next) {
  80ab41:	8b 36                	mov    (%esi),%esi
  80ab43:	83 c4 10             	add    $0x10,%esp
  80ab46:	85 f6                	test   %esi,%esi
  80ab48:	75 d5                	jne    80ab1f <jif_input+0x47>
    /* no packet could be read, silently ignore this */
    if (p == NULL) return;
    /* points to packet payload, which starts with an Ethernet header */
    ethhdr = p->payload;

    switch (htons(ethhdr->type)) {
  80ab4a:	83 ec 0c             	sub    $0xc,%esp
  80ab4d:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80ab50:	8b 40 04             	mov    0x4(%eax),%eax
  80ab53:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ab57:	50                   	push   %eax
  80ab58:	e8 25 cc ff ff       	call   807782 <htons>
  80ab5d:	83 c4 10             	add    $0x10,%esp
  80ab60:	66 3d 00 08          	cmp    $0x800,%ax
  80ab64:	74 16                	je     80ab7c <jif_input+0xa4>
  80ab66:	66 3d 06 08          	cmp    $0x806,%ax
  80ab6a:	74 42                	je     80abae <jif_input+0xd6>
	/* pass p to ARP module  */
	etharp_arp_input(netif, jif->ethaddr, p);
	break;

    default:
	pbuf_free(p);
  80ab6c:	83 ec 0c             	sub    $0xc,%esp
  80ab6f:	ff 75 dc             	pushl  -0x24(%ebp)
  80ab72:	e8 d6 9c ff ff       	call   80484d <pbuf_free>
  80ab77:	83 c4 10             	add    $0x10,%esp
  80ab7a:	eb 2a                	jmp    80aba6 <jif_input+0xce>
	etharp_ip_input(netif, p);
  80ab7c:	83 ec 08             	sub    $0x8,%esp
  80ab7f:	8b 7d dc             	mov    -0x24(%ebp),%edi
  80ab82:	57                   	push   %edi
  80ab83:	ff 75 08             	pushl  0x8(%ebp)
  80ab86:	e8 bc ea ff ff       	call   809647 <etharp_ip_input>
	pbuf_header(p, -(int)sizeof(struct eth_hdr));
  80ab8b:	83 c4 08             	add    $0x8,%esp
  80ab8e:	6a f2                	push   $0xfffffff2
  80ab90:	57                   	push   %edi
  80ab91:	e8 e3 9b ff ff       	call   804779 <pbuf_header>
	netif->input(p, netif);
  80ab96:	83 c4 08             	add    $0x8,%esp
  80ab99:	ff 75 08             	pushl  0x8(%ebp)
  80ab9c:	57                   	push   %edi
  80ab9d:	8b 45 08             	mov    0x8(%ebp),%eax
  80aba0:	ff 50 10             	call   *0x10(%eax)
	break;
  80aba3:	83 c4 10             	add    $0x10,%esp
    }
}
  80aba6:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80aba9:	5b                   	pop    %ebx
  80abaa:	5e                   	pop    %esi
  80abab:	5f                   	pop    %edi
  80abac:	5d                   	pop    %ebp
  80abad:	c3                   	ret    
	etharp_arp_input(netif, jif->ethaddr, p);
  80abae:	83 ec 04             	sub    $0x4,%esp
  80abb1:	ff 75 dc             	pushl  -0x24(%ebp)
  80abb4:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80abb7:	ff 30                	pushl  (%eax)
  80abb9:	ff 75 08             	pushl  0x8(%ebp)
  80abbc:	e8 d2 ea ff ff       	call   809693 <etharp_arp_input>
	break;
  80abc1:	83 c4 10             	add    $0x10,%esp
  80abc4:	eb e0                	jmp    80aba6 <jif_input+0xce>

0080abc6 <jif_init>:
 *
 */

err_t
jif_init(struct netif *netif)
{
  80abc6:	55                   	push   %ebp
  80abc7:	89 e5                	mov    %esp,%ebp
  80abc9:	57                   	push   %edi
  80abca:	56                   	push   %esi
  80abcb:	53                   	push   %ebx
  80abcc:	83 ec 28             	sub    $0x28,%esp
  80abcf:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct jif *jif;
    envid_t *output_envid; 

    jif = mem_malloc(sizeof(struct jif));
  80abd2:	6a 08                	push   $0x8
  80abd4:	e8 47 96 ff ff       	call   804220 <mem_malloc>

    if (jif == NULL) {
  80abd9:	83 c4 10             	add    $0x10,%esp
  80abdc:	85 c0                	test   %eax,%eax
  80abde:	0f 84 87 00 00 00    	je     80ac6b <jif_init+0xa5>
  80abe4:	89 c6                	mov    %eax,%esi
	LWIP_DEBUGF(NETIF_DEBUG, ("jif_init: out of memory\n"));
	return ERR_MEM;
    }

    output_envid = (envid_t *)netif->state;
  80abe6:	8b 7b 1c             	mov    0x1c(%ebx),%edi

    netif->state = jif;
  80abe9:	89 43 1c             	mov    %eax,0x1c(%ebx)
    netif->output = jif_output;
  80abec:	c7 43 14 c2 aa 80 00 	movl   $0x80aac2,0x14(%ebx)
    netif->linkoutput = low_level_output;
  80abf3:	c7 43 18 f8 a9 80 00 	movl   $0x80a9f8,0x18(%ebx)
    memcpy(&netif->name[0], "en", 2);
  80abfa:	83 ec 04             	sub    $0x4,%esp
  80abfd:	6a 02                	push   $0x2
  80abff:	68 a0 39 81 00       	push   $0x8139a0
  80ac04:	8d 43 2f             	lea    0x2f(%ebx),%eax
  80ac07:	50                   	push   %eax
  80ac08:	e8 b4 43 00 00       	call   80efc1 <memcpy>

    jif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
  80ac0d:	8d 43 25             	lea    0x25(%ebx),%eax
  80ac10:	89 06                	mov    %eax,(%esi)
    jif->envid = *output_envid; 
  80ac12:	8b 07                	mov    (%edi),%eax
  80ac14:	89 46 04             	mov    %eax,0x4(%esi)
    netif->hwaddr_len = 6;
  80ac17:	c6 43 24 06          	movb   $0x6,0x24(%ebx)
    netif->mtu = 1500;
  80ac1b:	66 c7 43 2c dc 05    	movw   $0x5dc,0x2c(%ebx)
    netif->flags = NETIF_FLAG_BROADCAST;
  80ac21:	c6 43 2e 02          	movb   $0x2,0x2e(%ebx)
    netif->hwaddr[0] = 0x52;
  80ac25:	c6 43 25 52          	movb   $0x52,0x25(%ebx)
    netif->hwaddr[1] = 0x54;
  80ac29:	c6 43 26 54          	movb   $0x54,0x26(%ebx)
    netif->hwaddr[2] = 0x00;
  80ac2d:	c6 43 27 00          	movb   $0x0,0x27(%ebx)
    netif->hwaddr[3] = 0x12;
  80ac31:	c6 43 28 12          	movb   $0x12,0x28(%ebx)
    netif->hwaddr[4] = 0x34;
  80ac35:	c6 43 29 34          	movb   $0x34,0x29(%ebx)
    netif->hwaddr[5] = 0x56;
  80ac39:	c6 43 2a 56          	movb   $0x56,0x2a(%ebx)
    etharp_init();

    // qemu user-net is dumb; if the host OS does not send and ARP request
    // first, the qemu will send packets destined for the host using the mac
    // addr 00:00:00:00:00; do a arp request for the user-net NAT at 10.0.2.2
    uint32_t ipaddr = inet_addr("10.0.2.2");
  80ac3d:	c7 04 24 ab 10 81 00 	movl   $0x8110ab,(%esp)
  80ac44:	e8 4f cd ff ff       	call   807998 <inet_addr>
  80ac49:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    etharp_query(netif, (struct ip_addr *) &ipaddr, 0);
  80ac4c:	83 c4 0c             	add    $0xc,%esp
  80ac4f:	6a 00                	push   $0x0
  80ac51:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ac54:	50                   	push   %eax
  80ac55:	53                   	push   %ebx
  80ac56:	e8 40 ed ff ff       	call   80999b <etharp_query>

    return ERR_OK;
  80ac5b:	83 c4 10             	add    $0x10,%esp
  80ac5e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80ac63:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80ac66:	5b                   	pop    %ebx
  80ac67:	5e                   	pop    %esi
  80ac68:	5f                   	pop    %edi
  80ac69:	5d                   	pop    %ebp
  80ac6a:	c3                   	ret    
	return ERR_MEM;
  80ac6b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80ac70:	eb f1                	jmp    80ac63 <jif_init+0x9d>

0080ac72 <netconn_new_with_proto_and_callback>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_new_with_proto_and_callback(enum netconn_type t, u8_t proto, netconn_callback callback)
{
  80ac72:	55                   	push   %ebp
  80ac73:	89 e5                	mov    %esp,%ebp
  80ac75:	56                   	push   %esi
  80ac76:	53                   	push   %ebx
  80ac77:	83 ec 28             	sub    $0x28,%esp
  80ac7a:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct netconn *conn;
  struct api_msg msg;

  conn = netconn_alloc(t, callback);
  80ac7d:	ff 75 10             	pushl  0x10(%ebp)
  80ac80:	ff 75 08             	pushl  0x8(%ebp)
  80ac83:	e8 53 0f 00 00       	call   80bbdb <netconn_alloc>
  80ac88:	89 c3                	mov    %eax,%ebx
  
  if (conn != NULL ) {
  80ac8a:	83 c4 10             	add    $0x10,%esp
  80ac8d:	85 c0                	test   %eax,%eax
  80ac8f:	74 65                	je     80acf6 <netconn_new_with_proto_and_callback+0x84>
    msg.function = do_newconn;
  80ac91:	c7 45 e4 d2 ba 80 00 	movl   $0x80bad2,-0x1c(%ebp)
    msg.msg.msg.n.proto = proto;
  80ac98:	89 f0                	mov    %esi,%eax
  80ac9a:	88 45 ec             	mov    %al,-0x14(%ebp)
    msg.msg.conn = conn;
  80ac9d:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    TCPIP_APIMSG(&msg);
  80aca0:	83 ec 0c             	sub    $0xc,%esp
  80aca3:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80aca6:	50                   	push   %eax
  80aca7:	e8 ad 76 ff ff       	call   802359 <tcpip_apimsg>

    if (conn->err != ERR_OK) {
  80acac:	83 c4 10             	add    $0x10,%esp
  80acaf:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80acb3:	74 41                	je     80acf6 <netconn_new_with_proto_and_callback+0x84>
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
  80acb5:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80acb9:	75 44                	jne    80acff <netconn_new_with_proto_and_callback+0x8d>
      LWIP_ASSERT("conn has no op_completed", conn->op_completed != SYS_SEM_NULL);
  80acbb:	8b 43 10             	mov    0x10(%ebx),%eax
  80acbe:	83 f8 ff             	cmp    $0xffffffff,%eax
  80acc1:	74 50                	je     80ad13 <netconn_new_with_proto_and_callback+0xa1>
      LWIP_ASSERT("conn has no recvmbox", conn->recvmbox != SYS_MBOX_NULL);
  80acc3:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80acc7:	74 5e                	je     80ad27 <netconn_new_with_proto_and_callback+0xb5>
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", conn->acceptmbox == SYS_MBOX_NULL);
  80acc9:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80accd:	75 6c                	jne    80ad3b <netconn_new_with_proto_and_callback+0xc9>
      sys_sem_free(conn->op_completed);
  80accf:	83 ec 0c             	sub    $0xc,%esp
  80acd2:	50                   	push   %eax
  80acd3:	e8 10 f2 ff ff       	call   809ee8 <sys_sem_free>
      sys_mbox_free(conn->recvmbox);
  80acd8:	83 c4 04             	add    $0x4,%esp
  80acdb:	ff 73 14             	pushl  0x14(%ebx)
  80acde:	e8 8e f2 ff ff       	call   809f71 <sys_mbox_free>
      memp_free(MEMP_NETCONN, conn);
  80ace3:	83 c4 08             	add    $0x8,%esp
  80ace6:	53                   	push   %ebx
  80ace7:	6a 07                	push   $0x7
  80ace9:	e8 f0 97 ff ff       	call   8044de <memp_free>
      return NULL;
  80acee:	83 c4 10             	add    $0x10,%esp
  80acf1:	bb 00 00 00 00       	mov    $0x0,%ebx
    }
  }
  return conn;
}
  80acf6:	89 d8                	mov    %ebx,%eax
  80acf8:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80acfb:	5b                   	pop    %ebx
  80acfc:	5e                   	pop    %esi
  80acfd:	5d                   	pop    %ebp
  80acfe:	c3                   	ret    
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
  80acff:	83 ec 04             	sub    $0x4,%esp
  80ad02:	68 c8 2c 81 00       	push   $0x812cc8
  80ad07:	6a 52                	push   $0x52
  80ad09:	68 7a 2d 81 00       	push   $0x812d7a
  80ad0e:	e8 40 39 00 00       	call   80e653 <_panic>
      LWIP_ASSERT("conn has no op_completed", conn->op_completed != SYS_SEM_NULL);
  80ad13:	83 ec 04             	sub    $0x4,%esp
  80ad16:	68 91 2d 81 00       	push   $0x812d91
  80ad1b:	6a 53                	push   $0x53
  80ad1d:	68 7a 2d 81 00       	push   $0x812d7a
  80ad22:	e8 2c 39 00 00       	call   80e653 <_panic>
      LWIP_ASSERT("conn has no recvmbox", conn->recvmbox != SYS_MBOX_NULL);
  80ad27:	83 ec 04             	sub    $0x4,%esp
  80ad2a:	68 aa 2d 81 00       	push   $0x812daa
  80ad2f:	6a 54                	push   $0x54
  80ad31:	68 7a 2d 81 00       	push   $0x812d7a
  80ad36:	e8 18 39 00 00       	call   80e653 <_panic>
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", conn->acceptmbox == SYS_MBOX_NULL);
  80ad3b:	83 ec 04             	sub    $0x4,%esp
  80ad3e:	68 ec 2c 81 00       	push   $0x812cec
  80ad43:	6a 55                	push   $0x55
  80ad45:	68 7a 2d 81 00       	push   $0x812d7a
  80ad4a:	e8 04 39 00 00       	call   80e653 <_panic>

0080ad4f <netconn_delete>:
 * @param conn the netconn to delete
 * @return ERR_OK if the connection was deleted
 */
err_t
netconn_delete(struct netconn *conn)
{
  80ad4f:	55                   	push   %ebp
  80ad50:	89 e5                	mov    %esp,%ebp
  80ad52:	53                   	push   %ebx
  80ad53:	83 ec 24             	sub    $0x24,%esp
  80ad56:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
  if (conn == NULL) {
  80ad59:	85 db                	test   %ebx,%ebx
  80ad5b:	74 28                	je     80ad85 <netconn_delete+0x36>
    return ERR_OK;
  }

  msg.function = do_delconn;
  80ad5d:	c7 45 e4 1a be 80 00 	movl   $0x80be1a,-0x1c(%ebp)
  msg.msg.conn = conn;
  80ad64:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  tcpip_apimsg(&msg);
  80ad67:	83 ec 0c             	sub    $0xc,%esp
  80ad6a:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ad6d:	50                   	push   %eax
  80ad6e:	e8 e6 75 ff ff       	call   802359 <tcpip_apimsg>

  conn->pcb.tcp = NULL;
  80ad73:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netconn_free(conn);
  80ad7a:	89 1c 24             	mov    %ebx,(%esp)
  80ad7d:	e8 07 0f 00 00       	call   80bc89 <netconn_free>

  return ERR_OK;
  80ad82:	83 c4 10             	add    $0x10,%esp
}
  80ad85:	b8 00 00 00 00       	mov    $0x0,%eax
  80ad8a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ad8d:	c9                   	leave  
  80ad8e:	c3                   	ret    

0080ad8f <netconn_type>:
 * @param conn the netconn of which to get the type
 * @return the netconn_type of conn
 */
enum netconn_type
netconn_type(struct netconn *conn)
{
  80ad8f:	55                   	push   %ebp
  80ad90:	89 e5                	mov    %esp,%ebp
  80ad92:	83 ec 08             	sub    $0x8,%esp
  80ad95:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netconn_type: invalid conn", (conn != NULL), return NETCONN_INVALID;);
  80ad98:	85 c0                	test   %eax,%eax
  80ad9a:	74 04                	je     80ada0 <netconn_type+0x11>
  80ad9c:	8b 00                	mov    (%eax),%eax
  return conn->type;
}
  80ad9e:	c9                   	leave  
  80ad9f:	c3                   	ret    
  LWIP_ERROR("netconn_type: invalid conn", (conn != NULL), return NETCONN_INVALID;);
  80ada0:	83 ec 04             	sub    $0x4,%esp
  80ada3:	68 bf 2d 81 00       	push   $0x812dbf
  80ada8:	68 84 00 00 00       	push   $0x84
  80adad:	68 7a 2d 81 00       	push   $0x812d7a
  80adb2:	e8 9c 38 00 00       	call   80e653 <_panic>

0080adb7 <netconn_getaddr>:
 * @return ERR_CONN for invalid connections
 *         ERR_OK if the information was retrieved
 */
err_t
netconn_getaddr(struct netconn *conn, struct ip_addr *addr, u16_t *port, u8_t local)
{
  80adb7:	55                   	push   %ebp
  80adb8:	89 e5                	mov    %esp,%ebp
  80adba:	53                   	push   %ebx
  80adbb:	83 ec 24             	sub    $0x24,%esp
  80adbe:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80adc1:	8b 55 0c             	mov    0xc(%ebp),%edx
  80adc4:	8b 45 10             	mov    0x10(%ebp),%eax
  80adc7:	8b 4d 14             	mov    0x14(%ebp),%ecx
  struct api_msg msg;

  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
  80adca:	85 db                	test   %ebx,%ebx
  80adcc:	74 30                	je     80adfe <netconn_getaddr+0x47>
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
  80adce:	85 d2                	test   %edx,%edx
  80add0:	74 43                	je     80ae15 <netconn_getaddr+0x5e>
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
  80add2:	85 c0                	test   %eax,%eax
  80add4:	74 56                	je     80ae2c <netconn_getaddr+0x75>

  msg.function = do_getaddr;
  80add6:	c7 45 e4 65 c2 80 00 	movl   $0x80c265,-0x1c(%ebp)
  msg.msg.conn = conn;
  80addd:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.ad.ipaddr = addr;
  80ade0:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.ad.port = port;
  80ade3:	89 45 f0             	mov    %eax,-0x10(%ebp)
  msg.msg.msg.ad.local = local;
  80ade6:	88 4d f4             	mov    %cl,-0xc(%ebp)
  TCPIP_APIMSG(&msg);
  80ade9:	83 ec 0c             	sub    $0xc,%esp
  80adec:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80adef:	50                   	push   %eax
  80adf0:	e8 64 75 ff ff       	call   802359 <tcpip_apimsg>

  return conn->err;
  80adf5:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80adf9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80adfc:	c9                   	leave  
  80adfd:	c3                   	ret    
  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
  80adfe:	83 ec 04             	sub    $0x4,%esp
  80ae01:	68 da 2d 81 00       	push   $0x812dda
  80ae06:	68 98 00 00 00       	push   $0x98
  80ae0b:	68 7a 2d 81 00       	push   $0x812d7a
  80ae10:	e8 3e 38 00 00       	call   80e653 <_panic>
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
  80ae15:	83 ec 04             	sub    $0x4,%esp
  80ae18:	68 f8 2d 81 00       	push   $0x812df8
  80ae1d:	68 99 00 00 00       	push   $0x99
  80ae22:	68 7a 2d 81 00       	push   $0x812d7a
  80ae27:	e8 27 38 00 00       	call   80e653 <_panic>
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
  80ae2c:	83 ec 04             	sub    $0x4,%esp
  80ae2f:	68 16 2e 81 00       	push   $0x812e16
  80ae34:	68 9a 00 00 00       	push   $0x9a
  80ae39:	68 7a 2d 81 00       	push   $0x812d7a
  80ae3e:	e8 10 38 00 00       	call   80e653 <_panic>

0080ae43 <netconn_bind>:
 * @param port the local port to bind the netconn to (not used for RAW)
 * @return ERR_OK if bound, any other err_t on failure
 */
err_t
netconn_bind(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80ae43:	55                   	push   %ebp
  80ae44:	89 e5                	mov    %esp,%ebp
  80ae46:	53                   	push   %ebx
  80ae47:	83 ec 24             	sub    $0x24,%esp
  80ae4a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80ae4d:	8b 45 10             	mov    0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
  80ae50:	85 db                	test   %ebx,%ebx
  80ae52:	74 29                	je     80ae7d <netconn_bind+0x3a>

  msg.function = do_bind;
  80ae54:	c7 45 e4 c1 be 80 00 	movl   $0x80bec1,-0x1c(%ebp)
  msg.msg.conn = conn;
  80ae5b:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80ae5e:	8b 55 0c             	mov    0xc(%ebp),%edx
  80ae61:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.bc.port = port;
  80ae64:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  TCPIP_APIMSG(&msg);
  80ae68:	83 ec 0c             	sub    $0xc,%esp
  80ae6b:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ae6e:	50                   	push   %eax
  80ae6f:	e8 e5 74 ff ff       	call   802359 <tcpip_apimsg>
  return conn->err;
  80ae74:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80ae78:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ae7b:	c9                   	leave  
  80ae7c:	c3                   	ret    
  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
  80ae7d:	83 ec 04             	sub    $0x4,%esp
  80ae80:	68 34 2e 81 00       	push   $0x812e34
  80ae85:	68 b5 00 00 00       	push   $0xb5
  80ae8a:	68 7a 2d 81 00       	push   $0x812d7a
  80ae8f:	e8 bf 37 00 00       	call   80e653 <_panic>

0080ae94 <netconn_connect>:
 * @param port the remote port to connect to (no used for RAW)
 * @return ERR_OK if connected, return value of tcp_/udp_/raw_connect otherwise
 */
err_t
netconn_connect(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80ae94:	55                   	push   %ebp
  80ae95:	89 e5                	mov    %esp,%ebp
  80ae97:	53                   	push   %ebx
  80ae98:	83 ec 24             	sub    $0x24,%esp
  80ae9b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80ae9e:	8b 45 10             	mov    0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
  80aea1:	85 db                	test   %ebx,%ebx
  80aea3:	74 29                	je     80aece <netconn_connect+0x3a>

  msg.function = do_connect;
  80aea5:	c7 45 e4 4f bf 80 00 	movl   $0x80bf4f,-0x1c(%ebp)
  msg.msg.conn = conn;
  80aeac:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80aeaf:	8b 55 0c             	mov    0xc(%ebp),%edx
  80aeb2:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.bc.port = port;
  80aeb5:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  /* This is the only function which need to not block tcpip_thread */
  tcpip_apimsg(&msg);
  80aeb9:	83 ec 0c             	sub    $0xc,%esp
  80aebc:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80aebf:	50                   	push   %eax
  80aec0:	e8 94 74 ff ff       	call   802359 <tcpip_apimsg>
  return conn->err;
  80aec5:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80aec9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80aecc:	c9                   	leave  
  80aecd:	c3                   	ret    
  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
  80aece:	83 ec 04             	sub    $0x4,%esp
  80aed1:	68 4f 2e 81 00       	push   $0x812e4f
  80aed6:	68 cc 00 00 00       	push   $0xcc
  80aedb:	68 7a 2d 81 00       	push   $0x812d7a
  80aee0:	e8 6e 37 00 00       	call   80e653 <_panic>

0080aee5 <netconn_disconnect>:
 * @param conn the netconn to disconnect
 * @return TODO: return value is not set here...
 */
err_t
netconn_disconnect(struct netconn *conn)
{
  80aee5:	55                   	push   %ebp
  80aee6:	89 e5                	mov    %esp,%ebp
  80aee8:	53                   	push   %ebx
  80aee9:	83 ec 24             	sub    $0x24,%esp
  80aeec:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
  80aeef:	85 db                	test   %ebx,%ebx
  80aef1:	74 1f                	je     80af12 <netconn_disconnect+0x2d>

  msg.function = do_disconnect;
  80aef3:	c7 45 e4 04 c0 80 00 	movl   $0x80c004,-0x1c(%ebp)
  msg.msg.conn = conn;
  80aefa:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  TCPIP_APIMSG(&msg);
  80aefd:	83 ec 0c             	sub    $0xc,%esp
  80af00:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80af03:	50                   	push   %eax
  80af04:	e8 50 74 ff ff       	call   802359 <tcpip_apimsg>
  return conn->err;
  80af09:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80af0d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80af10:	c9                   	leave  
  80af11:	c3                   	ret    
  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
  80af12:	83 ec 04             	sub    $0x4,%esp
  80af15:	68 10 2d 81 00       	push   $0x812d10
  80af1a:	68 e2 00 00 00       	push   $0xe2
  80af1f:	68 7a 2d 81 00       	push   $0x812d7a
  80af24:	e8 2a 37 00 00       	call   80e653 <_panic>

0080af29 <netconn_listen_with_backlog>:
 * @return ERR_OK if the netconn was set to listen (UDP and RAW netconns
 *         don't return any error (yet?))
 */
err_t
netconn_listen_with_backlog(struct netconn *conn, u8_t backlog)
{
  80af29:	55                   	push   %ebp
  80af2a:	89 e5                	mov    %esp,%ebp
  80af2c:	53                   	push   %ebx
  80af2d:	83 ec 24             	sub    $0x24,%esp
  80af30:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */
  LWIP_UNUSED_ARG(backlog);

  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
  80af33:	85 db                	test   %ebx,%ebx
  80af35:	74 1f                	je     80af56 <netconn_listen_with_backlog+0x2d>

  msg.function = do_listen;
  80af37:	c7 45 e4 41 c0 80 00 	movl   $0x80c041,-0x1c(%ebp)
  msg.msg.conn = conn;
  80af3e:	89 5d e8             	mov    %ebx,-0x18(%ebp)
#if TCP_LISTEN_BACKLOG
  msg.msg.msg.lb.backlog = backlog;
#endif /* TCP_LISTEN_BACKLOG */
  TCPIP_APIMSG(&msg);
  80af41:	83 ec 0c             	sub    $0xc,%esp
  80af44:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80af47:	50                   	push   %eax
  80af48:	e8 0c 74 ff ff       	call   802359 <tcpip_apimsg>
  return conn->err;
  80af4d:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80af51:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80af54:	c9                   	leave  
  80af55:	c3                   	ret    
  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
  80af56:	83 ec 04             	sub    $0x4,%esp
  80af59:	68 6d 2e 81 00       	push   $0x812e6d
  80af5e:	68 fa 00 00 00       	push   $0xfa
  80af63:	68 7a 2d 81 00       	push   $0x812d7a
  80af68:	e8 e6 36 00 00       	call   80e653 <_panic>

0080af6d <netconn_accept>:
 * @param conn the TCP listen netconn
 * @return the newly accepted netconn or NULL on timeout
 */
struct netconn *
netconn_accept(struct netconn *conn)
{
  80af6d:	55                   	push   %ebp
  80af6e:	89 e5                	mov    %esp,%ebp
  80af70:	53                   	push   %ebx
  80af71:	83 ec 14             	sub    $0x14,%esp
  80af74:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct netconn *newconn;

  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return NULL;);
  80af77:	85 db                	test   %ebx,%ebx
  80af79:	74 36                	je     80afb1 <netconn_accept+0x44>
  LWIP_ERROR("netconn_accept: invalid acceptmbox", (conn->acceptmbox != SYS_MBOX_NULL), return NULL;);
  80af7b:	8b 43 18             	mov    0x18(%ebx),%eax
  80af7e:	83 f8 ff             	cmp    $0xffffffff,%eax
  80af81:	74 45                	je     80afc8 <netconn_accept+0x5b>
#if LWIP_SO_RCVTIMEO
  if (sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
    newconn = NULL;
  } else
#else
  sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, 0);
  80af83:	83 ec 04             	sub    $0x4,%esp
  80af86:	6a 00                	push   $0x0
  80af88:	8d 55 f4             	lea    -0xc(%ebp),%edx
  80af8b:	52                   	push   %edx
  80af8c:	50                   	push   %eax
  80af8d:	e8 07 f4 ff ff       	call   80a399 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/
  {
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
  80af92:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80af95:	83 c4 10             	add    $0x10,%esp
  80af98:	85 c0                	test   %eax,%eax
  80af9a:	74 0d                	je     80afa9 <netconn_accept+0x3c>
  80af9c:	83 ec 04             	sub    $0x4,%esp
  80af9f:	6a 00                	push   $0x0
  80afa1:	6a 01                	push   $0x1
  80afa3:	53                   	push   %ebx
  80afa4:	ff d0                	call   *%eax
  80afa6:	83 c4 10             	add    $0x10,%esp
    }
#endif /* TCP_LISTEN_BACKLOG */
  }

  return newconn;
}
  80afa9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80afac:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80afaf:	c9                   	leave  
  80afb0:	c3                   	ret    
  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return NULL;);
  80afb1:	83 ec 04             	sub    $0x4,%esp
  80afb4:	68 8a 2e 81 00       	push   $0x812e8a
  80afb9:	68 10 01 00 00       	push   $0x110
  80afbe:	68 7a 2d 81 00       	push   $0x812d7a
  80afc3:	e8 8b 36 00 00       	call   80e653 <_panic>
  LWIP_ERROR("netconn_accept: invalid acceptmbox", (conn->acceptmbox != SYS_MBOX_NULL), return NULL;);
  80afc8:	83 ec 04             	sub    $0x4,%esp
  80afcb:	68 34 2d 81 00       	push   $0x812d34
  80afd0:	68 11 01 00 00       	push   $0x111
  80afd5:	68 7a 2d 81 00       	push   $0x812d7a
  80afda:	e8 74 36 00 00       	call   80e653 <_panic>

0080afdf <netconn_recv>:
 * @param conn the netconn from which to receive data
 * @return a new netbuf containing received data or NULL on memory error or timeout
 */
struct netbuf *
netconn_recv(struct netconn *conn)
{
  80afdf:	55                   	push   %ebp
  80afe0:	89 e5                	mov    %esp,%ebp
  80afe2:	53                   	push   %ebx
  80afe3:	83 ec 24             	sub    $0x24,%esp
  80afe6:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;
  struct netbuf *buf = NULL;
  80afe9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  struct pbuf *p;
  u16_t len;

  LWIP_ERROR("netconn_recv: invalid conn",  (conn != NULL), return NULL;);
  80aff0:	85 db                	test   %ebx,%ebx
  80aff2:	0f 84 cf 00 00 00    	je     80b0c7 <netconn_recv+0xe8>

  if (conn->recvmbox == SYS_MBOX_NULL) {
  80aff8:	8b 43 14             	mov    0x14(%ebx),%eax
  80affb:	83 f8 ff             	cmp    $0xffffffff,%eax
  80affe:	0f 84 da 00 00 00    	je     80b0de <netconn_recv+0xff>
    /* TCP listen conns don't have a recvmbox! */
    conn->err = ERR_CONN;
    return NULL;
  }

  if (ERR_IS_FATAL(conn->err)) {
  80b004:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  80b008:	0f 8c 5a 01 00 00    	jl     80b168 <netconn_recv+0x189>
    return NULL;
  }

  if (conn->type == NETCONN_TCP) {
  80b00e:	83 3b 10             	cmpl   $0x10,(%ebx)
  80b011:	0f 85 0c 01 00 00    	jne    80b123 <netconn_recv+0x144>
#if LWIP_TCP
    if (conn->state == NETCONN_LISTEN) {
  80b017:	83 7b 04 02          	cmpl   $0x2,0x4(%ebx)
  80b01b:	0f 84 c8 00 00 00    	je     80b0e9 <netconn_recv+0x10a>
      /* @todo: should calling netconn_recv on a TCP listen conn be fatal?? */
      conn->err = ERR_CONN;
      return NULL;
    }

    buf = memp_malloc(MEMP_NETBUF);
  80b021:	83 ec 0c             	sub    $0xc,%esp
  80b024:	6a 06                	push   $0x6
  80b026:	e8 5d 94 ff ff       	call   804488 <memp_malloc>
  80b02b:	89 45 e0             	mov    %eax,-0x20(%ebp)

    if (buf == NULL) {
  80b02e:	83 c4 10             	add    $0x10,%esp
  80b031:	85 c0                	test   %eax,%eax
  80b033:	0f 84 bb 00 00 00    	je     80b0f4 <netconn_recv+0x115>
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      conn->err = ERR_TIMEOUT;
      p = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, 0);
  80b039:	83 ec 04             	sub    $0x4,%esp
  80b03c:	6a 00                	push   $0x0
  80b03e:	8d 45 dc             	lea    -0x24(%ebp),%eax
  80b041:	50                   	push   %eax
  80b042:	ff 73 14             	pushl  0x14(%ebx)
  80b045:	e8 4f f3 ff ff       	call   80a399 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/

    if (p != NULL) {
  80b04a:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80b04d:	83 c4 10             	add    $0x10,%esp
  80b050:	85 c0                	test   %eax,%eax
  80b052:	0f 84 1a 01 00 00    	je     80b172 <netconn_recv+0x193>
      len = p->tot_len;
  80b058:	0f b7 50 08          	movzwl 0x8(%eax),%edx
      SYS_ARCH_DEC(conn->recv_avail, len);
  80b05c:	66 29 53 20          	sub    %dx,0x20(%ebx)
    } else {
      len = 0;
    }

    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80b060:	8b 4b 2c             	mov    0x2c(%ebx),%ecx
  80b063:	85 c9                	test   %ecx,%ecx
  80b065:	74 16                	je     80b07d <netconn_recv+0x9e>
  80b067:	83 ec 04             	sub    $0x4,%esp
  80b06a:	0f b7 d2             	movzwl %dx,%edx
  80b06d:	52                   	push   %edx
  80b06e:	6a 01                	push   $0x1
  80b070:	53                   	push   %ebx
  80b071:	ff d1                	call   *%ecx

    /* If we are closed, we indicate that we no longer wish to use the socket */
    if (p == NULL) {
  80b073:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80b076:	83 c4 10             	add    $0x10,%esp
  80b079:	85 c0                	test   %eax,%eax
  80b07b:	74 7d                	je     80b0fa <netconn_recv+0x11b>
        conn->err = ERR_CLSD;
      }
      return NULL;
    }

    buf->p = p;
  80b07d:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80b080:	89 02                	mov    %eax,(%edx)
    buf->ptr = p;
  80b082:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80b085:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80b088:	89 50 04             	mov    %edx,0x4(%eax)
    buf->port = 0;
  80b08b:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
    buf->addr = NULL;
  80b091:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

    /* Let the stack know that we have taken the data. */
    msg.function = do_recv;
  80b098:	c7 45 e4 cf c1 80 00 	movl   $0x80c1cf,-0x1c(%ebp)
    msg.msg.conn = conn;
  80b09f:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    if (buf != NULL) {
  80b0a2:	85 c0                	test   %eax,%eax
  80b0a4:	74 75                	je     80b11b <netconn_recv+0x13c>
      msg.msg.msg.r.len = buf->p->tot_len;
  80b0a6:	8b 00                	mov    (%eax),%eax
  80b0a8:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80b0ac:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    } else {
      msg.msg.msg.r.len = 1;
    }
    TCPIP_APIMSG(&msg);
  80b0b0:	83 ec 0c             	sub    $0xc,%esp
  80b0b3:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b0b6:	50                   	push   %eax
  80b0b7:	e8 9d 72 ff ff       	call   802359 <tcpip_apimsg>
  80b0bc:	83 c4 10             	add    $0x10,%esp
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv: received %p (err %d)\n", (void *)buf, conn->err));

  return buf;
  80b0bf:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
  80b0c2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b0c5:	c9                   	leave  
  80b0c6:	c3                   	ret    
  LWIP_ERROR("netconn_recv: invalid conn",  (conn != NULL), return NULL;);
  80b0c7:	83 ec 04             	sub    $0x4,%esp
  80b0ca:	68 a7 2e 81 00       	push   $0x812ea7
  80b0cf:	68 3a 01 00 00       	push   $0x13a
  80b0d4:	68 7a 2d 81 00       	push   $0x812d7a
  80b0d9:	e8 75 35 00 00       	call   80e653 <_panic>
    conn->err = ERR_CONN;
  80b0de:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
    return NULL;
  80b0e2:	b8 00 00 00 00       	mov    $0x0,%eax
  80b0e7:	eb d9                	jmp    80b0c2 <netconn_recv+0xe3>
      conn->err = ERR_CONN;
  80b0e9:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
      return NULL;
  80b0ed:	b8 00 00 00 00       	mov    $0x0,%eax
  80b0f2:	eb ce                	jmp    80b0c2 <netconn_recv+0xe3>
      conn->err = ERR_MEM;
  80b0f4:	c6 43 0c ff          	movb   $0xff,0xc(%ebx)
      return NULL;
  80b0f8:	eb c8                	jmp    80b0c2 <netconn_recv+0xe3>
      memp_free(MEMP_NETBUF, buf);
  80b0fa:	83 ec 08             	sub    $0x8,%esp
  80b0fd:	ff 75 e0             	pushl  -0x20(%ebp)
  80b100:	6a 06                	push   $0x6
  80b102:	e8 d7 93 ff ff       	call   8044de <memp_free>
      if (conn->err == ERR_OK) {
  80b107:	83 c4 10             	add    $0x10,%esp
      return NULL;
  80b10a:	b8 00 00 00 00       	mov    $0x0,%eax
      if (conn->err == ERR_OK) {
  80b10f:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80b113:	75 ad                	jne    80b0c2 <netconn_recv+0xe3>
        conn->err = ERR_CLSD;
  80b115:	c6 43 0c f9          	movb   $0xf9,0xc(%ebx)
  80b119:	eb a7                	jmp    80b0c2 <netconn_recv+0xe3>
      msg.msg.msg.r.len = 1;
  80b11b:	66 c7 45 ec 01 00    	movw   $0x1,-0x14(%ebp)
  80b121:	eb 8d                	jmp    80b0b0 <netconn_recv+0xd1>
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, 0);
  80b123:	83 ec 04             	sub    $0x4,%esp
  80b126:	6a 00                	push   $0x0
  80b128:	8d 55 e0             	lea    -0x20(%ebp),%edx
  80b12b:	52                   	push   %edx
  80b12c:	50                   	push   %eax
  80b12d:	e8 67 f2 ff ff       	call   80a399 <sys_arch_mbox_fetch>
    if (buf!=NULL) {
  80b132:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80b135:	83 c4 10             	add    $0x10,%esp
  80b138:	85 c0                	test   %eax,%eax
  80b13a:	74 83                	je     80b0bf <netconn_recv+0xe0>
      SYS_ARCH_DEC(conn->recv_avail, buf->p->tot_len);
  80b13c:	8b 10                	mov    (%eax),%edx
  80b13e:	0f b7 52 08          	movzwl 0x8(%edx),%edx
  80b142:	66 29 53 20          	sub    %dx,0x20(%ebx)
      API_EVENT(conn, NETCONN_EVT_RCVMINUS, buf->p->tot_len);
  80b146:	8b 53 2c             	mov    0x2c(%ebx),%edx
  80b149:	85 d2                	test   %edx,%edx
  80b14b:	0f 84 6e ff ff ff    	je     80b0bf <netconn_recv+0xe0>
  80b151:	83 ec 04             	sub    $0x4,%esp
  80b154:	8b 00                	mov    (%eax),%eax
  80b156:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80b15a:	50                   	push   %eax
  80b15b:	6a 01                	push   $0x1
  80b15d:	53                   	push   %ebx
  80b15e:	ff d2                	call   *%edx
  80b160:	83 c4 10             	add    $0x10,%esp
  80b163:	e9 57 ff ff ff       	jmp    80b0bf <netconn_recv+0xe0>
    return NULL;
  80b168:	b8 00 00 00 00       	mov    $0x0,%eax
  80b16d:	e9 50 ff ff ff       	jmp    80b0c2 <netconn_recv+0xe3>
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80b172:	8b 4b 2c             	mov    0x2c(%ebx),%ecx
  80b175:	85 c9                	test   %ecx,%ecx
  80b177:	74 81                	je     80b0fa <netconn_recv+0x11b>
      len = 0;
  80b179:	ba 00 00 00 00       	mov    $0x0,%edx
  80b17e:	e9 e4 fe ff ff       	jmp    80b067 <netconn_recv+0x88>

0080b183 <netconn_send>:
 * @param buf a netbuf containing the data to send
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_send(struct netconn *conn, struct netbuf *buf)
{
  80b183:	55                   	push   %ebp
  80b184:	89 e5                	mov    %esp,%ebp
  80b186:	53                   	push   %ebx
  80b187:	83 ec 24             	sub    $0x24,%esp
  80b18a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b18d:	85 db                	test   %ebx,%ebx
  80b18f:	74 25                	je     80b1b6 <netconn_send+0x33>

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %d bytes\n", buf->p->tot_len));
  msg.function = do_send;
  80b191:	c7 45 e4 29 c1 80 00 	movl   $0x80c129,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b198:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.b = buf;
  80b19b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b19e:	89 45 ec             	mov    %eax,-0x14(%ebp)
  TCPIP_APIMSG(&msg);
  80b1a1:	83 ec 0c             	sub    $0xc,%esp
  80b1a4:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b1a7:	50                   	push   %eax
  80b1a8:	e8 ac 71 ff ff       	call   802359 <tcpip_apimsg>
  return conn->err;
  80b1ad:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b1b1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b1b4:	c9                   	leave  
  80b1b5:	c3                   	ret    
  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b1b6:	83 ec 04             	sub    $0x4,%esp
  80b1b9:	68 c2 2e 81 00       	push   $0x812ec2
  80b1be:	68 b9 01 00 00       	push   $0x1b9
  80b1c3:	68 7a 2d 81 00       	push   $0x812d7a
  80b1c8:	e8 86 34 00 00       	call   80e653 <_panic>

0080b1cd <netconn_sendto>:
{
  80b1cd:	55                   	push   %ebp
  80b1ce:	89 e5                	mov    %esp,%ebp
  80b1d0:	83 ec 08             	sub    $0x8,%esp
  80b1d3:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b1d6:	8b 55 14             	mov    0x14(%ebp),%edx
  if (buf != NULL) {
  80b1d9:	85 c0                	test   %eax,%eax
  80b1db:	74 1b                	je     80b1f8 <netconn_sendto+0x2b>
    buf->addr = addr;
  80b1dd:	8b 4d 10             	mov    0x10(%ebp),%ecx
  80b1e0:	89 48 08             	mov    %ecx,0x8(%eax)
    buf->port = port;
  80b1e3:	66 89 50 0c          	mov    %dx,0xc(%eax)
    return netconn_send(conn, buf);
  80b1e7:	83 ec 08             	sub    $0x8,%esp
  80b1ea:	50                   	push   %eax
  80b1eb:	ff 75 08             	pushl  0x8(%ebp)
  80b1ee:	e8 90 ff ff ff       	call   80b183 <netconn_send>
  80b1f3:	83 c4 10             	add    $0x10,%esp
}
  80b1f6:	c9                   	leave  
  80b1f7:	c3                   	ret    
  return ERR_VAL;
  80b1f8:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80b1fd:	eb f7                	jmp    80b1f6 <netconn_sendto+0x29>

0080b1ff <netconn_write>:
 * - NETCONN_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_write(struct netconn *conn, const void *dataptr, int size, u8_t apiflags)
{
  80b1ff:	55                   	push   %ebp
  80b200:	89 e5                	mov    %esp,%ebp
  80b202:	53                   	push   %ebx
  80b203:	83 ec 24             	sub    $0x24,%esp
  80b206:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b209:	8b 45 14             	mov    0x14(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b20c:	85 db                	test   %ebx,%ebx
  80b20e:	74 33                	je     80b243 <netconn_write+0x44>
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
  80b210:	83 3b 10             	cmpl   $0x10,(%ebx)
  80b213:	75 45                	jne    80b25a <netconn_write+0x5b>

  msg.function = do_write;
  80b215:	c7 45 e4 15 c2 80 00 	movl   $0x80c215,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b21c:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.w.dataptr = dataptr;
  80b21f:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b222:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.w.apiflags = apiflags;
  80b225:	88 45 f4             	mov    %al,-0xc(%ebp)
  msg.msg.msg.w.len = size;
  80b228:	8b 45 10             	mov    0x10(%ebp),%eax
  80b22b:	89 45 f0             	mov    %eax,-0x10(%ebp)
  /* For locking the core: this _can_ be delayed on low memory/low send buffer,
     but if it is, this is done inside api_msg.c:do_write(), so we can use the
     non-blocking version here. */
  TCPIP_APIMSG(&msg);
  80b22e:	83 ec 0c             	sub    $0xc,%esp
  80b231:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b234:	50                   	push   %eax
  80b235:	e8 1f 71 ff ff       	call   802359 <tcpip_apimsg>
  return conn->err;
  80b23a:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b23e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b241:	c9                   	leave  
  80b242:	c3                   	ret    
  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b243:	83 ec 04             	sub    $0x4,%esp
  80b246:	68 dd 2e 81 00       	push   $0x812edd
  80b24b:	68 d3 01 00 00       	push   $0x1d3
  80b250:	68 7a 2d 81 00       	push   $0x812d7a
  80b255:	e8 f9 33 00 00       	call   80e653 <_panic>
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
  80b25a:	83 ec 04             	sub    $0x4,%esp
  80b25d:	68 58 2d 81 00       	push   $0x812d58
  80b262:	68 d4 01 00 00       	push   $0x1d4
  80b267:	68 7a 2d 81 00       	push   $0x812d7a
  80b26c:	e8 e2 33 00 00       	call   80e653 <_panic>

0080b271 <netconn_close>:
 * @param conn the TCP netconn to close
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
err_t
netconn_close(struct netconn *conn)
{
  80b271:	55                   	push   %ebp
  80b272:	89 e5                	mov    %esp,%ebp
  80b274:	53                   	push   %ebx
  80b275:	83 ec 24             	sub    $0x24,%esp
  80b278:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b27b:	85 db                	test   %ebx,%ebx
  80b27d:	74 1f                	je     80b29e <netconn_close+0x2d>

  msg.function = do_close;
  80b27f:	c7 45 e4 27 c3 80 00 	movl   $0x80c327,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b286:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  tcpip_apimsg(&msg);
  80b289:	83 ec 0c             	sub    $0xc,%esp
  80b28c:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b28f:	50                   	push   %eax
  80b290:	e8 c4 70 ff ff       	call   802359 <tcpip_apimsg>
  return conn->err;
  80b295:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b299:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b29c:	c9                   	leave  
  80b29d:	c3                   	ret    
  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b29e:	83 ec 04             	sub    $0x4,%esp
  80b2a1:	68 f9 2e 81 00       	push   $0x812ef9
  80b2a6:	68 ed 01 00 00       	push   $0x1ed
  80b2ab:	68 7a 2d 81 00       	push   $0x812d7a
  80b2b0:	e8 9e 33 00 00       	call   80e653 <_panic>

0080b2b5 <recv_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.recv) for parameters and return value
 */
static err_t
recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  80b2b5:	55                   	push   %ebp
  80b2b6:	89 e5                	mov    %esp,%ebp
  80b2b8:	56                   	push   %esi
  80b2b9:	53                   	push   %ebx
  80b2ba:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b2bd:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b2c0:	8b 75 10             	mov    0x10(%ebp),%esi
  80b2c3:	8b 55 14             	mov    0x14(%ebp),%edx
  struct netconn *conn;
  u16_t len;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  80b2c6:	85 c0                	test   %eax,%eax
  80b2c8:	74 5a                	je     80b324 <recv_tcp+0x6f>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  80b2ca:	85 db                	test   %ebx,%ebx
  80b2cc:	74 6d                	je     80b33b <recv_tcp+0x86>
  conn = arg;
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
  80b2ce:	39 43 08             	cmp    %eax,0x8(%ebx)
  80b2d1:	75 7f                	jne    80b352 <recv_tcp+0x9d>

  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80b2d3:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b2d7:	0f 84 8c 00 00 00    	je     80b369 <recv_tcp+0xb4>
    return ERR_VAL;
  }

  conn->err = err;
  80b2dd:	88 53 0c             	mov    %dl,0xc(%ebx)
  if (p != NULL) {
    len = p->tot_len;
    SYS_ARCH_INC(conn->recv_avail, len);
  } else {
    len = 0;
  80b2e0:	b8 00 00 00 00       	mov    $0x0,%eax
  if (p != NULL) {
  80b2e5:	85 f6                	test   %esi,%esi
  80b2e7:	74 08                	je     80b2f1 <recv_tcp+0x3c>
    len = p->tot_len;
  80b2e9:	0f b7 46 08          	movzwl 0x8(%esi),%eax
    SYS_ARCH_INC(conn->recv_avail, len);
  80b2ed:	66 01 43 20          	add    %ax,0x20(%ebx)
  }
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
  80b2f1:	8b 53 2c             	mov    0x2c(%ebx),%edx
  80b2f4:	85 d2                	test   %edx,%edx
  80b2f6:	74 0f                	je     80b307 <recv_tcp+0x52>
  80b2f8:	83 ec 04             	sub    $0x4,%esp
  80b2fb:	0f b7 c0             	movzwl %ax,%eax
  80b2fe:	50                   	push   %eax
  80b2ff:	6a 00                	push   $0x0
  80b301:	53                   	push   %ebx
  80b302:	ff d2                	call   *%edx
  80b304:	83 c4 10             	add    $0x10,%esp
  if (sys_mbox_trypost(conn->recvmbox, p) != ERR_OK) {
  80b307:	83 ec 08             	sub    $0x8,%esp
  80b30a:	56                   	push   %esi
  80b30b:	ff 73 14             	pushl  0x14(%ebx)
  80b30e:	e8 91 ef ff ff       	call   80a2a4 <sys_mbox_trypost>
  80b313:	83 c4 10             	add    $0x10,%esp
  80b316:	84 c0                	test   %al,%al
  80b318:	0f 95 c0             	setne  %al
  80b31b:	f7 d8                	neg    %eax
    return ERR_MEM;
  }

  return ERR_OK;
}
  80b31d:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80b320:	5b                   	pop    %ebx
  80b321:	5e                   	pop    %esi
  80b322:	5d                   	pop    %ebp
  80b323:	c3                   	ret    
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  80b324:	83 ec 04             	sub    $0x4,%esp
  80b327:	68 18 2f 81 00       	push   $0x812f18
  80b32c:	68 c1 00 00 00       	push   $0xc1
  80b331:	68 62 30 81 00       	push   $0x813062
  80b336:	e8 18 33 00 00       	call   80e653 <_panic>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  80b33b:	83 ec 04             	sub    $0x4,%esp
  80b33e:	68 3c 2f 81 00       	push   $0x812f3c
  80b343:	68 c2 00 00 00       	push   $0xc2
  80b348:	68 62 30 81 00       	push   $0x813062
  80b34d:	e8 01 33 00 00       	call   80e653 <_panic>
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
  80b352:	83 ec 04             	sub    $0x4,%esp
  80b355:	68 79 30 81 00       	push   $0x813079
  80b35a:	68 c4 00 00 00       	push   $0xc4
  80b35f:	68 62 30 81 00       	push   $0x813062
  80b364:	e8 ea 32 00 00       	call   80e653 <_panic>
    return ERR_VAL;
  80b369:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80b36e:	eb ad                	jmp    80b31d <recv_tcp+0x68>

0080b370 <recv_udp>:
{
  80b370:	55                   	push   %ebp
  80b371:	89 e5                	mov    %esp,%ebp
  80b373:	57                   	push   %edi
  80b374:	56                   	push   %esi
  80b375:	53                   	push   %ebx
  80b376:	83 ec 1c             	sub    $0x1c,%esp
  80b379:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b37c:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b37f:	8b 7d 10             	mov    0x10(%ebp),%edi
  80b382:	8b 4d 18             	mov    0x18(%ebp),%ecx
  80b385:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  80b388:	85 c0                	test   %eax,%eax
  80b38a:	74 7f                	je     80b40b <recv_udp+0x9b>
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
  80b38c:	85 db                	test   %ebx,%ebx
  80b38e:	0f 84 8e 00 00 00    	je     80b422 <recv_udp+0xb2>
  LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
  80b394:	39 43 08             	cmp    %eax,0x8(%ebx)
  80b397:	0f 85 9c 00 00 00    	jne    80b439 <recv_udp+0xc9>
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80b39d:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b3a1:	0f 84 a9 00 00 00    	je     80b450 <recv_udp+0xe0>
  buf = memp_malloc(MEMP_NETBUF);
  80b3a7:	83 ec 0c             	sub    $0xc,%esp
  80b3aa:	6a 06                	push   $0x6
  80b3ac:	e8 d7 90 ff ff       	call   804488 <memp_malloc>
  80b3b1:	89 c6                	mov    %eax,%esi
  if (buf == NULL) {
  80b3b3:	83 c4 10             	add    $0x10,%esp
  80b3b6:	85 c0                	test   %eax,%eax
  80b3b8:	0f 84 a0 00 00 00    	je     80b45e <recv_udp+0xee>
    buf->p = p;
  80b3be:	89 38                	mov    %edi,(%eax)
    buf->ptr = p;
  80b3c0:	89 78 04             	mov    %edi,0x4(%eax)
    buf->addr = addr;
  80b3c3:	8b 45 14             	mov    0x14(%ebp),%eax
  80b3c6:	89 46 08             	mov    %eax,0x8(%esi)
    buf->port = port;
  80b3c9:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80b3cd:	66 89 46 0c          	mov    %ax,0xc(%esi)
  SYS_ARCH_INC(conn->recv_avail, p->tot_len);
  80b3d1:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80b3d5:	66 01 43 20          	add    %ax,0x20(%ebx)
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, p->tot_len);
  80b3d9:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b3dc:	85 c0                	test   %eax,%eax
  80b3de:	74 10                	je     80b3f0 <recv_udp+0x80>
  80b3e0:	83 ec 04             	sub    $0x4,%esp
  80b3e3:	0f b7 57 08          	movzwl 0x8(%edi),%edx
  80b3e7:	52                   	push   %edx
  80b3e8:	6a 00                	push   $0x0
  80b3ea:	53                   	push   %ebx
  80b3eb:	ff d0                	call   *%eax
  80b3ed:	83 c4 10             	add    $0x10,%esp
  if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80b3f0:	83 ec 08             	sub    $0x8,%esp
  80b3f3:	56                   	push   %esi
  80b3f4:	ff 73 14             	pushl  0x14(%ebx)
  80b3f7:	e8 a8 ee ff ff       	call   80a2a4 <sys_mbox_trypost>
  80b3fc:	83 c4 10             	add    $0x10,%esp
  80b3ff:	84 c0                	test   %al,%al
  80b401:	75 69                	jne    80b46c <recv_udp+0xfc>
}
  80b403:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80b406:	5b                   	pop    %ebx
  80b407:	5e                   	pop    %esi
  80b408:	5f                   	pop    %edi
  80b409:	5d                   	pop    %ebp
  80b40a:	c3                   	ret    
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  80b40b:	83 ec 04             	sub    $0x4,%esp
  80b40e:	68 5c 2f 81 00       	push   $0x812f5c
  80b413:	68 8e 00 00 00       	push   $0x8e
  80b418:	68 62 30 81 00       	push   $0x813062
  80b41d:	e8 31 32 00 00       	call   80e653 <_panic>
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
  80b422:	83 ec 04             	sub    $0x4,%esp
  80b425:	68 80 2f 81 00       	push   $0x812f80
  80b42a:	68 8f 00 00 00       	push   $0x8f
  80b42f:	68 62 30 81 00       	push   $0x813062
  80b434:	e8 1a 32 00 00       	call   80e653 <_panic>
  LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
  80b439:	83 ec 04             	sub    $0x4,%esp
  80b43c:	68 97 30 81 00       	push   $0x813097
  80b441:	68 91 00 00 00       	push   $0x91
  80b446:	68 62 30 81 00       	push   $0x813062
  80b44b:	e8 03 32 00 00       	call   80e653 <_panic>
    pbuf_free(p);
  80b450:	83 ec 0c             	sub    $0xc,%esp
  80b453:	57                   	push   %edi
  80b454:	e8 f4 93 ff ff       	call   80484d <pbuf_free>
    return;
  80b459:	83 c4 10             	add    $0x10,%esp
  80b45c:	eb a5                	jmp    80b403 <recv_udp+0x93>
    pbuf_free(p);
  80b45e:	83 ec 0c             	sub    $0xc,%esp
  80b461:	57                   	push   %edi
  80b462:	e8 e6 93 ff ff       	call   80484d <pbuf_free>
    return;
  80b467:	83 c4 10             	add    $0x10,%esp
  80b46a:	eb 97                	jmp    80b403 <recv_udp+0x93>
    netbuf_delete(buf);
  80b46c:	83 ec 0c             	sub    $0xc,%esp
  80b46f:	56                   	push   %esi
  80b470:	e8 d4 6f ff ff       	call   802449 <netbuf_delete>
    return;
  80b475:	83 c4 10             	add    $0x10,%esp
  80b478:	eb 89                	jmp    80b403 <recv_udp+0x93>

0080b47a <recv_raw>:
{
  80b47a:	55                   	push   %ebp
  80b47b:	89 e5                	mov    %esp,%ebp
  80b47d:	57                   	push   %edi
  80b47e:	56                   	push   %esi
  80b47f:	53                   	push   %ebx
  80b480:	83 ec 0c             	sub    $0xc,%esp
  80b483:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL)) {
  80b486:	85 db                	test   %ebx,%ebx
  80b488:	0f 84 98 00 00 00    	je     80b526 <recv_raw+0xac>
  80b48e:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b492:	0f 84 8e 00 00 00    	je     80b526 <recv_raw+0xac>
    q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  80b498:	83 ec 04             	sub    $0x4,%esp
  80b49b:	6a 00                	push   $0x0
  80b49d:	8b 45 10             	mov    0x10(%ebp),%eax
  80b4a0:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80b4a4:	50                   	push   %eax
  80b4a5:	6a 03                	push   $0x3
  80b4a7:	e8 67 94 ff ff       	call   804913 <pbuf_alloc>
  80b4ac:	89 c6                	mov    %eax,%esi
    if(q != NULL) {
  80b4ae:	83 c4 10             	add    $0x10,%esp
  80b4b1:	85 c0                	test   %eax,%eax
  80b4b3:	74 71                	je     80b526 <recv_raw+0xac>
      if (pbuf_copy(q, p) != ERR_OK) {
  80b4b5:	83 ec 08             	sub    $0x8,%esp
  80b4b8:	ff 75 10             	pushl  0x10(%ebp)
  80b4bb:	50                   	push   %eax
  80b4bc:	e8 2b 99 ff ff       	call   804dec <pbuf_copy>
  80b4c1:	83 c4 10             	add    $0x10,%esp
  80b4c4:	84 c0                	test   %al,%al
  80b4c6:	75 6b                	jne    80b533 <recv_raw+0xb9>
      buf = memp_malloc(MEMP_NETBUF);
  80b4c8:	83 ec 0c             	sub    $0xc,%esp
  80b4cb:	6a 06                	push   $0x6
  80b4cd:	e8 b6 8f ff ff       	call   804488 <memp_malloc>
  80b4d2:	89 c7                	mov    %eax,%edi
      if (buf == NULL) {
  80b4d4:	83 c4 10             	add    $0x10,%esp
  80b4d7:	85 c0                	test   %eax,%eax
  80b4d9:	74 66                	je     80b541 <recv_raw+0xc7>
      buf->p = q;
  80b4db:	89 37                	mov    %esi,(%edi)
      buf->ptr = q;
  80b4dd:	89 77 04             	mov    %esi,0x4(%edi)
      buf->addr = &(((struct ip_hdr*)(q->payload))->src);
  80b4e0:	8b 46 04             	mov    0x4(%esi),%eax
  80b4e3:	83 c0 0c             	add    $0xc,%eax
  80b4e6:	89 47 08             	mov    %eax,0x8(%edi)
      buf->port = pcb->protocol;
  80b4e9:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b4ec:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  80b4f0:	66 89 47 0c          	mov    %ax,0xc(%edi)
      SYS_ARCH_INC(conn->recv_avail, q->tot_len);
  80b4f4:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80b4f8:	66 01 43 20          	add    %ax,0x20(%ebx)
      API_EVENT(conn, NETCONN_EVT_RCVPLUS, q->tot_len);
  80b4fc:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b4ff:	85 c0                	test   %eax,%eax
  80b501:	74 10                	je     80b513 <recv_raw+0x99>
  80b503:	83 ec 04             	sub    $0x4,%esp
  80b506:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  80b50a:	52                   	push   %edx
  80b50b:	6a 00                	push   $0x0
  80b50d:	53                   	push   %ebx
  80b50e:	ff d0                	call   *%eax
  80b510:	83 c4 10             	add    $0x10,%esp
      if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80b513:	83 ec 08             	sub    $0x8,%esp
  80b516:	57                   	push   %edi
  80b517:	ff 73 14             	pushl  0x14(%ebx)
  80b51a:	e8 85 ed ff ff       	call   80a2a4 <sys_mbox_trypost>
  80b51f:	83 c4 10             	add    $0x10,%esp
  80b522:	84 c0                	test   %al,%al
  80b524:	75 29                	jne    80b54f <recv_raw+0xd5>
}
  80b526:	b8 00 00 00 00       	mov    $0x0,%eax
  80b52b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80b52e:	5b                   	pop    %ebx
  80b52f:	5e                   	pop    %esi
  80b530:	5f                   	pop    %edi
  80b531:	5d                   	pop    %ebp
  80b532:	c3                   	ret    
        pbuf_free(q);
  80b533:	83 ec 0c             	sub    $0xc,%esp
  80b536:	56                   	push   %esi
  80b537:	e8 11 93 ff ff       	call   80484d <pbuf_free>
  80b53c:	83 c4 10             	add    $0x10,%esp
  80b53f:	eb e5                	jmp    80b526 <recv_raw+0xac>
        pbuf_free(q);
  80b541:	83 ec 0c             	sub    $0xc,%esp
  80b544:	56                   	push   %esi
  80b545:	e8 03 93 ff ff       	call   80484d <pbuf_free>
        return 0;
  80b54a:	83 c4 10             	add    $0x10,%esp
  80b54d:	eb d7                	jmp    80b526 <recv_raw+0xac>
        netbuf_delete(buf);
  80b54f:	83 ec 0c             	sub    $0xc,%esp
  80b552:	57                   	push   %edi
  80b553:	e8 f1 6e ff ff       	call   802449 <netbuf_delete>
  80b558:	83 c4 10             	add    $0x10,%esp
  80b55b:	eb c9                	jmp    80b526 <recv_raw+0xac>

0080b55d <setup_tcp>:
 *
 * @param conn the TCP netconn to setup
 */
static void
setup_tcp(struct netconn *conn)
{
  80b55d:	55                   	push   %ebp
  80b55e:	89 e5                	mov    %esp,%ebp
  80b560:	53                   	push   %ebx
  80b561:	83 ec 0c             	sub    $0xc,%esp
  struct tcp_pcb *pcb;

  pcb = conn->pcb.tcp;
  80b564:	8b 58 08             	mov    0x8(%eax),%ebx
  tcp_arg(pcb, conn);
  80b567:	50                   	push   %eax
  80b568:	53                   	push   %ebx
  80b569:	e8 02 a3 ff ff       	call   805870 <tcp_arg>
  tcp_recv(pcb, recv_tcp);
  80b56e:	83 c4 08             	add    $0x8,%esp
  80b571:	68 b5 b2 80 00       	push   $0x80b2b5
  80b576:	53                   	push   %ebx
  80b577:	e8 02 a3 ff ff       	call   80587e <tcp_recv>
  tcp_sent(pcb, sent_tcp);
  80b57c:	83 c4 08             	add    $0x8,%esp
  80b57f:	68 3f ba 80 00       	push   $0x80ba3f
  80b584:	53                   	push   %ebx
  80b585:	e8 05 a3 ff ff       	call   80588f <tcp_sent>
  tcp_poll(pcb, poll_tcp, 4);
  80b58a:	83 c4 0c             	add    $0xc,%esp
  80b58d:	6a 04                	push   $0x4
  80b58f:	68 f9 b9 80 00       	push   $0x80b9f9
  80b594:	53                   	push   %ebx
  80b595:	e8 25 a3 ff ff       	call   8058bf <tcp_poll>
  tcp_err(pcb, err_tcp);
  80b59a:	83 c4 08             	add    $0x8,%esp
  80b59d:	68 fc b5 80 00       	push   $0x80b5fc
  80b5a2:	53                   	push   %ebx
  80b5a3:	e8 f8 a2 ff ff       	call   8058a0 <tcp_err>
}
  80b5a8:	83 c4 10             	add    $0x10,%esp
  80b5ab:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b5ae:	c9                   	leave  
  80b5af:	c3                   	ret    

0080b5b0 <do_connected>:
 *
 * @see tcp.h (struct tcp_pcb.connected) for parameters and return values
 */
static err_t
do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
{
  80b5b0:	55                   	push   %ebp
  80b5b1:	89 e5                	mov    %esp,%ebp
  80b5b3:	53                   	push   %ebx
  80b5b4:	83 ec 04             	sub    $0x4,%esp
  80b5b7:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b5ba:	8b 45 10             	mov    0x10(%ebp),%eax

  LWIP_UNUSED_ARG(pcb);

  conn = arg;

  if (conn == NULL) {
  80b5bd:	85 db                	test   %ebx,%ebx
  80b5bf:	74 34                	je     80b5f5 <do_connected+0x45>
    return ERR_VAL;
  }

  conn->err = err;
  80b5c1:	88 43 0c             	mov    %al,0xc(%ebx)
  if ((conn->type == NETCONN_TCP) && (err == ERR_OK)) {
  80b5c4:	83 3b 10             	cmpl   $0x10,(%ebx)
  80b5c7:	75 04                	jne    80b5cd <do_connected+0x1d>
  80b5c9:	84 c0                	test   %al,%al
  80b5cb:	74 1f                	je     80b5ec <do_connected+0x3c>
    setup_tcp(conn);
  }
  conn->state = NETCONN_NONE;
  80b5cd:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sys_sem_signal(conn->op_completed);
  80b5d4:	83 ec 0c             	sub    $0xc,%esp
  80b5d7:	ff 73 10             	pushl  0x10(%ebx)
  80b5da:	e8 45 eb ff ff       	call   80a124 <sys_sem_signal>
  return ERR_OK;
  80b5df:	83 c4 10             	add    $0x10,%esp
  80b5e2:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80b5e7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b5ea:	c9                   	leave  
  80b5eb:	c3                   	ret    
    setup_tcp(conn);
  80b5ec:	89 d8                	mov    %ebx,%eax
  80b5ee:	e8 6a ff ff ff       	call   80b55d <setup_tcp>
  80b5f3:	eb d8                	jmp    80b5cd <do_connected+0x1d>
    return ERR_VAL;
  80b5f5:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80b5fa:	eb eb                	jmp    80b5e7 <do_connected+0x37>

0080b5fc <err_tcp>:
{
  80b5fc:	55                   	push   %ebp
  80b5fd:	89 e5                	mov    %esp,%ebp
  80b5ff:	53                   	push   %ebx
  80b600:	83 ec 04             	sub    $0x4,%esp
  80b603:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b606:	8b 45 0c             	mov    0xc(%ebp),%eax
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80b609:	85 db                	test   %ebx,%ebx
  80b60b:	74 7e                	je     80b68b <err_tcp+0x8f>
  conn->pcb.tcp = NULL;
  80b60d:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  conn->err = err;
  80b614:	88 43 0c             	mov    %al,0xc(%ebx)
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80b617:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b61b:	74 24                	je     80b641 <err_tcp+0x45>
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80b61d:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b620:	85 c0                	test   %eax,%eax
  80b622:	74 0d                	je     80b631 <err_tcp+0x35>
  80b624:	83 ec 04             	sub    $0x4,%esp
  80b627:	6a 00                	push   $0x0
  80b629:	6a 00                	push   $0x0
  80b62b:	53                   	push   %ebx
  80b62c:	ff d0                	call   *%eax
  80b62e:	83 c4 10             	add    $0x10,%esp
    sys_mbox_post(conn->recvmbox, NULL);
  80b631:	83 ec 08             	sub    $0x8,%esp
  80b634:	6a 00                	push   $0x0
  80b636:	ff 73 14             	pushl  0x14(%ebx)
  80b639:	e8 2b ed ff ff       	call   80a369 <sys_mbox_post>
  80b63e:	83 c4 10             	add    $0x10,%esp
  if (conn->op_completed != SYS_SEM_NULL && conn->state == NETCONN_CONNECT) {
  80b641:	8b 43 10             	mov    0x10(%ebx),%eax
  80b644:	83 f8 ff             	cmp    $0xffffffff,%eax
  80b647:	74 06                	je     80b64f <err_tcp+0x53>
  80b649:	83 7b 04 03          	cmpl   $0x3,0x4(%ebx)
  80b64d:	74 53                	je     80b6a2 <err_tcp+0xa6>
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80b64f:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80b653:	74 24                	je     80b679 <err_tcp+0x7d>
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80b655:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b658:	85 c0                	test   %eax,%eax
  80b65a:	74 0d                	je     80b669 <err_tcp+0x6d>
  80b65c:	83 ec 04             	sub    $0x4,%esp
  80b65f:	6a 00                	push   $0x0
  80b661:	6a 00                	push   $0x0
  80b663:	53                   	push   %ebx
  80b664:	ff d0                	call   *%eax
  80b666:	83 c4 10             	add    $0x10,%esp
    sys_mbox_post(conn->acceptmbox, NULL);
  80b669:	83 ec 08             	sub    $0x8,%esp
  80b66c:	6a 00                	push   $0x0
  80b66e:	ff 73 18             	pushl  0x18(%ebx)
  80b671:	e8 f3 ec ff ff       	call   80a369 <sys_mbox_post>
  80b676:	83 c4 10             	add    $0x10,%esp
  if ((conn->state == NETCONN_WRITE) || (conn->state == NETCONN_CLOSE)) {
  80b679:	8b 43 04             	mov    0x4(%ebx),%eax
  80b67c:	83 f8 01             	cmp    $0x1,%eax
  80b67f:	74 36                	je     80b6b7 <err_tcp+0xbb>
  80b681:	83 f8 04             	cmp    $0x4,%eax
  80b684:	74 31                	je     80b6b7 <err_tcp+0xbb>
}
  80b686:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b689:	c9                   	leave  
  80b68a:	c3                   	ret    
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80b68b:	83 ec 04             	sub    $0x4,%esp
  80b68e:	68 b5 30 81 00       	push   $0x8130b5
  80b693:	68 22 01 00 00       	push   $0x122
  80b698:	68 62 30 81 00       	push   $0x813062
  80b69d:	e8 b1 2f 00 00       	call   80e653 <_panic>
    conn->state = NETCONN_NONE;
  80b6a2:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    sys_sem_signal(conn->op_completed);
  80b6a9:	83 ec 0c             	sub    $0xc,%esp
  80b6ac:	50                   	push   %eax
  80b6ad:	e8 72 ea ff ff       	call   80a124 <sys_sem_signal>
  80b6b2:	83 c4 10             	add    $0x10,%esp
  80b6b5:	eb 98                	jmp    80b64f <err_tcp+0x53>
    conn->state = NETCONN_NONE;
  80b6b7:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    sys_sem_signal(conn->op_completed);
  80b6be:	83 ec 0c             	sub    $0xc,%esp
  80b6c1:	ff 73 10             	pushl  0x10(%ebx)
  80b6c4:	e8 5b ea ff ff       	call   80a124 <sys_sem_signal>
  80b6c9:	83 c4 10             	add    $0x10,%esp
}
  80b6cc:	eb b8                	jmp    80b686 <err_tcp+0x8a>

0080b6ce <do_writemore>:
 * @return ERR_OK
 *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
 */
static err_t
do_writemore(struct netconn *conn)
{
  80b6ce:	55                   	push   %ebp
  80b6cf:	89 e5                	mov    %esp,%ebp
  80b6d1:	57                   	push   %edi
  80b6d2:	56                   	push   %esi
  80b6d3:	53                   	push   %ebx
  80b6d4:	83 ec 0c             	sub    $0xc,%esp
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;

  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
  80b6d7:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
  80b6db:	0f 85 c9 00 00 00    	jne    80b7aa <do_writemore+0xdc>
  80b6e1:	89 c6                	mov    %eax,%esi

  dataptr = (u8_t*)conn->write_msg->msg.w.dataptr + conn->write_offset;
  80b6e3:	8b 40 24             	mov    0x24(%eax),%eax
  80b6e6:	8b 7e 28             	mov    0x28(%esi),%edi
  80b6e9:	89 fa                	mov    %edi,%edx
  80b6eb:	03 50 04             	add    0x4(%eax),%edx
  if ((conn->write_msg->msg.w.len - conn->write_offset > 0xffff)) { /* max_u16_t */
  80b6ee:	8b 58 08             	mov    0x8(%eax),%ebx
  80b6f1:	89 d9                	mov    %ebx,%ecx
  80b6f3:	29 f9                	sub    %edi,%ecx
    len = 0xffff;
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  } else {
    len = conn->write_msg->msg.w.len - conn->write_offset;
  80b6f5:	29 fb                	sub    %edi,%ebx
  80b6f7:	81 f9 00 00 01 00    	cmp    $0x10000,%ecx
  80b6fd:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
  80b702:	0f 4d d9             	cmovge %ecx,%ebx
  }
  available = tcp_sndbuf(conn->pcb.tcp);
  80b705:	8b 4e 08             	mov    0x8(%esi),%ecx
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  }

  err = tcp_write(conn->pcb.tcp, dataptr, len, conn->write_msg->msg.w.apiflags);
  80b708:	66 39 59 6e          	cmp    %bx,0x6e(%ecx)
  80b70c:	66 0f 46 59 6e       	cmovbe 0x6e(%ecx),%bx
  80b711:	0f b7 db             	movzwl %bx,%ebx
  80b714:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  80b718:	50                   	push   %eax
  80b719:	53                   	push   %ebx
  80b71a:	52                   	push   %edx
  80b71b:	51                   	push   %ecx
  80b71c:	e8 8c c9 ff ff       	call   8080ad <tcp_write>
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  80b721:	89 da                	mov    %ebx,%edx
  80b723:	03 56 28             	add    0x28(%esi),%edx
  80b726:	8b 4e 24             	mov    0x24(%esi),%ecx
  80b729:	83 c4 10             	add    $0x10,%esp
  80b72c:	3b 51 08             	cmp    0x8(%ecx),%edx
  80b72f:	0f 8f 8c 00 00 00    	jg     80b7c1 <do_writemore+0xf3>
  if (err == ERR_OK) {
  80b735:	84 c0                	test   %al,%al
  80b737:	0f 85 bf 00 00 00    	jne    80b7fc <do_writemore+0x12e>
    conn->write_offset += len;
  80b73d:	89 56 28             	mov    %edx,0x28(%esi)
  u8_t write_finished = 0;
  80b740:	bf 00 00 00 00       	mov    $0x0,%edi
    if (conn->write_offset == conn->write_msg->msg.w.len) {
  80b745:	3b 51 08             	cmp    0x8(%ecx),%edx
  80b748:	0f 84 8a 00 00 00    	je     80b7d8 <do_writemore+0x10a>
      /* everything was written */
      write_finished = 1;
      conn->write_msg = NULL;
      conn->write_offset = 0;
    }
    err = tcp_output_nagle(conn->pcb.tcp);
  80b74e:	8b 46 08             	mov    0x8(%esi),%eax
  80b751:	83 78 78 00          	cmpl   $0x0,0x78(%eax)
  80b755:	74 1a                	je     80b771 <do_writemore+0xa3>
  80b757:	f6 40 20 40          	testb  $0x40,0x20(%eax)
  80b75b:	75 14                	jne    80b771 <do_writemore+0xa3>
  80b75d:	8b 50 74             	mov    0x74(%eax),%edx
  80b760:	85 d2                	test   %edx,%edx
  80b762:	0f 84 88 00 00 00    	je     80b7f0 <do_writemore+0x122>
  80b768:	83 3a 00             	cmpl   $0x0,(%edx)
  80b76b:	0f 84 85 00 00 00    	je     80b7f6 <do_writemore+0x128>
  80b771:	83 ec 0c             	sub    $0xc,%esp
  80b774:	50                   	push   %eax
  80b775:	e8 88 c9 ff ff       	call   808102 <tcp_output>
    conn->err = err;
  80b77a:	88 46 0c             	mov    %al,0xc(%esi)
    if ((err == ERR_OK) && (tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT)) {
  80b77d:	83 c4 10             	add    $0x10,%esp
  80b780:	84 c0                	test   %al,%al
  80b782:	75 1e                	jne    80b7a2 <do_writemore+0xd4>
  80b784:	8b 46 08             	mov    0x8(%esi),%eax
  80b787:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80b78d:	77 13                	ja     80b7a2 <do_writemore+0xd4>
      API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
  80b78f:	8b 46 2c             	mov    0x2c(%esi),%eax
  80b792:	85 c0                	test   %eax,%eax
  80b794:	74 0c                	je     80b7a2 <do_writemore+0xd4>
  80b796:	83 ec 04             	sub    $0x4,%esp
  80b799:	53                   	push   %ebx
  80b79a:	6a 03                	push   $0x3
  80b79c:	56                   	push   %esi
  80b79d:	ff d0                	call   *%eax
  80b79f:	83 c4 10             	add    $0x10,%esp
       the error to the application thread. */
    conn->err = err;
    write_finished = 1;
  }

  if (write_finished) {
  80b7a2:	89 f8                	mov    %edi,%eax
  80b7a4:	84 c0                	test   %al,%al
  80b7a6:	75 5b                	jne    80b803 <do_writemore+0x135>
  80b7a8:	eb 6e                	jmp    80b818 <do_writemore+0x14a>
  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
  80b7aa:	83 ec 04             	sub    $0x4,%esp
  80b7ad:	68 c2 30 81 00       	push   $0x8130c2
  80b7b2:	68 b8 03 00 00       	push   $0x3b8
  80b7b7:	68 62 30 81 00       	push   $0x813062
  80b7bc:	e8 92 2e 00 00       	call   80e653 <_panic>
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  80b7c1:	83 ec 04             	sub    $0x4,%esp
  80b7c4:	68 df 30 81 00       	push   $0x8130df
  80b7c9:	68 cd 03 00 00       	push   $0x3cd
  80b7ce:	68 62 30 81 00       	push   $0x813062
  80b7d3:	e8 7b 2e 00 00       	call   80e653 <_panic>
      conn->write_msg = NULL;
  80b7d8:	c7 46 24 00 00 00 00 	movl   $0x0,0x24(%esi)
      conn->write_offset = 0;
  80b7df:	c7 46 28 00 00 00 00 	movl   $0x0,0x28(%esi)
      write_finished = 1;
  80b7e6:	bf 01 00 00 00       	mov    $0x1,%edi
  80b7eb:	e9 5e ff ff ff       	jmp    80b74e <do_writemore+0x80>
    conn->err = err;
  80b7f0:	c6 46 0c 00          	movb   $0x0,0xc(%esi)
  80b7f4:	eb 8e                	jmp    80b784 <do_writemore+0xb6>
  80b7f6:	c6 46 0c 00          	movb   $0x0,0xc(%esi)
  80b7fa:	eb 88                	jmp    80b784 <do_writemore+0xb6>
  } else if (err == ERR_MEM) {
  80b7fc:	3c ff                	cmp    $0xff,%al
  80b7fe:	74 25                	je     80b825 <do_writemore+0x157>
    conn->err = err;
  80b800:	88 46 0c             	mov    %al,0xc(%esi)
    /* everything was written: set back connection state
       and back to application task */
    conn->state = NETCONN_NONE;
  80b803:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
#if LWIP_TCPIP_CORE_LOCKING
    if (conn->write_delayed != 0)
#endif
    {
      sys_sem_signal(conn->op_completed);
  80b80a:	83 ec 0c             	sub    $0xc,%esp
  80b80d:	ff 76 10             	pushl  0x10(%esi)
  80b810:	e8 0f e9 ff ff       	call   80a124 <sys_sem_signal>
  80b815:	83 c4 10             	add    $0x10,%esp
#if LWIP_TCPIP_CORE_LOCKING
  else
    return ERR_MEM;
#endif
  return ERR_OK;
}
  80b818:	b8 00 00 00 00       	mov    $0x0,%eax
  80b81d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80b820:	5b                   	pop    %ebx
  80b821:	5e                   	pop    %esi
  80b822:	5f                   	pop    %edi
  80b823:	5d                   	pop    %ebp
  80b824:	c3                   	ret    
    err = tcp_output(conn->pcb.tcp);
  80b825:	83 ec 0c             	sub    $0xc,%esp
  80b828:	ff 76 08             	pushl  0x8(%esi)
  80b82b:	e8 d2 c8 ff ff       	call   808102 <tcp_output>
  80b830:	83 c4 10             	add    $0x10,%esp
  80b833:	eb e3                	jmp    80b818 <do_writemore+0x14a>

0080b835 <do_close_internal>:
{
  80b835:	55                   	push   %ebp
  80b836:	89 e5                	mov    %esp,%ebp
  80b838:	53                   	push   %ebx
  80b839:	83 ec 04             	sub    $0x4,%esp
  LWIP_ASSERT("invalid conn", (conn != NULL));
  80b83c:	85 c0                	test   %eax,%eax
  80b83e:	0f 84 e2 00 00 00    	je     80b926 <do_close_internal+0xf1>
  80b844:	89 c3                	mov    %eax,%ebx
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
  80b846:	83 38 10             	cmpl   $0x10,(%eax)
  80b849:	0f 85 ee 00 00 00    	jne    80b93d <do_close_internal+0x108>
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  80b84f:	83 78 04 04          	cmpl   $0x4,0x4(%eax)
  80b853:	0f 85 fb 00 00 00    	jne    80b954 <do_close_internal+0x11f>
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  80b859:	8b 40 08             	mov    0x8(%eax),%eax
  80b85c:	85 c0                	test   %eax,%eax
  80b85e:	0f 84 07 01 00 00    	je     80b96b <do_close_internal+0x136>
  tcp_arg(conn->pcb.tcp, NULL);
  80b864:	83 ec 08             	sub    $0x8,%esp
  80b867:	6a 00                	push   $0x0
  80b869:	50                   	push   %eax
  80b86a:	e8 01 a0 ff ff       	call   805870 <tcp_arg>
  if (conn->pcb.tcp->state == LISTEN) {
  80b86f:	8b 43 08             	mov    0x8(%ebx),%eax
  80b872:	83 c4 10             	add    $0x10,%esp
  80b875:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80b879:	0f 84 03 01 00 00    	je     80b982 <do_close_internal+0x14d>
    tcp_recv(conn->pcb.tcp, NULL);
  80b87f:	83 ec 08             	sub    $0x8,%esp
  80b882:	6a 00                	push   $0x0
  80b884:	50                   	push   %eax
  80b885:	e8 f4 9f ff ff       	call   80587e <tcp_recv>
    tcp_accept(conn->pcb.tcp, NULL);
  80b88a:	83 c4 08             	add    $0x8,%esp
  80b88d:	6a 00                	push   $0x0
  80b88f:	ff 73 08             	pushl  0x8(%ebx)
  80b892:	e8 1a a0 ff ff       	call   8058b1 <tcp_accept>
    tcp_sent(conn->pcb.tcp, NULL);
  80b897:	83 c4 08             	add    $0x8,%esp
  80b89a:	6a 00                	push   $0x0
  80b89c:	ff 73 08             	pushl  0x8(%ebx)
  80b89f:	e8 eb 9f ff ff       	call   80588f <tcp_sent>
    tcp_poll(conn->pcb.tcp, NULL, 4);
  80b8a4:	83 c4 0c             	add    $0xc,%esp
  80b8a7:	6a 04                	push   $0x4
  80b8a9:	6a 00                	push   $0x0
  80b8ab:	ff 73 08             	pushl  0x8(%ebx)
  80b8ae:	e8 0c a0 ff ff       	call   8058bf <tcp_poll>
    tcp_err(conn->pcb.tcp, NULL);
  80b8b3:	83 c4 08             	add    $0x8,%esp
  80b8b6:	6a 00                	push   $0x0
  80b8b8:	ff 73 08             	pushl  0x8(%ebx)
  80b8bb:	e8 e0 9f ff ff       	call   8058a0 <tcp_err>
  80b8c0:	83 c4 10             	add    $0x10,%esp
  err = tcp_close(conn->pcb.tcp);
  80b8c3:	83 ec 0c             	sub    $0xc,%esp
  80b8c6:	ff 73 08             	pushl  0x8(%ebx)
  80b8c9:	e8 a3 a1 ff ff       	call   805a71 <tcp_close>
  if (err == ERR_OK) {
  80b8ce:	83 c4 10             	add    $0x10,%esp
  80b8d1:	84 c0                	test   %al,%al
  80b8d3:	0f 85 bc 00 00 00    	jne    80b995 <do_close_internal+0x160>
    conn->state = NETCONN_NONE;
  80b8d9:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    conn->pcb.tcp = NULL;
  80b8e0:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    conn->err = ERR_OK;
  80b8e7:	c6 43 0c 00          	movb   $0x0,0xc(%ebx)
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80b8eb:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b8ee:	85 c0                	test   %eax,%eax
  80b8f0:	74 21                	je     80b913 <do_close_internal+0xde>
  80b8f2:	83 ec 04             	sub    $0x4,%esp
  80b8f5:	6a 00                	push   $0x0
  80b8f7:	6a 00                	push   $0x0
  80b8f9:	53                   	push   %ebx
  80b8fa:	ff d0                	call   *%eax
    API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
  80b8fc:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b8ff:	83 c4 10             	add    $0x10,%esp
  80b902:	85 c0                	test   %eax,%eax
  80b904:	74 0d                	je     80b913 <do_close_internal+0xde>
  80b906:	83 ec 04             	sub    $0x4,%esp
  80b909:	6a 00                	push   $0x0
  80b90b:	6a 02                	push   $0x2
  80b90d:	53                   	push   %ebx
  80b90e:	ff d0                	call   *%eax
  80b910:	83 c4 10             	add    $0x10,%esp
    sys_sem_signal(conn->op_completed);
  80b913:	83 ec 0c             	sub    $0xc,%esp
  80b916:	ff 73 10             	pushl  0x10(%ebx)
  80b919:	e8 06 e8 ff ff       	call   80a124 <sys_sem_signal>
  80b91e:	83 c4 10             	add    $0x10,%esp
}
  80b921:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b924:	c9                   	leave  
  80b925:	c3                   	ret    
  LWIP_ASSERT("invalid conn", (conn != NULL));
  80b926:	83 ec 04             	sub    $0x4,%esp
  80b929:	68 d0 2e 81 00       	push   $0x812ed0
  80b92e:	68 53 02 00 00       	push   $0x253
  80b933:	68 62 30 81 00       	push   $0x813062
  80b938:	e8 16 2d 00 00       	call   80e653 <_panic>
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
  80b93d:	83 ec 04             	sub    $0x4,%esp
  80b940:	68 fd 30 81 00       	push   $0x8130fd
  80b945:	68 54 02 00 00       	push   $0x254
  80b94a:	68 62 30 81 00       	push   $0x813062
  80b94f:	e8 ff 2c 00 00       	call   80e653 <_panic>
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  80b954:	83 ec 04             	sub    $0x4,%esp
  80b957:	68 a0 2f 81 00       	push   $0x812fa0
  80b95c:	68 55 02 00 00       	push   $0x255
  80b961:	68 62 30 81 00       	push   $0x813062
  80b966:	e8 e8 2c 00 00       	call   80e653 <_panic>
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  80b96b:	83 ec 04             	sub    $0x4,%esp
  80b96e:	68 1b 31 81 00       	push   $0x81311b
  80b973:	68 56 02 00 00       	push   $0x256
  80b978:	68 62 30 81 00       	push   $0x813062
  80b97d:	e8 d1 2c 00 00       	call   80e653 <_panic>
    tcp_accept(conn->pcb.tcp, NULL);
  80b982:	83 ec 08             	sub    $0x8,%esp
  80b985:	6a 00                	push   $0x0
  80b987:	50                   	push   %eax
  80b988:	e8 24 9f ff ff       	call   8058b1 <tcp_accept>
  80b98d:	83 c4 10             	add    $0x10,%esp
  80b990:	e9 2e ff ff ff       	jmp    80b8c3 <do_close_internal+0x8e>
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
  80b995:	8b 43 08             	mov    0x8(%ebx),%eax
  80b998:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80b99c:	74 44                	je     80b9e2 <do_close_internal+0x1ad>
    tcp_sent(conn->pcb.tcp, sent_tcp);
  80b99e:	83 ec 08             	sub    $0x8,%esp
  80b9a1:	68 3f ba 80 00       	push   $0x80ba3f
  80b9a6:	50                   	push   %eax
  80b9a7:	e8 e3 9e ff ff       	call   80588f <tcp_sent>
    tcp_poll(conn->pcb.tcp, poll_tcp, 4);
  80b9ac:	83 c4 0c             	add    $0xc,%esp
  80b9af:	6a 04                	push   $0x4
  80b9b1:	68 f9 b9 80 00       	push   $0x80b9f9
  80b9b6:	ff 73 08             	pushl  0x8(%ebx)
  80b9b9:	e8 01 9f ff ff       	call   8058bf <tcp_poll>
    tcp_err(conn->pcb.tcp, err_tcp);
  80b9be:	83 c4 08             	add    $0x8,%esp
  80b9c1:	68 fc b5 80 00       	push   $0x80b5fc
  80b9c6:	ff 73 08             	pushl  0x8(%ebx)
  80b9c9:	e8 d2 9e ff ff       	call   8058a0 <tcp_err>
    tcp_arg(conn->pcb.tcp, conn);
  80b9ce:	83 c4 08             	add    $0x8,%esp
  80b9d1:	53                   	push   %ebx
  80b9d2:	ff 73 08             	pushl  0x8(%ebx)
  80b9d5:	e8 96 9e ff ff       	call   805870 <tcp_arg>
  80b9da:	83 c4 10             	add    $0x10,%esp
}
  80b9dd:	e9 3f ff ff ff       	jmp    80b921 <do_close_internal+0xec>
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
  80b9e2:	83 ec 04             	sub    $0x4,%esp
  80b9e5:	68 c4 2f 81 00       	push   $0x812fc4
  80b9ea:	68 75 02 00 00       	push   $0x275
  80b9ef:	68 62 30 81 00       	push   $0x813062
  80b9f4:	e8 5a 2c 00 00       	call   80e653 <_panic>

0080b9f9 <poll_tcp>:
{
  80b9f9:	55                   	push   %ebp
  80b9fa:	89 e5                	mov    %esp,%ebp
  80b9fc:	83 ec 08             	sub    $0x8,%esp
  80b9ff:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80ba02:	85 c0                	test   %eax,%eax
  80ba04:	74 14                	je     80ba1a <poll_tcp+0x21>
  if (conn->state == NETCONN_WRITE) {
  80ba06:	8b 50 04             	mov    0x4(%eax),%edx
  80ba09:	83 fa 01             	cmp    $0x1,%edx
  80ba0c:	74 23                	je     80ba31 <poll_tcp+0x38>
  } else if (conn->state == NETCONN_CLOSE) {
  80ba0e:	83 fa 04             	cmp    $0x4,%edx
  80ba11:	74 25                	je     80ba38 <poll_tcp+0x3f>
}
  80ba13:	b8 00 00 00 00       	mov    $0x0,%eax
  80ba18:	c9                   	leave  
  80ba19:	c3                   	ret    
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80ba1a:	83 ec 04             	sub    $0x4,%esp
  80ba1d:	68 b5 30 81 00       	push   $0x8130b5
  80ba22:	68 eb 00 00 00       	push   $0xeb
  80ba27:	68 62 30 81 00       	push   $0x813062
  80ba2c:	e8 22 2c 00 00       	call   80e653 <_panic>
    do_writemore(conn);
  80ba31:	e8 98 fc ff ff       	call   80b6ce <do_writemore>
  80ba36:	eb db                	jmp    80ba13 <poll_tcp+0x1a>
    do_close_internal(conn);
  80ba38:	e8 f8 fd ff ff       	call   80b835 <do_close_internal>
  80ba3d:	eb d4                	jmp    80ba13 <poll_tcp+0x1a>

0080ba3f <sent_tcp>:
{
  80ba3f:	55                   	push   %ebp
  80ba40:	89 e5                	mov    %esp,%ebp
  80ba42:	56                   	push   %esi
  80ba43:	53                   	push   %ebx
  80ba44:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80ba47:	8b 75 10             	mov    0x10(%ebp),%esi
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80ba4a:	85 db                	test   %ebx,%ebx
  80ba4c:	74 3e                	je     80ba8c <sent_tcp+0x4d>
  if (conn->state == NETCONN_WRITE) {
  80ba4e:	8b 43 04             	mov    0x4(%ebx),%eax
  80ba51:	83 f8 01             	cmp    $0x1,%eax
  80ba54:	74 4d                	je     80baa3 <sent_tcp+0x64>
  } else if (conn->state == NETCONN_CLOSE) {
  80ba56:	83 f8 04             	cmp    $0x4,%eax
  80ba59:	74 6e                	je     80bac9 <sent_tcp+0x8a>
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT)) {
  80ba5b:	8b 43 08             	mov    0x8(%ebx),%eax
  80ba5e:	85 c0                	test   %eax,%eax
  80ba60:	74 1e                	je     80ba80 <sent_tcp+0x41>
  80ba62:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80ba68:	76 16                	jbe    80ba80 <sent_tcp+0x41>
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
  80ba6a:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80ba6d:	85 c0                	test   %eax,%eax
  80ba6f:	74 0f                	je     80ba80 <sent_tcp+0x41>
  80ba71:	83 ec 04             	sub    $0x4,%esp
  80ba74:	0f b7 f6             	movzwl %si,%esi
  80ba77:	56                   	push   %esi
  80ba78:	6a 02                	push   $0x2
  80ba7a:	53                   	push   %ebx
  80ba7b:	ff d0                	call   *%eax
  80ba7d:	83 c4 10             	add    $0x10,%esp
}
  80ba80:	b8 00 00 00 00       	mov    $0x0,%eax
  80ba85:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80ba88:	5b                   	pop    %ebx
  80ba89:	5e                   	pop    %esi
  80ba8a:	5d                   	pop    %ebp
  80ba8b:	c3                   	ret    
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80ba8c:	83 ec 04             	sub    $0x4,%esp
  80ba8f:	68 b5 30 81 00       	push   $0x8130b5
  80ba94:	68 03 01 00 00       	push   $0x103
  80ba99:	68 62 30 81 00       	push   $0x813062
  80ba9e:	e8 b0 2b 00 00       	call   80e653 <_panic>
    LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
  80baa3:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80baa7:	74 09                	je     80bab2 <sent_tcp+0x73>
    do_writemore(conn);
  80baa9:	89 d8                	mov    %ebx,%eax
  80baab:	e8 1e fc ff ff       	call   80b6ce <do_writemore>
  80bab0:	eb a9                	jmp    80ba5b <sent_tcp+0x1c>
    LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
  80bab2:	83 ec 04             	sub    $0x4,%esp
  80bab5:	68 2e 31 81 00       	push   $0x81312e
  80baba:	68 06 01 00 00       	push   $0x106
  80babf:	68 62 30 81 00       	push   $0x813062
  80bac4:	e8 8a 2b 00 00       	call   80e653 <_panic>
    do_close_internal(conn);
  80bac9:	89 d8                	mov    %ebx,%eax
  80bacb:	e8 65 fd ff ff       	call   80b835 <do_close_internal>
  80bad0:	eb 89                	jmp    80ba5b <sent_tcp+0x1c>

0080bad2 <do_newconn>:
{
  80bad2:	55                   	push   %ebp
  80bad3:	89 e5                	mov    %esp,%ebp
  80bad5:	56                   	push   %esi
  80bad6:	53                   	push   %ebx
  80bad7:	8b 5d 08             	mov    0x8(%ebp),%ebx
   if(msg->conn->pcb.tcp == NULL) {
  80bada:	8b 03                	mov    (%ebx),%eax
  80badc:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80bae0:	74 17                	je     80baf9 <do_newconn+0x27>
   TCPIP_APIMSG_ACK(msg);
  80bae2:	83 ec 0c             	sub    $0xc,%esp
  80bae5:	8b 03                	mov    (%ebx),%eax
  80bae7:	ff 70 10             	pushl  0x10(%eax)
  80baea:	e8 35 e6 ff ff       	call   80a124 <sys_sem_signal>
}
  80baef:	83 c4 10             	add    $0x10,%esp
  80baf2:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80baf5:	5b                   	pop    %ebx
  80baf6:	5e                   	pop    %esi
  80baf7:	5d                   	pop    %ebp
  80baf8:	c3                   	ret    
   msg->conn->err = ERR_OK;
  80baf9:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
   LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);
  80bafd:	8b 33                	mov    (%ebx),%esi
  80baff:	83 7e 08 00          	cmpl   $0x0,0x8(%esi)
  80bb03:	75 20                	jne    80bb25 <do_newconn+0x53>
   switch(NETCONNTYPE_GROUP(msg->conn->type)) {
  80bb05:	8b 06                	mov    (%esi),%eax
  80bb07:	25 f0 00 00 00       	and    $0xf0,%eax
  80bb0c:	83 f8 20             	cmp    $0x20,%eax
  80bb0f:	74 67                	je     80bb78 <do_newconn+0xa6>
  80bb11:	83 f8 40             	cmp    $0x40,%eax
  80bb14:	74 26                	je     80bb3c <do_newconn+0x6a>
  80bb16:	83 f8 10             	cmp    $0x10,%eax
  80bb19:	0f 84 99 00 00 00    	je     80bbb8 <do_newconn+0xe6>
     msg->conn->err = ERR_VAL;
  80bb1f:	c6 46 0c f7          	movb   $0xf7,0xc(%esi)
  80bb23:	eb bd                	jmp    80bae2 <do_newconn+0x10>
   LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);
  80bb25:	83 ec 04             	sub    $0x4,%esp
  80bb28:	68 e8 2f 81 00       	push   $0x812fe8
  80bb2d:	68 8a 01 00 00       	push   $0x18a
  80bb32:	68 62 30 81 00       	push   $0x813062
  80bb37:	e8 17 2b 00 00       	call   80e653 <_panic>
     msg->conn->pcb.raw = raw_new(msg->msg.n.proto);
  80bb3c:	83 ec 0c             	sub    $0xc,%esp
  80bb3f:	0f b6 43 04          	movzbl 0x4(%ebx),%eax
  80bb43:	50                   	push   %eax
  80bb44:	e8 7c 25 00 00       	call   80e0c5 <raw_new>
  80bb49:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.raw == NULL) {
  80bb4c:	8b 03                	mov    (%ebx),%eax
  80bb4e:	8b 50 08             	mov    0x8(%eax),%edx
  80bb51:	83 c4 10             	add    $0x10,%esp
  80bb54:	85 d2                	test   %edx,%edx
  80bb56:	74 17                	je     80bb6f <do_newconn+0x9d>
     raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
  80bb58:	83 ec 04             	sub    $0x4,%esp
  80bb5b:	50                   	push   %eax
  80bb5c:	68 7a b4 80 00       	push   $0x80b47a
  80bb61:	52                   	push   %edx
  80bb62:	e8 e5 23 00 00       	call   80df4c <raw_recv>
  80bb67:	83 c4 10             	add    $0x10,%esp
  80bb6a:	e9 73 ff ff ff       	jmp    80bae2 <do_newconn+0x10>
       msg->conn->err = ERR_MEM;
  80bb6f:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80bb73:	e9 6a ff ff ff       	jmp    80bae2 <do_newconn+0x10>
     msg->conn->pcb.udp = udp_new();
  80bb78:	e8 15 d5 ff ff       	call   809092 <udp_new>
  80bb7d:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.udp == NULL) {
  80bb80:	8b 03                	mov    (%ebx),%eax
  80bb82:	8b 50 08             	mov    0x8(%eax),%edx
  80bb85:	85 d2                	test   %edx,%edx
  80bb87:	74 20                	je     80bba9 <do_newconn+0xd7>
     if (msg->conn->type==NETCONN_UDPNOCHKSUM) {
  80bb89:	83 38 22             	cmpl   $0x22,(%eax)
  80bb8c:	74 24                	je     80bbb2 <do_newconn+0xe0>
     udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  80bb8e:	8b 03                	mov    (%ebx),%eax
  80bb90:	83 ec 04             	sub    $0x4,%esp
  80bb93:	50                   	push   %eax
  80bb94:	68 70 b3 80 00       	push   $0x80b370
  80bb99:	ff 70 08             	pushl  0x8(%eax)
  80bb9c:	e8 99 d4 ff ff       	call   80903a <udp_recv>
  80bba1:	83 c4 10             	add    $0x10,%esp
  80bba4:	e9 39 ff ff ff       	jmp    80bae2 <do_newconn+0x10>
       msg->conn->err = ERR_MEM;
  80bba9:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80bbad:	e9 30 ff ff ff       	jmp    80bae2 <do_newconn+0x10>
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
  80bbb2:	c6 42 10 01          	movb   $0x1,0x10(%edx)
  80bbb6:	eb d6                	jmp    80bb8e <do_newconn+0xbc>
     msg->conn->pcb.tcp = tcp_new();
  80bbb8:	e8 a6 a7 ff ff       	call   806363 <tcp_new>
  80bbbd:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.tcp == NULL) {
  80bbc0:	8b 03                	mov    (%ebx),%eax
  80bbc2:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80bbc6:	74 0a                	je     80bbd2 <do_newconn+0x100>
     setup_tcp(msg->conn);
  80bbc8:	e8 90 f9 ff ff       	call   80b55d <setup_tcp>
  80bbcd:	e9 10 ff ff ff       	jmp    80bae2 <do_newconn+0x10>
       msg->conn->err = ERR_MEM;
  80bbd2:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80bbd6:	e9 07 ff ff ff       	jmp    80bae2 <do_newconn+0x10>

0080bbdb <netconn_alloc>:
{
  80bbdb:	55                   	push   %ebp
  80bbdc:	89 e5                	mov    %esp,%ebp
  80bbde:	53                   	push   %ebx
  80bbdf:	83 ec 10             	sub    $0x10,%esp
  conn = memp_malloc(MEMP_NETCONN);
  80bbe2:	6a 07                	push   $0x7
  80bbe4:	e8 9f 88 ff ff       	call   804488 <memp_malloc>
  80bbe9:	89 c3                	mov    %eax,%ebx
  if (conn == NULL) {
  80bbeb:	83 c4 10             	add    $0x10,%esp
  80bbee:	85 c0                	test   %eax,%eax
  80bbf0:	74 5b                	je     80bc4d <netconn_alloc+0x72>
  conn->err = ERR_OK;
  80bbf2:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
  conn->type = t;
  80bbf6:	8b 45 08             	mov    0x8(%ebp),%eax
  80bbf9:	89 03                	mov    %eax,(%ebx)
  conn->pcb.tcp = NULL;
  80bbfb:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  if ((conn->op_completed = sys_sem_new(0)) == SYS_SEM_NULL) {
  80bc02:	83 ec 0c             	sub    $0xc,%esp
  80bc05:	6a 00                	push   $0x0
  80bc07:	e8 5b e2 ff ff       	call   809e67 <sys_sem_new>
  80bc0c:	89 43 10             	mov    %eax,0x10(%ebx)
  80bc0f:	83 c4 10             	add    $0x10,%esp
  80bc12:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bc15:	74 3d                	je     80bc54 <netconn_alloc+0x79>
  if ((conn->recvmbox = sys_mbox_new(size)) == SYS_MBOX_NULL) {
  80bc17:	83 ec 0c             	sub    $0xc,%esp
  80bc1a:	6a 00                	push   $0x0
  80bc1c:	e8 ef e3 ff ff       	call   80a010 <sys_mbox_new>
  80bc21:	89 43 14             	mov    %eax,0x14(%ebx)
  80bc24:	83 c4 10             	add    $0x10,%esp
  80bc27:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bc2a:	74 3d                	je     80bc69 <netconn_alloc+0x8e>
  conn->acceptmbox   = SYS_MBOX_NULL;
  80bc2c:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  conn->state        = NETCONN_NONE;
  80bc33:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  conn->socket       = -1;
  80bc3a:	c7 43 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%ebx)
  conn->callback     = callback;
  80bc41:	8b 45 0c             	mov    0xc(%ebp),%eax
  80bc44:	89 43 2c             	mov    %eax,0x2c(%ebx)
  conn->recv_avail   = 0;
  80bc47:	66 c7 43 20 00 00    	movw   $0x0,0x20(%ebx)
}
  80bc4d:	89 d8                	mov    %ebx,%eax
  80bc4f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80bc52:	c9                   	leave  
  80bc53:	c3                   	ret    
    memp_free(MEMP_NETCONN, conn);
  80bc54:	83 ec 08             	sub    $0x8,%esp
  80bc57:	53                   	push   %ebx
  80bc58:	6a 07                	push   $0x7
  80bc5a:	e8 7f 88 ff ff       	call   8044de <memp_free>
    return NULL;
  80bc5f:	83 c4 10             	add    $0x10,%esp
  80bc62:	bb 00 00 00 00       	mov    $0x0,%ebx
  80bc67:	eb e4                	jmp    80bc4d <netconn_alloc+0x72>
    sys_sem_free(conn->op_completed);
  80bc69:	83 ec 0c             	sub    $0xc,%esp
  80bc6c:	ff 73 10             	pushl  0x10(%ebx)
  80bc6f:	e8 74 e2 ff ff       	call   809ee8 <sys_sem_free>
    memp_free(MEMP_NETCONN, conn);
  80bc74:	83 c4 08             	add    $0x8,%esp
  80bc77:	53                   	push   %ebx
  80bc78:	6a 07                	push   $0x7
  80bc7a:	e8 5f 88 ff ff       	call   8044de <memp_free>
    return NULL;
  80bc7f:	83 c4 10             	add    $0x10,%esp
  80bc82:	bb 00 00 00 00       	mov    $0x0,%ebx
  80bc87:	eb c4                	jmp    80bc4d <netconn_alloc+0x72>

0080bc89 <netconn_free>:
{
  80bc89:	55                   	push   %ebp
  80bc8a:	89 e5                	mov    %esp,%ebp
  80bc8c:	56                   	push   %esi
  80bc8d:	53                   	push   %ebx
  80bc8e:	83 ec 10             	sub    $0x10,%esp
  80bc91:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
  80bc94:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80bc98:	75 0b                	jne    80bca5 <netconn_free+0x1c>
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  80bc9a:	8d 75 f4             	lea    -0xc(%ebp),%esi
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80bc9d:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80bca1:	75 27                	jne    80bcca <netconn_free+0x41>
  80bca3:	eb 68                	jmp    80bd0d <netconn_free+0x84>
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
  80bca5:	83 ec 04             	sub    $0x4,%esp
  80bca8:	68 08 30 81 00       	push   $0x813008
  80bcad:	68 26 02 00 00       	push   $0x226
  80bcb2:	68 62 30 81 00       	push   $0x813062
  80bcb7:	e8 97 29 00 00       	call   80e653 <_panic>
        netbuf_delete((struct netbuf *)mem);
  80bcbc:	83 ec 0c             	sub    $0xc,%esp
  80bcbf:	ff 75 f4             	pushl  -0xc(%ebp)
  80bcc2:	e8 82 67 ff ff       	call   802449 <netbuf_delete>
  80bcc7:	83 c4 10             	add    $0x10,%esp
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  80bcca:	83 ec 08             	sub    $0x8,%esp
  80bccd:	56                   	push   %esi
  80bcce:	ff 73 14             	pushl  0x14(%ebx)
  80bcd1:	e8 b1 e7 ff ff       	call   80a487 <sys_arch_mbox_tryfetch>
  80bcd6:	83 c4 10             	add    $0x10,%esp
  80bcd9:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bcdc:	74 1a                	je     80bcf8 <netconn_free+0x6f>
      if (conn->type == NETCONN_TCP) {
  80bcde:	83 3b 10             	cmpl   $0x10,(%ebx)
  80bce1:	75 d9                	jne    80bcbc <netconn_free+0x33>
        if(mem != NULL) {
  80bce3:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80bce6:	85 c0                	test   %eax,%eax
  80bce8:	74 e0                	je     80bcca <netconn_free+0x41>
          pbuf_free((struct pbuf *)mem);
  80bcea:	83 ec 0c             	sub    $0xc,%esp
  80bced:	50                   	push   %eax
  80bcee:	e8 5a 8b ff ff       	call   80484d <pbuf_free>
  80bcf3:	83 c4 10             	add    $0x10,%esp
  80bcf6:	eb d2                	jmp    80bcca <netconn_free+0x41>
    sys_mbox_free(conn->recvmbox);
  80bcf8:	83 ec 0c             	sub    $0xc,%esp
  80bcfb:	ff 73 14             	pushl  0x14(%ebx)
  80bcfe:	e8 6e e2 ff ff       	call   809f71 <sys_mbox_free>
    conn->recvmbox = SYS_MBOX_NULL;
  80bd03:	c7 43 14 ff ff ff ff 	movl   $0xffffffff,0x14(%ebx)
  80bd0a:	83 c4 10             	add    $0x10,%esp
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  80bd0d:	8d 75 f4             	lea    -0xc(%ebp),%esi
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80bd10:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80bd14:	75 10                	jne    80bd26 <netconn_free+0x9d>
  80bd16:	eb 37                	jmp    80bd4f <netconn_free+0xc6>
      netconn_delete((struct netconn *)mem);
  80bd18:	83 ec 0c             	sub    $0xc,%esp
  80bd1b:	ff 75 f4             	pushl  -0xc(%ebp)
  80bd1e:	e8 2c f0 ff ff       	call   80ad4f <netconn_delete>
  80bd23:	83 c4 10             	add    $0x10,%esp
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  80bd26:	83 ec 08             	sub    $0x8,%esp
  80bd29:	56                   	push   %esi
  80bd2a:	ff 73 18             	pushl  0x18(%ebx)
  80bd2d:	e8 55 e7 ff ff       	call   80a487 <sys_arch_mbox_tryfetch>
  80bd32:	83 c4 10             	add    $0x10,%esp
  80bd35:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bd38:	75 de                	jne    80bd18 <netconn_free+0x8f>
    sys_mbox_free(conn->acceptmbox);
  80bd3a:	83 ec 0c             	sub    $0xc,%esp
  80bd3d:	ff 73 18             	pushl  0x18(%ebx)
  80bd40:	e8 2c e2 ff ff       	call   809f71 <sys_mbox_free>
    conn->acceptmbox = SYS_MBOX_NULL;
  80bd45:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  80bd4c:	83 c4 10             	add    $0x10,%esp
  sys_sem_free(conn->op_completed);
  80bd4f:	83 ec 0c             	sub    $0xc,%esp
  80bd52:	ff 73 10             	pushl  0x10(%ebx)
  80bd55:	e8 8e e1 ff ff       	call   809ee8 <sys_sem_free>
  conn->op_completed = SYS_SEM_NULL;
  80bd5a:	c7 43 10 ff ff ff ff 	movl   $0xffffffff,0x10(%ebx)
  memp_free(MEMP_NETCONN, conn);
  80bd61:	83 c4 08             	add    $0x8,%esp
  80bd64:	53                   	push   %ebx
  80bd65:	6a 07                	push   $0x7
  80bd67:	e8 72 87 ff ff       	call   8044de <memp_free>
}
  80bd6c:	83 c4 10             	add    $0x10,%esp
  80bd6f:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80bd72:	5b                   	pop    %ebx
  80bd73:	5e                   	pop    %esi
  80bd74:	5d                   	pop    %ebp
  80bd75:	c3                   	ret    

0080bd76 <accept_function>:
{
  80bd76:	55                   	push   %ebp
  80bd77:	89 e5                	mov    %esp,%ebp
  80bd79:	57                   	push   %edi
  80bd7a:	56                   	push   %esi
  80bd7b:	53                   	push   %ebx
  80bd7c:	83 ec 0c             	sub    $0xc,%esp
  80bd7f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80bd82:	8b 7d 10             	mov    0x10(%ebp),%edi
  LWIP_ERROR("accept_function: invalid conn->acceptmbox",
  80bd85:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80bd89:	74 57                	je     80bde2 <accept_function+0x6c>
  newconn = netconn_alloc(conn->type, conn->callback);
  80bd8b:	83 ec 08             	sub    $0x8,%esp
  80bd8e:	ff 73 2c             	pushl  0x2c(%ebx)
  80bd91:	ff 33                	pushl  (%ebx)
  80bd93:	e8 43 fe ff ff       	call   80bbdb <netconn_alloc>
  80bd98:	89 c6                	mov    %eax,%esi
  if (newconn == NULL) {
  80bd9a:	83 c4 10             	add    $0x10,%esp
  80bd9d:	85 c0                	test   %eax,%eax
  80bd9f:	74 72                	je     80be13 <accept_function+0x9d>
  newconn->pcb.tcp = newpcb;
  80bda1:	8b 45 0c             	mov    0xc(%ebp),%eax
  80bda4:	89 46 08             	mov    %eax,0x8(%esi)
  setup_tcp(newconn);
  80bda7:	89 f0                	mov    %esi,%eax
  80bda9:	e8 af f7 ff ff       	call   80b55d <setup_tcp>
  newconn->err = err;
  80bdae:	89 f8                	mov    %edi,%eax
  80bdb0:	88 46 0c             	mov    %al,0xc(%esi)
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80bdb3:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80bdb6:	85 c0                	test   %eax,%eax
  80bdb8:	74 0d                	je     80bdc7 <accept_function+0x51>
  80bdba:	83 ec 04             	sub    $0x4,%esp
  80bdbd:	6a 00                	push   $0x0
  80bdbf:	6a 00                	push   $0x0
  80bdc1:	53                   	push   %ebx
  80bdc2:	ff d0                	call   *%eax
  80bdc4:	83 c4 10             	add    $0x10,%esp
  if (sys_mbox_trypost(conn->acceptmbox, newconn) != ERR_OK) {
  80bdc7:	83 ec 08             	sub    $0x8,%esp
  80bdca:	56                   	push   %esi
  80bdcb:	ff 73 18             	pushl  0x18(%ebx)
  80bdce:	e8 d1 e4 ff ff       	call   80a2a4 <sys_mbox_trypost>
  80bdd3:	83 c4 10             	add    $0x10,%esp
  80bdd6:	84 c0                	test   %al,%al
  80bdd8:	75 1f                	jne    80bdf9 <accept_function+0x83>
}
  80bdda:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80bddd:	5b                   	pop    %ebx
  80bdde:	5e                   	pop    %esi
  80bddf:	5f                   	pop    %edi
  80bde0:	5d                   	pop    %ebp
  80bde1:	c3                   	ret    
  LWIP_ERROR("accept_function: invalid conn->acceptmbox",
  80bde2:	83 ec 04             	sub    $0x4,%esp
  80bde5:	68 38 30 81 00       	push   $0x813038
  80bdea:	68 65 01 00 00       	push   $0x165
  80bdef:	68 62 30 81 00       	push   $0x813062
  80bdf4:	e8 5a 28 00 00       	call   80e653 <_panic>
    newconn->pcb.tcp = NULL;
  80bdf9:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
    netconn_free(newconn);
  80be00:	83 ec 0c             	sub    $0xc,%esp
  80be03:	56                   	push   %esi
  80be04:	e8 80 fe ff ff       	call   80bc89 <netconn_free>
    return ERR_MEM;
  80be09:	83 c4 10             	add    $0x10,%esp
  80be0c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80be11:	eb c7                	jmp    80bdda <accept_function+0x64>
    return ERR_MEM;
  80be13:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80be18:	eb c0                	jmp    80bdda <accept_function+0x64>

0080be1a <do_delconn>:
{
  80be1a:	55                   	push   %ebp
  80be1b:	89 e5                	mov    %esp,%ebp
  80be1d:	53                   	push   %ebx
  80be1e:	83 ec 04             	sub    $0x4,%esp
  80be21:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (msg->conn->pcb.tcp != NULL) {
  80be24:	8b 13                	mov    (%ebx),%edx
  80be26:	8b 4a 08             	mov    0x8(%edx),%ecx
  80be29:	85 c9                	test   %ecx,%ecx
  80be2b:	74 16                	je     80be43 <do_delconn+0x29>
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80be2d:	8b 02                	mov    (%edx),%eax
  80be2f:	25 f0 00 00 00       	and    $0xf0,%eax
  80be34:	83 f8 20             	cmp    $0x20,%eax
  80be37:	74 5f                	je     80be98 <do_delconn+0x7e>
  80be39:	83 f8 40             	cmp    $0x40,%eax
  80be3c:	74 4c                	je     80be8a <do_delconn+0x70>
  80be3e:	83 f8 10             	cmp    $0x10,%eax
  80be41:	74 6e                	je     80beb1 <do_delconn+0x97>
  API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
  80be43:	8b 13                	mov    (%ebx),%edx
  80be45:	8b 42 2c             	mov    0x2c(%edx),%eax
  80be48:	85 c0                	test   %eax,%eax
  80be4a:	74 23                	je     80be6f <do_delconn+0x55>
  80be4c:	83 ec 04             	sub    $0x4,%esp
  80be4f:	6a 00                	push   $0x0
  80be51:	6a 00                	push   $0x0
  80be53:	52                   	push   %edx
  80be54:	ff d0                	call   *%eax
  API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
  80be56:	8b 13                	mov    (%ebx),%edx
  80be58:	8b 42 2c             	mov    0x2c(%edx),%eax
  80be5b:	83 c4 10             	add    $0x10,%esp
  80be5e:	85 c0                	test   %eax,%eax
  80be60:	74 0d                	je     80be6f <do_delconn+0x55>
  80be62:	83 ec 04             	sub    $0x4,%esp
  80be65:	6a 00                	push   $0x0
  80be67:	6a 02                	push   $0x2
  80be69:	52                   	push   %edx
  80be6a:	ff d0                	call   *%eax
  80be6c:	83 c4 10             	add    $0x10,%esp
  if (msg->conn->op_completed != SYS_SEM_NULL) {
  80be6f:	8b 03                	mov    (%ebx),%eax
  80be71:	8b 40 10             	mov    0x10(%eax),%eax
  80be74:	83 f8 ff             	cmp    $0xffffffff,%eax
  80be77:	74 0c                	je     80be85 <do_delconn+0x6b>
    sys_sem_signal(msg->conn->op_completed);
  80be79:	83 ec 0c             	sub    $0xc,%esp
  80be7c:	50                   	push   %eax
  80be7d:	e8 a2 e2 ff ff       	call   80a124 <sys_sem_signal>
  80be82:	83 c4 10             	add    $0x10,%esp
}
  80be85:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80be88:	c9                   	leave  
  80be89:	c3                   	ret    
      raw_remove(msg->conn->pcb.raw);
  80be8a:	83 ec 0c             	sub    $0xc,%esp
  80be8d:	51                   	push   %ecx
  80be8e:	e8 ee 21 00 00       	call   80e081 <raw_remove>
      break;
  80be93:	83 c4 10             	add    $0x10,%esp
  80be96:	eb ab                	jmp    80be43 <do_delconn+0x29>
      msg->conn->pcb.udp->recv_arg = NULL;
  80be98:	c7 41 1c 00 00 00 00 	movl   $0x0,0x1c(%ecx)
      udp_remove(msg->conn->pcb.udp);
  80be9f:	83 ec 0c             	sub    $0xc,%esp
  80bea2:	8b 03                	mov    (%ebx),%eax
  80bea4:	ff 70 08             	pushl  0x8(%eax)
  80bea7:	e8 a2 d1 ff ff       	call   80904e <udp_remove>
      break;
  80beac:	83 c4 10             	add    $0x10,%esp
  80beaf:	eb 92                	jmp    80be43 <do_delconn+0x29>
      msg->conn->state = NETCONN_CLOSE;
  80beb1:	c7 42 04 04 00 00 00 	movl   $0x4,0x4(%edx)
      do_close_internal(msg->conn);
  80beb8:	8b 03                	mov    (%ebx),%eax
  80beba:	e8 76 f9 ff ff       	call   80b835 <do_close_internal>
      return;
  80bebf:	eb c4                	jmp    80be85 <do_delconn+0x6b>

0080bec1 <do_bind>:
{
  80bec1:	55                   	push   %ebp
  80bec2:	89 e5                	mov    %esp,%ebp
  80bec4:	56                   	push   %esi
  80bec5:	53                   	push   %ebx
  80bec6:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80bec9:	8b 33                	mov    (%ebx),%esi
  80becb:	80 7e 0c fc          	cmpb   $0xfc,0xc(%esi)
  80becf:	7c 67                	jl     80bf38 <do_bind+0x77>
    if (msg->conn->pcb.tcp != NULL) {
  80bed1:	8b 56 08             	mov    0x8(%esi),%edx
  80bed4:	85 d2                	test   %edx,%edx
  80bed6:	74 5c                	je     80bf34 <do_bind+0x73>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80bed8:	8b 06                	mov    (%esi),%eax
  80beda:	25 f0 00 00 00       	and    $0xf0,%eax
  80bedf:	83 f8 20             	cmp    $0x20,%eax
  80bee2:	74 37                	je     80bf1b <do_bind+0x5a>
  80bee4:	83 f8 40             	cmp    $0x40,%eax
  80bee7:	74 1e                	je     80bf07 <do_bind+0x46>
  80bee9:	83 f8 10             	cmp    $0x10,%eax
  80beec:	75 4a                	jne    80bf38 <do_bind+0x77>
        msg->conn->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80beee:	83 ec 04             	sub    $0x4,%esp
  80bef1:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80bef5:	50                   	push   %eax
  80bef6:	ff 73 04             	pushl  0x4(%ebx)
  80bef9:	52                   	push   %edx
  80befa:	e8 00 95 ff ff       	call   8053ff <tcp_bind>
  80beff:	88 46 0c             	mov    %al,0xc(%esi)
        break;
  80bf02:	83 c4 10             	add    $0x10,%esp
  80bf05:	eb 31                	jmp    80bf38 <do_bind+0x77>
        msg->conn->err = raw_bind(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80bf07:	83 ec 08             	sub    $0x8,%esp
  80bf0a:	ff 73 04             	pushl  0x4(%ebx)
  80bf0d:	52                   	push   %edx
  80bf0e:	e8 fe 1f 00 00       	call   80df11 <raw_bind>
  80bf13:	88 46 0c             	mov    %al,0xc(%esi)
        break;
  80bf16:	83 c4 10             	add    $0x10,%esp
  80bf19:	eb 1d                	jmp    80bf38 <do_bind+0x77>
        msg->conn->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80bf1b:	83 ec 04             	sub    $0x4,%esp
  80bf1e:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80bf22:	50                   	push   %eax
  80bf23:	ff 73 04             	pushl  0x4(%ebx)
  80bf26:	52                   	push   %edx
  80bf27:	e8 d3 cd ff ff       	call   808cff <udp_bind>
  80bf2c:	88 46 0c             	mov    %al,0xc(%esi)
        break;
  80bf2f:	83 c4 10             	add    $0x10,%esp
  80bf32:	eb 04                	jmp    80bf38 <do_bind+0x77>
      msg->conn->err = ERR_VAL;
  80bf34:	c6 46 0c f7          	movb   $0xf7,0xc(%esi)
  TCPIP_APIMSG_ACK(msg);
  80bf38:	83 ec 0c             	sub    $0xc,%esp
  80bf3b:	8b 03                	mov    (%ebx),%eax
  80bf3d:	ff 70 10             	pushl  0x10(%eax)
  80bf40:	e8 df e1 ff ff       	call   80a124 <sys_sem_signal>
}
  80bf45:	83 c4 10             	add    $0x10,%esp
  80bf48:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80bf4b:	5b                   	pop    %ebx
  80bf4c:	5e                   	pop    %esi
  80bf4d:	5d                   	pop    %ebp
  80bf4e:	c3                   	ret    

0080bf4f <do_connect>:
{
  80bf4f:	55                   	push   %ebp
  80bf50:	89 e5                	mov    %esp,%ebp
  80bf52:	56                   	push   %esi
  80bf53:	53                   	push   %ebx
  80bf54:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (msg->conn->pcb.tcp == NULL) {
  80bf57:	8b 33                	mov    (%ebx),%esi
  80bf59:	8b 56 08             	mov    0x8(%esi),%edx
  80bf5c:	85 d2                	test   %edx,%edx
  80bf5e:	74 1d                	je     80bf7d <do_connect+0x2e>
  switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80bf60:	8b 06                	mov    (%esi),%eax
  80bf62:	25 f0 00 00 00       	and    $0xf0,%eax
  80bf67:	83 f8 20             	cmp    $0x20,%eax
  80bf6a:	74 42                	je     80bfae <do_connect+0x5f>
  80bf6c:	83 f8 40             	cmp    $0x40,%eax
  80bf6f:	74 1c                	je     80bf8d <do_connect+0x3e>
  80bf71:	83 f8 10             	cmp    $0x10,%eax
  80bf74:	74 5e                	je     80bfd4 <do_connect+0x85>
}
  80bf76:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80bf79:	5b                   	pop    %ebx
  80bf7a:	5e                   	pop    %esi
  80bf7b:	5d                   	pop    %ebp
  80bf7c:	c3                   	ret    
    sys_sem_signal(msg->conn->op_completed);
  80bf7d:	83 ec 0c             	sub    $0xc,%esp
  80bf80:	ff 76 10             	pushl  0x10(%esi)
  80bf83:	e8 9c e1 ff ff       	call   80a124 <sys_sem_signal>
    return;
  80bf88:	83 c4 10             	add    $0x10,%esp
  80bf8b:	eb e9                	jmp    80bf76 <do_connect+0x27>
    msg->conn->err = raw_connect(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80bf8d:	83 ec 08             	sub    $0x8,%esp
  80bf90:	ff 73 04             	pushl  0x4(%ebx)
  80bf93:	52                   	push   %edx
  80bf94:	e8 95 1f 00 00       	call   80df2e <raw_connect>
  80bf99:	88 46 0c             	mov    %al,0xc(%esi)
    sys_sem_signal(msg->conn->op_completed);
  80bf9c:	83 c4 04             	add    $0x4,%esp
  80bf9f:	8b 03                	mov    (%ebx),%eax
  80bfa1:	ff 70 10             	pushl  0x10(%eax)
  80bfa4:	e8 7b e1 ff ff       	call   80a124 <sys_sem_signal>
    break;
  80bfa9:	83 c4 10             	add    $0x10,%esp
  80bfac:	eb c8                	jmp    80bf76 <do_connect+0x27>
    msg->conn->err = udp_connect(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80bfae:	83 ec 04             	sub    $0x4,%esp
  80bfb1:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80bfb5:	50                   	push   %eax
  80bfb6:	ff 73 04             	pushl  0x4(%ebx)
  80bfb9:	52                   	push   %edx
  80bfba:	e8 ef cf ff ff       	call   808fae <udp_connect>
  80bfbf:	88 46 0c             	mov    %al,0xc(%esi)
    sys_sem_signal(msg->conn->op_completed);
  80bfc2:	83 c4 04             	add    $0x4,%esp
  80bfc5:	8b 03                	mov    (%ebx),%eax
  80bfc7:	ff 70 10             	pushl  0x10(%eax)
  80bfca:	e8 55 e1 ff ff       	call   80a124 <sys_sem_signal>
    break;
  80bfcf:	83 c4 10             	add    $0x10,%esp
  80bfd2:	eb a2                	jmp    80bf76 <do_connect+0x27>
    msg->conn->state = NETCONN_CONNECT;
  80bfd4:	c7 46 04 03 00 00 00 	movl   $0x3,0x4(%esi)
    setup_tcp(msg->conn);
  80bfdb:	8b 03                	mov    (%ebx),%eax
  80bfdd:	e8 7b f5 ff ff       	call   80b55d <setup_tcp>
    msg->conn->err = tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port,
  80bfe2:	8b 33                	mov    (%ebx),%esi
  80bfe4:	68 b0 b5 80 00       	push   $0x80b5b0
  80bfe9:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80bfed:	50                   	push   %eax
  80bfee:	ff 73 04             	pushl  0x4(%ebx)
  80bff1:	ff 76 08             	pushl  0x8(%esi)
  80bff4:	e8 b2 a3 ff ff       	call   8063ab <tcp_connect>
  80bff9:	88 46 0c             	mov    %al,0xc(%esi)
    break;
  80bffc:	83 c4 10             	add    $0x10,%esp
  80bfff:	e9 72 ff ff ff       	jmp    80bf76 <do_connect+0x27>

0080c004 <do_disconnect>:
{
  80c004:	55                   	push   %ebp
  80c005:	89 e5                	mov    %esp,%ebp
  80c007:	53                   	push   %ebx
  80c008:	83 ec 04             	sub    $0x4,%esp
  80c00b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
  80c00e:	8b 13                	mov    (%ebx),%edx
  80c010:	8b 02                	mov    (%edx),%eax
  80c012:	25 f0 00 00 00       	and    $0xf0,%eax
  80c017:	83 f8 20             	cmp    $0x20,%eax
  80c01a:	74 15                	je     80c031 <do_disconnect+0x2d>
  TCPIP_APIMSG_ACK(msg);
  80c01c:	83 ec 0c             	sub    $0xc,%esp
  80c01f:	8b 03                	mov    (%ebx),%eax
  80c021:	ff 70 10             	pushl  0x10(%eax)
  80c024:	e8 fb e0 ff ff       	call   80a124 <sys_sem_signal>
}
  80c029:	83 c4 10             	add    $0x10,%esp
  80c02c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80c02f:	c9                   	leave  
  80c030:	c3                   	ret    
    udp_disconnect(msg->conn->pcb.udp);
  80c031:	83 ec 0c             	sub    $0xc,%esp
  80c034:	ff 72 08             	pushl  0x8(%edx)
  80c037:	e8 e3 cf ff ff       	call   80901f <udp_disconnect>
  80c03c:	83 c4 10             	add    $0x10,%esp
  80c03f:	eb db                	jmp    80c01c <do_disconnect+0x18>

0080c041 <do_listen>:
{
  80c041:	55                   	push   %ebp
  80c042:	89 e5                	mov    %esp,%ebp
  80c044:	57                   	push   %edi
  80c045:	56                   	push   %esi
  80c046:	53                   	push   %ebx
  80c047:	83 ec 0c             	sub    $0xc,%esp
  80c04a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c04d:	8b 03                	mov    (%ebx),%eax
  80c04f:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80c053:	7c 0c                	jl     80c061 <do_listen+0x20>
    if (msg->conn->pcb.tcp != NULL) {
  80c055:	8b 50 08             	mov    0x8(%eax),%edx
  80c058:	85 d2                	test   %edx,%edx
  80c05a:	74 05                	je     80c061 <do_listen+0x20>
      if (msg->conn->type == NETCONN_TCP) {
  80c05c:	83 38 10             	cmpl   $0x10,(%eax)
  80c05f:	74 18                	je     80c079 <do_listen+0x38>
  TCPIP_APIMSG_ACK(msg);
  80c061:	83 ec 0c             	sub    $0xc,%esp
  80c064:	8b 03                	mov    (%ebx),%eax
  80c066:	ff 70 10             	pushl  0x10(%eax)
  80c069:	e8 b6 e0 ff ff       	call   80a124 <sys_sem_signal>
}
  80c06e:	83 c4 10             	add    $0x10,%esp
  80c071:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80c074:	5b                   	pop    %ebx
  80c075:	5e                   	pop    %esi
  80c076:	5f                   	pop    %edi
  80c077:	5d                   	pop    %ebp
  80c078:	c3                   	ret    
        if (msg->conn->pcb.tcp->state == CLOSED) {
  80c079:	83 7a 10 00          	cmpl   $0x0,0x10(%edx)
  80c07d:	74 06                	je     80c085 <do_listen+0x44>
          msg->conn->err = ERR_CONN;
  80c07f:	c6 40 0c f8          	movb   $0xf8,0xc(%eax)
  80c083:	eb dc                	jmp    80c061 <do_listen+0x20>
          struct tcp_pcb* lpcb = tcp_listen(msg->conn->pcb.tcp);
  80c085:	83 ec 08             	sub    $0x8,%esp
  80c088:	68 ff 00 00 00       	push   $0xff
  80c08d:	52                   	push   %edx
  80c08e:	e8 ec 94 ff ff       	call   80557f <tcp_listen_with_backlog>
  80c093:	89 c6                	mov    %eax,%esi
          if (lpcb == NULL) {
  80c095:	83 c4 10             	add    $0x10,%esp
  80c098:	85 c0                	test   %eax,%eax
  80c09a:	74 4e                	je     80c0ea <do_listen+0xa9>
            if (msg->conn->recvmbox != SYS_MBOX_NULL) {
  80c09c:	8b 03                	mov    (%ebx),%eax
  80c09e:	8b 40 14             	mov    0x14(%eax),%eax
  80c0a1:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c0a4:	75 4f                	jne    80c0f5 <do_listen+0xb4>
            if (msg->conn->acceptmbox == SYS_MBOX_NULL) {
  80c0a6:	8b 3b                	mov    (%ebx),%edi
  80c0a8:	83 7f 18 ff          	cmpl   $0xffffffff,0x18(%edi)
  80c0ac:	74 5e                	je     80c10c <do_listen+0xcb>
            if (msg->conn->err == ERR_OK) {
  80c0ae:	8b 03                	mov    (%ebx),%eax
  80c0b0:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c0b4:	75 ab                	jne    80c061 <do_listen+0x20>
              msg->conn->state = NETCONN_LISTEN;
  80c0b6:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
              msg->conn->pcb.tcp = lpcb;
  80c0bd:	8b 03                	mov    (%ebx),%eax
  80c0bf:	89 70 08             	mov    %esi,0x8(%eax)
              tcp_arg(msg->conn->pcb.tcp, msg->conn);
  80c0c2:	8b 03                	mov    (%ebx),%eax
  80c0c4:	83 ec 08             	sub    $0x8,%esp
  80c0c7:	50                   	push   %eax
  80c0c8:	ff 70 08             	pushl  0x8(%eax)
  80c0cb:	e8 a0 97 ff ff       	call   805870 <tcp_arg>
              tcp_accept(msg->conn->pcb.tcp, accept_function);
  80c0d0:	83 c4 08             	add    $0x8,%esp
  80c0d3:	68 76 bd 80 00       	push   $0x80bd76
  80c0d8:	8b 03                	mov    (%ebx),%eax
  80c0da:	ff 70 08             	pushl  0x8(%eax)
  80c0dd:	e8 cf 97 ff ff       	call   8058b1 <tcp_accept>
  80c0e2:	83 c4 10             	add    $0x10,%esp
  80c0e5:	e9 77 ff ff ff       	jmp    80c061 <do_listen+0x20>
            msg->conn->err = ERR_MEM;
  80c0ea:	8b 03                	mov    (%ebx),%eax
  80c0ec:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80c0f0:	e9 6c ff ff ff       	jmp    80c061 <do_listen+0x20>
              sys_mbox_free(msg->conn->recvmbox);
  80c0f5:	83 ec 0c             	sub    $0xc,%esp
  80c0f8:	50                   	push   %eax
  80c0f9:	e8 73 de ff ff       	call   809f71 <sys_mbox_free>
              msg->conn->recvmbox = SYS_MBOX_NULL;
  80c0fe:	8b 03                	mov    (%ebx),%eax
  80c100:	c7 40 14 ff ff ff ff 	movl   $0xffffffff,0x14(%eax)
  80c107:	83 c4 10             	add    $0x10,%esp
  80c10a:	eb 9a                	jmp    80c0a6 <do_listen+0x65>
              if ((msg->conn->acceptmbox = sys_mbox_new(DEFAULT_ACCEPTMBOX_SIZE)) == SYS_MBOX_NULL) {
  80c10c:	83 ec 0c             	sub    $0xc,%esp
  80c10f:	6a 00                	push   $0x0
  80c111:	e8 fa de ff ff       	call   80a010 <sys_mbox_new>
  80c116:	89 47 18             	mov    %eax,0x18(%edi)
  80c119:	83 c4 10             	add    $0x10,%esp
  80c11c:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c11f:	75 8d                	jne    80c0ae <do_listen+0x6d>
                msg->conn->err = ERR_MEM;
  80c121:	8b 03                	mov    (%ebx),%eax
  80c123:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80c127:	eb 85                	jmp    80c0ae <do_listen+0x6d>

0080c129 <do_send>:
{
  80c129:	55                   	push   %ebp
  80c12a:	89 e5                	mov    %esp,%ebp
  80c12c:	57                   	push   %edi
  80c12d:	56                   	push   %esi
  80c12e:	53                   	push   %ebx
  80c12f:	83 ec 0c             	sub    $0xc,%esp
  80c132:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c135:	8b 33                	mov    (%ebx),%esi
  80c137:	80 7e 0c fc          	cmpb   $0xfc,0xc(%esi)
  80c13b:	7c 67                	jl     80c1a4 <do_send+0x7b>
    if (msg->conn->pcb.tcp != NULL) {
  80c13d:	8b 56 08             	mov    0x8(%esi),%edx
  80c140:	85 d2                	test   %edx,%edx
  80c142:	74 60                	je     80c1a4 <do_send+0x7b>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80c144:	8b 06                	mov    (%esi),%eax
  80c146:	25 f0 00 00 00       	and    $0xf0,%eax
  80c14b:	83 f8 20             	cmp    $0x20,%eax
  80c14e:	74 36                	je     80c186 <do_send+0x5d>
  80c150:	83 f8 40             	cmp    $0x40,%eax
  80c153:	75 4f                	jne    80c1a4 <do_send+0x7b>
        if (msg->msg.b->addr == NULL) {
  80c155:	8b 43 04             	mov    0x4(%ebx),%eax
  80c158:	8b 48 08             	mov    0x8(%eax),%ecx
  80c15b:	85 c9                	test   %ecx,%ecx
  80c15d:	74 14                	je     80c173 <do_send+0x4a>
          msg->conn->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, msg->msg.b->addr);
  80c15f:	83 ec 04             	sub    $0x4,%esp
  80c162:	51                   	push   %ecx
  80c163:	ff 30                	pushl  (%eax)
  80c165:	52                   	push   %edx
  80c166:	e8 f5 1d 00 00       	call   80df60 <raw_sendto>
  80c16b:	88 46 0c             	mov    %al,0xc(%esi)
  80c16e:	83 c4 10             	add    $0x10,%esp
  80c171:	eb 31                	jmp    80c1a4 <do_send+0x7b>
          msg->conn->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
  80c173:	83 ec 08             	sub    $0x8,%esp
  80c176:	ff 30                	pushl  (%eax)
  80c178:	52                   	push   %edx
  80c179:	e8 eb 1e 00 00       	call   80e069 <raw_send>
  80c17e:	88 46 0c             	mov    %al,0xc(%esi)
  80c181:	83 c4 10             	add    $0x10,%esp
  80c184:	eb 1e                	jmp    80c1a4 <do_send+0x7b>
        if (msg->msg.b->addr == NULL) {
  80c186:	8b 43 04             	mov    0x4(%ebx),%eax
  80c189:	8b 48 08             	mov    0x8(%eax),%ecx
  80c18c:	85 c9                	test   %ecx,%ecx
  80c18e:	74 2c                	je     80c1bc <do_send+0x93>
          msg->conn->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, msg->msg.b->addr, msg->msg.b->port);
  80c190:	0f b7 78 0c          	movzwl 0xc(%eax),%edi
  80c194:	57                   	push   %edi
  80c195:	51                   	push   %ecx
  80c196:	ff 30                	pushl  (%eax)
  80c198:	52                   	push   %edx
  80c199:	e8 b3 cd ff ff       	call   808f51 <udp_sendto>
  80c19e:	88 46 0c             	mov    %al,0xc(%esi)
  80c1a1:	83 c4 10             	add    $0x10,%esp
  TCPIP_APIMSG_ACK(msg);
  80c1a4:	83 ec 0c             	sub    $0xc,%esp
  80c1a7:	8b 03                	mov    (%ebx),%eax
  80c1a9:	ff 70 10             	pushl  0x10(%eax)
  80c1ac:	e8 73 df ff ff       	call   80a124 <sys_sem_signal>
}
  80c1b1:	83 c4 10             	add    $0x10,%esp
  80c1b4:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80c1b7:	5b                   	pop    %ebx
  80c1b8:	5e                   	pop    %esi
  80c1b9:	5f                   	pop    %edi
  80c1ba:	5d                   	pop    %ebp
  80c1bb:	c3                   	ret    
          msg->conn->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
  80c1bc:	83 ec 08             	sub    $0x8,%esp
  80c1bf:	ff 30                	pushl  (%eax)
  80c1c1:	52                   	push   %edx
  80c1c2:	e8 ca cd ff ff       	call   808f91 <udp_send>
  80c1c7:	88 46 0c             	mov    %al,0xc(%esi)
  80c1ca:	83 c4 10             	add    $0x10,%esp
  80c1cd:	eb d5                	jmp    80c1a4 <do_send+0x7b>

0080c1cf <do_recv>:
{
  80c1cf:	55                   	push   %ebp
  80c1d0:	89 e5                	mov    %esp,%ebp
  80c1d2:	53                   	push   %ebx
  80c1d3:	83 ec 04             	sub    $0x4,%esp
  80c1d6:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c1d9:	8b 03                	mov    (%ebx),%eax
  80c1db:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80c1df:	7c 0c                	jl     80c1ed <do_recv+0x1e>
    if (msg->conn->pcb.tcp != NULL) {
  80c1e1:	8b 50 08             	mov    0x8(%eax),%edx
  80c1e4:	85 d2                	test   %edx,%edx
  80c1e6:	74 05                	je     80c1ed <do_recv+0x1e>
      if (msg->conn->type == NETCONN_TCP) {
  80c1e8:	83 38 10             	cmpl   $0x10,(%eax)
  80c1eb:	74 15                	je     80c202 <do_recv+0x33>
  TCPIP_APIMSG_ACK(msg);
  80c1ed:	83 ec 0c             	sub    $0xc,%esp
  80c1f0:	8b 03                	mov    (%ebx),%eax
  80c1f2:	ff 70 10             	pushl  0x10(%eax)
  80c1f5:	e8 2a df ff ff       	call   80a124 <sys_sem_signal>
}
  80c1fa:	83 c4 10             	add    $0x10,%esp
  80c1fd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80c200:	c9                   	leave  
  80c201:	c3                   	ret    
          tcp_recved(msg->conn->pcb.tcp, msg->msg.r.len);
  80c202:	83 ec 08             	sub    $0x8,%esp
  80c205:	0f b7 43 04          	movzwl 0x4(%ebx),%eax
  80c209:	50                   	push   %eax
  80c20a:	52                   	push   %edx
  80c20b:	e8 a6 94 ff ff       	call   8056b6 <tcp_recved>
  80c210:	83 c4 10             	add    $0x10,%esp
  80c213:	eb d8                	jmp    80c1ed <do_recv+0x1e>

0080c215 <do_write>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_write(struct api_msg_msg *msg)
{
  80c215:	55                   	push   %ebp
  80c216:	89 e5                	mov    %esp,%ebp
  80c218:	83 ec 08             	sub    $0x8,%esp
  80c21b:	8b 55 08             	mov    0x8(%ebp),%edx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c21e:	8b 02                	mov    (%edx),%eax
  80c220:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80c224:	7c 0f                	jl     80c235 <do_write+0x20>
    if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80c226:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80c22a:	74 05                	je     80c231 <do_write+0x1c>
  80c22c:	83 38 10             	cmpl   $0x10,(%eax)
  80c22f:	74 16                	je     80c247 <do_write+0x32>
      /* for both cases: if do_writemore was called, don't ACK the APIMSG! */
      return;
#endif /* LWIP_TCP */
#if (LWIP_UDP || LWIP_RAW)
    } else {
      msg->conn->err = ERR_VAL;
  80c231:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
#endif /* (LWIP_UDP || LWIP_RAW) */
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80c235:	83 ec 0c             	sub    $0xc,%esp
  80c238:	8b 02                	mov    (%edx),%eax
  80c23a:	ff 70 10             	pushl  0x10(%eax)
  80c23d:	e8 e2 de ff ff       	call   80a124 <sys_sem_signal>
  80c242:	83 c4 10             	add    $0x10,%esp
}
  80c245:	c9                   	leave  
  80c246:	c3                   	ret    
      msg->conn->state = NETCONN_WRITE;
  80c247:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
      msg->conn->write_msg = msg;
  80c24e:	8b 02                	mov    (%edx),%eax
  80c250:	89 50 24             	mov    %edx,0x24(%eax)
      msg->conn->write_offset = 0;
  80c253:	8b 02                	mov    (%edx),%eax
  80c255:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
      do_writemore(msg->conn);
  80c25c:	8b 02                	mov    (%edx),%eax
  80c25e:	e8 6b f4 ff ff       	call   80b6ce <do_writemore>
      return;
  80c263:	eb e0                	jmp    80c245 <do_write+0x30>

0080c265 <do_getaddr>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_getaddr(struct api_msg_msg *msg)
{
  80c265:	55                   	push   %ebp
  80c266:	89 e5                	mov    %esp,%ebp
  80c268:	83 ec 08             	sub    $0x8,%esp
  80c26b:	8b 45 08             	mov    0x8(%ebp),%eax
  if (msg->conn->pcb.ip != NULL) {
  80c26e:	8b 08                	mov    (%eax),%ecx
  80c270:	8b 51 08             	mov    0x8(%ecx),%edx
  80c273:	85 d2                	test   %edx,%edx
  80c275:	0f 84 96 00 00 00    	je     80c311 <do_getaddr+0xac>
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local?msg->conn->pcb.ip->local_ip:msg->conn->pcb.ip->remote_ip);
  80c27b:	8b 48 04             	mov    0x4(%eax),%ecx
  80c27e:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c282:	74 32                	je     80c2b6 <do_getaddr+0x51>
  80c284:	8b 12                	mov    (%edx),%edx
  80c286:	89 11                	mov    %edx,(%ecx)
    
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80c288:	8b 08                	mov    (%eax),%ecx
  80c28a:	8b 11                	mov    (%ecx),%edx
  80c28c:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80c292:	83 fa 20             	cmp    $0x20,%edx
  80c295:	74 41                	je     80c2d8 <do_getaddr+0x73>
  80c297:	83 fa 40             	cmp    $0x40,%edx
  80c29a:	74 21                	je     80c2bd <do_getaddr+0x58>
  80c29c:	83 fa 10             	cmp    $0x10,%edx
  80c29f:	75 74                	jne    80c315 <do_getaddr+0xb0>
      }
      break;
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
  80c2a1:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c2a5:	74 61                	je     80c308 <do_getaddr+0xa3>
  80c2a7:	8b 51 08             	mov    0x8(%ecx),%edx
  80c2aa:	0f b7 4a 1c          	movzwl 0x1c(%edx),%ecx
  80c2ae:	8b 50 08             	mov    0x8(%eax),%edx
  80c2b1:	66 89 0a             	mov    %cx,(%edx)
      break;
  80c2b4:	eb 5f                	jmp    80c315 <do_getaddr+0xb0>
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local?msg->conn->pcb.ip->local_ip:msg->conn->pcb.ip->remote_ip);
  80c2b6:	8b 52 04             	mov    0x4(%edx),%edx
  80c2b9:	89 11                	mov    %edx,(%ecx)
  80c2bb:	eb cb                	jmp    80c288 <do_getaddr+0x23>
      if (msg->msg.ad.local) {
  80c2bd:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c2c1:	74 0f                	je     80c2d2 <do_getaddr+0x6d>
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
  80c2c3:	8b 50 08             	mov    0x8(%eax),%edx
  80c2c6:	8b 49 08             	mov    0x8(%ecx),%ecx
  80c2c9:	0f b6 49 10          	movzbl 0x10(%ecx),%ecx
  80c2cd:	66 89 0a             	mov    %cx,(%edx)
  80c2d0:	eb 43                	jmp    80c315 <do_getaddr+0xb0>
        msg->conn->err = ERR_CONN;
  80c2d2:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80c2d6:	eb 3d                	jmp    80c315 <do_getaddr+0xb0>
      if (msg->msg.ad.local) {
  80c2d8:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c2dc:	75 0f                	jne    80c2ed <do_getaddr+0x88>
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
  80c2de:	8b 51 08             	mov    0x8(%ecx),%edx
  80c2e1:	f6 42 10 04          	testb  $0x4,0x10(%edx)
  80c2e5:	75 15                	jne    80c2fc <do_getaddr+0x97>
          msg->conn->err = ERR_CONN;
  80c2e7:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80c2eb:	eb 28                	jmp    80c315 <do_getaddr+0xb0>
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
  80c2ed:	8b 50 08             	mov    0x8(%eax),%edx
  80c2f0:	8b 49 08             	mov    0x8(%ecx),%ecx
  80c2f3:	0f b7 49 12          	movzwl 0x12(%ecx),%ecx
  80c2f7:	66 89 0a             	mov    %cx,(%edx)
  80c2fa:	eb 19                	jmp    80c315 <do_getaddr+0xb0>
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
  80c2fc:	8b 48 08             	mov    0x8(%eax),%ecx
  80c2ff:	0f b7 52 14          	movzwl 0x14(%edx),%edx
  80c303:	66 89 11             	mov    %dx,(%ecx)
  80c306:	eb 0d                	jmp    80c315 <do_getaddr+0xb0>
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
  80c308:	8b 51 08             	mov    0x8(%ecx),%edx
  80c30b:	0f b7 4a 1e          	movzwl 0x1e(%edx),%ecx
  80c30f:	eb 9d                	jmp    80c2ae <do_getaddr+0x49>
#endif /* LWIP_TCP */
    }
  } else {
    msg->conn->err = ERR_CONN;
  80c311:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  }
  TCPIP_APIMSG_ACK(msg);
  80c315:	83 ec 0c             	sub    $0xc,%esp
  80c318:	8b 00                	mov    (%eax),%eax
  80c31a:	ff 70 10             	pushl  0x10(%eax)
  80c31d:	e8 02 de ff ff       	call   80a124 <sys_sem_signal>
}
  80c322:	83 c4 10             	add    $0x10,%esp
  80c325:	c9                   	leave  
  80c326:	c3                   	ret    

0080c327 <do_close>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_close(struct api_msg_msg *msg)
{
  80c327:	55                   	push   %ebp
  80c328:	89 e5                	mov    %esp,%ebp
  80c32a:	83 ec 08             	sub    $0x8,%esp
  80c32d:	8b 55 08             	mov    0x8(%ebp),%edx
#if LWIP_TCP
  if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80c330:	8b 02                	mov    (%edx),%eax
  80c332:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80c336:	74 05                	je     80c33d <do_close+0x16>
  80c338:	83 38 10             	cmpl   $0x10,(%eax)
  80c33b:	74 16                	je     80c353 <do_close+0x2c>
      do_close_internal(msg->conn);
      /* for tcp netconns, do_close_internal ACKs the message */
  } else
#endif /* LWIP_TCP */
  {
    msg->conn->err = ERR_VAL;
  80c33d:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
    TCPIP_APIMSG_ACK(msg);
  80c341:	83 ec 0c             	sub    $0xc,%esp
  80c344:	8b 02                	mov    (%edx),%eax
  80c346:	ff 70 10             	pushl  0x10(%eax)
  80c349:	e8 d6 dd ff ff       	call   80a124 <sys_sem_signal>
  80c34e:	83 c4 10             	add    $0x10,%esp
  }
}
  80c351:	c9                   	leave  
  80c352:	c3                   	ret    
      msg->conn->state = NETCONN_CLOSE;
  80c353:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%eax)
      do_close_internal(msg->conn);
  80c35a:	8b 02                	mov    (%edx),%eax
  80c35c:	e8 d4 f4 ff ff       	call   80b835 <do_close_internal>
  80c361:	eb ee                	jmp    80c351 <do_close+0x2a>

0080c363 <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
  80c363:	55                   	push   %ebp
  80c364:	89 e5                	mov    %esp,%ebp
  80c366:	57                   	push   %edi
  80c367:	56                   	push   %esi
  80c368:	53                   	push   %ebx
  80c369:	83 ec 18             	sub    $0x18,%esp
  80c36c:	89 c7                	mov    %eax,%edi
  u8_t c;
  u8_t *opts, opt;
  u16_t mss;

  opts = (u8_t *)tcphdr + TCP_HLEN;
  80c36e:	8b 35 b0 b1 b3 00    	mov    0xb3b1b0,%esi

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
  80c374:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  80c378:	50                   	push   %eax
  80c379:	e8 11 b4 ff ff       	call   80778f <ntohs>
  80c37e:	83 c4 10             	add    $0x10,%esp
  80c381:	66 3d ff 5f          	cmp    $0x5fff,%ax
  80c385:	0f 86 83 00 00 00    	jbe    80c40e <tcp_parseopt+0xab>
  opts = (u8_t *)tcphdr + TCP_HLEN;
  80c38b:	83 c6 14             	add    $0x14,%esi
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  80c38e:	bb 00 00 00 00       	mov    $0x0,%ebx
  80c393:	eb 10                	jmp    80c3a5 <tcp_parseopt+0x42>
      opt = opts[c];
      if (opt == 0x00) {
        /* End of options. */
        break;
      } else if (opt == 0x01) {
        ++c;
  80c395:	83 c3 01             	add    $0x1,%ebx
  80c398:	eb 0b                	jmp    80c3a5 <tcp_parseopt+0x42>
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;

        /* And we are done processing options. */
        break;
      } else {
        if (opts[c + 1] == 0) {
  80c39a:	0f b6 44 16 01       	movzbl 0x1(%esi,%edx,1),%eax
  80c39f:	84 c0                	test   %al,%al
  80c3a1:	74 6b                	je     80c40e <tcp_parseopt+0xab>
             and we don't process them further. */
          break;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
  80c3a3:	01 c3                	add    %eax,%ebx
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  80c3a5:	83 ec 0c             	sub    $0xc,%esp
  80c3a8:	a1 b0 b1 b3 00       	mov    0xb3b1b0,%eax
  80c3ad:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c3b1:	50                   	push   %eax
  80c3b2:	e8 d8 b3 ff ff       	call   80778f <ntohs>
  80c3b7:	0f b6 d3             	movzbl %bl,%edx
  80c3ba:	66 c1 e8 0c          	shr    $0xc,%ax
  80c3be:	0f b7 c0             	movzwl %ax,%eax
  80c3c1:	8d 04 85 ec ff ff ff 	lea    -0x14(,%eax,4),%eax
  80c3c8:	83 c4 10             	add    $0x10,%esp
  80c3cb:	39 c2                	cmp    %eax,%edx
  80c3cd:	7d 3f                	jge    80c40e <tcp_parseopt+0xab>
      opt = opts[c];
  80c3cf:	0f b6 d3             	movzbl %bl,%edx
  80c3d2:	0f b6 04 16          	movzbl (%esi,%edx,1),%eax
      if (opt == 0x00) {
  80c3d6:	84 c0                	test   %al,%al
  80c3d8:	74 34                	je     80c40e <tcp_parseopt+0xab>
      } else if (opt == 0x01) {
  80c3da:	3c 01                	cmp    $0x1,%al
  80c3dc:	74 b7                	je     80c395 <tcp_parseopt+0x32>
      } else if (opt == 0x02 &&
  80c3de:	3c 02                	cmp    $0x2,%al
  80c3e0:	75 b8                	jne    80c39a <tcp_parseopt+0x37>
  80c3e2:	80 7c 16 01 04       	cmpb   $0x4,0x1(%esi,%edx,1)
  80c3e7:	75 b1                	jne    80c39a <tcp_parseopt+0x37>
        mss = (opts[c + 2] << 8) | opts[c + 3];
  80c3e9:	0f b6 44 16 02       	movzbl 0x2(%esi,%edx,1),%eax
  80c3ee:	c1 e0 08             	shl    $0x8,%eax
  80c3f1:	89 c1                	mov    %eax,%ecx
  80c3f3:	0f b6 44 16 03       	movzbl 0x3(%esi,%edx,1),%eax
  80c3f8:	09 c8                	or     %ecx,%eax
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
  80c3fa:	8d 50 ff             	lea    -0x1(%eax),%edx
  80c3fd:	66 81 fa b4 05       	cmp    $0x5b4,%dx
  80c402:	ba b4 05 00 00       	mov    $0x5b4,%edx
  80c407:	0f 43 c2             	cmovae %edx,%eax
  80c40a:	66 89 47 34          	mov    %ax,0x34(%edi)
      }
    }
  }
}
  80c40e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80c411:	5b                   	pop    %ebx
  80c412:	5e                   	pop    %esi
  80c413:	5f                   	pop    %edi
  80c414:	5d                   	pop    %ebp
  80c415:	c3                   	ret    

0080c416 <tcp_receive>:
{
  80c416:	55                   	push   %ebp
  80c417:	89 e5                	mov    %esp,%ebp
  80c419:	57                   	push   %edi
  80c41a:	56                   	push   %esi
  80c41b:	53                   	push   %ebx
  80c41c:	83 ec 1c             	sub    $0x1c,%esp
  80c41f:	89 c7                	mov    %eax,%edi
  if (flags & TCP_ACK) {
  80c421:	f6 05 a0 b1 b3 00 10 	testb  $0x10,0xb3b1a0
  80c428:	0f 84 2e 04 00 00    	je     80c85c <tcp_receive+0x446>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  80c42e:	0f b7 48 5c          	movzwl 0x5c(%eax),%ecx
  80c432:	8b 50 60             	mov    0x60(%eax),%edx
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
  80c435:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80c43a:	39 c2                	cmp    %eax,%edx
  80c43c:	78 53                	js     80c491 <tcp_receive+0x7b>
  80c43e:	39 c2                	cmp    %eax,%edx
  80c440:	74 36                	je     80c478 <tcp_receive+0x62>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  80c442:	8b 35 a4 b1 b3 00    	mov    0xb3b1a4,%esi
  80c448:	39 77 64             	cmp    %esi,0x64(%edi)
  80c44b:	74 38                	je     80c485 <tcp_receive+0x6f>
    if (pcb->lastack == ackno) {
  80c44d:	8b 5f 48             	mov    0x48(%edi),%ebx
  80c450:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80c455:	39 c3                	cmp    %eax,%ebx
  80c457:	74 68                	je     80c4c1 <tcp_receive+0xab>
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_max)){
  80c459:	8d 50 ff             	lea    -0x1(%eax),%edx
  80c45c:	39 da                	cmp    %ebx,%edx
  80c45e:	78 0d                	js     80c46d <tcp_receive+0x57>
  80c460:	89 c2                	mov    %eax,%edx
  80c462:	2b 57 58             	sub    0x58(%edi),%edx
  80c465:	85 d2                	test   %edx,%edx
  80c467:	0f 8e 02 01 00 00    	jle    80c56f <tcp_receive+0x159>
      pcb->acked = 0;
  80c46d:	66 c7 47 6c 00 00    	movw   $0x0,0x6c(%edi)
  80c473:	e9 ce 02 00 00       	jmp    80c746 <tcp_receive+0x330>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  80c478:	8b 35 a4 b1 b3 00    	mov    0xb3b1a4,%esi
  80c47e:	39 77 64             	cmp    %esi,0x64(%edi)
  80c481:	79 bf                	jns    80c442 <tcp_receive+0x2c>
  80c483:	eb 0c                	jmp    80c491 <tcp_receive+0x7b>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
  80c485:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80c48b:	66 3b 4b 0e          	cmp    0xe(%ebx),%cx
  80c48f:	73 bc                	jae    80c44d <tcp_receive+0x37>
      pcb->snd_wnd = tcphdr->wnd;
  80c491:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80c497:	0f b7 5b 0e          	movzwl 0xe(%ebx),%ebx
  80c49b:	66 89 5f 5c          	mov    %bx,0x5c(%edi)
      pcb->snd_wl1 = seqno;
  80c49f:	89 47 60             	mov    %eax,0x60(%edi)
      pcb->snd_wl2 = ackno;
  80c4a2:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80c4a7:	89 47 64             	mov    %eax,0x64(%edi)
      if (pcb->snd_wnd > 0 && pcb->persist_backoff > 0) {
  80c4aa:	66 85 db             	test   %bx,%bx
  80c4ad:	74 9e                	je     80c44d <tcp_receive+0x37>
  80c4af:	80 bf a4 00 00 00 00 	cmpb   $0x0,0xa4(%edi)
  80c4b6:	74 95                	je     80c44d <tcp_receive+0x37>
          pcb->persist_backoff = 0;
  80c4b8:	c6 87 a4 00 00 00 00 	movb   $0x0,0xa4(%edi)
  80c4bf:	eb 8c                	jmp    80c44d <tcp_receive+0x37>
      pcb->acked = 0;
  80c4c1:	66 c7 47 6c 00 00    	movw   $0x0,0x6c(%edi)
      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  80c4c7:	0f b7 47 5c          	movzwl 0x5c(%edi),%eax
  80c4cb:	03 47 60             	add    0x60(%edi),%eax
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  80c4ce:	0f b7 c9             	movzwl %cx,%ecx
  80c4d1:	01 ca                	add    %ecx,%edx
      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  80c4d3:	39 d0                	cmp    %edx,%eax
  80c4d5:	0f 85 6b 02 00 00    	jne    80c746 <tcp_receive+0x330>
        ++pcb->dupacks;
  80c4db:	0f b6 47 4c          	movzbl 0x4c(%edi),%eax
  80c4df:	83 c0 01             	add    $0x1,%eax
  80c4e2:	88 47 4c             	mov    %al,0x4c(%edi)
        if (pcb->dupacks >= 3 && pcb->unacked != NULL) {
  80c4e5:	3c 02                	cmp    $0x2,%al
  80c4e7:	0f 86 59 02 00 00    	jbe    80c746 <tcp_receive+0x330>
  80c4ed:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c4f1:	0f 84 4f 02 00 00    	je     80c746 <tcp_receive+0x330>
          if (!(pcb->flags & TF_INFR)) {
  80c4f7:	f6 47 20 04          	testb  $0x4,0x20(%edi)
  80c4fb:	74 1c                	je     80c519 <tcp_receive+0x103>
            if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  80c4fd:	0f b7 47 4e          	movzwl 0x4e(%edi),%eax
  80c501:	89 c2                	mov    %eax,%edx
  80c503:	66 03 57 34          	add    0x34(%edi),%dx
  80c507:	66 39 d0             	cmp    %dx,%ax
  80c50a:	0f 83 36 02 00 00    	jae    80c746 <tcp_receive+0x330>
              pcb->cwnd += pcb->mss;
  80c510:	66 89 57 4e          	mov    %dx,0x4e(%edi)
  80c514:	e9 2d 02 00 00       	jmp    80c746 <tcp_receive+0x330>
            tcp_rexmit(pcb);
  80c519:	83 ec 0c             	sub    $0xc,%esp
  80c51c:	57                   	push   %edi
  80c51d:	e8 23 c2 ff ff       	call   808745 <tcp_rexmit>
            if (pcb->cwnd > pcb->snd_wnd)
  80c522:	0f b7 4f 4e          	movzwl 0x4e(%edi),%ecx
  80c526:	0f b7 47 5c          	movzwl 0x5c(%edi),%eax
  80c52a:	83 c4 10             	add    $0x10,%esp
              pcb->ssthresh = pcb->snd_wnd / 2;
  80c52d:	89 cb                	mov    %ecx,%ebx
  80c52f:	66 d1 eb             	shr    %bx
  80c532:	89 c2                	mov    %eax,%edx
  80c534:	66 d1 ea             	shr    %dx
  80c537:	66 39 c1             	cmp    %ax,%cx
  80c53a:	0f 46 d3             	cmovbe %ebx,%edx
  80c53d:	66 89 57 50          	mov    %dx,0x50(%edi)
            if (pcb->ssthresh < 2*pcb->mss) {
  80c541:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  80c545:	81 e2 ff 7f 00 00    	and    $0x7fff,%edx
  80c54b:	0f b7 c8             	movzwl %ax,%ecx
  80c54e:	01 c9                	add    %ecx,%ecx
  80c550:	39 ca                	cmp    %ecx,%edx
  80c552:	7d 07                	jge    80c55b <tcp_receive+0x145>
              pcb->ssthresh = 2*pcb->mss;
  80c554:	8d 14 00             	lea    (%eax,%eax,1),%edx
  80c557:	66 89 57 50          	mov    %dx,0x50(%edi)
            pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
  80c55b:	8d 04 40             	lea    (%eax,%eax,2),%eax
  80c55e:	66 03 47 50          	add    0x50(%edi),%ax
  80c562:	66 89 47 4e          	mov    %ax,0x4e(%edi)
            pcb->flags |= TF_INFR;
  80c566:	80 4f 20 04          	orb    $0x4,0x20(%edi)
  80c56a:	e9 d7 01 00 00       	jmp    80c746 <tcp_receive+0x330>
      if (pcb->flags & TF_INFR) {
  80c56f:	0f b6 57 20          	movzbl 0x20(%edi),%edx
  80c573:	f6 c2 04             	test   $0x4,%dl
  80c576:	74 0e                	je     80c586 <tcp_receive+0x170>
        pcb->flags &= ~TF_INFR;
  80c578:	83 e2 fb             	and    $0xfffffffb,%edx
  80c57b:	88 57 20             	mov    %dl,0x20(%edi)
        pcb->cwnd = pcb->ssthresh;
  80c57e:	0f b7 57 50          	movzwl 0x50(%edi),%edx
  80c582:	66 89 57 4e          	mov    %dx,0x4e(%edi)
      pcb->nrtx = 0;
  80c586:	c6 47 46 00          	movb   $0x0,0x46(%edi)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  80c58a:	0f b7 57 40          	movzwl 0x40(%edi),%edx
  80c58e:	66 c1 fa 03          	sar    $0x3,%dx
  80c592:	66 03 57 42          	add    0x42(%edi),%dx
  80c596:	66 89 57 44          	mov    %dx,0x44(%edi)
      pcb->acked = (u16_t)(ackno - pcb->lastack);
  80c59a:	89 c2                	mov    %eax,%edx
  80c59c:	29 da                	sub    %ebx,%edx
  80c59e:	66 89 57 6c          	mov    %dx,0x6c(%edi)
      pcb->snd_buf += pcb->acked;
  80c5a2:	66 01 57 6e          	add    %dx,0x6e(%edi)
      pcb->dupacks = 0;
  80c5a6:	c6 47 4c 00          	movb   $0x0,0x4c(%edi)
      pcb->lastack = ackno;
  80c5aa:	89 47 48             	mov    %eax,0x48(%edi)
      if (pcb->state >= ESTABLISHED) {
  80c5ad:	83 7f 10 03          	cmpl   $0x3,0x10(%edi)
  80c5b1:	76 1d                	jbe    80c5d0 <tcp_receive+0x1ba>
        if (pcb->cwnd < pcb->ssthresh) {
  80c5b3:	0f b7 4f 4e          	movzwl 0x4e(%edi),%ecx
  80c5b7:	66 3b 4f 50          	cmp    0x50(%edi),%cx
  80c5bb:	0f 83 d7 00 00 00    	jae    80c698 <tcp_receive+0x282>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  80c5c1:	89 c8                	mov    %ecx,%eax
  80c5c3:	66 03 47 34          	add    0x34(%edi),%ax
  80c5c7:	66 39 c1             	cmp    %ax,%cx
  80c5ca:	73 04                	jae    80c5d0 <tcp_receive+0x1ba>
            pcb->cwnd += pcb->mss;
  80c5cc:	66 89 47 4e          	mov    %ax,0x4e(%edi)
      while (pcb->unacked != NULL &&
  80c5d0:	8b 47 78             	mov    0x78(%edi),%eax
  80c5d3:	85 c0                	test   %eax,%eax
  80c5d5:	0f 84 2a 01 00 00    	je     80c705 <tcp_receive+0x2ef>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
  80c5db:	83 ec 0c             	sub    $0xc,%esp
  80c5de:	8b 40 10             	mov    0x10(%eax),%eax
  80c5e1:	ff 70 04             	pushl  0x4(%eax)
  80c5e4:	e8 d1 b3 ff ff       	call   8079ba <ntohl>
  80c5e9:	89 c3                	mov    %eax,%ebx
  80c5eb:	8b 47 78             	mov    0x78(%edi),%eax
  80c5ee:	0f b7 70 0c          	movzwl 0xc(%eax),%esi
  80c5f2:	8b 40 10             	mov    0x10(%eax),%eax
  80c5f5:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c5f9:	89 04 24             	mov    %eax,(%esp)
  80c5fc:	e8 8e b1 ff ff       	call   80778f <ntohs>
  80c601:	83 c4 10             	add    $0x10,%esp
  80c604:	ba 01 00 00 00       	mov    $0x1,%edx
  80c609:	a8 01                	test   $0x1,%al
  80c60b:	0f 84 bf 00 00 00    	je     80c6d0 <tcp_receive+0x2ba>
  80c611:	2b 1d a4 b1 b3 00    	sub    0xb3b1a4,%ebx
  80c617:	01 d6                	add    %edx,%esi
  80c619:	01 f3                	add    %esi,%ebx
      while (pcb->unacked != NULL &&
  80c61b:	85 db                	test   %ebx,%ebx
  80c61d:	0f 8f d0 00 00 00    	jg     80c6f3 <tcp_receive+0x2dd>
        next = pcb->unacked;
  80c623:	8b 5f 78             	mov    0x78(%edi),%ebx
        pcb->unacked = pcb->unacked->next;
  80c626:	8b 03                	mov    (%ebx),%eax
  80c628:	89 47 78             	mov    %eax,0x78(%edi)
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80c62b:	0f b7 77 70          	movzwl 0x70(%edi),%esi
  80c62f:	83 ec 0c             	sub    $0xc,%esp
  80c632:	ff 73 04             	pushl  0x4(%ebx)
  80c635:	e8 56 86 ff ff       	call   804c90 <pbuf_clen>
  80c63a:	0f b6 c0             	movzbl %al,%eax
  80c63d:	83 c4 10             	add    $0x10,%esp
  80c640:	66 39 c6             	cmp    %ax,%si
  80c643:	72 74                	jb     80c6b9 <tcp_receive+0x2a3>
        pcb->snd_queuelen -= pbuf_clen(next->p);
  80c645:	83 ec 0c             	sub    $0xc,%esp
  80c648:	ff 73 04             	pushl  0x4(%ebx)
  80c64b:	e8 40 86 ff ff       	call   804c90 <pbuf_clen>
  80c650:	0f b6 c0             	movzbl %al,%eax
  80c653:	66 29 47 70          	sub    %ax,0x70(%edi)
        tcp_seg_free(next);
  80c657:	89 1c 24             	mov    %ebx,(%esp)
  80c65a:	e8 5e 91 ff ff       	call   8057bd <tcp_seg_free>
        if (pcb->snd_queuelen != 0) {
  80c65f:	83 c4 10             	add    $0x10,%esp
  80c662:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  80c667:	0f 84 63 ff ff ff    	je     80c5d0 <tcp_receive+0x1ba>
          LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
  80c66d:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c671:	0f 85 59 ff ff ff    	jne    80c5d0 <tcp_receive+0x1ba>
  80c677:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  80c67b:	0f 85 4f ff ff ff    	jne    80c5d0 <tcp_receive+0x1ba>
  80c681:	83 ec 04             	sub    $0x4,%esp
  80c684:	68 6c 31 81 00       	push   $0x81316c
  80c689:	68 5c 03 00 00       	push   $0x35c
  80c68e:	68 b0 32 81 00       	push   $0x8132b0
  80c693:	e8 bb 1f 00 00       	call   80e653 <_panic>
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
  80c698:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  80c69c:	0f af c0             	imul   %eax,%eax
  80c69f:	0f b7 d9             	movzwl %cx,%ebx
  80c6a2:	99                   	cltd   
  80c6a3:	f7 fb                	idiv   %ebx
  80c6a5:	01 c8                	add    %ecx,%eax
          if (new_cwnd > pcb->cwnd) {
  80c6a7:	66 39 c1             	cmp    %ax,%cx
  80c6aa:	0f 83 20 ff ff ff    	jae    80c5d0 <tcp_receive+0x1ba>
            pcb->cwnd = new_cwnd;
  80c6b0:	66 89 47 4e          	mov    %ax,0x4e(%edi)
  80c6b4:	e9 17 ff ff ff       	jmp    80c5d0 <tcp_receive+0x1ba>
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80c6b9:	83 ec 04             	sub    $0x4,%esp
  80c6bc:	68 44 31 81 00       	push   $0x813144
  80c6c1:	68 55 03 00 00       	push   $0x355
  80c6c6:	68 b0 32 81 00       	push   $0x8132b0
  80c6cb:	e8 83 1f 00 00       	call   80e653 <_panic>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
  80c6d0:	83 ec 0c             	sub    $0xc,%esp
  80c6d3:	8b 47 78             	mov    0x78(%edi),%eax
  80c6d6:	8b 40 10             	mov    0x10(%eax),%eax
  80c6d9:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c6dd:	50                   	push   %eax
  80c6de:	e8 ac b0 ff ff       	call   80778f <ntohs>
  80c6e3:	66 d1 e8             	shr    %ax
  80c6e6:	89 c2                	mov    %eax,%edx
  80c6e8:	83 e2 01             	and    $0x1,%edx
  80c6eb:	83 c4 10             	add    $0x10,%esp
  80c6ee:	e9 1e ff ff ff       	jmp    80c611 <tcp_receive+0x1fb>
      if(pcb->unacked == NULL)
  80c6f3:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c6f7:	74 0c                	je     80c705 <tcp_receive+0x2ef>
        pcb->rtime = 0;
  80c6f9:	66 c7 47 32 00 00    	movw   $0x0,0x32(%edi)
      pcb->polltmr = 0;
  80c6ff:	c6 47 30 00          	movb   $0x0,0x30(%edi)
  80c703:	eb 41                	jmp    80c746 <tcp_receive+0x330>
        pcb->rtime = -1;
  80c705:	66 c7 47 32 ff ff    	movw   $0xffff,0x32(%edi)
  80c70b:	eb f2                	jmp    80c6ff <tcp_receive+0x2e9>
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80c70d:	83 ec 04             	sub    $0x4,%esp
  80c710:	68 44 31 81 00       	push   $0x813144
  80c715:	68 7f 03 00 00       	push   $0x37f
  80c71a:	68 b0 32 81 00       	push   $0x8132b0
  80c71f:	e8 2f 1f 00 00       	call   80e653 <_panic>
        LWIP_ASSERT("tcp_receive: valid queue length",
  80c724:	83 ec 04             	sub    $0x4,%esp
  80c727:	68 6c 31 81 00       	push   $0x81316c
  80c72c:	68 85 03 00 00       	push   $0x385
  80c731:	68 b0 32 81 00       	push   $0x8132b0
  80c736:	e8 18 1f 00 00       	call   80e653 <_panic>
      if (pcb->unsent != NULL) {
  80c73b:	8b 47 74             	mov    0x74(%edi),%eax
  80c73e:	85 c0                	test   %eax,%eax
  80c740:	0f 85 c8 00 00 00    	jne    80c80e <tcp_receive+0x3f8>
    while (pcb->unsent != NULL &&
  80c746:	8b 47 74             	mov    0x74(%edi),%eax
  80c749:	85 c0                	test   %eax,%eax
  80c74b:	0f 84 f9 00 00 00    	je     80c84a <tcp_receive+0x434>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80c751:	8b 35 a4 b1 b3 00    	mov    0xb3b1a4,%esi
  80c757:	83 ec 0c             	sub    $0xc,%esp
  80c75a:	8b 40 10             	mov    0x10(%eax),%eax
  80c75d:	ff 70 04             	pushl  0x4(%eax)
  80c760:	e8 55 b2 ff ff       	call   8079ba <ntohl>
  80c765:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80c768:	8b 47 74             	mov    0x74(%edi),%eax
  80c76b:	0f b7 58 0c          	movzwl 0xc(%eax),%ebx
  80c76f:	8b 40 10             	mov    0x10(%eax),%eax
  80c772:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c776:	89 04 24             	mov    %eax,(%esp)
  80c779:	e8 11 b0 ff ff       	call   80778f <ntohs>
  80c77e:	83 c4 10             	add    $0x10,%esp
  80c781:	ba 01 00 00 00       	mov    $0x1,%edx
  80c786:	a8 01                	test   $0x1,%al
  80c788:	0f 84 99 00 00 00    	je     80c827 <tcp_receive+0x411>
  80c78e:	2b 75 e4             	sub    -0x1c(%ebp),%esi
  80c791:	01 d3                	add    %edx,%ebx
    while (pcb->unsent != NULL &&
  80c793:	39 de                	cmp    %ebx,%esi
  80c795:	0f 88 af 00 00 00    	js     80c84a <tcp_receive+0x434>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80c79b:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80c7a0:	2b 47 58             	sub    0x58(%edi),%eax
  80c7a3:	85 c0                	test   %eax,%eax
  80c7a5:	0f 8f 9f 00 00 00    	jg     80c84a <tcp_receive+0x434>
      next = pcb->unsent;
  80c7ab:	8b 5f 74             	mov    0x74(%edi),%ebx
      pcb->unsent = pcb->unsent->next;
  80c7ae:	8b 03                	mov    (%ebx),%eax
  80c7b0:	89 47 74             	mov    %eax,0x74(%edi)
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80c7b3:	0f b7 77 70          	movzwl 0x70(%edi),%esi
  80c7b7:	83 ec 0c             	sub    $0xc,%esp
  80c7ba:	ff 73 04             	pushl  0x4(%ebx)
  80c7bd:	e8 ce 84 ff ff       	call   804c90 <pbuf_clen>
  80c7c2:	0f b6 c0             	movzbl %al,%eax
  80c7c5:	83 c4 10             	add    $0x10,%esp
  80c7c8:	66 39 c6             	cmp    %ax,%si
  80c7cb:	0f 82 3c ff ff ff    	jb     80c70d <tcp_receive+0x2f7>
      pcb->snd_queuelen -= pbuf_clen(next->p);
  80c7d1:	83 ec 0c             	sub    $0xc,%esp
  80c7d4:	ff 73 04             	pushl  0x4(%ebx)
  80c7d7:	e8 b4 84 ff ff       	call   804c90 <pbuf_clen>
  80c7dc:	0f b6 c0             	movzbl %al,%eax
  80c7df:	66 29 47 70          	sub    %ax,0x70(%edi)
      tcp_seg_free(next);
  80c7e3:	89 1c 24             	mov    %ebx,(%esp)
  80c7e6:	e8 d2 8f ff ff       	call   8057bd <tcp_seg_free>
      if (pcb->snd_queuelen != 0) {
  80c7eb:	83 c4 10             	add    $0x10,%esp
  80c7ee:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  80c7f3:	0f 84 42 ff ff ff    	je     80c73b <tcp_receive+0x325>
        LWIP_ASSERT("tcp_receive: valid queue length",
  80c7f9:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c7fd:	0f 85 38 ff ff ff    	jne    80c73b <tcp_receive+0x325>
  80c803:	8b 47 74             	mov    0x74(%edi),%eax
  80c806:	85 c0                	test   %eax,%eax
  80c808:	0f 84 16 ff ff ff    	je     80c724 <tcp_receive+0x30e>
        pcb->snd_nxt = htonl(pcb->unsent->tcphdr->seqno);
  80c80e:	83 ec 0c             	sub    $0xc,%esp
  80c811:	8b 40 10             	mov    0x10(%eax),%eax
  80c814:	ff 70 04             	pushl  0x4(%eax)
  80c817:	e8 80 af ff ff       	call   80779c <htonl>
  80c81c:	89 47 54             	mov    %eax,0x54(%edi)
  80c81f:	83 c4 10             	add    $0x10,%esp
  80c822:	e9 1f ff ff ff       	jmp    80c746 <tcp_receive+0x330>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80c827:	83 ec 0c             	sub    $0xc,%esp
  80c82a:	8b 47 74             	mov    0x74(%edi),%eax
  80c82d:	8b 40 10             	mov    0x10(%eax),%eax
  80c830:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c834:	50                   	push   %eax
  80c835:	e8 55 af ff ff       	call   80778f <ntohs>
  80c83a:	66 d1 e8             	shr    %ax
  80c83d:	89 c2                	mov    %eax,%edx
  80c83f:	83 e2 01             	and    $0x1,%edx
  80c842:	83 c4 10             	add    $0x10,%esp
  80c845:	e9 44 ff ff ff       	jmp    80c78e <tcp_receive+0x378>
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
  80c84a:	8b 47 38             	mov    0x38(%edi),%eax
  80c84d:	85 c0                	test   %eax,%eax
  80c84f:	74 0b                	je     80c85c <tcp_receive+0x446>
  80c851:	8b 0d a4 b1 b3 00    	mov    0xb3b1a4,%ecx
  80c857:	39 4f 3c             	cmp    %ecx,0x3c(%edi)
  80c85a:	78 71                	js     80c8cd <tcp_receive+0x4b7>
  if (tcplen > 0) {
  80c85c:	0f b7 05 9e b1 b3 00 	movzwl 0xb3b19e,%eax
  80c863:	66 85 c0             	test   %ax,%ax
  80c866:	0f 84 72 08 00 00    	je     80d0de <tcp_receive+0xcc8>
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
  80c86c:	8b 5f 24             	mov    0x24(%edi),%ebx
  80c86f:	8b 0d a8 b1 b3 00    	mov    0xb3b1a8,%ecx
  80c875:	89 da                	mov    %ebx,%edx
  80c877:	29 ca                	sub    %ecx,%edx
  80c879:	89 d6                	mov    %edx,%esi
  80c87b:	83 ee 01             	sub    $0x1,%esi
  80c87e:	78 16                	js     80c896 <tcp_receive+0x480>
  80c880:	be 01 00 00 00       	mov    $0x1,%esi
  80c885:	29 ce                	sub    %ecx,%esi
  80c887:	0f b7 c0             	movzwl %ax,%eax
  80c88a:	29 c6                	sub    %eax,%esi
  80c88c:	01 de                	add    %ebx,%esi
  80c88e:	85 f6                	test   %esi,%esi
  80c890:	0f 8e 85 00 00 00    	jle    80c91b <tcp_receive+0x505>
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
  80c896:	39 d9                	cmp    %ebx,%ecx
  80c898:	0f 88 be 01 00 00    	js     80ca5c <tcp_receive+0x646>
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  80c89e:	0f b7 47 28          	movzwl 0x28(%edi),%eax
  80c8a2:	89 ca                	mov    %ecx,%edx
  80c8a4:	29 c2                	sub    %eax,%edx
  80c8a6:	8d 42 01             	lea    0x1(%edx),%eax
  80c8a9:	29 d8                	sub    %ebx,%eax
  80c8ab:	85 c0                	test   %eax,%eax
  80c8ad:	0f 8e be 01 00 00    	jle    80ca71 <tcp_receive+0x65b>
      tcp_ack_now(pcb);
  80c8b3:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80c8b7:	83 ec 0c             	sub    $0xc,%esp
  80c8ba:	57                   	push   %edi
  80c8bb:	e8 42 b8 ff ff       	call   808102 <tcp_output>
  80c8c0:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80c8c3:	b8 00 00 00 00       	mov    $0x0,%eax
  80c8c8:	e9 46 08 00 00       	jmp    80d113 <tcp_receive+0xcfd>
      m = m - (pcb->sa >> 3);
  80c8cd:	0f b7 4f 40          	movzwl 0x40(%edi),%ecx
      m = (s16_t)(tcp_ticks - pcb->rttest);
  80c8d1:	0f b7 15 40 b2 b3 00 	movzwl 0xb3b240,%edx
  80c8d8:	29 c2                	sub    %eax,%edx
      m = m - (pcb->sa >> 3);
  80c8da:	89 c8                	mov    %ecx,%eax
  80c8dc:	66 c1 f8 03          	sar    $0x3,%ax
  80c8e0:	29 c2                	sub    %eax,%edx
      pcb->sa += m;
  80c8e2:	8d 04 11             	lea    (%ecx,%edx,1),%eax
  80c8e5:	66 89 47 40          	mov    %ax,0x40(%edi)
        m = -m;
  80c8e9:	89 d1                	mov    %edx,%ecx
  80c8eb:	f7 d9                	neg    %ecx
  80c8ed:	66 85 d2             	test   %dx,%dx
  80c8f0:	0f 49 ca             	cmovns %edx,%ecx
      m = m - (pcb->sv >> 2);
  80c8f3:	0f b7 57 42          	movzwl 0x42(%edi),%edx
  80c8f7:	89 d3                	mov    %edx,%ebx
  80c8f9:	66 c1 fb 02          	sar    $0x2,%bx
      pcb->sv += m;
  80c8fd:	29 da                	sub    %ebx,%edx
  80c8ff:	01 ca                	add    %ecx,%edx
  80c901:	66 89 57 42          	mov    %dx,0x42(%edi)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  80c905:	66 c1 f8 03          	sar    $0x3,%ax
  80c909:	01 c2                	add    %eax,%edx
  80c90b:	66 89 57 44          	mov    %dx,0x44(%edi)
      pcb->rttest = 0;
  80c90f:	c7 47 38 00 00 00 00 	movl   $0x0,0x38(%edi)
  80c916:	e9 41 ff ff ff       	jmp    80c85c <tcp_receive+0x446>
      off = pcb->rcv_nxt - seqno;
  80c91b:	89 d0                	mov    %edx,%eax
      p = inseg.p;
  80c91d:	8b 1d b8 b1 b3 00    	mov    0xb3b1b8,%ebx
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
  80c923:	85 db                	test   %ebx,%ebx
  80c925:	0f 84 a4 00 00 00    	je     80c9cf <tcp_receive+0x5b9>
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
  80c92b:	81 fa fe 7f 00 00    	cmp    $0x7ffe,%edx
  80c931:	0f 8f af 00 00 00    	jg     80c9e6 <tcp_receive+0x5d0>
      if (inseg.p->len < off) {
  80c937:	0f b7 4b 0a          	movzwl 0xa(%ebx),%ecx
  80c93b:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  80c93e:	39 d1                	cmp    %edx,%ecx
  80c940:	0f 8d e5 00 00 00    	jge    80ca2b <tcp_receive+0x615>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
  80c946:	0f b7 73 08          	movzwl 0x8(%ebx),%esi
  80c94a:	0f b7 ce             	movzwl %si,%ecx
  80c94d:	39 d1                	cmp    %edx,%ecx
  80c94f:	0f 8c a8 00 00 00    	jl     80c9fd <tcp_receive+0x5e7>
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
  80c955:	29 d6                	sub    %edx,%esi
  80c957:	89 f2                	mov    %esi,%edx
  80c959:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
          off -= p->len;
  80c95c:	29 c8                	sub    %ecx,%eax
          p->tot_len = new_tot_len;
  80c95e:	66 89 53 08          	mov    %dx,0x8(%ebx)
          p->len = 0;
  80c962:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
          p = p->next;
  80c968:	8b 1b                	mov    (%ebx),%ebx
        while (p->len < off) {
  80c96a:	0f b7 4b 0a          	movzwl 0xa(%ebx),%ecx
  80c96e:	39 c1                	cmp    %eax,%ecx
  80c970:	7c ea                	jl     80c95c <tcp_receive+0x546>
        if(pbuf_header(p, (s16_t)-off)) {
  80c972:	83 ec 08             	sub    $0x8,%esp
  80c975:	f7 d8                	neg    %eax
  80c977:	98                   	cwtl   
  80c978:	50                   	push   %eax
  80c979:	53                   	push   %ebx
  80c97a:	e8 fa 7d ff ff       	call   804779 <pbuf_header>
  80c97f:	83 c4 10             	add    $0x10,%esp
  80c982:	84 c0                	test   %al,%al
  80c984:	0f 85 8a 00 00 00    	jne    80ca14 <tcp_receive+0x5fe>
      inseg.dataptr = p->payload;
  80c98a:	8b 43 04             	mov    0x4(%ebx),%eax
  80c98d:	a3 bc b1 b3 00       	mov    %eax,0xb3b1bc
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
  80c992:	8b 57 24             	mov    0x24(%edi),%edx
  80c995:	0f b7 05 c0 b1 b3 00 	movzwl 0xb3b1c0,%eax
  80c99c:	66 03 05 a8 b1 b3 00 	add    0xb3b1a8,%ax
  80c9a3:	29 d0                	sub    %edx,%eax
  80c9a5:	66 a3 c0 b1 b3 00    	mov    %ax,0xb3b1c0
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
  80c9ab:	89 15 a8 b1 b3 00    	mov    %edx,0xb3b1a8
  80c9b1:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
  80c9b6:	89 50 04             	mov    %edx,0x4(%eax)
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  80c9b9:	8b 0d a8 b1 b3 00    	mov    0xb3b1a8,%ecx
  80c9bf:	8b 5f 24             	mov    0x24(%edi),%ebx
  80c9c2:	39 d9                	cmp    %ebx,%ecx
  80c9c4:	0f 89 d4 fe ff ff    	jns    80c89e <tcp_receive+0x488>
  80c9ca:	e9 e4 fe ff ff       	jmp    80c8b3 <tcp_receive+0x49d>
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
  80c9cf:	83 ec 04             	sub    $0x4,%esp
  80c9d2:	68 c7 32 81 00       	push   $0x8132c7
  80c9d7:	68 e5 03 00 00       	push   $0x3e5
  80c9dc:	68 b0 32 81 00       	push   $0x8132b0
  80c9e1:	e8 6d 1c 00 00       	call   80e653 <_panic>
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
  80c9e6:	83 ec 04             	sub    $0x4,%esp
  80c9e9:	68 d7 32 81 00       	push   $0x8132d7
  80c9ee:	68 e6 03 00 00       	push   $0x3e6
  80c9f3:	68 b0 32 81 00       	push   $0x8132b0
  80c9f8:	e8 56 1c 00 00       	call   80e653 <_panic>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
  80c9fd:	83 ec 04             	sub    $0x4,%esp
  80ca00:	68 e6 32 81 00       	push   $0x8132e6
  80ca05:	68 e8 03 00 00       	push   $0x3e8
  80ca0a:	68 b0 32 81 00       	push   $0x8132b0
  80ca0f:	e8 3f 1c 00 00       	call   80e653 <_panic>
          LWIP_ASSERT("pbuf_header failed", 0);
  80ca14:	83 ec 04             	sub    $0x4,%esp
  80ca17:	68 f6 32 81 00       	push   $0x8132f6
  80ca1c:	68 f5 03 00 00       	push   $0x3f5
  80ca21:	68 b0 32 81 00       	push   $0x8132b0
  80ca26:	e8 28 1c 00 00       	call   80e653 <_panic>
        if(pbuf_header(inseg.p, (s16_t)-off)) {
  80ca2b:	83 ec 08             	sub    $0x8,%esp
  80ca2e:	f7 da                	neg    %edx
  80ca30:	0f bf c2             	movswl %dx,%eax
  80ca33:	50                   	push   %eax
  80ca34:	53                   	push   %ebx
  80ca35:	e8 3f 7d ff ff       	call   804779 <pbuf_header>
  80ca3a:	83 c4 10             	add    $0x10,%esp
  80ca3d:	84 c0                	test   %al,%al
  80ca3f:	0f 84 45 ff ff ff    	je     80c98a <tcp_receive+0x574>
          LWIP_ASSERT("pbuf_header failed", 0);
  80ca45:	83 ec 04             	sub    $0x4,%esp
  80ca48:	68 f6 32 81 00       	push   $0x8132f6
  80ca4d:	68 fa 03 00 00       	push   $0x3fa
  80ca52:	68 b0 32 81 00       	push   $0x8132b0
  80ca57:	e8 f7 1b 00 00       	call   80e653 <_panic>
        tcp_ack_now(pcb);
  80ca5c:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80ca60:	83 ec 0c             	sub    $0xc,%esp
  80ca63:	57                   	push   %edi
  80ca64:	e8 99 b6 ff ff       	call   808102 <tcp_output>
  80ca69:	83 c4 10             	add    $0x10,%esp
  80ca6c:	e9 48 ff ff ff       	jmp    80c9b9 <tcp_receive+0x5a3>
      if (pcb->rcv_nxt == seqno) {
  80ca71:	39 d9                	cmp    %ebx,%ecx
  80ca73:	0f 85 d2 03 00 00    	jne    80ce4b <tcp_receive+0xa35>
        if (pcb->ooseq != NULL &&
  80ca79:	8b 47 7c             	mov    0x7c(%edi),%eax
  80ca7c:	85 c0                	test   %eax,%eax
  80ca7e:	74 1d                	je     80ca9d <tcp_receive+0x687>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
  80ca80:	8b 50 10             	mov    0x10(%eax),%edx
  80ca83:	8b 5a 04             	mov    0x4(%edx),%ebx
  80ca86:	0f b7 15 c0 b1 b3 00 	movzwl 0xb3b1c0,%edx
  80ca8d:	89 de                	mov    %ebx,%esi
  80ca8f:	29 d6                	sub    %edx,%esi
  80ca91:	89 f2                	mov    %esi,%edx
  80ca93:	29 ca                	sub    %ecx,%edx
        if (pcb->ooseq != NULL &&
  80ca95:	85 d2                	test   %edx,%edx
  80ca97:	0f 8e b0 00 00 00    	jle    80cb4d <tcp_receive+0x737>
        tcplen = TCP_TCPLEN(&inseg);
  80ca9d:	0f b7 1d c0 b1 b3 00 	movzwl 0xb3b1c0,%ebx
  80caa4:	83 ec 0c             	sub    $0xc,%esp
  80caa7:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
  80caac:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cab0:	50                   	push   %eax
  80cab1:	e8 d9 ac ff ff       	call   80778f <ntohs>
  80cab6:	83 c4 10             	add    $0x10,%esp
  80cab9:	ba 01 00 00 00       	mov    $0x1,%edx
  80cabe:	a8 01                	test   $0x1,%al
  80cac0:	0f 84 00 01 00 00    	je     80cbc6 <tcp_receive+0x7b0>
  80cac6:	8d 04 13             	lea    (%ebx,%edx,1),%eax
  80cac9:	66 a3 9e b1 b3 00    	mov    %ax,0xb3b19e
        if (pcb->state != CLOSE_WAIT) {
  80cacf:	83 7f 10 07          	cmpl   $0x7,0x10(%edi)
  80cad3:	74 06                	je     80cadb <tcp_receive+0x6c5>
          pcb->rcv_nxt += tcplen;
  80cad5:	0f b7 d0             	movzwl %ax,%edx
  80cad8:	01 57 24             	add    %edx,0x24(%edi)
        if (pcb->rcv_wnd < tcplen) {
  80cadb:	0f b7 57 28          	movzwl 0x28(%edi),%edx
          pcb->rcv_wnd = 0;
  80cadf:	89 d1                	mov    %edx,%ecx
  80cae1:	29 c1                	sub    %eax,%ecx
  80cae3:	66 39 d0             	cmp    %dx,%ax
  80cae6:	ba 00 00 00 00       	mov    $0x0,%edx
  80caeb:	0f 46 d1             	cmovbe %ecx,%edx
  80caee:	66 89 57 28          	mov    %dx,0x28(%edi)
        if (pcb->rcv_ann_wnd < tcplen) {
  80caf2:	0f b7 57 2a          	movzwl 0x2a(%edi),%edx
          pcb->rcv_ann_wnd = 0;
  80caf6:	89 d1                	mov    %edx,%ecx
  80caf8:	29 c1                	sub    %eax,%ecx
  80cafa:	66 39 d0             	cmp    %dx,%ax
  80cafd:	b8 00 00 00 00       	mov    $0x0,%eax
  80cb02:	0f 46 c1             	cmovbe %ecx,%eax
  80cb05:	66 89 47 2a          	mov    %ax,0x2a(%edi)
        if (inseg.p->tot_len > 0) {
  80cb09:	a1 b8 b1 b3 00       	mov    0xb3b1b8,%eax
  80cb0e:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  80cb13:	74 0f                	je     80cb24 <tcp_receive+0x70e>
          recv_data = inseg.p;
  80cb15:	a3 98 b1 b3 00       	mov    %eax,0xb3b198
          inseg.p = NULL;
  80cb1a:	c7 05 b8 b1 b3 00 00 	movl   $0x0,0xb3b1b8
  80cb21:	00 00 00 
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
  80cb24:	83 ec 0c             	sub    $0xc,%esp
  80cb27:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
  80cb2c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cb30:	50                   	push   %eax
  80cb31:	e8 59 ac ff ff       	call   80778f <ntohs>
  80cb36:	83 c4 10             	add    $0x10,%esp
  80cb39:	a8 01                	test   $0x1,%al
  80cb3b:	0f 84 dc 01 00 00    	je     80cd1d <tcp_receive+0x907>
          recv_flags = TF_GOT_FIN;
  80cb41:	c6 05 9c b1 b3 00 20 	movb   $0x20,0xb3b19c
  80cb48:	e9 d0 01 00 00       	jmp    80cd1d <tcp_receive+0x907>
          if (pcb->ooseq->len > 0) {
  80cb4d:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  80cb52:	74 23                	je     80cb77 <tcp_receive+0x761>
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
  80cb54:	29 cb                	sub    %ecx,%ebx
  80cb56:	66 89 1d c0 b1 b3 00 	mov    %bx,0xb3b1c0
            pbuf_realloc(inseg.p, inseg.len);
  80cb5d:	83 ec 08             	sub    $0x8,%esp
  80cb60:	0f b7 db             	movzwl %bx,%ebx
  80cb63:	53                   	push   %ebx
  80cb64:	ff 35 b8 b1 b3 00    	pushl  0xb3b1b8
  80cb6a:	e8 0f 80 ff ff       	call   804b7e <pbuf_realloc>
  80cb6f:	83 c4 10             	add    $0x10,%esp
  80cb72:	e9 26 ff ff ff       	jmp    80ca9d <tcp_receive+0x687>
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  80cb77:	83 ec 0c             	sub    $0xc,%esp
  80cb7a:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
  80cb7f:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cb83:	50                   	push   %eax
  80cb84:	e8 06 ac ff ff       	call   80778f <ntohs>
  80cb89:	89 c3                	mov    %eax,%ebx
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
  80cb8b:	8b 47 7c             	mov    0x7c(%edi),%eax
  80cb8e:	8b 40 10             	mov    0x10(%eax),%eax
  80cb91:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cb95:	89 04 24             	mov    %eax,(%esp)
  80cb98:	e8 f2 ab ff ff       	call   80778f <ntohs>
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  80cb9d:	31 c3                	xor    %eax,%ebx
  80cb9f:	83 c4 10             	add    $0x10,%esp
  80cba2:	f6 c3 03             	test   $0x3,%bl
  80cba5:	0f 85 f2 fe ff ff    	jne    80ca9d <tcp_receive+0x687>
              struct tcp_seg *old_ooseq = pcb->ooseq;
  80cbab:	8b 47 7c             	mov    0x7c(%edi),%eax
              pcb->ooseq = pcb->ooseq->next;
  80cbae:	8b 10                	mov    (%eax),%edx
  80cbb0:	89 57 7c             	mov    %edx,0x7c(%edi)
              memp_free(MEMP_TCP_SEG, old_ooseq);
  80cbb3:	83 ec 08             	sub    $0x8,%esp
  80cbb6:	50                   	push   %eax
  80cbb7:	6a 04                	push   $0x4
  80cbb9:	e8 20 79 ff ff       	call   8044de <memp_free>
  80cbbe:	83 c4 10             	add    $0x10,%esp
  80cbc1:	e9 d7 fe ff ff       	jmp    80ca9d <tcp_receive+0x687>
        tcplen = TCP_TCPLEN(&inseg);
  80cbc6:	83 ec 0c             	sub    $0xc,%esp
  80cbc9:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
  80cbce:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cbd2:	50                   	push   %eax
  80cbd3:	e8 b7 ab ff ff       	call   80778f <ntohs>
  80cbd8:	66 d1 e8             	shr    %ax
  80cbdb:	89 c2                	mov    %eax,%edx
  80cbdd:	83 e2 01             	and    $0x1,%edx
  80cbe0:	83 c4 10             	add    $0x10,%esp
  80cbe3:	e9 de fe ff ff       	jmp    80cac6 <tcp_receive+0x6b0>
          pcb->rcv_nxt += TCP_TCPLEN(cseg);
  80cbe8:	83 ec 0c             	sub    $0xc,%esp
  80cbeb:	8b 43 10             	mov    0x10(%ebx),%eax
  80cbee:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cbf2:	50                   	push   %eax
  80cbf3:	e8 97 ab ff ff       	call   80778f <ntohs>
  80cbf8:	66 d1 e8             	shr    %ax
  80cbfb:	89 c2                	mov    %eax,%edx
  80cbfd:	83 e2 01             	and    $0x1,%edx
  80cc00:	83 c4 10             	add    $0x10,%esp
  80cc03:	e9 55 01 00 00       	jmp    80cd5d <tcp_receive+0x947>
          if (pcb->rcv_wnd < TCP_TCPLEN(cseg)) {
  80cc08:	83 ec 0c             	sub    $0xc,%esp
  80cc0b:	8b 43 10             	mov    0x10(%ebx),%eax
  80cc0e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cc12:	50                   	push   %eax
  80cc13:	e8 77 ab ff ff       	call   80778f <ntohs>
  80cc18:	66 d1 e8             	shr    %ax
  80cc1b:	89 c2                	mov    %eax,%edx
  80cc1d:	83 e2 01             	and    $0x1,%edx
  80cc20:	83 c4 10             	add    $0x10,%esp
  80cc23:	e9 65 01 00 00       	jmp    80cd8d <tcp_receive+0x977>
            pcb->rcv_wnd -= TCP_TCPLEN(cseg);
  80cc28:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80cc2c:	83 ec 0c             	sub    $0xc,%esp
  80cc2f:	8b 43 10             	mov    0x10(%ebx),%eax
  80cc32:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cc36:	50                   	push   %eax
  80cc37:	e8 53 ab ff ff       	call   80778f <ntohs>
  80cc3c:	83 c4 10             	add    $0x10,%esp
  80cc3f:	ba 01 00 00 00       	mov    $0x1,%edx
  80cc44:	a8 01                	test   $0x1,%al
  80cc46:	74 0b                	je     80cc53 <tcp_receive+0x83d>
  80cc48:	01 d6                	add    %edx,%esi
  80cc4a:	66 29 77 28          	sub    %si,0x28(%edi)
  80cc4e:	e9 4b 01 00 00       	jmp    80cd9e <tcp_receive+0x988>
  80cc53:	83 ec 0c             	sub    $0xc,%esp
  80cc56:	8b 43 10             	mov    0x10(%ebx),%eax
  80cc59:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cc5d:	50                   	push   %eax
  80cc5e:	e8 2c ab ff ff       	call   80778f <ntohs>
  80cc63:	66 d1 e8             	shr    %ax
  80cc66:	89 c2                	mov    %eax,%edx
  80cc68:	83 e2 01             	and    $0x1,%edx
  80cc6b:	83 c4 10             	add    $0x10,%esp
  80cc6e:	eb d8                	jmp    80cc48 <tcp_receive+0x832>
          if (pcb->rcv_ann_wnd < TCP_TCPLEN(cseg)) {
  80cc70:	83 ec 0c             	sub    $0xc,%esp
  80cc73:	8b 43 10             	mov    0x10(%ebx),%eax
  80cc76:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cc7a:	50                   	push   %eax
  80cc7b:	e8 0f ab ff ff       	call   80778f <ntohs>
  80cc80:	66 d1 e8             	shr    %ax
  80cc83:	89 c2                	mov    %eax,%edx
  80cc85:	83 e2 01             	and    $0x1,%edx
  80cc88:	83 c4 10             	add    $0x10,%esp
  80cc8b:	e9 39 01 00 00       	jmp    80cdc9 <tcp_receive+0x9b3>
            pcb->rcv_ann_wnd -= TCP_TCPLEN(cseg);
  80cc90:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80cc94:	83 ec 0c             	sub    $0xc,%esp
  80cc97:	8b 43 10             	mov    0x10(%ebx),%eax
  80cc9a:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cc9e:	50                   	push   %eax
  80cc9f:	e8 eb aa ff ff       	call   80778f <ntohs>
  80cca4:	83 c4 10             	add    $0x10,%esp
  80cca7:	ba 01 00 00 00       	mov    $0x1,%edx
  80ccac:	a8 01                	test   $0x1,%al
  80ccae:	74 0b                	je     80ccbb <tcp_receive+0x8a5>
  80ccb0:	01 d6                	add    %edx,%esi
  80ccb2:	66 29 77 2a          	sub    %si,0x2a(%edi)
  80ccb6:	e9 1f 01 00 00       	jmp    80cdda <tcp_receive+0x9c4>
  80ccbb:	83 ec 0c             	sub    $0xc,%esp
  80ccbe:	8b 43 10             	mov    0x10(%ebx),%eax
  80ccc1:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ccc5:	50                   	push   %eax
  80ccc6:	e8 c4 aa ff ff       	call   80778f <ntohs>
  80cccb:	66 d1 e8             	shr    %ax
  80ccce:	89 c2                	mov    %eax,%edx
  80ccd0:	83 e2 01             	and    $0x1,%edx
  80ccd3:	83 c4 10             	add    $0x10,%esp
  80ccd6:	eb d8                	jmp    80ccb0 <tcp_receive+0x89a>
              recv_data = cseg->p;
  80ccd8:	a3 98 b1 b3 00       	mov    %eax,0xb3b198
            cseg->p = NULL;
  80ccdd:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
  80cce4:	83 ec 0c             	sub    $0xc,%esp
  80cce7:	8b 43 10             	mov    0x10(%ebx),%eax
  80ccea:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ccee:	50                   	push   %eax
  80ccef:	e8 9b aa ff ff       	call   80778f <ntohs>
  80ccf4:	83 c4 10             	add    $0x10,%esp
  80ccf7:	a8 01                	test   $0x1,%al
  80ccf9:	74 11                	je     80cd0c <tcp_receive+0x8f6>
            recv_flags = TF_GOT_FIN;
  80ccfb:	c6 05 9c b1 b3 00 20 	movb   $0x20,0xb3b19c
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
  80cd02:	83 7f 10 04          	cmpl   $0x4,0x10(%edi)
  80cd06:	0f 84 fc 00 00 00    	je     80ce08 <tcp_receive+0x9f2>
          pcb->ooseq = cseg->next;
  80cd0c:	8b 03                	mov    (%ebx),%eax
  80cd0e:	89 47 7c             	mov    %eax,0x7c(%edi)
          tcp_seg_free(cseg);
  80cd11:	83 ec 0c             	sub    $0xc,%esp
  80cd14:	53                   	push   %ebx
  80cd15:	e8 a3 8a ff ff       	call   8057bd <tcp_seg_free>
  80cd1a:	83 c4 10             	add    $0x10,%esp
        while (pcb->ooseq != NULL &&
  80cd1d:	8b 5f 7c             	mov    0x7c(%edi),%ebx
  80cd20:	85 db                	test   %ebx,%ebx
  80cd22:	0f 84 ec 00 00 00    	je     80ce14 <tcp_receive+0x9fe>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
  80cd28:	8b 53 10             	mov    0x10(%ebx),%edx
  80cd2b:	8b 42 04             	mov    0x4(%edx),%eax
        while (pcb->ooseq != NULL &&
  80cd2e:	3b 47 24             	cmp    0x24(%edi),%eax
  80cd31:	0f 85 dd 00 00 00    	jne    80ce14 <tcp_receive+0x9fe>
          seqno = pcb->ooseq->tcphdr->seqno;
  80cd37:	a3 a8 b1 b3 00       	mov    %eax,0xb3b1a8
          pcb->rcv_nxt += TCP_TCPLEN(cseg);
  80cd3c:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80cd40:	83 ec 0c             	sub    $0xc,%esp
  80cd43:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  80cd47:	50                   	push   %eax
  80cd48:	e8 42 aa ff ff       	call   80778f <ntohs>
  80cd4d:	83 c4 10             	add    $0x10,%esp
  80cd50:	ba 01 00 00 00       	mov    $0x1,%edx
  80cd55:	a8 01                	test   $0x1,%al
  80cd57:	0f 84 8b fe ff ff    	je     80cbe8 <tcp_receive+0x7d2>
  80cd5d:	01 d6                	add    %edx,%esi
  80cd5f:	01 77 24             	add    %esi,0x24(%edi)
          if (pcb->rcv_wnd < TCP_TCPLEN(cseg)) {
  80cd62:	0f b7 47 28          	movzwl 0x28(%edi),%eax
  80cd66:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80cd69:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80cd6d:	83 ec 0c             	sub    $0xc,%esp
  80cd70:	8b 43 10             	mov    0x10(%ebx),%eax
  80cd73:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cd77:	50                   	push   %eax
  80cd78:	e8 12 aa ff ff       	call   80778f <ntohs>
  80cd7d:	83 c4 10             	add    $0x10,%esp
  80cd80:	ba 01 00 00 00       	mov    $0x1,%edx
  80cd85:	a8 01                	test   $0x1,%al
  80cd87:	0f 84 7b fe ff ff    	je     80cc08 <tcp_receive+0x7f2>
  80cd8d:	01 d6                	add    %edx,%esi
  80cd8f:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
  80cd92:	0f 8d 90 fe ff ff    	jge    80cc28 <tcp_receive+0x812>
            pcb->rcv_wnd = 0;
  80cd98:	66 c7 47 28 00 00    	movw   $0x0,0x28(%edi)
          if (pcb->rcv_ann_wnd < TCP_TCPLEN(cseg)) {
  80cd9e:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  80cda2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80cda5:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80cda9:	83 ec 0c             	sub    $0xc,%esp
  80cdac:	8b 43 10             	mov    0x10(%ebx),%eax
  80cdaf:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cdb3:	50                   	push   %eax
  80cdb4:	e8 d6 a9 ff ff       	call   80778f <ntohs>
  80cdb9:	83 c4 10             	add    $0x10,%esp
  80cdbc:	ba 01 00 00 00       	mov    $0x1,%edx
  80cdc1:	a8 01                	test   $0x1,%al
  80cdc3:	0f 84 a7 fe ff ff    	je     80cc70 <tcp_receive+0x85a>
  80cdc9:	01 d6                	add    %edx,%esi
  80cdcb:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
  80cdce:	0f 8d bc fe ff ff    	jge    80cc90 <tcp_receive+0x87a>
            pcb->rcv_ann_wnd = 0;
  80cdd4:	66 c7 47 2a 00 00    	movw   $0x0,0x2a(%edi)
          if (cseg->p->tot_len > 0) {
  80cdda:	8b 43 04             	mov    0x4(%ebx),%eax
  80cddd:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  80cde2:	0f 84 fc fe ff ff    	je     80cce4 <tcp_receive+0x8ce>
            if (recv_data) {
  80cde8:	8b 15 98 b1 b3 00    	mov    0xb3b198,%edx
  80cdee:	85 d2                	test   %edx,%edx
  80cdf0:	0f 84 e2 fe ff ff    	je     80ccd8 <tcp_receive+0x8c2>
              pbuf_cat(recv_data, cseg->p);
  80cdf6:	83 ec 08             	sub    $0x8,%esp
  80cdf9:	50                   	push   %eax
  80cdfa:	52                   	push   %edx
  80cdfb:	e8 b9 7e ff ff       	call   804cb9 <pbuf_cat>
  80ce00:	83 c4 10             	add    $0x10,%esp
  80ce03:	e9 d5 fe ff ff       	jmp    80ccdd <tcp_receive+0x8c7>
              pcb->state = CLOSE_WAIT;
  80ce08:	c7 47 10 07 00 00 00 	movl   $0x7,0x10(%edi)
  80ce0f:	e9 f8 fe ff ff       	jmp    80cd0c <tcp_receive+0x8f6>
        tcp_ack(pcb);
  80ce14:	0f b6 47 20          	movzbl 0x20(%edi),%eax
  80ce18:	a8 01                	test   $0x1,%al
  80ce1a:	75 10                	jne    80ce2c <tcp_receive+0xa16>
  80ce1c:	83 c8 01             	or     $0x1,%eax
  80ce1f:	88 47 20             	mov    %al,0x20(%edi)
        accepted_inseq = 1; 
  80ce22:	b8 01 00 00 00       	mov    $0x1,%eax
  80ce27:	e9 e7 02 00 00       	jmp    80d113 <tcp_receive+0xcfd>
        tcp_ack(pcb);
  80ce2c:	83 e0 fe             	and    $0xfffffffe,%eax
  80ce2f:	83 c8 02             	or     $0x2,%eax
  80ce32:	88 47 20             	mov    %al,0x20(%edi)
  80ce35:	83 ec 0c             	sub    $0xc,%esp
  80ce38:	57                   	push   %edi
  80ce39:	e8 c4 b2 ff ff       	call   808102 <tcp_output>
  80ce3e:	83 c4 10             	add    $0x10,%esp
        accepted_inseq = 1; 
  80ce41:	b8 01 00 00 00       	mov    $0x1,%eax
  80ce46:	e9 c8 02 00 00       	jmp    80d113 <tcp_receive+0xcfd>
        tcp_ack_now(pcb);
  80ce4b:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80ce4f:	83 ec 0c             	sub    $0xc,%esp
  80ce52:	57                   	push   %edi
  80ce53:	e8 aa b2 ff ff       	call   808102 <tcp_output>
        if (pcb->ooseq == NULL) {
  80ce58:	8b 5f 7c             	mov    0x7c(%edi),%ebx
  80ce5b:	83 c4 10             	add    $0x10,%esp
  80ce5e:	85 db                	test   %ebx,%ebx
  80ce60:	74 1e                	je     80ce80 <tcp_receive+0xa6a>
            if (seqno == next->tcphdr->seqno) {
  80ce62:	8b 0d a8 b1 b3 00    	mov    0xb3b1a8,%ecx
  80ce68:	8d 41 ff             	lea    -0x1(%ecx),%eax
  80ce6b:	8d 51 01             	lea    0x1(%ecx),%edx
  80ce6e:	89 55 e4             	mov    %edx,-0x1c(%ebp)
          prev = NULL;
  80ce71:	be 00 00 00 00       	mov    $0x0,%esi
  80ce76:	89 7d e0             	mov    %edi,-0x20(%ebp)
  80ce79:	89 c7                	mov    %eax,%edi
  80ce7b:	e9 e3 00 00 00       	jmp    80cf63 <tcp_receive+0xb4d>
          pcb->ooseq = tcp_seg_copy(&inseg);
  80ce80:	83 ec 0c             	sub    $0xc,%esp
  80ce83:	68 b4 b1 b3 00       	push   $0xb3b1b4
  80ce88:	e8 a9 89 ff ff       	call   805836 <tcp_seg_copy>
  80ce8d:	89 47 7c             	mov    %eax,0x7c(%edi)
  80ce90:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80ce93:	b8 00 00 00 00       	mov    $0x0,%eax
  80ce98:	e9 76 02 00 00       	jmp    80d113 <tcp_receive+0xcfd>
  80ce9d:	8b 7d e0             	mov    -0x20(%ebp),%edi
  80cea0:	b8 00 00 00 00       	mov    $0x0,%eax
              if (inseg.len > next->len) {
  80cea5:	0f b7 4b 0c          	movzwl 0xc(%ebx),%ecx
  80cea9:	66 39 0d c0 b1 b3 00 	cmp    %cx,0xb3b1c0
  80ceb0:	0f 86 5d 02 00 00    	jbe    80d113 <tcp_receive+0xcfd>
                cseg = tcp_seg_copy(&inseg);
  80ceb6:	83 ec 0c             	sub    $0xc,%esp
  80ceb9:	68 b4 b1 b3 00       	push   $0xb3b1b4
  80cebe:	e8 73 89 ff ff       	call   805836 <tcp_seg_copy>
  80cec3:	89 c1                	mov    %eax,%ecx
  80cec5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                if (cseg != NULL) {
  80cec8:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80cecb:	b8 00 00 00 00       	mov    $0x0,%eax
                if (cseg != NULL) {
  80ced0:	85 c9                	test   %ecx,%ecx
  80ced2:	0f 84 3b 02 00 00    	je     80d113 <tcp_receive+0xcfd>
                  cseg->next = next->next;
  80ced8:	8b 03                	mov    (%ebx),%eax
  80ceda:	89 01                	mov    %eax,(%ecx)
                  if (prev != NULL) {
  80cedc:	85 f6                	test   %esi,%esi
  80cede:	74 65                	je     80cf45 <tcp_receive+0xb2f>
                    prev->next = cseg;
  80cee0:	89 0e                	mov    %ecx,(%esi)
                  tcp_seg_free(next);
  80cee2:	83 ec 0c             	sub    $0xc,%esp
  80cee5:	53                   	push   %ebx
  80cee6:	e8 d2 88 ff ff       	call   8057bd <tcp_seg_free>
                  if (cseg->next != NULL) {
  80ceeb:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  80ceee:	8b 16                	mov    (%esi),%edx
  80cef0:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80cef3:	b8 00 00 00 00       	mov    $0x0,%eax
                  if (cseg->next != NULL) {
  80cef8:	85 d2                	test   %edx,%edx
  80cefa:	0f 84 13 02 00 00    	je     80d113 <tcp_receive+0xcfd>
                    if (TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
  80cf00:	8b 1d a8 b1 b3 00    	mov    0xb3b1a8,%ebx
  80cf06:	8b 42 10             	mov    0x10(%edx),%eax
  80cf09:	8b 50 04             	mov    0x4(%eax),%edx
  80cf0c:	0f b7 4e 0c          	movzwl 0xc(%esi),%ecx
  80cf10:	01 d9                	add    %ebx,%ecx
  80cf12:	29 d1                	sub    %edx,%ecx
  u8_t accepted_inseq = 0;
  80cf14:	b8 00 00 00 00       	mov    $0x0,%eax
                    if (TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
  80cf19:	85 c9                	test   %ecx,%ecx
  80cf1b:	0f 8e f2 01 00 00    	jle    80d113 <tcp_receive+0xcfd>
                      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
  80cf21:	89 d0                	mov    %edx,%eax
  80cf23:	29 d8                	sub    %ebx,%eax
  80cf25:	66 89 46 0c          	mov    %ax,0xc(%esi)
                      pbuf_realloc(cseg->p, cseg->len);
  80cf29:	83 ec 08             	sub    $0x8,%esp
  80cf2c:	0f b7 c0             	movzwl %ax,%eax
  80cf2f:	50                   	push   %eax
  80cf30:	ff 76 04             	pushl  0x4(%esi)
  80cf33:	e8 46 7c ff ff       	call   804b7e <pbuf_realloc>
  80cf38:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80cf3b:	b8 00 00 00 00       	mov    $0x0,%eax
  80cf40:	e9 ce 01 00 00       	jmp    80d113 <tcp_receive+0xcfd>
                    pcb->ooseq = cseg;
  80cf45:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80cf48:	89 47 7c             	mov    %eax,0x7c(%edi)
  80cf4b:	eb 95                	jmp    80cee2 <tcp_receive+0xacc>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
  80cf4d:	39 c1                	cmp    %eax,%ecx
  80cf4f:	0f 88 c5 00 00 00    	js     80d01a <tcp_receive+0xc04>
              if (next->next == NULL &&
  80cf55:	8b 13                	mov    (%ebx),%edx
  80cf57:	89 de                	mov    %ebx,%esi
  80cf59:	85 d2                	test   %edx,%edx
  80cf5b:	0f 84 13 01 00 00    	je     80d074 <tcp_receive+0xc5e>
  80cf61:	89 d3                	mov    %edx,%ebx
            if (seqno == next->tcphdr->seqno) {
  80cf63:	8b 43 10             	mov    0x10(%ebx),%eax
  80cf66:	8b 40 04             	mov    0x4(%eax),%eax
  80cf69:	39 c8                	cmp    %ecx,%eax
  80cf6b:	0f 84 2c ff ff ff    	je     80ce9d <tcp_receive+0xa87>
              if (prev == NULL) {
  80cf71:	85 f6                	test   %esi,%esi
  80cf73:	74 d8                	je     80cf4d <tcp_receive+0xb37>
                if(TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)){
  80cf75:	8b 56 10             	mov    0x10(%esi),%edx
  80cf78:	3b 7a 04             	cmp    0x4(%edx),%edi
  80cf7b:	78 d8                	js     80cf55 <tcp_receive+0xb3f>
  80cf7d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80cf80:	29 c2                	sub    %eax,%edx
  80cf82:	85 d2                	test   %edx,%edx
  80cf84:	7f cf                	jg     80cf55 <tcp_receive+0xb3f>
                if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  80cf86:	0f b7 15 c0 b1 b3 00 	movzwl 0xb3b1c0,%edx
  80cf8d:	01 ca                	add    %ecx,%edx
  80cf8f:	29 c2                	sub    %eax,%edx
  80cf91:	85 d2                	test   %edx,%edx
  80cf93:	7e 1d                	jle    80cfb2 <tcp_receive+0xb9c>
                  inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  80cf95:	29 c8                	sub    %ecx,%eax
  80cf97:	66 a3 c0 b1 b3 00    	mov    %ax,0xb3b1c0
                  pbuf_realloc(inseg.p, inseg.len);
  80cf9d:	83 ec 08             	sub    $0x8,%esp
  80cfa0:	0f b7 c0             	movzwl %ax,%eax
  80cfa3:	50                   	push   %eax
  80cfa4:	ff 35 b8 b1 b3 00    	pushl  0xb3b1b8
  80cfaa:	e8 cf 7b ff ff       	call   804b7e <pbuf_realloc>
  80cfaf:	83 c4 10             	add    $0x10,%esp
                cseg = tcp_seg_copy(&inseg);
  80cfb2:	83 ec 0c             	sub    $0xc,%esp
  80cfb5:	68 b4 b1 b3 00       	push   $0xb3b1b4
  80cfba:	e8 77 88 ff ff       	call   805836 <tcp_seg_copy>
  80cfbf:	89 c2                	mov    %eax,%edx
                if (cseg != NULL) {
  80cfc1:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80cfc4:	b8 00 00 00 00       	mov    $0x0,%eax
                if (cseg != NULL) {
  80cfc9:	85 d2                	test   %edx,%edx
  80cfcb:	0f 84 42 01 00 00    	je     80d113 <tcp_receive+0xcfd>
                  cseg->next = next;
  80cfd1:	89 1a                	mov    %ebx,(%edx)
                  prev->next = cseg;
  80cfd3:	89 16                	mov    %edx,(%esi)
                  if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
  80cfd5:	8b 46 10             	mov    0x10(%esi),%eax
  80cfd8:	8b 58 04             	mov    0x4(%eax),%ebx
  80cfdb:	8b 15 a8 b1 b3 00    	mov    0xb3b1a8,%edx
  80cfe1:	0f b7 4e 0c          	movzwl 0xc(%esi),%ecx
  80cfe5:	01 d9                	add    %ebx,%ecx
  80cfe7:	29 d1                	sub    %edx,%ecx
  u8_t accepted_inseq = 0;
  80cfe9:	b8 00 00 00 00       	mov    $0x0,%eax
                  if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
  80cfee:	85 c9                	test   %ecx,%ecx
  80cff0:	0f 8e 1d 01 00 00    	jle    80d113 <tcp_receive+0xcfd>
                    prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
  80cff6:	89 d0                	mov    %edx,%eax
  80cff8:	29 d8                	sub    %ebx,%eax
  80cffa:	66 89 46 0c          	mov    %ax,0xc(%esi)
                    pbuf_realloc(prev->p, prev->len);
  80cffe:	83 ec 08             	sub    $0x8,%esp
  80d001:	0f b7 c0             	movzwl %ax,%eax
  80d004:	50                   	push   %eax
  80d005:	ff 76 04             	pushl  0x4(%esi)
  80d008:	e8 71 7b ff ff       	call   804b7e <pbuf_realloc>
  80d00d:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80d010:	b8 00 00 00 00       	mov    $0x0,%eax
  80d015:	e9 f9 00 00 00       	jmp    80d113 <tcp_receive+0xcfd>
  80d01a:	8b 7d e0             	mov    -0x20(%ebp),%edi
                  if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  80d01d:	0f b7 15 c0 b1 b3 00 	movzwl 0xb3b1c0,%edx
  80d024:	01 ca                	add    %ecx,%edx
  80d026:	29 c2                	sub    %eax,%edx
  80d028:	85 d2                	test   %edx,%edx
  80d02a:	7f 29                	jg     80d055 <tcp_receive+0xc3f>
                  cseg = tcp_seg_copy(&inseg);
  80d02c:	83 ec 0c             	sub    $0xc,%esp
  80d02f:	68 b4 b1 b3 00       	push   $0xb3b1b4
  80d034:	e8 fd 87 ff ff       	call   805836 <tcp_seg_copy>
  80d039:	89 c2                	mov    %eax,%edx
                  if (cseg != NULL) {
  80d03b:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80d03e:	b8 00 00 00 00       	mov    $0x0,%eax
                  if (cseg != NULL) {
  80d043:	85 d2                	test   %edx,%edx
  80d045:	0f 84 c8 00 00 00    	je     80d113 <tcp_receive+0xcfd>
                    cseg->next = next;
  80d04b:	89 1a                	mov    %ebx,(%edx)
                    pcb->ooseq = cseg;
  80d04d:	89 57 7c             	mov    %edx,0x7c(%edi)
  80d050:	e9 be 00 00 00       	jmp    80d113 <tcp_receive+0xcfd>
                    inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  80d055:	29 c8                	sub    %ecx,%eax
  80d057:	66 a3 c0 b1 b3 00    	mov    %ax,0xb3b1c0
                    pbuf_realloc(inseg.p, inseg.len);
  80d05d:	83 ec 08             	sub    $0x8,%esp
  80d060:	0f b7 c0             	movzwl %ax,%eax
  80d063:	50                   	push   %eax
  80d064:	ff 35 b8 b1 b3 00    	pushl  0xb3b1b8
  80d06a:	e8 0f 7b ff ff       	call   804b7e <pbuf_realloc>
  80d06f:	83 c4 10             	add    $0x10,%esp
  80d072:	eb b8                	jmp    80d02c <tcp_receive+0xc16>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
  80d074:	29 c1                	sub    %eax,%ecx
  u8_t accepted_inseq = 0;
  80d076:	b8 00 00 00 00       	mov    $0x0,%eax
              if (next->next == NULL &&
  80d07b:	85 c9                	test   %ecx,%ecx
  80d07d:	0f 8e 90 00 00 00    	jle    80d113 <tcp_receive+0xcfd>
                next->next = tcp_seg_copy(&inseg);
  80d083:	83 ec 0c             	sub    $0xc,%esp
  80d086:	68 b4 b1 b3 00       	push   $0xb3b1b4
  80d08b:	e8 a6 87 ff ff       	call   805836 <tcp_seg_copy>
  80d090:	89 c2                	mov    %eax,%edx
  80d092:	89 03                	mov    %eax,(%ebx)
                if (next->next != NULL) {
  80d094:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80d097:	b8 00 00 00 00       	mov    $0x0,%eax
                if (next->next != NULL) {
  80d09c:	85 d2                	test   %edx,%edx
  80d09e:	74 73                	je     80d113 <tcp_receive+0xcfd>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
  80d0a0:	8b 43 10             	mov    0x10(%ebx),%eax
  80d0a3:	8b 70 04             	mov    0x4(%eax),%esi
  80d0a6:	8b 15 a8 b1 b3 00    	mov    0xb3b1a8,%edx
  80d0ac:	0f b7 4b 0c          	movzwl 0xc(%ebx),%ecx
  80d0b0:	01 f1                	add    %esi,%ecx
  80d0b2:	29 d1                	sub    %edx,%ecx
  u8_t accepted_inseq = 0;
  80d0b4:	b8 00 00 00 00       	mov    $0x0,%eax
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
  80d0b9:	85 c9                	test   %ecx,%ecx
  80d0bb:	7e 56                	jle    80d113 <tcp_receive+0xcfd>
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
  80d0bd:	89 d0                	mov    %edx,%eax
  80d0bf:	29 f0                	sub    %esi,%eax
  80d0c1:	66 89 43 0c          	mov    %ax,0xc(%ebx)
                    pbuf_realloc(next->p, next->len);
  80d0c5:	83 ec 08             	sub    $0x8,%esp
  80d0c8:	0f b7 c0             	movzwl %ax,%eax
  80d0cb:	50                   	push   %eax
  80d0cc:	ff 73 04             	pushl  0x4(%ebx)
  80d0cf:	e8 aa 7a ff ff       	call   804b7e <pbuf_realloc>
  80d0d4:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80d0d7:	b8 00 00 00 00       	mov    $0x0,%eax
  80d0dc:	eb 35                	jmp    80d113 <tcp_receive+0xcfd>
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
  80d0de:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80d0e3:	8b 4f 24             	mov    0x24(%edi),%ecx
  80d0e6:	39 c8                	cmp    %ecx,%eax
  80d0e8:	78 14                	js     80d0fe <tcp_receive+0xce8>
  80d0ea:	8d 50 01             	lea    0x1(%eax),%edx
  80d0ed:	29 ca                	sub    %ecx,%edx
  80d0ef:	0f b7 47 28          	movzwl 0x28(%edi),%eax
  80d0f3:	29 c2                	sub    %eax,%edx
  u8_t accepted_inseq = 0;
  80d0f5:	b8 00 00 00 00       	mov    $0x0,%eax
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
  80d0fa:	85 d2                	test   %edx,%edx
  80d0fc:	7e 15                	jle    80d113 <tcp_receive+0xcfd>
      tcp_ack_now(pcb);
  80d0fe:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80d102:	83 ec 0c             	sub    $0xc,%esp
  80d105:	57                   	push   %edi
  80d106:	e8 f7 af ff ff       	call   808102 <tcp_output>
  80d10b:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80d10e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80d113:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80d116:	5b                   	pop    %ebx
  80d117:	5e                   	pop    %esi
  80d118:	5f                   	pop    %edi
  80d119:	5d                   	pop    %ebp
  80d11a:	c3                   	ret    

0080d11b <tcp_input>:
{
  80d11b:	55                   	push   %ebp
  80d11c:	89 e5                	mov    %esp,%ebp
  80d11e:	57                   	push   %edi
  80d11f:	56                   	push   %esi
  80d120:	53                   	push   %ebx
  80d121:	83 ec 38             	sub    $0x38,%esp
  80d124:	8b 5d 08             	mov    0x8(%ebp),%ebx
  iphdr = p->payload;
  80d127:	8b 73 04             	mov    0x4(%ebx),%esi
  80d12a:	89 35 ac b1 b3 00    	mov    %esi,0xb3b1ac
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
  80d130:	0f b7 06             	movzwl (%esi),%eax
  80d133:	50                   	push   %eax
  80d134:	e8 56 a6 ff ff       	call   80778f <ntohs>
  80d139:	66 c1 e8 08          	shr    $0x8,%ax
  80d13d:	83 e0 0f             	and    $0xf,%eax
  80d140:	8d 04 86             	lea    (%esi,%eax,4),%eax
  80d143:	a3 b0 b1 b3 00       	mov    %eax,0xb3b1b0
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
  80d148:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80d14d:	0f b7 00             	movzwl (%eax),%eax
  80d150:	89 04 24             	mov    %eax,(%esp)
  80d153:	e8 37 a6 ff ff       	call   80778f <ntohs>
  80d158:	83 c4 08             	add    $0x8,%esp
  80d15b:	66 c1 e8 06          	shr    $0x6,%ax
  80d15f:	83 e0 3c             	and    $0x3c,%eax
  80d162:	f7 d8                	neg    %eax
  80d164:	98                   	cwtl   
  80d165:	50                   	push   %eax
  80d166:	53                   	push   %ebx
  80d167:	e8 0d 76 ff ff       	call   804779 <pbuf_header>
  80d16c:	83 c4 10             	add    $0x10,%esp
  80d16f:	84 c0                	test   %al,%al
  80d171:	75 07                	jne    80d17a <tcp_input+0x5f>
  80d173:	66 83 7b 08 13       	cmpw   $0x13,0x8(%ebx)
  80d178:	77 14                	ja     80d18e <tcp_input+0x73>
    pbuf_free(p);
  80d17a:	83 ec 0c             	sub    $0xc,%esp
  80d17d:	53                   	push   %ebx
  80d17e:	e8 ca 76 ff ff       	call   80484d <pbuf_free>
    return;
  80d183:	83 c4 10             	add    $0x10,%esp
}
  80d186:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80d189:	5b                   	pop    %ebx
  80d18a:	5e                   	pop    %esi
  80d18b:	5f                   	pop    %edi
  80d18c:	5d                   	pop    %ebp
  80d18d:	c3                   	ret    
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  80d18e:	83 ec 08             	sub    $0x8,%esp
  80d191:	ff 75 0c             	pushl  0xc(%ebp)
  80d194:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80d199:	83 c0 10             	add    $0x10,%eax
  80d19c:	50                   	push   %eax
  80d19d:	e8 9b 93 ff ff       	call   80653d <ip_addr_isbroadcast>
  80d1a2:	83 c4 10             	add    $0x10,%esp
  80d1a5:	84 c0                	test   %al,%al
  80d1a7:	0f 85 54 01 00 00    	jne    80d301 <tcp_input+0x1e6>
      ip_addr_ismulticast(&(iphdr->dest))) {
  80d1ad:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80d1b2:	8b 70 10             	mov    0x10(%eax),%esi
  80d1b5:	83 ec 0c             	sub    $0xc,%esp
  80d1b8:	68 00 00 00 f0       	push   $0xf0000000
  80d1bd:	e8 f8 a7 ff ff       	call   8079ba <ntohl>
  80d1c2:	21 c6                	and    %eax,%esi
  80d1c4:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80d1cb:	e8 ea a7 ff ff       	call   8079ba <ntohl>
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  80d1d0:	83 c4 10             	add    $0x10,%esp
  80d1d3:	39 c6                	cmp    %eax,%esi
  80d1d5:	0f 84 26 01 00 00    	je     80d301 <tcp_input+0x1e6>
      (struct ip_addr *)&(iphdr->dest),
  80d1db:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  80d1e0:	83 ec 0c             	sub    $0xc,%esp
  80d1e3:	0f b7 53 08          	movzwl 0x8(%ebx),%edx
  80d1e7:	52                   	push   %edx
  80d1e8:	6a 06                	push   $0x6
  80d1ea:	8d 50 10             	lea    0x10(%eax),%edx
  80d1ed:	52                   	push   %edx
  80d1ee:	83 c0 0c             	add    $0xc,%eax
  80d1f1:	50                   	push   %eax
  80d1f2:	53                   	push   %ebx
  80d1f3:	e8 70 a2 ff ff       	call   807468 <inet_chksum_pseudo>
  80d1f8:	83 c4 20             	add    $0x20,%esp
  80d1fb:	66 85 c0             	test   %ax,%ax
  80d1fe:	0f 85 0e 01 00 00    	jne    80d312 <tcp_input+0x1f7>
  hdrlen = TCPH_HDRLEN(tcphdr);
  80d204:	83 ec 0c             	sub    $0xc,%esp
  80d207:	a1 b0 b1 b3 00       	mov    0xb3b1b0,%eax
  80d20c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d210:	50                   	push   %eax
  80d211:	e8 79 a5 ff ff       	call   80778f <ntohs>
  if(pbuf_header(p, -(hdrlen * 4))){
  80d216:	83 c4 08             	add    $0x8,%esp
  hdrlen = TCPH_HDRLEN(tcphdr);
  80d219:	66 c1 e8 0c          	shr    $0xc,%ax
  if(pbuf_header(p, -(hdrlen * 4))){
  80d21d:	f7 d8                	neg    %eax
  80d21f:	c1 e0 02             	shl    $0x2,%eax
  80d222:	98                   	cwtl   
  80d223:	50                   	push   %eax
  80d224:	53                   	push   %ebx
  80d225:	e8 4f 75 ff ff       	call   804779 <pbuf_header>
  80d22a:	83 c4 10             	add    $0x10,%esp
  80d22d:	84 c0                	test   %al,%al
  80d22f:	0f 85 ee 00 00 00    	jne    80d323 <tcp_input+0x208>
  tcphdr->src = ntohs(tcphdr->src);
  80d235:	8b 35 b0 b1 b3 00    	mov    0xb3b1b0,%esi
  80d23b:	83 ec 0c             	sub    $0xc,%esp
  80d23e:	0f b7 06             	movzwl (%esi),%eax
  80d241:	50                   	push   %eax
  80d242:	e8 48 a5 ff ff       	call   80778f <ntohs>
  80d247:	66 89 06             	mov    %ax,(%esi)
  tcphdr->dest = ntohs(tcphdr->dest);
  80d24a:	8b 35 b0 b1 b3 00    	mov    0xb3b1b0,%esi
  80d250:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  80d254:	89 04 24             	mov    %eax,(%esp)
  80d257:	e8 33 a5 ff ff       	call   80778f <ntohs>
  80d25c:	66 89 46 02          	mov    %ax,0x2(%esi)
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  80d260:	8b 35 b0 b1 b3 00    	mov    0xb3b1b0,%esi
  80d266:	83 c4 04             	add    $0x4,%esp
  80d269:	ff 76 04             	pushl  0x4(%esi)
  80d26c:	e8 49 a7 ff ff       	call   8079ba <ntohl>
  80d271:	89 46 04             	mov    %eax,0x4(%esi)
  80d274:	a3 a8 b1 b3 00       	mov    %eax,0xb3b1a8
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  80d279:	8b 35 b0 b1 b3 00    	mov    0xb3b1b0,%esi
  80d27f:	83 c4 04             	add    $0x4,%esp
  80d282:	ff 76 08             	pushl  0x8(%esi)
  80d285:	e8 30 a7 ff ff       	call   8079ba <ntohl>
  80d28a:	89 46 08             	mov    %eax,0x8(%esi)
  80d28d:	a3 a4 b1 b3 00       	mov    %eax,0xb3b1a4
  tcphdr->wnd = ntohs(tcphdr->wnd);
  80d292:	8b 35 b0 b1 b3 00    	mov    0xb3b1b0,%esi
  80d298:	0f b7 46 0e          	movzwl 0xe(%esi),%eax
  80d29c:	89 04 24             	mov    %eax,(%esp)
  80d29f:	e8 eb a4 ff ff       	call   80778f <ntohs>
  80d2a4:	66 89 46 0e          	mov    %ax,0xe(%esi)
  flags = TCPH_FLAGS(tcphdr) & TCP_FLAGS;
  80d2a8:	a1 b0 b1 b3 00       	mov    0xb3b1b0,%eax
  80d2ad:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d2b1:	89 04 24             	mov    %eax,(%esp)
  80d2b4:	e8 d6 a4 ff ff       	call   80778f <ntohs>
  80d2b9:	89 c1                	mov    %eax,%ecx
  80d2bb:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
  80d2bf:	83 e0 3f             	and    $0x3f,%eax
  80d2c2:	a2 a0 b1 b3 00       	mov    %al,0xb3b1a0
  tcplen = p->tot_len + ((flags & TCP_FIN || flags & TCP_SYN)? 1: 0);
  80d2c7:	83 c4 10             	add    $0x10,%esp
  80d2ca:	f6 c1 03             	test   $0x3,%cl
  80d2cd:	0f 95 c0             	setne  %al
  80d2d0:	0f b6 c0             	movzbl %al,%eax
  80d2d3:	66 03 43 08          	add    0x8(%ebx),%ax
  80d2d7:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
  80d2db:	66 a3 9e b1 b3 00    	mov    %ax,0xb3b19e
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d2e1:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80d2e6:	89 45 d0             	mov    %eax,-0x30(%ebp)
    if (pcb->remote_port == tcphdr->src &&
  80d2e9:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80d2ef:	8b 0d ac b1 b3 00    	mov    0xb3b1ac,%ecx
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d2f5:	89 c6                	mov    %eax,%esi
  prev = NULL;
  80d2f7:	bf 00 00 00 00       	mov    $0x0,%edi
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d2fc:	e9 ab 00 00 00       	jmp    80d3ac <tcp_input+0x291>
    pbuf_free(p);
  80d301:	83 ec 0c             	sub    $0xc,%esp
  80d304:	53                   	push   %ebx
  80d305:	e8 43 75 ff ff       	call   80484d <pbuf_free>
    return;
  80d30a:	83 c4 10             	add    $0x10,%esp
  80d30d:	e9 74 fe ff ff       	jmp    80d186 <tcp_input+0x6b>
    pbuf_free(p);
  80d312:	83 ec 0c             	sub    $0xc,%esp
  80d315:	53                   	push   %ebx
  80d316:	e8 32 75 ff ff       	call   80484d <pbuf_free>
    return;
  80d31b:	83 c4 10             	add    $0x10,%esp
  80d31e:	e9 63 fe ff ff       	jmp    80d186 <tcp_input+0x6b>
    pbuf_free(p);
  80d323:	83 ec 0c             	sub    $0xc,%esp
  80d326:	53                   	push   %ebx
  80d327:	e8 21 75 ff ff       	call   80484d <pbuf_free>
    return;
  80d32c:	83 c4 10             	add    $0x10,%esp
  80d32f:	e9 52 fe ff ff       	jmp    80d186 <tcp_input+0x6b>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
  80d334:	83 ec 04             	sub    $0x4,%esp
  80d337:	68 8c 31 81 00       	push   $0x81318c
  80d33c:	68 b5 00 00 00       	push   $0xb5
  80d341:	68 b0 32 81 00       	push   $0x8132b0
  80d346:	e8 08 13 00 00       	call   80e653 <_panic>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  80d34b:	83 ec 04             	sub    $0x4,%esp
  80d34e:	68 b4 31 81 00       	push   $0x8131b4
  80d353:	68 b6 00 00 00       	push   $0xb6
  80d358:	68 b0 32 81 00       	push   $0x8132b0
  80d35d:	e8 f1 12 00 00       	call   80e653 <_panic>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  80d362:	83 ec 04             	sub    $0x4,%esp
  80d365:	68 e0 31 81 00       	push   $0x8131e0
  80d36a:	68 b7 00 00 00       	push   $0xb7
  80d36f:	68 b0 32 81 00       	push   $0x8132b0
  80d374:	e8 da 12 00 00       	call   80e653 <_panic>
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
  80d379:	83 ec 04             	sub    $0x4,%esp
  80d37c:	68 08 32 81 00       	push   $0x813208
  80d381:	68 c0 00 00 00       	push   $0xc0
  80d386:	68 b0 32 81 00       	push   $0x8132b0
  80d38b:	e8 c3 12 00 00       	call   80e653 <_panic>
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
  80d390:	83 ec 04             	sub    $0x4,%esp
  80d393:	68 34 32 81 00       	push   $0x813234
  80d398:	68 c6 00 00 00       	push   $0xc6
  80d39d:	68 b0 32 81 00       	push   $0x8132b0
  80d3a2:	e8 ac 12 00 00       	call   80e653 <_panic>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d3a7:	89 f7                	mov    %esi,%edi
  80d3a9:	8b 76 0c             	mov    0xc(%esi),%esi
  80d3ac:	85 f6                	test   %esi,%esi
  80d3ae:	0f 84 80 01 00 00    	je     80d534 <tcp_input+0x419>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
  80d3b4:	8b 46 10             	mov    0x10(%esi),%eax
  80d3b7:	85 c0                	test   %eax,%eax
  80d3b9:	0f 84 75 ff ff ff    	je     80d334 <tcp_input+0x219>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  80d3bf:	83 f8 0a             	cmp    $0xa,%eax
  80d3c2:	74 87                	je     80d34b <tcp_input+0x230>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  80d3c4:	83 f8 01             	cmp    $0x1,%eax
  80d3c7:	74 99                	je     80d362 <tcp_input+0x247>
    if (pcb->remote_port == tcphdr->src &&
  80d3c9:	0f b7 02             	movzwl (%edx),%eax
  80d3cc:	66 39 46 1e          	cmp    %ax,0x1e(%esi)
  80d3d0:	75 d5                	jne    80d3a7 <tcp_input+0x28c>
  80d3d2:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d3d6:	66 39 46 1c          	cmp    %ax,0x1c(%esi)
  80d3da:	75 cb                	jne    80d3a7 <tcp_input+0x28c>
       pcb->local_port == tcphdr->dest &&
  80d3dc:	8b 41 0c             	mov    0xc(%ecx),%eax
  80d3df:	39 46 04             	cmp    %eax,0x4(%esi)
  80d3e2:	75 c3                	jne    80d3a7 <tcp_input+0x28c>
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80d3e4:	8b 41 10             	mov    0x10(%ecx),%eax
  80d3e7:	39 06                	cmp    %eax,(%esi)
  80d3e9:	75 bc                	jne    80d3a7 <tcp_input+0x28c>
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
  80d3eb:	8b 46 0c             	mov    0xc(%esi),%eax
  80d3ee:	39 c6                	cmp    %eax,%esi
  80d3f0:	74 87                	je     80d379 <tcp_input+0x25e>
      if (prev != NULL) {
  80d3f2:	85 ff                	test   %edi,%edi
  80d3f4:	74 13                	je     80d409 <tcp_input+0x2ee>
        prev->next = pcb->next;
  80d3f6:	89 47 0c             	mov    %eax,0xc(%edi)
        pcb->next = tcp_active_pcbs;
  80d3f9:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80d3fc:	89 46 0c             	mov    %eax,0xc(%esi)
        tcp_active_pcbs = pcb;
  80d3ff:	89 35 3c b2 b3 00    	mov    %esi,0xb3b23c
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
  80d405:	39 c6                	cmp    %eax,%esi
  80d407:	74 87                	je     80d390 <tcp_input+0x275>
    inseg.next = NULL;
  80d409:	c7 05 b4 b1 b3 00 00 	movl   $0x0,0xb3b1b4
  80d410:	00 00 00 
    inseg.len = p->tot_len;
  80d413:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80d417:	66 a3 c0 b1 b3 00    	mov    %ax,0xb3b1c0
    inseg.dataptr = p->payload;
  80d41d:	8b 43 04             	mov    0x4(%ebx),%eax
  80d420:	a3 bc b1 b3 00       	mov    %eax,0xb3b1bc
    inseg.p = p;
  80d425:	89 1d b8 b1 b3 00    	mov    %ebx,0xb3b1b8
    inseg.tcphdr = tcphdr;
  80d42b:	89 15 c4 b1 b3 00    	mov    %edx,0xb3b1c4
    recv_data = NULL;
  80d431:	c7 05 98 b1 b3 00 00 	movl   $0x0,0xb3b198
  80d438:	00 00 00 
    recv_flags = 0;
  80d43b:	c6 05 9c b1 b3 00 00 	movb   $0x0,0xb3b19c
    if (pcb->refused_data != NULL) {
  80d442:	8b 86 80 00 00 00    	mov    0x80(%esi),%eax
  80d448:	85 c0                	test   %eax,%eax
  80d44a:	74 2c                	je     80d478 <tcp_input+0x35d>
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80d44c:	8b 96 88 00 00 00    	mov    0x88(%esi),%edx
  80d452:	85 d2                	test   %edx,%edx
  80d454:	0f 84 0d 03 00 00    	je     80d767 <tcp_input+0x64c>
  80d45a:	6a 00                	push   $0x0
  80d45c:	50                   	push   %eax
  80d45d:	56                   	push   %esi
  80d45e:	ff 76 18             	pushl  0x18(%esi)
  80d461:	ff d2                	call   *%edx
      if (err == ERR_OK) {
  80d463:	83 c4 10             	add    $0x10,%esp
  80d466:	84 c0                	test   %al,%al
  80d468:	0f 85 0a 03 00 00    	jne    80d778 <tcp_input+0x65d>
        pcb->refused_data = NULL;
  80d46e:	c7 86 80 00 00 00 00 	movl   $0x0,0x80(%esi)
  80d475:	00 00 00 
    tcp_input_pcb = pcb;
  80d478:	89 35 58 b2 b3 00    	mov    %esi,0xb3b258
  if (flags & TCP_RST) {
  80d47e:	0f b6 05 a0 b1 b3 00 	movzbl 0xb3b1a0,%eax
  80d485:	a8 04                	test   $0x4,%al
  80d487:	0f 84 26 03 00 00    	je     80d7b3 <tcp_input+0x698>
    if (pcb->state == SYN_SENT) {
  80d48d:	8b 56 10             	mov    0x10(%esi),%edx
  80d490:	83 fa 02             	cmp    $0x2,%edx
  80d493:	0f 84 f0 02 00 00    	je     80d789 <tcp_input+0x66e>
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  80d499:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80d49e:	2b 46 24             	sub    0x24(%esi),%eax
  80d4a1:	78 1d                	js     80d4c0 <tcp_input+0x3a5>
  80d4a3:	0f b7 4e 28          	movzwl 0x28(%esi),%ecx
  80d4a7:	29 c8                	sub    %ecx,%eax
  80d4a9:	85 c0                	test   %eax,%eax
  80d4ab:	7f 13                	jg     80d4c0 <tcp_input+0x3a5>
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
  80d4ad:	85 d2                	test   %edx,%edx
  80d4af:	0f 84 e7 02 00 00    	je     80d79c <tcp_input+0x681>
      recv_flags = TF_RESET;
  80d4b5:	c6 05 9c b1 b3 00 08 	movb   $0x8,0xb3b19c
      pcb->flags &= ~TF_ACK_DELAY;
  80d4bc:	80 66 20 fe          	andb   $0xfe,0x20(%esi)
    tcp_input_pcb = NULL;
  80d4c0:	c7 05 58 b2 b3 00 00 	movl   $0x0,0xb3b258
  80d4c7:	00 00 00 
      if (recv_flags & TF_RESET) {
  80d4ca:	0f b6 05 9c b1 b3 00 	movzbl 0xb3b19c,%eax
  80d4d1:	a8 08                	test   $0x8,%al
  80d4d3:	0f 84 2b 08 00 00    	je     80dd04 <tcp_input+0xbe9>
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
  80d4d9:	8b 86 98 00 00 00    	mov    0x98(%esi),%eax
  80d4df:	85 c0                	test   %eax,%eax
  80d4e1:	74 0d                	je     80d4f0 <tcp_input+0x3d5>
  80d4e3:	83 ec 08             	sub    $0x8,%esp
  80d4e6:	6a fa                	push   $0xfffffffa
  80d4e8:	ff 76 18             	pushl  0x18(%esi)
  80d4eb:	ff d0                	call   *%eax
  80d4ed:	83 c4 10             	add    $0x10,%esp
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80d4f0:	83 ec 08             	sub    $0x8,%esp
  80d4f3:	56                   	push   %esi
  80d4f4:	68 3c b2 b3 00       	push   $0xb3b23c
  80d4f9:	e8 54 84 ff ff       	call   805952 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  80d4fe:	83 c4 08             	add    $0x8,%esp
  80d501:	56                   	push   %esi
  80d502:	6a 02                	push   $0x2
  80d504:	e8 d5 6f ff ff       	call   8044de <memp_free>
  80d509:	83 c4 10             	add    $0x10,%esp
    if (inseg.p != NULL)
  80d50c:	a1 b8 b1 b3 00       	mov    0xb3b1b8,%eax
  80d511:	85 c0                	test   %eax,%eax
  80d513:	0f 84 6d fc ff ff    	je     80d186 <tcp_input+0x6b>
      pbuf_free(inseg.p);
  80d519:	83 ec 0c             	sub    $0xc,%esp
  80d51c:	50                   	push   %eax
  80d51d:	e8 2b 73 ff ff       	call   80484d <pbuf_free>
      inseg.p = NULL;
  80d522:	c7 05 b8 b1 b3 00 00 	movl   $0x0,0xb3b1b8
  80d529:	00 00 00 
  80d52c:	83 c4 10             	add    $0x10,%esp
  80d52f:	e9 52 fc ff ff       	jmp    80d186 <tcp_input+0x6b>
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80d534:	8b 35 50 b2 b3 00    	mov    0xb3b250,%esi
  80d53a:	eb 1a                	jmp    80d556 <tcp_input+0x43b>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  80d53c:	83 ec 04             	sub    $0x4,%esp
  80d53f:	68 60 32 81 00       	push   $0x813260
  80d544:	68 d0 00 00 00       	push   $0xd0
  80d549:	68 b0 32 81 00       	push   $0x8132b0
  80d54e:	e8 00 11 00 00       	call   80e653 <_panic>
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80d553:	8b 76 0c             	mov    0xc(%esi),%esi
  80d556:	85 f6                	test   %esi,%esi
  80d558:	74 6e                	je     80d5c8 <tcp_input+0x4ad>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  80d55a:	83 7e 10 0a          	cmpl   $0xa,0x10(%esi)
  80d55e:	75 dc                	jne    80d53c <tcp_input+0x421>
      if (pcb->remote_port == tcphdr->src &&
  80d560:	0f b7 02             	movzwl (%edx),%eax
  80d563:	66 39 46 1e          	cmp    %ax,0x1e(%esi)
  80d567:	75 ea                	jne    80d553 <tcp_input+0x438>
  80d569:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d56d:	66 39 46 1c          	cmp    %ax,0x1c(%esi)
  80d571:	75 e0                	jne    80d553 <tcp_input+0x438>
         pcb->local_port == tcphdr->dest &&
  80d573:	8b 41 0c             	mov    0xc(%ecx),%eax
  80d576:	39 46 04             	cmp    %eax,0x4(%esi)
  80d579:	75 d8                	jne    80d553 <tcp_input+0x438>
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80d57b:	8b 41 10             	mov    0x10(%ecx),%eax
  80d57e:	39 06                	cmp    %eax,(%esi)
  80d580:	75 d1                	jne    80d553 <tcp_input+0x438>
  if (TCP_SEQ_GT(seqno + tcplen, pcb->rcv_nxt)) {
  80d582:	0f b7 45 d4          	movzwl -0x2c(%ebp),%eax
  80d586:	03 05 a8 b1 b3 00    	add    0xb3b1a8,%eax
  80d58c:	89 c2                	mov    %eax,%edx
  80d58e:	2b 56 24             	sub    0x24(%esi),%edx
  80d591:	85 d2                	test   %edx,%edx
  80d593:	7e 03                	jle    80d598 <tcp_input+0x47d>
    pcb->rcv_nxt = seqno + tcplen;
  80d595:	89 46 24             	mov    %eax,0x24(%esi)
  if (tcplen > 0) {
  80d598:	66 83 7d d4 00       	cmpw   $0x0,-0x2c(%ebp)
  80d59d:	74 10                	je     80d5af <tcp_input+0x494>
    tcp_ack_now(pcb);
  80d59f:	80 4e 20 02          	orb    $0x2,0x20(%esi)
  80d5a3:	83 ec 0c             	sub    $0xc,%esp
  80d5a6:	56                   	push   %esi
  80d5a7:	e8 56 ab ff ff       	call   808102 <tcp_output>
  80d5ac:	83 c4 10             	add    $0x10,%esp
  return tcp_output(pcb);
  80d5af:	83 ec 0c             	sub    $0xc,%esp
  80d5b2:	56                   	push   %esi
  80d5b3:	e8 4a ab ff ff       	call   808102 <tcp_output>
        pbuf_free(p);
  80d5b8:	89 1c 24             	mov    %ebx,(%esp)
  80d5bb:	e8 8d 72 ff ff       	call   80484d <pbuf_free>
        return;
  80d5c0:	83 c4 10             	add    $0x10,%esp
  80d5c3:	e9 be fb ff ff       	jmp    80d186 <tcp_input+0x6b>
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80d5c8:	a1 44 b2 b3 00       	mov    0xb3b244,%eax
  80d5cd:	89 45 d0             	mov    %eax,-0x30(%ebp)
  80d5d0:	89 c7                	mov    %eax,%edi
  80d5d2:	eb 0f                	jmp    80d5e3 <tcp_input+0x4c8>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
  80d5d4:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d5d8:	66 39 47 1c          	cmp    %ax,0x1c(%edi)
  80d5dc:	74 1e                	je     80d5fc <tcp_input+0x4e1>
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80d5de:	89 fe                	mov    %edi,%esi
  80d5e0:	8b 7f 0c             	mov    0xc(%edi),%edi
  80d5e3:	85 ff                	test   %edi,%edi
  80d5e5:	0f 84 20 08 00 00    	je     80de0b <tcp_input+0xcf0>
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
  80d5eb:	85 ff                	test   %edi,%edi
  80d5ed:	74 e5                	je     80d5d4 <tcp_input+0x4b9>
  80d5ef:	8b 07                	mov    (%edi),%eax
  80d5f1:	85 c0                	test   %eax,%eax
  80d5f3:	74 df                	je     80d5d4 <tcp_input+0x4b9>
  80d5f5:	3b 41 10             	cmp    0x10(%ecx),%eax
  80d5f8:	75 e4                	jne    80d5de <tcp_input+0x4c3>
  80d5fa:	eb d8                	jmp    80d5d4 <tcp_input+0x4b9>
        if (prev != NULL) {
  80d5fc:	85 f6                	test   %esi,%esi
  80d5fe:	74 12                	je     80d612 <tcp_input+0x4f7>
          ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
  80d600:	8b 47 0c             	mov    0xc(%edi),%eax
  80d603:	89 46 0c             	mov    %eax,0xc(%esi)
          lpcb->next = tcp_listen_pcbs.listen_pcbs;
  80d606:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80d609:	89 47 0c             	mov    %eax,0xc(%edi)
          tcp_listen_pcbs.listen_pcbs = lpcb;
  80d60c:	89 3d 44 b2 b3 00    	mov    %edi,0xb3b244
  if (flags & TCP_ACK) {
  80d612:	f6 45 d6 10          	testb  $0x10,-0x2a(%ebp)
  80d616:	75 17                	jne    80d62f <tcp_input+0x514>
  } else if (flags & TCP_SYN) {
  80d618:	f6 45 d6 02          	testb  $0x2,-0x2a(%ebp)
  80d61c:	75 43                	jne    80d661 <tcp_input+0x546>
        pbuf_free(p);
  80d61e:	83 ec 0c             	sub    $0xc,%esp
  80d621:	53                   	push   %ebx
  80d622:	e8 26 72 ff ff       	call   80484d <pbuf_free>
        return;
  80d627:	83 c4 10             	add    $0x10,%esp
  80d62a:	e9 57 fb ff ff       	jmp    80d186 <tcp_input+0x6b>
    tcp_rst(ackno + 1, seqno + tcplen,
  80d62f:	83 ec 08             	sub    $0x8,%esp
  80d632:	0f b7 02             	movzwl (%edx),%eax
  80d635:	50                   	push   %eax
  80d636:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d63a:	50                   	push   %eax
  80d63b:	8d 41 0c             	lea    0xc(%ecx),%eax
  80d63e:	50                   	push   %eax
  80d63f:	83 c1 10             	add    $0x10,%ecx
  80d642:	51                   	push   %ecx
  80d643:	0f b7 45 d4          	movzwl -0x2c(%ebp),%eax
  80d647:	03 05 a8 b1 b3 00    	add    0xb3b1a8,%eax
  80d64d:	50                   	push   %eax
  80d64e:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80d653:	83 c0 01             	add    $0x1,%eax
  80d656:	50                   	push   %eax
  80d657:	e8 67 af ff ff       	call   8085c3 <tcp_rst>
  80d65c:	83 c4 20             	add    $0x20,%esp
  80d65f:	eb bd                	jmp    80d61e <tcp_input+0x503>
    npcb = tcp_alloc(pcb->prio);
  80d661:	83 ec 0c             	sub    $0xc,%esp
  80d664:	0f b6 47 14          	movzbl 0x14(%edi),%eax
  80d668:	50                   	push   %eax
  80d669:	e8 66 8b ff ff       	call   8061d4 <tcp_alloc>
  80d66e:	89 c6                	mov    %eax,%esi
    if (npcb == NULL) {
  80d670:	83 c4 10             	add    $0x10,%esp
  80d673:	85 c0                	test   %eax,%eax
  80d675:	74 a7                	je     80d61e <tcp_input+0x503>
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
  80d677:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80d67c:	83 f8 f0             	cmp    $0xfffffff0,%eax
  80d67f:	0f 84 ce 00 00 00    	je     80d753 <tcp_input+0x638>
  80d685:	8b 50 10             	mov    0x10(%eax),%edx
  80d688:	89 16                	mov    %edx,(%esi)
    npcb->local_port = pcb->local_port;
  80d68a:	0f b7 57 1c          	movzwl 0x1c(%edi),%edx
  80d68e:	66 89 56 1c          	mov    %dx,0x1c(%esi)
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
  80d692:	83 f8 f4             	cmp    $0xfffffff4,%eax
  80d695:	0f 84 c2 00 00 00    	je     80d75d <tcp_input+0x642>
  80d69b:	8b 40 0c             	mov    0xc(%eax),%eax
  80d69e:	89 46 04             	mov    %eax,0x4(%esi)
    npcb->remote_port = tcphdr->src;
  80d6a1:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
  80d6a7:	0f b7 02             	movzwl (%edx),%eax
  80d6aa:	66 89 46 1e          	mov    %ax,0x1e(%esi)
    npcb->state = SYN_RCVD;
  80d6ae:	c7 46 10 03 00 00 00 	movl   $0x3,0x10(%esi)
    npcb->rcv_nxt = seqno + 1;
  80d6b5:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80d6ba:	8d 48 01             	lea    0x1(%eax),%ecx
  80d6bd:	89 4e 24             	mov    %ecx,0x24(%esi)
    npcb->snd_wnd = tcphdr->wnd;
  80d6c0:	0f b7 52 0e          	movzwl 0xe(%edx),%edx
  80d6c4:	66 89 56 5c          	mov    %dx,0x5c(%esi)
    npcb->ssthresh = npcb->snd_wnd;
  80d6c8:	66 89 56 50          	mov    %dx,0x50(%esi)
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
  80d6cc:	83 e8 01             	sub    $0x1,%eax
  80d6cf:	89 46 60             	mov    %eax,0x60(%esi)
    npcb->callback_arg = pcb->callback_arg;
  80d6d2:	8b 47 18             	mov    0x18(%edi),%eax
  80d6d5:	89 46 18             	mov    %eax,0x18(%esi)
    npcb->accept = pcb->accept;
  80d6d8:	8b 47 20             	mov    0x20(%edi),%eax
  80d6db:	89 86 90 00 00 00    	mov    %eax,0x90(%esi)
    npcb->so_options = pcb->so_options & (SOF_DEBUG|SOF_DONTROUTE|SOF_KEEPALIVE|SOF_OOBINLINE|SOF_LINGER);
  80d6e1:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80d6e5:	66 25 99 01          	and    $0x199,%ax
  80d6e9:	66 89 46 08          	mov    %ax,0x8(%esi)
    TCP_REG(&tcp_active_pcbs, npcb);
  80d6ed:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80d6f2:	89 46 0c             	mov    %eax,0xc(%esi)
  80d6f5:	89 35 3c b2 b3 00    	mov    %esi,0xb3b23c
  80d6fb:	e8 b7 4a ff ff       	call   8021b7 <tcp_timer_needed>
    tcp_parseopt(npcb);
  80d700:	89 f0                	mov    %esi,%eax
  80d702:	e8 5c ec ff ff       	call   80c363 <tcp_parseopt>
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
  80d707:	83 ec 08             	sub    $0x8,%esp
  80d70a:	8d 46 04             	lea    0x4(%esi),%eax
  80d70d:	50                   	push   %eax
  80d70e:	0f b7 46 34          	movzwl 0x34(%esi),%eax
  80d712:	50                   	push   %eax
  80d713:	e8 5a 8c ff ff       	call   806372 <tcp_eff_send_mss>
  80d718:	66 89 46 34          	mov    %ax,0x34(%esi)
    optdata = TCP_BUILD_MSS_OPTION();
  80d71c:	c7 04 24 b4 05 04 02 	movl   $0x20405b4,(%esp)
  80d723:	e8 74 a0 ff ff       	call   80779c <htonl>
  80d728:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    tcp_enqueue(npcb, NULL, 0, TCP_SYN | TCP_ACK, 0, (u8_t *)&optdata, 4);
  80d72b:	83 c4 0c             	add    $0xc,%esp
  80d72e:	6a 04                	push   $0x4
  80d730:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80d733:	50                   	push   %eax
  80d734:	6a 00                	push   $0x0
  80d736:	6a 12                	push   $0x12
  80d738:	6a 00                	push   $0x0
  80d73a:	6a 00                	push   $0x0
  80d73c:	56                   	push   %esi
  80d73d:	e8 88 a2 ff ff       	call   8079ca <tcp_enqueue>
    return tcp_output(npcb);
  80d742:	83 c4 14             	add    $0x14,%esp
  80d745:	56                   	push   %esi
  80d746:	e8 b7 a9 ff ff       	call   808102 <tcp_output>
  80d74b:	83 c4 10             	add    $0x10,%esp
  80d74e:	e9 cb fe ff ff       	jmp    80d61e <tcp_input+0x503>
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
  80d753:	ba 00 00 00 00       	mov    $0x0,%edx
  80d758:	e9 2b ff ff ff       	jmp    80d688 <tcp_input+0x56d>
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
  80d75d:	b8 00 00 00 00       	mov    $0x0,%eax
  80d762:	e9 37 ff ff ff       	jmp    80d69e <tcp_input+0x583>
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80d767:	83 ec 0c             	sub    $0xc,%esp
  80d76a:	50                   	push   %eax
  80d76b:	e8 dd 70 ff ff       	call   80484d <pbuf_free>
  80d770:	83 c4 10             	add    $0x10,%esp
  80d773:	e9 f6 fc ff ff       	jmp    80d46e <tcp_input+0x353>
        pbuf_free(p);
  80d778:	83 ec 0c             	sub    $0xc,%esp
  80d77b:	53                   	push   %ebx
  80d77c:	e8 cc 70 ff ff       	call   80484d <pbuf_free>
        return;
  80d781:	83 c4 10             	add    $0x10,%esp
  80d784:	e9 fd f9 ff ff       	jmp    80d186 <tcp_input+0x6b>
      if (ackno == pcb->snd_nxt) {
  80d789:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80d78e:	39 46 54             	cmp    %eax,0x54(%esi)
  80d791:	0f 85 29 fd ff ff    	jne    80d4c0 <tcp_input+0x3a5>
  80d797:	e9 19 fd ff ff       	jmp    80d4b5 <tcp_input+0x39a>
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
  80d79c:	83 ec 04             	sub    $0x4,%esp
  80d79f:	68 90 32 81 00       	push   $0x813290
  80d7a4:	68 09 02 00 00       	push   $0x209
  80d7a9:	68 b0 32 81 00       	push   $0x8132b0
  80d7ae:	e8 a0 0e 00 00       	call   80e653 <_panic>
  pcb->tmr = tcp_ticks;
  80d7b3:	8b 15 40 b2 b3 00    	mov    0xb3b240,%edx
  80d7b9:	89 56 2c             	mov    %edx,0x2c(%esi)
  pcb->keep_cnt_sent = 0;
  80d7bc:	c6 86 a5 00 00 00 00 	movb   $0x0,0xa5(%esi)
  switch (pcb->state) {
  80d7c3:	83 7e 10 09          	cmpl   $0x9,0x10(%esi)
  80d7c7:	0f 87 28 05 00 00    	ja     80dcf5 <tcp_input+0xbda>
  80d7cd:	8b 56 10             	mov    0x10(%esi),%edx
  80d7d0:	ff 24 95 34 33 81 00 	jmp    *0x813334(,%edx,4)
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
  80d7d7:	83 e0 12             	and    $0x12,%eax
  80d7da:	3c 12                	cmp    $0x12,%al
  80d7dc:	74 4d                	je     80d82b <tcp_input+0x710>
    else if (flags & TCP_ACK) {
  80d7de:	f6 05 a0 b1 b3 00 10 	testb  $0x10,0xb3b1a0
  80d7e5:	0f 84 d5 fc ff ff    	je     80d4c0 <tcp_input+0x3a5>
        tcphdr->dest, tcphdr->src);
  80d7eb:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  80d7f1:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80d7f6:	83 ec 08             	sub    $0x8,%esp
  80d7f9:	0f b7 0a             	movzwl (%edx),%ecx
  80d7fc:	51                   	push   %ecx
  80d7fd:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  80d801:	52                   	push   %edx
  80d802:	8d 50 0c             	lea    0xc(%eax),%edx
  80d805:	52                   	push   %edx
  80d806:	83 c0 10             	add    $0x10,%eax
  80d809:	50                   	push   %eax
  80d80a:	0f b7 05 9e b1 b3 00 	movzwl 0xb3b19e,%eax
  80d811:	03 05 a8 b1 b3 00    	add    0xb3b1a8,%eax
  80d817:	50                   	push   %eax
  80d818:	ff 35 a4 b1 b3 00    	pushl  0xb3b1a4
  80d81e:	e8 a0 ad ff ff       	call   8085c3 <tcp_rst>
  80d823:	83 c4 20             	add    $0x20,%esp
  80d826:	e9 95 fc ff ff       	jmp    80d4c0 <tcp_input+0x3a5>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
  80d82b:	83 ec 0c             	sub    $0xc,%esp
  80d82e:	8b 46 78             	mov    0x78(%esi),%eax
  80d831:	8b 40 10             	mov    0x10(%eax),%eax
  80d834:	ff 70 04             	pushl  0x4(%eax)
  80d837:	e8 7e a1 ff ff       	call   8079ba <ntohl>
  80d83c:	8d 50 01             	lea    0x1(%eax),%edx
  80d83f:	83 c4 10             	add    $0x10,%esp
  80d842:	3b 15 a4 b1 b3 00    	cmp    0xb3b1a4,%edx
  80d848:	75 94                	jne    80d7de <tcp_input+0x6c3>
      pcb->snd_buf++;
  80d84a:	66 83 46 6e 01       	addw   $0x1,0x6e(%esi)
      pcb->rcv_nxt = seqno + 1;
  80d84f:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80d854:	8d 48 01             	lea    0x1(%eax),%ecx
  80d857:	89 4e 24             	mov    %ecx,0x24(%esi)
      pcb->lastack = ackno;
  80d85a:	89 56 48             	mov    %edx,0x48(%esi)
      pcb->snd_wnd = tcphdr->wnd;
  80d85d:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
  80d863:	0f b7 52 0e          	movzwl 0xe(%edx),%edx
  80d867:	66 89 56 5c          	mov    %dx,0x5c(%esi)
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
  80d86b:	83 e8 01             	sub    $0x1,%eax
  80d86e:	89 46 60             	mov    %eax,0x60(%esi)
      pcb->state = ESTABLISHED;
  80d871:	c7 46 10 04 00 00 00 	movl   $0x4,0x10(%esi)
      tcp_parseopt(pcb);
  80d878:	89 f0                	mov    %esi,%eax
  80d87a:	e8 e4 ea ff ff       	call   80c363 <tcp_parseopt>
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
  80d87f:	83 ec 08             	sub    $0x8,%esp
  80d882:	8d 46 04             	lea    0x4(%esi),%eax
  80d885:	50                   	push   %eax
  80d886:	0f b7 46 34          	movzwl 0x34(%esi),%eax
  80d88a:	50                   	push   %eax
  80d88b:	e8 e2 8a ff ff       	call   806372 <tcp_eff_send_mss>
  80d890:	66 89 46 34          	mov    %ax,0x34(%esi)
      pcb->ssthresh = pcb->mss * 10;
  80d894:	6b d0 0a             	imul   $0xa,%eax,%edx
  80d897:	66 89 56 50          	mov    %dx,0x50(%esi)
      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80d89b:	83 c4 10             	add    $0x10,%esp
  80d89e:	66 83 7e 4e 01       	cmpw   $0x1,0x4e(%esi)
  80d8a3:	75 02                	jne    80d8a7 <tcp_input+0x78c>
  80d8a5:	01 c0                	add    %eax,%eax
  80d8a7:	66 89 46 4e          	mov    %ax,0x4e(%esi)
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
  80d8ab:	0f b7 46 70          	movzwl 0x70(%esi),%eax
  80d8af:	66 85 c0             	test   %ax,%ax
  80d8b2:	75 17                	jne    80d8cb <tcp_input+0x7b0>
  80d8b4:	83 ec 04             	sub    $0x4,%esp
  80d8b7:	68 09 33 81 00       	push   $0x813309
  80d8bc:	68 35 02 00 00       	push   $0x235
  80d8c1:	68 b0 32 81 00       	push   $0x8132b0
  80d8c6:	e8 88 0d 00 00       	call   80e653 <_panic>
      --pcb->snd_queuelen;
  80d8cb:	83 e8 01             	sub    $0x1,%eax
  80d8ce:	66 89 46 70          	mov    %ax,0x70(%esi)
      rseg = pcb->unacked;
  80d8d2:	8b 46 78             	mov    0x78(%esi),%eax
      pcb->unacked = rseg->next;
  80d8d5:	8b 10                	mov    (%eax),%edx
  80d8d7:	89 56 78             	mov    %edx,0x78(%esi)
      if(pcb->unacked == NULL)
  80d8da:	85 d2                	test   %edx,%edx
  80d8dc:	75 3f                	jne    80d91d <tcp_input+0x802>
        pcb->rtime = -1;
  80d8de:	66 c7 46 32 ff ff    	movw   $0xffff,0x32(%esi)
      tcp_seg_free(rseg);
  80d8e4:	83 ec 0c             	sub    $0xc,%esp
  80d8e7:	50                   	push   %eax
  80d8e8:	e8 d0 7e ff ff       	call   8057bd <tcp_seg_free>
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
  80d8ed:	8b 86 8c 00 00 00    	mov    0x8c(%esi),%eax
  80d8f3:	83 c4 10             	add    $0x10,%esp
  80d8f6:	85 c0                	test   %eax,%eax
  80d8f8:	74 0e                	je     80d908 <tcp_input+0x7ed>
  80d8fa:	83 ec 04             	sub    $0x4,%esp
  80d8fd:	6a 00                	push   $0x0
  80d8ff:	56                   	push   %esi
  80d900:	ff 76 18             	pushl  0x18(%esi)
  80d903:	ff d0                	call   *%eax
  80d905:	83 c4 10             	add    $0x10,%esp
      tcp_ack_now(pcb);
  80d908:	80 4e 20 02          	orb    $0x2,0x20(%esi)
  80d90c:	83 ec 0c             	sub    $0xc,%esp
  80d90f:	56                   	push   %esi
  80d910:	e8 ed a7 ff ff       	call   808102 <tcp_output>
  80d915:	83 c4 10             	add    $0x10,%esp
  80d918:	e9 a3 fb ff ff       	jmp    80d4c0 <tcp_input+0x3a5>
        pcb->rtime = 0;
  80d91d:	66 c7 46 32 00 00    	movw   $0x0,0x32(%esi)
        pcb->nrtx = 0;
  80d923:	c6 46 46 00          	movb   $0x0,0x46(%esi)
  80d927:	eb bb                	jmp    80d8e4 <tcp_input+0x7c9>
    if (flags & TCP_ACK &&
  80d929:	83 e0 14             	and    $0x14,%eax
  80d92c:	3c 10                	cmp    $0x10,%al
  80d92e:	0f 85 8c fb ff ff    	jne    80d4c0 <tcp_input+0x3a5>
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
  80d934:	8b 15 a4 b1 b3 00    	mov    0xb3b1a4,%edx
  80d93a:	8d 42 ff             	lea    -0x1(%edx),%eax
  80d93d:	3b 46 48             	cmp    0x48(%esi),%eax
  80d940:	0f 88 b5 00 00 00    	js     80d9fb <tcp_input+0x8e0>
  80d946:	89 d0                	mov    %edx,%eax
  80d948:	2b 46 54             	sub    0x54(%esi),%eax
  80d94b:	85 c0                	test   %eax,%eax
  80d94d:	0f 8f a8 00 00 00    	jg     80d9fb <tcp_input+0x8e0>
        pcb->state = ESTABLISHED;
  80d953:	c7 46 10 04 00 00 00 	movl   $0x4,0x10(%esi)
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
  80d95a:	8b 86 90 00 00 00    	mov    0x90(%esi),%eax
  80d960:	85 c0                	test   %eax,%eax
  80d962:	74 5c                	je     80d9c0 <tcp_input+0x8a5>
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
  80d964:	83 ec 04             	sub    $0x4,%esp
  80d967:	6a 00                	push   $0x0
  80d969:	56                   	push   %esi
  80d96a:	ff 76 18             	pushl  0x18(%esi)
  80d96d:	ff d0                	call   *%eax
        if (err != ERR_OK) {
  80d96f:	83 c4 10             	add    $0x10,%esp
  80d972:	84 c0                	test   %al,%al
  80d974:	75 61                	jne    80d9d7 <tcp_input+0x8bc>
        old_cwnd = pcb->cwnd;
  80d976:	0f b7 5e 4e          	movzwl 0x4e(%esi),%ebx
        accepted_inseq = tcp_receive(pcb);
  80d97a:	89 f0                	mov    %esi,%eax
  80d97c:	e8 95 ea ff ff       	call   80c416 <tcp_receive>
        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80d981:	66 83 fb 01          	cmp    $0x1,%bx
  80d985:	74 6b                	je     80d9f2 <tcp_input+0x8d7>
  80d987:	0f b7 56 34          	movzwl 0x34(%esi),%edx
  80d98b:	66 89 56 4e          	mov    %dx,0x4e(%esi)
        if ((flags & TCP_FIN) && accepted_inseq) {
  80d98f:	f6 05 a0 b1 b3 00 01 	testb  $0x1,0xb3b1a0
  80d996:	0f 84 24 fb ff ff    	je     80d4c0 <tcp_input+0x3a5>
  80d99c:	84 c0                	test   %al,%al
  80d99e:	0f 84 1c fb ff ff    	je     80d4c0 <tcp_input+0x3a5>
          tcp_ack_now(pcb);
  80d9a4:	80 4e 20 02          	orb    $0x2,0x20(%esi)
  80d9a8:	83 ec 0c             	sub    $0xc,%esp
  80d9ab:	56                   	push   %esi
  80d9ac:	e8 51 a7 ff ff       	call   808102 <tcp_output>
          pcb->state = CLOSE_WAIT;
  80d9b1:	c7 46 10 07 00 00 00 	movl   $0x7,0x10(%esi)
  80d9b8:	83 c4 10             	add    $0x10,%esp
  80d9bb:	e9 00 fb ff ff       	jmp    80d4c0 <tcp_input+0x3a5>
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
  80d9c0:	83 ec 04             	sub    $0x4,%esp
  80d9c3:	68 1f 33 81 00       	push   $0x81331f
  80d9c8:	68 5b 02 00 00       	push   $0x25b
  80d9cd:	68 b0 32 81 00       	push   $0x8132b0
  80d9d2:	e8 7c 0c 00 00       	call   80e653 <_panic>
          tcp_abort(pcb);
  80d9d7:	83 ec 0c             	sub    $0xc,%esp
  80d9da:	56                   	push   %esi
  80d9db:	e8 3e 82 ff ff       	call   805c1e <tcp_abort>
    tcp_input_pcb = NULL;
  80d9e0:	c7 05 58 b2 b3 00 00 	movl   $0x0,0xb3b258
  80d9e7:	00 00 00 
  80d9ea:	83 c4 10             	add    $0x10,%esp
  80d9ed:	e9 1a fb ff ff       	jmp    80d50c <tcp_input+0x3f1>
        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80d9f2:	0f b7 4e 34          	movzwl 0x34(%esi),%ecx
  80d9f6:	8d 14 09             	lea    (%ecx,%ecx,1),%edx
  80d9f9:	eb 90                	jmp    80d98b <tcp_input+0x870>
                tcphdr->dest, tcphdr->src);
  80d9fb:	8b 0d b0 b1 b3 00    	mov    0xb3b1b0,%ecx
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  80da01:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80da06:	83 ec 08             	sub    $0x8,%esp
  80da09:	0f b7 19             	movzwl (%ecx),%ebx
  80da0c:	53                   	push   %ebx
  80da0d:	0f b7 49 02          	movzwl 0x2(%ecx),%ecx
  80da11:	51                   	push   %ecx
  80da12:	8d 48 0c             	lea    0xc(%eax),%ecx
  80da15:	51                   	push   %ecx
  80da16:	83 c0 10             	add    $0x10,%eax
  80da19:	50                   	push   %eax
  80da1a:	0f b7 05 9e b1 b3 00 	movzwl 0xb3b19e,%eax
  80da21:	03 05 a8 b1 b3 00    	add    0xb3b1a8,%eax
  80da27:	50                   	push   %eax
  80da28:	52                   	push   %edx
  80da29:	e8 95 ab ff ff       	call   8085c3 <tcp_rst>
  80da2e:	83 c4 20             	add    $0x20,%esp
  80da31:	e9 8a fa ff ff       	jmp    80d4c0 <tcp_input+0x3a5>
    accepted_inseq = tcp_receive(pcb);
  80da36:	89 f0                	mov    %esi,%eax
  80da38:	e8 d9 e9 ff ff       	call   80c416 <tcp_receive>
    if ((flags & TCP_FIN) && accepted_inseq) { /* passive close */
  80da3d:	f6 05 a0 b1 b3 00 01 	testb  $0x1,0xb3b1a0
  80da44:	0f 84 76 fa ff ff    	je     80d4c0 <tcp_input+0x3a5>
  80da4a:	84 c0                	test   %al,%al
  80da4c:	0f 84 6e fa ff ff    	je     80d4c0 <tcp_input+0x3a5>
      tcp_ack_now(pcb);
  80da52:	80 4e 20 02          	orb    $0x2,0x20(%esi)
  80da56:	83 ec 0c             	sub    $0xc,%esp
  80da59:	56                   	push   %esi
  80da5a:	e8 a3 a6 ff ff       	call   808102 <tcp_output>
      pcb->state = CLOSE_WAIT;
  80da5f:	c7 46 10 07 00 00 00 	movl   $0x7,0x10(%esi)
  80da66:	83 c4 10             	add    $0x10,%esp
  80da69:	e9 52 fa ff ff       	jmp    80d4c0 <tcp_input+0x3a5>
    tcp_receive(pcb);
  80da6e:	89 f0                	mov    %esi,%eax
  80da70:	e8 a1 e9 ff ff       	call   80c416 <tcp_receive>
    if (flags & TCP_FIN) {
  80da75:	0f b6 05 a0 b1 b3 00 	movzbl 0xb3b1a0,%eax
  80da7c:	a8 01                	test   $0x1,%al
  80da7e:	0f 84 bf 00 00 00    	je     80db43 <tcp_input+0xa28>
      if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80da84:	a8 10                	test   $0x10,%al
  80da86:	74 0a                	je     80da92 <tcp_input+0x977>
  80da88:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80da8d:	39 46 54             	cmp    %eax,0x54(%esi)
  80da90:	74 1c                	je     80daae <tcp_input+0x993>
        tcp_ack_now(pcb);
  80da92:	80 4e 20 02          	orb    $0x2,0x20(%esi)
  80da96:	83 ec 0c             	sub    $0xc,%esp
  80da99:	56                   	push   %esi
  80da9a:	e8 63 a6 ff ff       	call   808102 <tcp_output>
        pcb->state = CLOSING;
  80da9f:	c7 46 10 08 00 00 00 	movl   $0x8,0x10(%esi)
  80daa6:	83 c4 10             	add    $0x10,%esp
  80daa9:	e9 12 fa ff ff       	jmp    80d4c0 <tcp_input+0x3a5>
        tcp_ack_now(pcb);
  80daae:	80 4e 20 02          	orb    $0x2,0x20(%esi)
  80dab2:	83 ec 0c             	sub    $0xc,%esp
  80dab5:	56                   	push   %esi
  80dab6:	e8 47 a6 ff ff       	call   808102 <tcp_output>
        tcp_pcb_purge(pcb);
  80dabb:	89 34 24             	mov    %esi,(%esp)
  80dabe:	e8 13 7e ff ff       	call   8058d6 <tcp_pcb_purge>
        TCP_RMV(&tcp_active_pcbs, pcb);
  80dac3:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80dac8:	83 c4 10             	add    $0x10,%esp
  80dacb:	39 c6                	cmp    %eax,%esi
  80dacd:	74 11                	je     80dae0 <tcp_input+0x9c5>
  80dacf:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80dad4:	ba 00 00 00 00       	mov    $0x0,%edx
  80dad9:	bf 01 00 00 00       	mov    $0x1,%edi
  80dade:	eb 3e                	jmp    80db1e <tcp_input+0xa03>
  80dae0:	8b 46 0c             	mov    0xc(%esi),%eax
  80dae3:	a3 3c b2 b3 00       	mov    %eax,0xb3b23c
        pcb->state = TIME_WAIT;
  80dae8:	c7 46 10 0a 00 00 00 	movl   $0xa,0x10(%esi)
        TCP_REG(&tcp_tw_pcbs, pcb);
  80daef:	a1 50 b2 b3 00       	mov    0xb3b250,%eax
  80daf4:	89 46 0c             	mov    %eax,0xc(%esi)
  80daf7:	89 35 50 b2 b3 00    	mov    %esi,0xb3b250
  80dafd:	e8 b5 46 ff ff       	call   8021b7 <tcp_timer_needed>
  80db02:	e9 b9 f9 ff ff       	jmp    80d4c0 <tcp_input+0x3a5>
        TCP_RMV(&tcp_active_pcbs, pcb);
  80db07:	8b 48 0c             	mov    0xc(%eax),%ecx
  80db0a:	39 ce                	cmp    %ecx,%esi
  80db0c:	0f 94 c3             	sete   %bl
  80db0f:	85 c9                	test   %ecx,%ecx
  80db11:	0f 95 45 d6          	setne  -0x2a(%ebp)
  80db15:	84 5d d6             	test   %bl,-0x2a(%ebp)
  80db18:	75 18                	jne    80db32 <tcp_input+0xa17>
  80db1a:	89 fa                	mov    %edi,%edx
  80db1c:	89 c8                	mov    %ecx,%eax
  80db1e:	85 c0                	test   %eax,%eax
  80db20:	75 e5                	jne    80db07 <tcp_input+0x9ec>
  80db22:	84 d2                	test   %dl,%dl
  80db24:	74 c2                	je     80dae8 <tcp_input+0x9cd>
  80db26:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  80db2d:	00 00 00 
  80db30:	eb b6                	jmp    80dae8 <tcp_input+0x9cd>
  80db32:	84 d2                	test   %dl,%dl
  80db34:	74 05                	je     80db3b <tcp_input+0xa20>
  80db36:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80db3b:	8b 56 0c             	mov    0xc(%esi),%edx
  80db3e:	89 50 0c             	mov    %edx,0xc(%eax)
  80db41:	eb a5                	jmp    80dae8 <tcp_input+0x9cd>
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80db43:	a8 10                	test   $0x10,%al
  80db45:	0f 84 75 f9 ff ff    	je     80d4c0 <tcp_input+0x3a5>
  80db4b:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80db50:	39 46 54             	cmp    %eax,0x54(%esi)
  80db53:	0f 85 67 f9 ff ff    	jne    80d4c0 <tcp_input+0x3a5>
      pcb->state = FIN_WAIT_2;
  80db59:	c7 46 10 06 00 00 00 	movl   $0x6,0x10(%esi)
  80db60:	e9 5b f9 ff ff       	jmp    80d4c0 <tcp_input+0x3a5>
    tcp_receive(pcb);
  80db65:	89 f0                	mov    %esi,%eax
  80db67:	e8 aa e8 ff ff       	call   80c416 <tcp_receive>
    if (flags & TCP_FIN) {
  80db6c:	f6 05 a0 b1 b3 00 01 	testb  $0x1,0xb3b1a0
  80db73:	0f 84 47 f9 ff ff    	je     80d4c0 <tcp_input+0x3a5>
      tcp_ack_now(pcb);
  80db79:	80 4e 20 02          	orb    $0x2,0x20(%esi)
  80db7d:	83 ec 0c             	sub    $0xc,%esp
  80db80:	56                   	push   %esi
  80db81:	e8 7c a5 ff ff       	call   808102 <tcp_output>
      tcp_pcb_purge(pcb);
  80db86:	89 34 24             	mov    %esi,(%esp)
  80db89:	e8 48 7d ff ff       	call   8058d6 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  80db8e:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80db93:	83 c4 10             	add    $0x10,%esp
  80db96:	39 c6                	cmp    %eax,%esi
  80db98:	74 2c                	je     80dbc6 <tcp_input+0xaab>
  80db9a:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80db9f:	ba 00 00 00 00       	mov    $0x0,%edx
  80dba4:	bf 01 00 00 00       	mov    $0x1,%edi
  80dba9:	85 c0                	test   %eax,%eax
  80dbab:	74 53                	je     80dc00 <tcp_input+0xae5>
  80dbad:	8b 48 0c             	mov    0xc(%eax),%ecx
  80dbb0:	39 ce                	cmp    %ecx,%esi
  80dbb2:	0f 94 c3             	sete   %bl
  80dbb5:	85 c9                	test   %ecx,%ecx
  80dbb7:	0f 95 45 d6          	setne  -0x2a(%ebp)
  80dbbb:	84 5d d6             	test   %bl,-0x2a(%ebp)
  80dbbe:	75 2d                	jne    80dbed <tcp_input+0xad2>
  80dbc0:	89 fa                	mov    %edi,%edx
  80dbc2:	89 c8                	mov    %ecx,%eax
  80dbc4:	eb e3                	jmp    80dba9 <tcp_input+0xa8e>
  80dbc6:	8b 46 0c             	mov    0xc(%esi),%eax
  80dbc9:	a3 3c b2 b3 00       	mov    %eax,0xb3b23c
      pcb->state = TIME_WAIT;
  80dbce:	c7 46 10 0a 00 00 00 	movl   $0xa,0x10(%esi)
      TCP_REG(&tcp_tw_pcbs, pcb);
  80dbd5:	a1 50 b2 b3 00       	mov    0xb3b250,%eax
  80dbda:	89 46 0c             	mov    %eax,0xc(%esi)
  80dbdd:	89 35 50 b2 b3 00    	mov    %esi,0xb3b250
  80dbe3:	e8 cf 45 ff ff       	call   8021b7 <tcp_timer_needed>
  80dbe8:	e9 d3 f8 ff ff       	jmp    80d4c0 <tcp_input+0x3a5>
  80dbed:	84 d2                	test   %dl,%dl
  80dbef:	75 08                	jne    80dbf9 <tcp_input+0xade>
      TCP_RMV(&tcp_active_pcbs, pcb);
  80dbf1:	8b 56 0c             	mov    0xc(%esi),%edx
  80dbf4:	89 50 0c             	mov    %edx,0xc(%eax)
  80dbf7:	eb d5                	jmp    80dbce <tcp_input+0xab3>
  80dbf9:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80dbfe:	eb f1                	jmp    80dbf1 <tcp_input+0xad6>
  80dc00:	84 d2                	test   %dl,%dl
  80dc02:	74 ca                	je     80dbce <tcp_input+0xab3>
  80dc04:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  80dc0b:	00 00 00 
  80dc0e:	eb be                	jmp    80dbce <tcp_input+0xab3>
    tcp_receive(pcb);
  80dc10:	89 f0                	mov    %esi,%eax
  80dc12:	e8 ff e7 ff ff       	call   80c416 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80dc17:	f6 05 a0 b1 b3 00 10 	testb  $0x10,0xb3b1a0
  80dc1e:	0f 84 9c f8 ff ff    	je     80d4c0 <tcp_input+0x3a5>
  80dc24:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80dc29:	39 46 54             	cmp    %eax,0x54(%esi)
  80dc2c:	0f 85 8e f8 ff ff    	jne    80d4c0 <tcp_input+0x3a5>
      tcp_ack_now(pcb);
  80dc32:	80 4e 20 02          	orb    $0x2,0x20(%esi)
  80dc36:	83 ec 0c             	sub    $0xc,%esp
  80dc39:	56                   	push   %esi
  80dc3a:	e8 c3 a4 ff ff       	call   808102 <tcp_output>
      tcp_pcb_purge(pcb);
  80dc3f:	89 34 24             	mov    %esi,(%esp)
  80dc42:	e8 8f 7c ff ff       	call   8058d6 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  80dc47:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80dc4c:	83 c4 10             	add    $0x10,%esp
  80dc4f:	39 c6                	cmp    %eax,%esi
  80dc51:	74 11                	je     80dc64 <tcp_input+0xb49>
  80dc53:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80dc58:	ba 00 00 00 00       	mov    $0x0,%edx
  80dc5d:	bf 01 00 00 00       	mov    $0x1,%edi
  80dc62:	eb 3e                	jmp    80dca2 <tcp_input+0xb87>
  80dc64:	8b 46 0c             	mov    0xc(%esi),%eax
  80dc67:	a3 3c b2 b3 00       	mov    %eax,0xb3b23c
      pcb->state = TIME_WAIT;
  80dc6c:	c7 46 10 0a 00 00 00 	movl   $0xa,0x10(%esi)
      TCP_REG(&tcp_tw_pcbs, pcb);
  80dc73:	a1 50 b2 b3 00       	mov    0xb3b250,%eax
  80dc78:	89 46 0c             	mov    %eax,0xc(%esi)
  80dc7b:	89 35 50 b2 b3 00    	mov    %esi,0xb3b250
  80dc81:	e8 31 45 ff ff       	call   8021b7 <tcp_timer_needed>
  80dc86:	e9 35 f8 ff ff       	jmp    80d4c0 <tcp_input+0x3a5>
      TCP_RMV(&tcp_active_pcbs, pcb);
  80dc8b:	8b 48 0c             	mov    0xc(%eax),%ecx
  80dc8e:	39 ce                	cmp    %ecx,%esi
  80dc90:	0f 94 c3             	sete   %bl
  80dc93:	85 c9                	test   %ecx,%ecx
  80dc95:	0f 95 45 d6          	setne  -0x2a(%ebp)
  80dc99:	84 5d d6             	test   %bl,-0x2a(%ebp)
  80dc9c:	75 18                	jne    80dcb6 <tcp_input+0xb9b>
  80dc9e:	89 fa                	mov    %edi,%edx
  80dca0:	89 c8                	mov    %ecx,%eax
  80dca2:	85 c0                	test   %eax,%eax
  80dca4:	75 e5                	jne    80dc8b <tcp_input+0xb70>
  80dca6:	84 d2                	test   %dl,%dl
  80dca8:	74 c2                	je     80dc6c <tcp_input+0xb51>
  80dcaa:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  80dcb1:	00 00 00 
  80dcb4:	eb b6                	jmp    80dc6c <tcp_input+0xb51>
  80dcb6:	84 d2                	test   %dl,%dl
  80dcb8:	74 05                	je     80dcbf <tcp_input+0xba4>
  80dcba:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80dcbf:	8b 56 0c             	mov    0xc(%esi),%edx
  80dcc2:	89 50 0c             	mov    %edx,0xc(%eax)
  80dcc5:	eb a5                	jmp    80dc6c <tcp_input+0xb51>
    tcp_receive(pcb);
  80dcc7:	89 f0                	mov    %esi,%eax
  80dcc9:	e8 48 e7 ff ff       	call   80c416 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80dcce:	f6 05 a0 b1 b3 00 10 	testb  $0x10,0xb3b1a0
  80dcd5:	0f 84 e5 f7 ff ff    	je     80d4c0 <tcp_input+0x3a5>
  80dcdb:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80dce0:	39 46 54             	cmp    %eax,0x54(%esi)
  80dce3:	0f 85 d7 f7 ff ff    	jne    80d4c0 <tcp_input+0x3a5>
      recv_flags = TF_CLOSED;
  80dce9:	c6 05 9c b1 b3 00 10 	movb   $0x10,0xb3b19c
  80dcf0:	e9 cb f7 ff ff       	jmp    80d4c0 <tcp_input+0x3a5>
    tcp_input_pcb = NULL;
  80dcf5:	c7 05 58 b2 b3 00 00 	movl   $0x0,0xb3b258
  80dcfc:	00 00 00 
  80dcff:	e9 c6 f7 ff ff       	jmp    80d4ca <tcp_input+0x3af>
      } else if (recv_flags & TF_CLOSED) {
  80dd04:	a8 10                	test   $0x10,%al
  80dd06:	0f 85 9a 00 00 00    	jne    80dda6 <tcp_input+0xc8b>
        if (pcb->acked > 0) {
  80dd0c:	0f b7 56 6c          	movzwl 0x6c(%esi),%edx
        err = ERR_OK;
  80dd10:	b8 00 00 00 00       	mov    $0x0,%eax
        if (pcb->acked > 0) {
  80dd15:	66 85 d2             	test   %dx,%dx
  80dd18:	74 1e                	je     80dd38 <tcp_input+0xc1d>
          TCP_EVENT_SENT(pcb, pcb->acked, err);
  80dd1a:	8b 86 84 00 00 00    	mov    0x84(%esi),%eax
  80dd20:	85 c0                	test   %eax,%eax
  80dd22:	0f 84 9f 00 00 00    	je     80ddc7 <tcp_input+0xcac>
  80dd28:	83 ec 04             	sub    $0x4,%esp
  80dd2b:	0f b7 d2             	movzwl %dx,%edx
  80dd2e:	52                   	push   %edx
  80dd2f:	56                   	push   %esi
  80dd30:	ff 76 18             	pushl  0x18(%esi)
  80dd33:	ff d0                	call   *%eax
  80dd35:	83 c4 10             	add    $0x10,%esp
        if (recv_data != NULL) {
  80dd38:	8b 15 98 b1 b3 00    	mov    0xb3b198,%edx
  80dd3e:	85 d2                	test   %edx,%edx
  80dd40:	0f 84 b6 00 00 00    	je     80ddfc <tcp_input+0xce1>
          if(flags & TCP_PSH) {
  80dd46:	f6 05 a0 b1 b3 00 08 	testb  $0x8,0xb3b1a0
  80dd4d:	74 04                	je     80dd53 <tcp_input+0xc38>
            recv_data->flags |= PBUF_FLAG_PUSH;
  80dd4f:	80 4a 0d 01          	orb    $0x1,0xd(%edx)
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  80dd53:	8b 86 88 00 00 00    	mov    0x88(%esi),%eax
  80dd59:	85 c0                	test   %eax,%eax
  80dd5b:	74 74                	je     80ddd1 <tcp_input+0xcb6>
  80dd5d:	6a 00                	push   $0x0
  80dd5f:	52                   	push   %edx
  80dd60:	56                   	push   %esi
  80dd61:	ff 76 18             	pushl  0x18(%esi)
  80dd64:	ff d0                	call   *%eax
          if (err != ERR_OK) {
  80dd66:	83 c4 10             	add    $0x10,%esp
  80dd69:	84 c0                	test   %al,%al
  80dd6b:	75 72                	jne    80dddf <tcp_input+0xcc4>
        if (recv_flags & TF_GOT_FIN) {
  80dd6d:	f6 05 9c b1 b3 00 20 	testb  $0x20,0xb3b19c
  80dd74:	74 1f                	je     80dd95 <tcp_input+0xc7a>
          TCP_EVENT_RECV(pcb, NULL, ERR_OK, err);
  80dd76:	8b 86 88 00 00 00    	mov    0x88(%esi),%eax
  80dd7c:	85 c0                	test   %eax,%eax
  80dd7e:	74 15                	je     80dd95 <tcp_input+0xc7a>
  80dd80:	6a 00                	push   $0x0
  80dd82:	6a 00                	push   $0x0
  80dd84:	56                   	push   %esi
  80dd85:	ff 76 18             	pushl  0x18(%esi)
  80dd88:	ff d0                	call   *%eax
  80dd8a:	83 c4 10             	add    $0x10,%esp
        if (err == ERR_OK) {
  80dd8d:	84 c0                	test   %al,%al
  80dd8f:	0f 85 77 f7 ff ff    	jne    80d50c <tcp_input+0x3f1>
          tcp_output(pcb);
  80dd95:	83 ec 0c             	sub    $0xc,%esp
  80dd98:	56                   	push   %esi
  80dd99:	e8 64 a3 ff ff       	call   808102 <tcp_output>
  80dd9e:	83 c4 10             	add    $0x10,%esp
  80dda1:	e9 66 f7 ff ff       	jmp    80d50c <tcp_input+0x3f1>
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80dda6:	83 ec 08             	sub    $0x8,%esp
  80dda9:	56                   	push   %esi
  80ddaa:	68 3c b2 b3 00       	push   $0xb3b23c
  80ddaf:	e8 9e 7b ff ff       	call   805952 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  80ddb4:	83 c4 08             	add    $0x8,%esp
  80ddb7:	56                   	push   %esi
  80ddb8:	6a 02                	push   $0x2
  80ddba:	e8 1f 67 ff ff       	call   8044de <memp_free>
  80ddbf:	83 c4 10             	add    $0x10,%esp
  80ddc2:	e9 45 f7 ff ff       	jmp    80d50c <tcp_input+0x3f1>
        err = ERR_OK;
  80ddc7:	b8 00 00 00 00       	mov    $0x0,%eax
  80ddcc:	e9 67 ff ff ff       	jmp    80dd38 <tcp_input+0xc1d>
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  80ddd1:	83 ec 0c             	sub    $0xc,%esp
  80ddd4:	52                   	push   %edx
  80ddd5:	e8 73 6a ff ff       	call   80484d <pbuf_free>
  80ddda:	83 c4 10             	add    $0x10,%esp
  80dddd:	eb 8e                	jmp    80dd6d <tcp_input+0xc52>
            pcb->refused_data = recv_data;
  80dddf:	a1 98 b1 b3 00       	mov    0xb3b198,%eax
  80dde4:	89 86 80 00 00 00    	mov    %eax,0x80(%esi)
        if (recv_flags & TF_GOT_FIN) {
  80ddea:	f6 05 9c b1 b3 00 20 	testb  $0x20,0xb3b19c
  80ddf1:	0f 84 15 f7 ff ff    	je     80d50c <tcp_input+0x3f1>
  80ddf7:	e9 7a ff ff ff       	jmp    80dd76 <tcp_input+0xc5b>
  80ddfc:	f6 05 9c b1 b3 00 20 	testb  $0x20,0xb3b19c
  80de03:	0f 85 6d ff ff ff    	jne    80dd76 <tcp_input+0xc5b>
  80de09:	eb 82                	jmp    80dd8d <tcp_input+0xc72>
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
  80de0b:	83 ec 0c             	sub    $0xc,%esp
  80de0e:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  80de12:	50                   	push   %eax
  80de13:	e8 77 99 ff ff       	call   80778f <ntohs>
  80de18:	83 c4 10             	add    $0x10,%esp
  80de1b:	a8 04                	test   $0x4,%al
  80de1d:	74 11                	je     80de30 <tcp_input+0xd15>
    pbuf_free(p);
  80de1f:	83 ec 0c             	sub    $0xc,%esp
  80de22:	53                   	push   %ebx
  80de23:	e8 25 6a ff ff       	call   80484d <pbuf_free>
  80de28:	83 c4 10             	add    $0x10,%esp
  80de2b:	e9 56 f3 ff ff       	jmp    80d186 <tcp_input+0x6b>
        tcphdr->dest, tcphdr->src);
  80de30:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
        &(iphdr->dest), &(iphdr->src),
  80de36:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
      tcp_rst(ackno, seqno + tcplen,
  80de3b:	83 ec 08             	sub    $0x8,%esp
  80de3e:	0f b7 0a             	movzwl (%edx),%ecx
  80de41:	51                   	push   %ecx
  80de42:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  80de46:	52                   	push   %edx
  80de47:	8d 50 0c             	lea    0xc(%eax),%edx
  80de4a:	52                   	push   %edx
  80de4b:	83 c0 10             	add    $0x10,%eax
  80de4e:	50                   	push   %eax
  80de4f:	0f b7 05 9e b1 b3 00 	movzwl 0xb3b19e,%eax
  80de56:	03 05 a8 b1 b3 00    	add    0xb3b1a8,%eax
  80de5c:	50                   	push   %eax
  80de5d:	ff 35 a4 b1 b3 00    	pushl  0xb3b1a4
  80de63:	e8 5b a7 ff ff       	call   8085c3 <tcp_rst>
  80de68:	83 c4 20             	add    $0x20,%esp
  80de6b:	eb b2                	jmp    80de1f <tcp_input+0xd04>

0080de6d <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
  80de6d:	55                   	push   %ebp
  80de6e:	89 e5                	mov    %esp,%ebp
  80de70:	57                   	push   %edi
  80de71:	56                   	push   %esi
  80de72:	53                   	push   %ebx
  80de73:	83 ec 28             	sub    $0x28,%esp
  s16_t proto;
  u8_t eaten = 0;

  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
  80de76:	8b 45 08             	mov    0x8(%ebp),%eax
  80de79:	8b 78 04             	mov    0x4(%eax),%edi
  proto = IPH_PROTO(iphdr);
  80de7c:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80de80:	50                   	push   %eax
  80de81:	e8 09 99 ff ff       	call   80778f <ntohs>

  prev = NULL;
  pcb = raw_pcbs;
  80de86:	8b 1d c8 b1 b3 00    	mov    0xb3b1c8,%ebx
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  80de8c:	83 c4 10             	add    $0x10,%esp
  u8_t eaten = 0;
  80de8f:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  prev = NULL;
  80de93:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    if (pcb->protocol == proto) {
  80de9a:	0f b6 f0             	movzbl %al,%esi
      /* receive callback function available? */
      if (pcb->recv != NULL) {
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
  80de9d:	83 c7 0c             	add    $0xc,%edi
  while ((eaten == 0) && (pcb != NULL)) {
  80dea0:	eb 11                	jmp    80deb3 <raw_input+0x46>
        {
          /* receive function ate the packet */
          p = NULL;
          eaten = 1;
  80dea2:	c6 45 e7 01          	movb   $0x1,-0x19(%ebp)
          p = NULL;
  80dea6:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
        }
      }
      /* no receive callback function was set for this raw PCB */
      /* drop the packet */
    }
    prev = pcb;
  80dead:	89 5d e0             	mov    %ebx,-0x20(%ebp)
    pcb = pcb->next;
  80deb0:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  while ((eaten == 0) && (pcb != NULL)) {
  80deb3:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
  80deb7:	75 4c                	jne    80df05 <raw_input+0x98>
  80deb9:	85 db                	test   %ebx,%ebx
  80debb:	74 48                	je     80df05 <raw_input+0x98>
    if (pcb->protocol == proto) {
  80debd:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  80dec1:	39 f0                	cmp    %esi,%eax
  80dec3:	75 e8                	jne    80dead <raw_input+0x40>
      if (pcb->recv != NULL) {
  80dec5:	8b 43 14             	mov    0x14(%ebx),%eax
  80dec8:	85 c0                	test   %eax,%eax
  80deca:	74 e1                	je     80dead <raw_input+0x40>
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
  80decc:	57                   	push   %edi
  80decd:	ff 75 08             	pushl  0x8(%ebp)
  80ded0:	53                   	push   %ebx
  80ded1:	ff 73 18             	pushl  0x18(%ebx)
  80ded4:	ff d0                	call   *%eax
  80ded6:	83 c4 10             	add    $0x10,%esp
  80ded9:	84 c0                	test   %al,%al
  80dedb:	74 d0                	je     80dead <raw_input+0x40>
          if (prev != NULL) {
  80dedd:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80dee0:	85 d2                	test   %edx,%edx
  80dee2:	74 be                	je     80dea2 <raw_input+0x35>
            prev->next = pcb->next;
  80dee4:	8b 43 0c             	mov    0xc(%ebx),%eax
  80dee7:	89 42 0c             	mov    %eax,0xc(%edx)
            pcb->next = raw_pcbs;
  80deea:	a1 c8 b1 b3 00       	mov    0xb3b1c8,%eax
  80deef:	89 43 0c             	mov    %eax,0xc(%ebx)
            raw_pcbs = pcb;
  80def2:	89 1d c8 b1 b3 00    	mov    %ebx,0xb3b1c8
          eaten = 1;
  80def8:	c6 45 e7 01          	movb   $0x1,-0x19(%ebp)
          p = NULL;
  80defc:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
  80df03:	eb a8                	jmp    80dead <raw_input+0x40>
  }
  return eaten;
}
  80df05:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
  80df09:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80df0c:	5b                   	pop    %ebx
  80df0d:	5e                   	pop    %esi
  80df0e:	5f                   	pop    %edi
  80df0f:	5d                   	pop    %ebp
  80df10:	c3                   	ret    

0080df11 <raw_bind>:
 *
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  80df11:	55                   	push   %ebp
  80df12:	89 e5                	mov    %esp,%ebp
  80df14:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&pcb->local_ip, ipaddr);
  80df17:	b8 00 00 00 00       	mov    $0x0,%eax
  80df1c:	85 d2                	test   %edx,%edx
  80df1e:	74 02                	je     80df22 <raw_bind+0x11>
  80df20:	8b 02                	mov    (%edx),%eax
  80df22:	8b 55 08             	mov    0x8(%ebp),%edx
  80df25:	89 02                	mov    %eax,(%edx)
  return ERR_OK;
}
  80df27:	b8 00 00 00 00       	mov    $0x0,%eax
  80df2c:	5d                   	pop    %ebp
  80df2d:	c3                   	ret    

0080df2e <raw_connect>:
 *
 * @see raw_disconnect() and raw_sendto()
 */
err_t
raw_connect(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  80df2e:	55                   	push   %ebp
  80df2f:	89 e5                	mov    %esp,%ebp
  80df31:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&pcb->remote_ip, ipaddr);
  80df34:	b8 00 00 00 00       	mov    $0x0,%eax
  80df39:	85 d2                	test   %edx,%edx
  80df3b:	74 02                	je     80df3f <raw_connect+0x11>
  80df3d:	8b 02                	mov    (%edx),%eax
  80df3f:	8b 55 08             	mov    0x8(%ebp),%edx
  80df42:	89 42 04             	mov    %eax,0x4(%edx)
  return ERR_OK;
}
  80df45:	b8 00 00 00 00       	mov    $0x0,%eax
  80df4a:	5d                   	pop    %ebp
  80df4b:	c3                   	ret    

0080df4c <raw_recv>:
void
raw_recv(struct raw_pcb *pcb,
         u8_t (* recv)(void *arg, struct raw_pcb *upcb, struct pbuf *p,
                      struct ip_addr *addr),
         void *recv_arg)
{
  80df4c:	55                   	push   %ebp
  80df4d:	89 e5                	mov    %esp,%ebp
  80df4f:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  80df52:	8b 55 0c             	mov    0xc(%ebp),%edx
  80df55:	89 50 14             	mov    %edx,0x14(%eax)
  pcb->recv_arg = recv_arg;
  80df58:	8b 55 10             	mov    0x10(%ebp),%edx
  80df5b:	89 50 18             	mov    %edx,0x18(%eax)
}
  80df5e:	5d                   	pop    %ebp
  80df5f:	c3                   	ret    

0080df60 <raw_sendto>:
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, struct ip_addr *ipaddr)
{
  80df60:	55                   	push   %ebp
  80df61:	89 e5                	mov    %esp,%ebp
  80df63:	57                   	push   %edi
  80df64:	56                   	push   %esi
  80df65:	53                   	push   %ebx
  80df66:	83 ec 24             	sub    $0x24,%esp
  80df69:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80df6c:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_sendto\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
  80df6f:	6a 14                	push   $0x14
  80df71:	56                   	push   %esi
  80df72:	e8 02 68 ff ff       	call   804779 <pbuf_header>
  80df77:	83 c4 10             	add    $0x10,%esp
  80df7a:	84 c0                	test   %al,%al
  80df7c:	74 51                	je     80dfcf <raw_sendto+0x6f>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
  80df7e:	83 ec 04             	sub    $0x4,%esp
  80df81:	6a 00                	push   $0x0
  80df83:	6a 00                	push   $0x0
  80df85:	6a 01                	push   $0x1
  80df87:	e8 87 69 ff ff       	call   804913 <pbuf_alloc>
  80df8c:	89 c7                	mov    %eax,%edi
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  80df8e:	83 c4 10             	add    $0x10,%esp
  80df91:	85 c0                	test   %eax,%eax
  80df93:	0f 84 c4 00 00 00    	je     80e05d <raw_sendto+0xfd>
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 2, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  80df99:	83 ec 08             	sub    $0x8,%esp
  80df9c:	56                   	push   %esi
  80df9d:	50                   	push   %eax
  80df9e:	e8 82 6d ff ff       	call   804d25 <pbuf_chain>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
      return ERR_MEM;
    }
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
  80dfa3:	83 c4 04             	add    $0x4,%esp
  80dfa6:	ff 75 10             	pushl  0x10(%ebp)
  80dfa9:	e8 cf 85 ff ff       	call   80657d <ip_route>
  80dfae:	83 c4 10             	add    $0x10,%esp
  80dfb1:	85 c0                	test   %eax,%eax
  80dfb3:	75 44                	jne    80dff9 <raw_sendto+0x99>
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
  80dfb5:	39 fe                	cmp    %edi,%esi
  80dfb7:	0f 84 a6 00 00 00    	je     80e063 <raw_sendto+0x103>
      pbuf_free(q);
  80dfbd:	83 ec 0c             	sub    $0xc,%esp
  80dfc0:	57                   	push   %edi
  80dfc1:	e8 87 68 ff ff       	call   80484d <pbuf_free>
  80dfc6:	83 c4 10             	add    $0x10,%esp
    }
    return ERR_RTE;
  80dfc9:	c6 45 e7 fc          	movb   $0xfc,-0x19(%ebp)
  80dfcd:	eb 6b                	jmp    80e03a <raw_sendto+0xda>
    if(pbuf_header(q, -IP_HLEN)) {
  80dfcf:	83 ec 08             	sub    $0x8,%esp
  80dfd2:	6a ec                	push   $0xffffffec
  80dfd4:	56                   	push   %esi
  80dfd5:	e8 9f 67 ff ff       	call   804779 <pbuf_header>
  80dfda:	83 c4 10             	add    $0x10,%esp
  80dfdd:	84 c0                	test   %al,%al
  80dfdf:	75 65                	jne    80e046 <raw_sendto+0xe6>
  if ((netif = ip_route(ipaddr)) == NULL) {
  80dfe1:	83 ec 0c             	sub    $0xc,%esp
  80dfe4:	ff 75 10             	pushl  0x10(%ebp)
  80dfe7:	e8 91 85 ff ff       	call   80657d <ip_route>
  80dfec:	83 c4 10             	add    $0x10,%esp
    return ERR_RTE;
  80dfef:	c6 45 e7 fc          	movb   $0xfc,-0x19(%ebp)
    q = p;
  80dff3:	89 f7                	mov    %esi,%edi
  if ((netif = ip_route(ipaddr)) == NULL) {
  80dff5:	85 c0                	test   %eax,%eax
  80dff7:	74 41                	je     80e03a <raw_sendto+0xda>
  }

  if (ip_addr_isany(&pcb->local_ip)) {
  80dff9:	89 da                	mov    %ebx,%edx
  80dffb:	85 db                	test   %ebx,%ebx
  80dffd:	74 05                	je     80e004 <raw_sendto+0xa4>
  80dfff:	83 3b 00             	cmpl   $0x0,(%ebx)
  80e002:	75 03                	jne    80e007 <raw_sendto+0xa7>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  80e004:	8d 50 04             	lea    0x4(%eax),%edx
  }

#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
  err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
  80e007:	83 ec 04             	sub    $0x4,%esp
  80e00a:	50                   	push   %eax
  80e00b:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  80e00f:	50                   	push   %eax
  80e010:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  80e014:	50                   	push   %eax
  80e015:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  80e019:	50                   	push   %eax
  80e01a:	ff 75 10             	pushl  0x10(%ebp)
  80e01d:	52                   	push   %edx
  80e01e:	57                   	push   %edi
  80e01f:	e8 ce 88 ff ff       	call   8068f2 <ip_output_if>
  80e024:	88 45 e7             	mov    %al,-0x19(%ebp)
#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = NULL;
#endif /* LWIP_NETIF_HWADDRHINT*/

  /* did we chain a header earlier? */
  if (q != p) {
  80e027:	83 c4 20             	add    $0x20,%esp
  80e02a:	39 fe                	cmp    %edi,%esi
  80e02c:	74 0c                	je     80e03a <raw_sendto+0xda>
    /* free the header */
    pbuf_free(q);
  80e02e:	83 ec 0c             	sub    $0xc,%esp
  80e031:	57                   	push   %edi
  80e032:	e8 16 68 ff ff       	call   80484d <pbuf_free>
  80e037:	83 c4 10             	add    $0x10,%esp
  }
  return err;
}
  80e03a:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
  80e03e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e041:	5b                   	pop    %ebx
  80e042:	5e                   	pop    %esi
  80e043:	5f                   	pop    %edi
  80e044:	5d                   	pop    %ebp
  80e045:	c3                   	ret    
      LWIP_ASSERT("Can't restore header we just removed!", 0);
  80e046:	83 ec 04             	sub    $0x4,%esp
  80e049:	68 5c 33 81 00       	push   $0x81335c
  80e04e:	68 e3 00 00 00       	push   $0xe3
  80e053:	68 82 33 81 00       	push   $0x813382
  80e058:	e8 f6 05 00 00       	call   80e653 <_panic>
      return ERR_MEM;
  80e05d:	c6 45 e7 ff          	movb   $0xff,-0x19(%ebp)
  80e061:	eb d7                	jmp    80e03a <raw_sendto+0xda>
    return ERR_RTE;
  80e063:	c6 45 e7 fc          	movb   $0xfc,-0x19(%ebp)
  80e067:	eb d1                	jmp    80e03a <raw_sendto+0xda>

0080e069 <raw_send>:
 * @param p the IP payload to send
 *
 */
err_t
raw_send(struct raw_pcb *pcb, struct pbuf *p)
{
  80e069:	55                   	push   %ebp
  80e06a:	89 e5                	mov    %esp,%ebp
  80e06c:	83 ec 0c             	sub    $0xc,%esp
  80e06f:	8b 45 08             	mov    0x8(%ebp),%eax
  return raw_sendto(pcb, p, &pcb->remote_ip);
  80e072:	8d 50 04             	lea    0x4(%eax),%edx
  80e075:	52                   	push   %edx
  80e076:	ff 75 0c             	pushl  0xc(%ebp)
  80e079:	50                   	push   %eax
  80e07a:	e8 e1 fe ff ff       	call   80df60 <raw_sendto>
}
  80e07f:	c9                   	leave  
  80e080:	c3                   	ret    

0080e081 <raw_remove>:
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
  80e081:	55                   	push   %ebp
  80e082:	89 e5                	mov    %esp,%ebp
  80e084:	83 ec 08             	sub    $0x8,%esp
  80e087:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
  80e08a:	a1 c8 b1 b3 00       	mov    0xb3b1c8,%eax
  80e08f:	39 c8                	cmp    %ecx,%eax
  80e091:	75 1b                	jne    80e0ae <raw_remove+0x2d>
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
  80e093:	8b 40 0c             	mov    0xc(%eax),%eax
  80e096:	a3 c8 b1 b3 00       	mov    %eax,0xb3b1c8
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
  80e09b:	83 ec 08             	sub    $0x8,%esp
  80e09e:	51                   	push   %ecx
  80e09f:	6a 00                	push   $0x0
  80e0a1:	e8 38 64 ff ff       	call   8044de <memp_free>
}
  80e0a6:	83 c4 10             	add    $0x10,%esp
  80e0a9:	c9                   	leave  
  80e0aa:	c3                   	ret    
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  80e0ab:	8b 40 0c             	mov    0xc(%eax),%eax
  80e0ae:	85 c0                	test   %eax,%eax
  80e0b0:	74 e9                	je     80e09b <raw_remove+0x1a>
      if (pcb2->next != NULL && pcb2->next == pcb) {
  80e0b2:	8b 50 0c             	mov    0xc(%eax),%edx
  80e0b5:	39 ca                	cmp    %ecx,%edx
  80e0b7:	75 f2                	jne    80e0ab <raw_remove+0x2a>
  80e0b9:	85 d2                	test   %edx,%edx
  80e0bb:	74 ee                	je     80e0ab <raw_remove+0x2a>
        pcb2->next = pcb->next;
  80e0bd:	8b 51 0c             	mov    0xc(%ecx),%edx
  80e0c0:	89 50 0c             	mov    %edx,0xc(%eax)
  80e0c3:	eb e6                	jmp    80e0ab <raw_remove+0x2a>

0080e0c5 <raw_new>:
 * @param proto the protocol number of the IPs payload (e.g. IP_PROTO_ICMP)
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u8_t proto) {
  80e0c5:	55                   	push   %ebp
  80e0c6:	89 e5                	mov    %esp,%ebp
  80e0c8:	56                   	push   %esi
  80e0c9:	53                   	push   %ebx
  80e0ca:	8b 75 08             	mov    0x8(%ebp),%esi
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_new\n"));

  pcb = memp_malloc(MEMP_RAW_PCB);
  80e0cd:	83 ec 0c             	sub    $0xc,%esp
  80e0d0:	6a 00                	push   $0x0
  80e0d2:	e8 b1 63 ff ff       	call   804488 <memp_malloc>
  80e0d7:	89 c3                	mov    %eax,%ebx
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
  80e0d9:	83 c4 10             	add    $0x10,%esp
  80e0dc:	85 c0                	test   %eax,%eax
  80e0de:	74 27                	je     80e107 <raw_new+0x42>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
  80e0e0:	83 ec 04             	sub    $0x4,%esp
  80e0e3:	6a 1c                	push   $0x1c
  80e0e5:	6a 00                	push   $0x0
  80e0e7:	50                   	push   %eax
  80e0e8:	e8 1f 0e 00 00       	call   80ef0c <memset>
    pcb->protocol = proto;
  80e0ed:	89 f0                	mov    %esi,%eax
  80e0ef:	88 43 10             	mov    %al,0x10(%ebx)
    pcb->ttl = RAW_TTL;
  80e0f2:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
    pcb->next = raw_pcbs;
  80e0f6:	a1 c8 b1 b3 00       	mov    0xb3b1c8,%eax
  80e0fb:	89 43 0c             	mov    %eax,0xc(%ebx)
    raw_pcbs = pcb;
  80e0fe:	89 1d c8 b1 b3 00    	mov    %ebx,0xb3b1c8
  80e104:	83 c4 10             	add    $0x10,%esp
  }
  return pcb;
}
  80e107:	89 d8                	mov    %ebx,%eax
  80e109:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80e10c:	5b                   	pop    %ebx
  80e10d:	5e                   	pop    %esi
  80e10e:	5d                   	pop    %ebp
  80e10f:	c3                   	ret    

0080e110 <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
  80e110:	55                   	push   %ebp
  80e111:	89 e5                	mov    %esp,%ebp
  80e113:	57                   	push   %edi
  80e114:	56                   	push   %esi
  80e115:	53                   	push   %ebx
  80e116:	83 ec 28             	sub    $0x28,%esp
  80e119:	8b 5d 08             	mov    0x8(%ebp),%ebx

  ICMP_STATS_INC(icmp.recv);
  snmp_inc_icmpinmsgs();


  iphdr = p->payload;
  80e11c:	8b 7b 04             	mov    0x4(%ebx),%edi
  hlen = IPH_HL(iphdr) * 4;
  80e11f:	0f b7 07             	movzwl (%edi),%eax
  80e122:	50                   	push   %eax
  80e123:	e8 67 96 ff ff       	call   80778f <ntohs>
  80e128:	66 c1 e8 06          	shr    $0x6,%ax
  80e12c:	83 e0 3c             	and    $0x3c,%eax
  80e12f:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
  80e133:	89 c6                	mov    %eax,%esi
  80e135:	f7 de                	neg    %esi
  80e137:	0f bf f6             	movswl %si,%esi
  80e13a:	83 c4 08             	add    $0x8,%esp
  80e13d:	56                   	push   %esi
  80e13e:	53                   	push   %ebx
  80e13f:	e8 35 66 ff ff       	call   804779 <pbuf_header>
  80e144:	83 c4 10             	add    $0x10,%esp
  80e147:	84 c0                	test   %al,%al
  80e149:	75 5d                	jne    80e1a8 <icmp_input+0x98>
  80e14b:	66 83 7b 08 03       	cmpw   $0x3,0x8(%ebx)
  80e150:	76 56                	jbe    80e1a8 <icmp_input+0x98>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  }

  type = *((u8_t *)p->payload);
  80e152:	8b 43 04             	mov    0x4(%ebx),%eax
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
#endif /* LWIP_DEBUG */
  switch (type) {
  80e155:	80 38 08             	cmpb   $0x8,(%eax)
  80e158:	0f 85 66 02 00 00    	jne    80e3c4 <icmp_input+0x2b4>
  case ICMP_ECHO:
    /* broadcast or multicast destination address? */
    if (ip_addr_isbroadcast(&iphdr->dest, inp) || ip_addr_ismulticast(&iphdr->dest)) {
  80e15e:	83 ec 08             	sub    $0x8,%esp
  80e161:	ff 75 0c             	pushl  0xc(%ebp)
  80e164:	8d 47 10             	lea    0x10(%edi),%eax
  80e167:	50                   	push   %eax
  80e168:	e8 d0 83 ff ff       	call   80653d <ip_addr_isbroadcast>
  80e16d:	83 c4 10             	add    $0x10,%esp
  80e170:	84 c0                	test   %al,%al
  80e172:	75 48                	jne    80e1bc <icmp_input+0xac>
  80e174:	8b 47 10             	mov    0x10(%edi),%eax
  80e177:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80e17a:	83 ec 0c             	sub    $0xc,%esp
  80e17d:	68 00 00 00 f0       	push   $0xf0000000
  80e182:	e8 33 98 ff ff       	call   8079ba <ntohl>
  80e187:	23 45 e0             	and    -0x20(%ebp),%eax
  80e18a:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80e18d:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80e194:	e8 21 98 ff ff       	call   8079ba <ntohl>
  80e199:	83 c4 10             	add    $0x10,%esp
  80e19c:	39 45 e0             	cmp    %eax,-0x20(%ebp)
  80e19f:	74 1b                	je     80e1bc <icmp_input+0xac>
      ICMP_STATS_INC(icmp.err);
      pbuf_free(p);
      return;
    }
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
  80e1a1:	66 83 7b 08 07       	cmpw   $0x7,0x8(%ebx)
  80e1a6:	77 22                	ja     80e1ca <icmp_input+0xba>
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
  return;
lenerr:
  pbuf_free(p);
  80e1a8:	83 ec 0c             	sub    $0xc,%esp
  80e1ab:	53                   	push   %ebx
  80e1ac:	e8 9c 66 ff ff       	call   80484d <pbuf_free>
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
  80e1b1:	83 c4 10             	add    $0x10,%esp
memerr:
  pbuf_free(p);
  ICMP_STATS_INC(icmp.err);
  snmp_inc_icmpinerrors();
  return;
}
  80e1b4:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e1b7:	5b                   	pop    %ebx
  80e1b8:	5e                   	pop    %esi
  80e1b9:	5f                   	pop    %edi
  80e1ba:	5d                   	pop    %ebp
  80e1bb:	c3                   	ret    
      pbuf_free(p);
  80e1bc:	83 ec 0c             	sub    $0xc,%esp
  80e1bf:	53                   	push   %ebx
  80e1c0:	e8 88 66 ff ff       	call   80484d <pbuf_free>
      return;
  80e1c5:	83 c4 10             	add    $0x10,%esp
  80e1c8:	eb ea                	jmp    80e1b4 <icmp_input+0xa4>
    if (inet_chksum_pbuf(p) != 0) {
  80e1ca:	83 ec 0c             	sub    $0xc,%esp
  80e1cd:	53                   	push   %ebx
  80e1ce:	e8 a1 94 ff ff       	call   807674 <inet_chksum_pbuf>
  80e1d3:	83 c4 10             	add    $0x10,%esp
  80e1d6:	66 85 c0             	test   %ax,%ax
  80e1d9:	0f 85 97 00 00 00    	jne    80e276 <icmp_input+0x166>
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  80e1df:	83 ec 08             	sub    $0x8,%esp
  80e1e2:	6a 22                	push   $0x22
  80e1e4:	53                   	push   %ebx
  80e1e5:	e8 8f 65 ff ff       	call   804779 <pbuf_header>
  80e1ea:	83 c4 10             	add    $0x10,%esp
  80e1ed:	84 c0                	test   %al,%al
  80e1ef:	0f 84 eb 00 00 00    	je     80e2e0 <icmp_input+0x1d0>
      if (pbuf_header(p, hlen)) {
  80e1f5:	83 ec 08             	sub    $0x8,%esp
  80e1f8:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80e1fc:	50                   	push   %eax
  80e1fd:	53                   	push   %ebx
  80e1fe:	e8 76 65 ff ff       	call   804779 <pbuf_header>
  80e203:	83 c4 10             	add    $0x10,%esp
  80e206:	84 c0                	test   %al,%al
  80e208:	75 7d                	jne    80e287 <icmp_input+0x177>
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
  80e20a:	83 ec 04             	sub    $0x4,%esp
  80e20d:	6a 00                	push   $0x0
  80e20f:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80e213:	50                   	push   %eax
  80e214:	6a 02                	push   $0x2
  80e216:	e8 f8 66 ff ff       	call   804913 <pbuf_alloc>
  80e21b:	89 45 e0             	mov    %eax,-0x20(%ebp)
      if (r == NULL) {
  80e21e:	83 c4 10             	add    $0x10,%esp
  80e221:	85 c0                	test   %eax,%eax
  80e223:	0f 84 f3 01 00 00    	je     80e41c <icmp_input+0x30c>
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
  80e229:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
  80e22d:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80e231:	83 c0 08             	add    $0x8,%eax
  80e234:	39 c2                	cmp    %eax,%edx
  80e236:	72 63                	jb     80e29b <icmp_input+0x18b>
      if (pbuf_copy(r, p) != ERR_OK) {
  80e238:	83 ec 08             	sub    $0x8,%esp
  80e23b:	53                   	push   %ebx
  80e23c:	ff 75 e0             	pushl  -0x20(%ebp)
  80e23f:	e8 a8 6b ff ff       	call   804dec <pbuf_copy>
  80e244:	83 c4 10             	add    $0x10,%esp
  80e247:	84 c0                	test   %al,%al
  80e249:	75 67                	jne    80e2b2 <icmp_input+0x1a2>
      iphdr = r->payload;
  80e24b:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80e24e:	8b 78 04             	mov    0x4(%eax),%edi
      if (pbuf_header(r, -hlen)) {
  80e251:	83 ec 08             	sub    $0x8,%esp
  80e254:	56                   	push   %esi
  80e255:	50                   	push   %eax
  80e256:	e8 1e 65 ff ff       	call   804779 <pbuf_header>
  80e25b:	83 c4 10             	add    $0x10,%esp
  80e25e:	84 c0                	test   %al,%al
  80e260:	75 67                	jne    80e2c9 <icmp_input+0x1b9>
      pbuf_free(p);
  80e262:	83 ec 0c             	sub    $0xc,%esp
  80e265:	53                   	push   %ebx
  80e266:	e8 e2 65 ff ff       	call   80484d <pbuf_free>
  80e26b:	83 c4 10             	add    $0x10,%esp
      p = r;
  80e26e:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80e271:	e9 80 00 00 00       	jmp    80e2f6 <icmp_input+0x1e6>
      pbuf_free(p);
  80e276:	83 ec 0c             	sub    $0xc,%esp
  80e279:	53                   	push   %ebx
  80e27a:	e8 ce 65 ff ff       	call   80484d <pbuf_free>
      return;
  80e27f:	83 c4 10             	add    $0x10,%esp
  80e282:	e9 2d ff ff ff       	jmp    80e1b4 <icmp_input+0xa4>
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
  80e287:	83 ec 04             	sub    $0x4,%esp
  80e28a:	68 98 33 81 00       	push   $0x813398
  80e28f:	6a 7b                	push   $0x7b
  80e291:	68 8c 34 81 00       	push   $0x81348c
  80e296:	e8 b8 03 00 00       	call   80e653 <_panic>
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
  80e29b:	83 ec 04             	sub    $0x4,%esp
  80e29e:	68 cc 33 81 00       	push   $0x8133cc
  80e2a3:	68 85 00 00 00       	push   $0x85
  80e2a8:	68 8c 34 81 00       	push   $0x81348c
  80e2ad:	e8 a1 03 00 00       	call   80e653 <_panic>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
  80e2b2:	83 ec 04             	sub    $0x4,%esp
  80e2b5:	68 04 34 81 00       	push   $0x813404
  80e2ba:	68 88 00 00 00       	push   $0x88
  80e2bf:	68 8c 34 81 00       	push   $0x81348c
  80e2c4:	e8 8a 03 00 00       	call   80e653 <_panic>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  80e2c9:	83 ec 04             	sub    $0x4,%esp
  80e2cc:	68 2c 34 81 00       	push   $0x81342c
  80e2d1:	68 8e 00 00 00       	push   $0x8e
  80e2d6:	68 8c 34 81 00       	push   $0x81348c
  80e2db:	e8 73 03 00 00       	call   80e653 <_panic>
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  80e2e0:	83 ec 08             	sub    $0x8,%esp
  80e2e3:	6a de                	push   $0xffffffde
  80e2e5:	53                   	push   %ebx
  80e2e6:	e8 8e 64 ff ff       	call   804779 <pbuf_header>
  80e2eb:	83 c4 10             	add    $0x10,%esp
  80e2ee:	84 c0                	test   %al,%al
  80e2f0:	0f 85 df 00 00 00    	jne    80e3d5 <icmp_input+0x2c5>
    iecho = p->payload;
  80e2f6:	8b 73 04             	mov    0x4(%ebx),%esi
    tmpaddr.addr = iphdr->src.addr;
  80e2f9:	8b 47 0c             	mov    0xc(%edi),%eax
    iphdr->src.addr = iphdr->dest.addr;
  80e2fc:	8b 57 10             	mov    0x10(%edi),%edx
  80e2ff:	89 57 0c             	mov    %edx,0xc(%edi)
    iphdr->dest.addr = tmpaddr.addr;
  80e302:	89 47 10             	mov    %eax,0x10(%edi)
    ICMPH_TYPE_SET(iecho, ICMP_ER);
  80e305:	83 ec 0c             	sub    $0xc,%esp
  80e308:	0f b7 06             	movzwl (%esi),%eax
  80e30b:	50                   	push   %eax
  80e30c:	e8 7e 94 ff ff       	call   80778f <ntohs>
  80e311:	0f b6 c0             	movzbl %al,%eax
  80e314:	89 04 24             	mov    %eax,(%esp)
  80e317:	e8 66 94 ff ff       	call   807782 <htons>
  80e31c:	66 89 06             	mov    %ax,(%esi)
    if (iecho->chksum >= htons(0xffff - (ICMP_ECHO << 8))) {
  80e31f:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  80e323:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  80e327:	c7 04 24 ff f7 00 00 	movl   $0xf7ff,(%esp)
  80e32e:	e8 4f 94 ff ff       	call   807782 <htons>
  80e333:	83 c4 10             	add    $0x10,%esp
  80e336:	66 39 45 e0          	cmp    %ax,-0x20(%ebp)
  80e33a:	0f 82 ac 00 00 00    	jb     80e3ec <icmp_input+0x2dc>
      iecho->chksum += htons(ICMP_ECHO << 8) + 1;
  80e340:	83 ec 0c             	sub    $0xc,%esp
  80e343:	68 00 08 00 00       	push   $0x800
  80e348:	e8 35 94 ff ff       	call   807782 <htons>
  80e34d:	0f b7 56 02          	movzwl 0x2(%esi),%edx
  80e351:	8d 44 10 01          	lea    0x1(%eax,%edx,1),%eax
  80e355:	66 89 46 02          	mov    %ax,0x2(%esi)
  80e359:	83 c4 10             	add    $0x10,%esp
    IPH_TTL_SET(iphdr, ICMP_TTL);
  80e35c:	83 ec 0c             	sub    $0xc,%esp
  80e35f:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80e363:	50                   	push   %eax
  80e364:	e8 26 94 ff ff       	call   80778f <ntohs>
  80e369:	66 0d 00 ff          	or     $0xff00,%ax
  80e36d:	0f b7 c0             	movzwl %ax,%eax
  80e370:	89 04 24             	mov    %eax,(%esp)
  80e373:	e8 0a 94 ff ff       	call   807782 <htons>
  80e378:	66 89 47 08          	mov    %ax,0x8(%edi)
    IPH_CHKSUM_SET(iphdr, 0);
  80e37c:	66 c7 47 0a 00 00    	movw   $0x0,0xa(%edi)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  80e382:	83 c4 08             	add    $0x8,%esp
  80e385:	6a 14                	push   $0x14
  80e387:	57                   	push   %edi
  80e388:	e8 d1 92 ff ff       	call   80765e <inet_chksum>
  80e38d:	66 89 47 0a          	mov    %ax,0xa(%edi)
    if(pbuf_header(p, hlen)) {
  80e391:	83 c4 08             	add    $0x8,%esp
  80e394:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80e398:	50                   	push   %eax
  80e399:	53                   	push   %ebx
  80e39a:	e8 da 63 ff ff       	call   804779 <pbuf_header>
  80e39f:	83 c4 10             	add    $0x10,%esp
  80e3a2:	84 c0                	test   %al,%al
  80e3a4:	75 5f                	jne    80e405 <icmp_input+0x2f5>
      ret = ip_output_if(p, &(iphdr->src), IP_HDRINCL,
  80e3a6:	83 ec 04             	sub    $0x4,%esp
  80e3a9:	ff 75 0c             	pushl  0xc(%ebp)
  80e3ac:	6a 01                	push   $0x1
  80e3ae:	6a 00                	push   $0x0
  80e3b0:	68 ff 00 00 00       	push   $0xff
  80e3b5:	6a 00                	push   $0x0
  80e3b7:	83 c7 0c             	add    $0xc,%edi
  80e3ba:	57                   	push   %edi
  80e3bb:	53                   	push   %ebx
  80e3bc:	e8 31 85 ff ff       	call   8068f2 <ip_output_if>
  80e3c1:	83 c4 20             	add    $0x20,%esp
  pbuf_free(p);
  80e3c4:	83 ec 0c             	sub    $0xc,%esp
  80e3c7:	53                   	push   %ebx
  80e3c8:	e8 80 64 ff ff       	call   80484d <pbuf_free>
  return;
  80e3cd:	83 c4 10             	add    $0x10,%esp
  80e3d0:	e9 df fd ff ff       	jmp    80e1b4 <icmp_input+0xa4>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  80e3d5:	83 ec 04             	sub    $0x4,%esp
  80e3d8:	68 2c 34 81 00       	push   $0x81342c
  80e3dd:	68 98 00 00 00       	push   $0x98
  80e3e2:	68 8c 34 81 00       	push   $0x81348c
  80e3e7:	e8 67 02 00 00       	call   80e653 <_panic>
      iecho->chksum += htons(ICMP_ECHO << 8);
  80e3ec:	83 ec 0c             	sub    $0xc,%esp
  80e3ef:	68 00 08 00 00       	push   $0x800
  80e3f4:	e8 89 93 ff ff       	call   807782 <htons>
  80e3f9:	66 01 46 02          	add    %ax,0x2(%esi)
  80e3fd:	83 c4 10             	add    $0x10,%esp
  80e400:	e9 57 ff ff ff       	jmp    80e35c <icmp_input+0x24c>
      LWIP_ASSERT("Can't move over header in packet", 0);
  80e405:	83 ec 04             	sub    $0x4,%esp
  80e408:	68 f4 24 81 00       	push   $0x8124f4
  80e40d:	68 b9 00 00 00       	push   $0xb9
  80e412:	68 8c 34 81 00       	push   $0x81348c
  80e417:	e8 37 02 00 00       	call   80e653 <_panic>
  pbuf_free(p);
  80e41c:	83 ec 0c             	sub    $0xc,%esp
  80e41f:	53                   	push   %ebx
  80e420:	e8 28 64 ff ff       	call   80484d <pbuf_free>
  return;
  80e425:	83 c4 10             	add    $0x10,%esp
  80e428:	e9 87 fd ff ff       	jmp    80e1b4 <icmp_input+0xa4>

0080e42d <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
  80e42d:	55                   	push   %ebp
  80e42e:	89 e5                	mov    %esp,%ebp
  80e430:	57                   	push   %edi
  80e431:	56                   	push   %esi
  80e432:	53                   	push   %ebx
  80e433:	83 ec 10             	sub    $0x10,%esp
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_dur_hdr *idur;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  80e436:	6a 00                	push   $0x0
  80e438:	6a 24                	push   $0x24
  80e43a:	6a 01                	push   $0x1
  80e43c:	e8 d2 64 ff ff       	call   804913 <pbuf_alloc>
                 PBUF_RAM);
  if (q == NULL) {
  80e441:	83 c4 10             	add    $0x10,%esp
  80e444:	85 c0                	test   %eax,%eax
  80e446:	0f 84 a5 00 00 00    	je     80e4f1 <icmp_dest_unreach+0xc4>
  80e44c:	89 c3                	mov    %eax,%ebx
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_dest_unreach: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80e44e:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  80e453:	0f 86 a0 00 00 00    	jbe    80e4f9 <icmp_dest_unreach+0xcc>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  80e459:	8b 45 08             	mov    0x8(%ebp),%eax
  80e45c:	8b 78 04             	mov    0x4(%eax),%edi

  idur = q->payload;
  80e45f:	8b 73 04             	mov    0x4(%ebx),%esi
  ICMPH_TYPE_SET(idur, ICMP_DUR);
  80e462:	83 ec 0c             	sub    $0xc,%esp
  80e465:	0f b7 06             	movzwl (%esi),%eax
  80e468:	50                   	push   %eax
  80e469:	e8 21 93 ff ff       	call   80778f <ntohs>
  80e46e:	0f b6 c0             	movzbl %al,%eax
  80e471:	80 cc 03             	or     $0x3,%ah
  80e474:	89 04 24             	mov    %eax,(%esp)
  80e477:	e8 06 93 ff ff       	call   807782 <htons>
  80e47c:	66 89 06             	mov    %ax,(%esi)
  ICMPH_CODE_SET(idur, t);
  80e47f:	0f b7 c0             	movzwl %ax,%eax
  80e482:	89 04 24             	mov    %eax,(%esp)
  80e485:	e8 05 93 ff ff       	call   80778f <ntohs>
  80e48a:	b0 00                	mov    $0x0,%al
  80e48c:	66 0b 45 0c          	or     0xc(%ebp),%ax
  80e490:	0f b7 c0             	movzwl %ax,%eax
  80e493:	89 04 24             	mov    %eax,(%esp)
  80e496:	e8 e7 92 ff ff       	call   807782 <htons>
  80e49b:	66 89 06             	mov    %ax,(%esi)

  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), p->payload,
  80e49e:	83 c4 0c             	add    $0xc,%esp
  80e4a1:	6a 1c                	push   $0x1c
  80e4a3:	8b 45 08             	mov    0x8(%ebp),%eax
  80e4a6:	ff 70 04             	pushl  0x4(%eax)
  80e4a9:	8b 43 04             	mov    0x4(%ebx),%eax
  80e4ac:	83 c0 08             	add    $0x8,%eax
  80e4af:	50                   	push   %eax
  80e4b0:	e8 0c 0b 00 00       	call   80efc1 <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  idur->chksum = 0;
  80e4b5:	66 c7 46 02 00 00    	movw   $0x0,0x2(%esi)
  idur->chksum = inet_chksum(idur, q->len);
  80e4bb:	83 c4 08             	add    $0x8,%esp
  80e4be:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80e4c2:	50                   	push   %eax
  80e4c3:	56                   	push   %esi
  80e4c4:	e8 95 91 ff ff       	call   80765e <inet_chksum>
  80e4c9:	66 89 46 02          	mov    %ax,0x2(%esi)
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpoutdestunreachs();

  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  80e4cd:	83 c4 08             	add    $0x8,%esp
  80e4d0:	6a 01                	push   $0x1
  80e4d2:	6a 00                	push   $0x0
  80e4d4:	68 ff 00 00 00       	push   $0xff
  80e4d9:	83 c7 0c             	add    $0xc,%edi
  80e4dc:	57                   	push   %edi
  80e4dd:	6a 00                	push   $0x0
  80e4df:	53                   	push   %ebx
  80e4e0:	e8 9a 85 ff ff       	call   806a7f <ip_output>
  pbuf_free(q);
  80e4e5:	83 c4 14             	add    $0x14,%esp
  80e4e8:	53                   	push   %ebx
  80e4e9:	e8 5f 63 ff ff       	call   80484d <pbuf_free>
  80e4ee:	83 c4 10             	add    $0x10,%esp
}
  80e4f1:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e4f4:	5b                   	pop    %ebx
  80e4f5:	5e                   	pop    %esi
  80e4f6:	5f                   	pop    %edi
  80e4f7:	5d                   	pop    %ebp
  80e4f8:	c3                   	ret    
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80e4f9:	83 ec 04             	sub    $0x4,%esp
  80e4fc:	68 60 34 81 00       	push   $0x813460
  80e501:	68 ef 00 00 00       	push   $0xef
  80e506:	68 8c 34 81 00       	push   $0x81348c
  80e50b:	e8 43 01 00 00       	call   80e653 <_panic>

0080e510 <icmp_time_exceeded>:
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
  80e510:	55                   	push   %ebp
  80e511:	89 e5                	mov    %esp,%ebp
  80e513:	57                   	push   %edi
  80e514:	56                   	push   %esi
  80e515:	53                   	push   %ebx
  80e516:	83 ec 10             	sub    $0x10,%esp
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_te_hdr *tehdr;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  80e519:	6a 00                	push   $0x0
  80e51b:	6a 24                	push   $0x24
  80e51d:	6a 01                	push   $0x1
  80e51f:	e8 ef 63 ff ff       	call   804913 <pbuf_alloc>
                 PBUF_RAM);
  if (q == NULL) {
  80e524:	83 c4 10             	add    $0x10,%esp
  80e527:	85 c0                	test   %eax,%eax
  80e529:	0f 84 a5 00 00 00    	je     80e5d4 <icmp_time_exceeded+0xc4>
  80e52f:	89 c3                	mov    %eax,%ebx
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80e531:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  80e536:	0f 86 a0 00 00 00    	jbe    80e5dc <icmp_time_exceeded+0xcc>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  80e53c:	8b 45 08             	mov    0x8(%ebp),%eax
  80e53f:	8b 78 04             	mov    0x4(%eax),%edi
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  tehdr = q->payload;
  80e542:	8b 73 04             	mov    0x4(%ebx),%esi
  ICMPH_TYPE_SET(tehdr, ICMP_TE);
  80e545:	83 ec 0c             	sub    $0xc,%esp
  80e548:	0f b7 06             	movzwl (%esi),%eax
  80e54b:	50                   	push   %eax
  80e54c:	e8 3e 92 ff ff       	call   80778f <ntohs>
  80e551:	0f b6 c0             	movzbl %al,%eax
  80e554:	80 cc 0b             	or     $0xb,%ah
  80e557:	89 04 24             	mov    %eax,(%esp)
  80e55a:	e8 23 92 ff ff       	call   807782 <htons>
  80e55f:	66 89 06             	mov    %ax,(%esi)
  ICMPH_CODE_SET(tehdr, t);
  80e562:	0f b7 c0             	movzwl %ax,%eax
  80e565:	89 04 24             	mov    %eax,(%esp)
  80e568:	e8 22 92 ff ff       	call   80778f <ntohs>
  80e56d:	b0 00                	mov    $0x0,%al
  80e56f:	66 0b 45 0c          	or     0xc(%ebp),%ax
  80e573:	0f b7 c0             	movzwl %ax,%eax
  80e576:	89 04 24             	mov    %eax,(%esp)
  80e579:	e8 04 92 ff ff       	call   807782 <htons>
  80e57e:	66 89 06             	mov    %ax,(%esi)

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), (u8_t *)p->payload,
  80e581:	83 c4 0c             	add    $0xc,%esp
  80e584:	6a 1c                	push   $0x1c
  80e586:	8b 45 08             	mov    0x8(%ebp),%eax
  80e589:	ff 70 04             	pushl  0x4(%eax)
  80e58c:	8b 43 04             	mov    0x4(%ebx),%eax
  80e58f:	83 c0 08             	add    $0x8,%eax
  80e592:	50                   	push   %eax
  80e593:	e8 29 0a 00 00       	call   80efc1 <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  tehdr->chksum = 0;
  80e598:	66 c7 46 02 00 00    	movw   $0x0,0x2(%esi)
  tehdr->chksum = inet_chksum(tehdr, q->len);
  80e59e:	83 c4 08             	add    $0x8,%esp
  80e5a1:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80e5a5:	50                   	push   %eax
  80e5a6:	56                   	push   %esi
  80e5a7:	e8 b2 90 ff ff       	call   80765e <inet_chksum>
  80e5ac:	66 89 46 02          	mov    %ax,0x2(%esi)
  ICMP_STATS_INC(icmp.xmit);
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  80e5b0:	83 c4 08             	add    $0x8,%esp
  80e5b3:	6a 01                	push   $0x1
  80e5b5:	6a 00                	push   $0x0
  80e5b7:	68 ff 00 00 00       	push   $0xff
  80e5bc:	83 c7 0c             	add    $0xc,%edi
  80e5bf:	57                   	push   %edi
  80e5c0:	6a 00                	push   $0x0
  80e5c2:	53                   	push   %ebx
  80e5c3:	e8 b7 84 ff ff       	call   806a7f <ip_output>
  pbuf_free(q);
  80e5c8:	83 c4 14             	add    $0x14,%esp
  80e5cb:	53                   	push   %ebx
  80e5cc:	e8 7c 62 ff ff       	call   80484d <pbuf_free>
  80e5d1:	83 c4 10             	add    $0x10,%esp
}
  80e5d4:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e5d7:	5b                   	pop    %ebx
  80e5d8:	5e                   	pop    %esi
  80e5d9:	5f                   	pop    %edi
  80e5da:	5d                   	pop    %ebp
  80e5db:	c3                   	ret    
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80e5dc:	83 ec 04             	sub    $0x4,%esp
  80e5df:	68 60 34 81 00       	push   $0x813460
  80e5e4:	68 1e 01 00 00       	push   $0x11e
  80e5e9:	68 8c 34 81 00       	push   $0x81348c
  80e5ee:	e8 60 00 00 00       	call   80e653 <_panic>

0080e5f3 <libmain>:
const volatile struct Env *thisenv;
const char *binaryname = "<unknown>";

void
libmain(int argc, char **argv)
{
  80e5f3:	55                   	push   %ebp
  80e5f4:	89 e5                	mov    %esp,%ebp
  80e5f6:	56                   	push   %esi
  80e5f7:	53                   	push   %ebx
  80e5f8:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80e5fb:	8b 75 0c             	mov    0xc(%ebp),%esi
	// set thisenv to point at our Env structure in envs[].
	// LAB 3: Your code here.
    thisenv = &envs[ENVX(sys_getenvid())];
  80e5fe:	e8 83 0b 00 00       	call   80f186 <sys_getenvid>
  80e603:	25 ff 03 00 00       	and    $0x3ff,%eax
  80e608:	6b c0 7c             	imul   $0x7c,%eax,%eax
  80e60b:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  80e610:	a3 5c b2 b3 00       	mov    %eax,0xb3b25c

	// save the name of the program so that panic() can use it
	if (argc > 0)
  80e615:	85 db                	test   %ebx,%ebx
  80e617:	7e 07                	jle    80e620 <libmain+0x2d>
		binaryname = argv[0];
  80e619:	8b 06                	mov    (%esi),%eax
  80e61b:	a3 e8 42 81 00       	mov    %eax,0x8142e8

	// call user main routine
	umain(argc, argv);
  80e620:	83 ec 08             	sub    $0x8,%esp
  80e623:	56                   	push   %esi
  80e624:	53                   	push   %ebx
  80e625:	e8 49 1f ff ff       	call   800573 <umain>

	// exit gracefully
	exit();
  80e62a:	e8 0a 00 00 00       	call   80e639 <exit>
}
  80e62f:	83 c4 10             	add    $0x10,%esp
  80e632:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80e635:	5b                   	pop    %ebx
  80e636:	5e                   	pop    %esi
  80e637:	5d                   	pop    %ebp
  80e638:	c3                   	ret    

0080e639 <exit>:

#include <inc/lib.h>

void
exit(void)
{
  80e639:	55                   	push   %ebp
  80e63a:	89 e5                	mov    %esp,%ebp
  80e63c:	83 ec 08             	sub    $0x8,%esp
	close_all();
  80e63f:	e8 8d 13 00 00       	call   80f9d1 <close_all>
	sys_env_destroy(0);
  80e644:	83 ec 0c             	sub    $0xc,%esp
  80e647:	6a 00                	push   $0x0
  80e649:	e8 f7 0a 00 00       	call   80f145 <sys_env_destroy>
}
  80e64e:	83 c4 10             	add    $0x10,%esp
  80e651:	c9                   	leave  
  80e652:	c3                   	ret    

0080e653 <_panic>:
 * It prints "panic: <message>", then causes a breakpoint exception,
 * which causes JOS to enter the JOS kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt, ...)
{
  80e653:	55                   	push   %ebp
  80e654:	89 e5                	mov    %esp,%ebp
  80e656:	56                   	push   %esi
  80e657:	53                   	push   %ebx
	va_list ap;

	va_start(ap, fmt);
  80e658:	8d 5d 14             	lea    0x14(%ebp),%ebx

	// Print the panic message
	cprintf("[%08x] user panic in %s at %s:%d: ",
  80e65b:	8b 35 e8 42 81 00    	mov    0x8142e8,%esi
  80e661:	e8 20 0b 00 00       	call   80f186 <sys_getenvid>
  80e666:	83 ec 0c             	sub    $0xc,%esp
  80e669:	ff 75 0c             	pushl  0xc(%ebp)
  80e66c:	ff 75 08             	pushl  0x8(%ebp)
  80e66f:	56                   	push   %esi
  80e670:	50                   	push   %eax
  80e671:	68 b0 34 81 00       	push   $0x8134b0
  80e676:	e8 b3 00 00 00       	call   80e72e <cprintf>
		sys_getenvid(), binaryname, file, line);
	vcprintf(fmt, ap);
  80e67b:	83 c4 18             	add    $0x18,%esp
  80e67e:	53                   	push   %ebx
  80e67f:	ff 75 10             	pushl  0x10(%ebp)
  80e682:	e8 56 00 00 00       	call   80e6dd <vcprintf>
	cprintf("\n");
  80e687:	c7 04 24 88 10 81 00 	movl   $0x811088,(%esp)
  80e68e:	e8 9b 00 00 00       	call   80e72e <cprintf>
  80e693:	83 c4 10             	add    $0x10,%esp

	// Cause a breakpoint exception
	while (1)
		asm volatile("int3");
  80e696:	cc                   	int3   
  80e697:	eb fd                	jmp    80e696 <_panic+0x43>

0080e699 <putch>:
};


static void
putch(int ch, struct printbuf *b)
{
  80e699:	55                   	push   %ebp
  80e69a:	89 e5                	mov    %esp,%ebp
  80e69c:	53                   	push   %ebx
  80e69d:	83 ec 04             	sub    $0x4,%esp
  80e6a0:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	b->buf[b->idx++] = ch;
  80e6a3:	8b 13                	mov    (%ebx),%edx
  80e6a5:	8d 42 01             	lea    0x1(%edx),%eax
  80e6a8:	89 03                	mov    %eax,(%ebx)
  80e6aa:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80e6ad:	88 4c 13 08          	mov    %cl,0x8(%ebx,%edx,1)
	if (b->idx == 256-1) {
  80e6b1:	3d ff 00 00 00       	cmp    $0xff,%eax
  80e6b6:	74 09                	je     80e6c1 <putch+0x28>
		sys_cputs(b->buf, b->idx);
		b->idx = 0;
	}
	b->cnt++;
  80e6b8:	83 43 04 01          	addl   $0x1,0x4(%ebx)
}
  80e6bc:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80e6bf:	c9                   	leave  
  80e6c0:	c3                   	ret    
		sys_cputs(b->buf, b->idx);
  80e6c1:	83 ec 08             	sub    $0x8,%esp
  80e6c4:	68 ff 00 00 00       	push   $0xff
  80e6c9:	8d 43 08             	lea    0x8(%ebx),%eax
  80e6cc:	50                   	push   %eax
  80e6cd:	e8 36 0a 00 00       	call   80f108 <sys_cputs>
		b->idx = 0;
  80e6d2:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  80e6d8:	83 c4 10             	add    $0x10,%esp
  80e6db:	eb db                	jmp    80e6b8 <putch+0x1f>

0080e6dd <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
  80e6dd:	55                   	push   %ebp
  80e6de:	89 e5                	mov    %esp,%ebp
  80e6e0:	81 ec 18 01 00 00    	sub    $0x118,%esp
	struct printbuf b;

	b.idx = 0;
  80e6e6:	c7 85 f0 fe ff ff 00 	movl   $0x0,-0x110(%ebp)
  80e6ed:	00 00 00 
	b.cnt = 0;
  80e6f0:	c7 85 f4 fe ff ff 00 	movl   $0x0,-0x10c(%ebp)
  80e6f7:	00 00 00 
	vprintfmt((void*)putch, &b, fmt, ap);
  80e6fa:	ff 75 0c             	pushl  0xc(%ebp)
  80e6fd:	ff 75 08             	pushl  0x8(%ebp)
  80e700:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
  80e706:	50                   	push   %eax
  80e707:	68 99 e6 80 00       	push   $0x80e699
  80e70c:	e8 1a 01 00 00       	call   80e82b <vprintfmt>
	sys_cputs(b.buf, b.idx);
  80e711:	83 c4 08             	add    $0x8,%esp
  80e714:	ff b5 f0 fe ff ff    	pushl  -0x110(%ebp)
  80e71a:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
  80e720:	50                   	push   %eax
  80e721:	e8 e2 09 00 00       	call   80f108 <sys_cputs>

	return b.cnt;
}
  80e726:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
  80e72c:	c9                   	leave  
  80e72d:	c3                   	ret    

0080e72e <cprintf>:

int
cprintf(const char *fmt, ...)
{
  80e72e:	55                   	push   %ebp
  80e72f:	89 e5                	mov    %esp,%ebp
  80e731:	83 ec 10             	sub    $0x10,%esp
	va_list ap;
	int cnt;

	va_start(ap, fmt);
  80e734:	8d 45 0c             	lea    0xc(%ebp),%eax
	cnt = vcprintf(fmt, ap);
  80e737:	50                   	push   %eax
  80e738:	ff 75 08             	pushl  0x8(%ebp)
  80e73b:	e8 9d ff ff ff       	call   80e6dd <vcprintf>
	va_end(ap);

	return cnt;
}
  80e740:	c9                   	leave  
  80e741:	c3                   	ret    

0080e742 <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  80e742:	55                   	push   %ebp
  80e743:	89 e5                	mov    %esp,%ebp
  80e745:	57                   	push   %edi
  80e746:	56                   	push   %esi
  80e747:	53                   	push   %ebx
  80e748:	83 ec 1c             	sub    $0x1c,%esp
  80e74b:	89 c7                	mov    %eax,%edi
  80e74d:	89 d6                	mov    %edx,%esi
  80e74f:	8b 45 08             	mov    0x8(%ebp),%eax
  80e752:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e755:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80e758:	89 55 dc             	mov    %edx,-0x24(%ebp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
  80e75b:	8b 4d 10             	mov    0x10(%ebp),%ecx
  80e75e:	bb 00 00 00 00       	mov    $0x0,%ebx
  80e763:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  80e766:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  80e769:	39 d3                	cmp    %edx,%ebx
  80e76b:	72 05                	jb     80e772 <printnum+0x30>
  80e76d:	39 45 10             	cmp    %eax,0x10(%ebp)
  80e770:	77 7a                	ja     80e7ec <printnum+0xaa>
		printnum(putch, putdat, num / base, base, width - 1, padc);
  80e772:	83 ec 0c             	sub    $0xc,%esp
  80e775:	ff 75 18             	pushl  0x18(%ebp)
  80e778:	8b 45 14             	mov    0x14(%ebp),%eax
  80e77b:	8d 58 ff             	lea    -0x1(%eax),%ebx
  80e77e:	53                   	push   %ebx
  80e77f:	ff 75 10             	pushl  0x10(%ebp)
  80e782:	83 ec 08             	sub    $0x8,%esp
  80e785:	ff 75 e4             	pushl  -0x1c(%ebp)
  80e788:	ff 75 e0             	pushl  -0x20(%ebp)
  80e78b:	ff 75 dc             	pushl  -0x24(%ebp)
  80e78e:	ff 75 d8             	pushl  -0x28(%ebp)
  80e791:	e8 2a 25 00 00       	call   810cc0 <__udivdi3>
  80e796:	83 c4 18             	add    $0x18,%esp
  80e799:	52                   	push   %edx
  80e79a:	50                   	push   %eax
  80e79b:	89 f2                	mov    %esi,%edx
  80e79d:	89 f8                	mov    %edi,%eax
  80e79f:	e8 9e ff ff ff       	call   80e742 <printnum>
  80e7a4:	83 c4 20             	add    $0x20,%esp
  80e7a7:	eb 13                	jmp    80e7bc <printnum+0x7a>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
			putch(padc, putdat);
  80e7a9:	83 ec 08             	sub    $0x8,%esp
  80e7ac:	56                   	push   %esi
  80e7ad:	ff 75 18             	pushl  0x18(%ebp)
  80e7b0:	ff d7                	call   *%edi
  80e7b2:	83 c4 10             	add    $0x10,%esp
		while (--width > 0)
  80e7b5:	83 eb 01             	sub    $0x1,%ebx
  80e7b8:	85 db                	test   %ebx,%ebx
  80e7ba:	7f ed                	jg     80e7a9 <printnum+0x67>
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
  80e7bc:	83 ec 08             	sub    $0x8,%esp
  80e7bf:	56                   	push   %esi
  80e7c0:	83 ec 04             	sub    $0x4,%esp
  80e7c3:	ff 75 e4             	pushl  -0x1c(%ebp)
  80e7c6:	ff 75 e0             	pushl  -0x20(%ebp)
  80e7c9:	ff 75 dc             	pushl  -0x24(%ebp)
  80e7cc:	ff 75 d8             	pushl  -0x28(%ebp)
  80e7cf:	e8 0c 26 00 00       	call   810de0 <__umoddi3>
  80e7d4:	83 c4 14             	add    $0x14,%esp
  80e7d7:	0f be 80 d3 34 81 00 	movsbl 0x8134d3(%eax),%eax
  80e7de:	50                   	push   %eax
  80e7df:	ff d7                	call   *%edi
}
  80e7e1:	83 c4 10             	add    $0x10,%esp
  80e7e4:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e7e7:	5b                   	pop    %ebx
  80e7e8:	5e                   	pop    %esi
  80e7e9:	5f                   	pop    %edi
  80e7ea:	5d                   	pop    %ebp
  80e7eb:	c3                   	ret    
  80e7ec:	8b 5d 14             	mov    0x14(%ebp),%ebx
  80e7ef:	eb c4                	jmp    80e7b5 <printnum+0x73>

0080e7f1 <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  80e7f1:	55                   	push   %ebp
  80e7f2:	89 e5                	mov    %esp,%ebp
  80e7f4:	8b 45 0c             	mov    0xc(%ebp),%eax
	b->cnt++;
  80e7f7:	83 40 08 01          	addl   $0x1,0x8(%eax)
	if (b->buf < b->ebuf)
  80e7fb:	8b 10                	mov    (%eax),%edx
  80e7fd:	3b 50 04             	cmp    0x4(%eax),%edx
  80e800:	73 0a                	jae    80e80c <sprintputch+0x1b>
		*b->buf++ = ch;
  80e802:	8d 4a 01             	lea    0x1(%edx),%ecx
  80e805:	89 08                	mov    %ecx,(%eax)
  80e807:	8b 45 08             	mov    0x8(%ebp),%eax
  80e80a:	88 02                	mov    %al,(%edx)
}
  80e80c:	5d                   	pop    %ebp
  80e80d:	c3                   	ret    

0080e80e <printfmt>:
{
  80e80e:	55                   	push   %ebp
  80e80f:	89 e5                	mov    %esp,%ebp
  80e811:	83 ec 08             	sub    $0x8,%esp
	va_start(ap, fmt);
  80e814:	8d 45 14             	lea    0x14(%ebp),%eax
	vprintfmt(putch, putdat, fmt, ap);
  80e817:	50                   	push   %eax
  80e818:	ff 75 10             	pushl  0x10(%ebp)
  80e81b:	ff 75 0c             	pushl  0xc(%ebp)
  80e81e:	ff 75 08             	pushl  0x8(%ebp)
  80e821:	e8 05 00 00 00       	call   80e82b <vprintfmt>
}
  80e826:	83 c4 10             	add    $0x10,%esp
  80e829:	c9                   	leave  
  80e82a:	c3                   	ret    

0080e82b <vprintfmt>:
{
  80e82b:	55                   	push   %ebp
  80e82c:	89 e5                	mov    %esp,%ebp
  80e82e:	57                   	push   %edi
  80e82f:	56                   	push   %esi
  80e830:	53                   	push   %ebx
  80e831:	83 ec 2c             	sub    $0x2c,%esp
  80e834:	8b 75 08             	mov    0x8(%ebp),%esi
  80e837:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80e83a:	8b 7d 10             	mov    0x10(%ebp),%edi
  80e83d:	e9 21 04 00 00       	jmp    80ec63 <vprintfmt+0x438>
		padc = ' ';
  80e842:	c6 45 d4 20          	movb   $0x20,-0x2c(%ebp)
		altflag = 0;
  80e846:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		precision = -1;
  80e84d:	c7 45 d0 ff ff ff ff 	movl   $0xffffffff,-0x30(%ebp)
		width = -1;
  80e854:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
		lflag = 0;
  80e85b:	b9 00 00 00 00       	mov    $0x0,%ecx
		switch (ch = *(unsigned char *) fmt++) {
  80e860:	8d 47 01             	lea    0x1(%edi),%eax
  80e863:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80e866:	0f b6 17             	movzbl (%edi),%edx
  80e869:	8d 42 dd             	lea    -0x23(%edx),%eax
  80e86c:	3c 55                	cmp    $0x55,%al
  80e86e:	0f 87 90 04 00 00    	ja     80ed04 <vprintfmt+0x4d9>
  80e874:	0f b6 c0             	movzbl %al,%eax
  80e877:	ff 24 85 20 36 81 00 	jmp    *0x813620(,%eax,4)
  80e87e:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			padc = '-';
  80e881:	c6 45 d4 2d          	movb   $0x2d,-0x2c(%ebp)
  80e885:	eb d9                	jmp    80e860 <vprintfmt+0x35>
		switch (ch = *(unsigned char *) fmt++) {
  80e887:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			padc = '0';
  80e88a:	c6 45 d4 30          	movb   $0x30,-0x2c(%ebp)
  80e88e:	eb d0                	jmp    80e860 <vprintfmt+0x35>
		switch (ch = *(unsigned char *) fmt++) {
  80e890:	0f b6 d2             	movzbl %dl,%edx
  80e893:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			for (precision = 0; ; ++fmt) {
  80e896:	b8 00 00 00 00       	mov    $0x0,%eax
  80e89b:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
				precision = precision * 10 + ch - '0';
  80e89e:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80e8a1:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
				ch = *fmt;
  80e8a5:	0f be 17             	movsbl (%edi),%edx
				if (ch < '0' || ch > '9')
  80e8a8:	8d 4a d0             	lea    -0x30(%edx),%ecx
  80e8ab:	83 f9 09             	cmp    $0x9,%ecx
  80e8ae:	77 55                	ja     80e905 <vprintfmt+0xda>
			for (precision = 0; ; ++fmt) {
  80e8b0:	83 c7 01             	add    $0x1,%edi
				precision = precision * 10 + ch - '0';
  80e8b3:	eb e9                	jmp    80e89e <vprintfmt+0x73>
			precision = va_arg(ap, int);
  80e8b5:	8b 45 14             	mov    0x14(%ebp),%eax
  80e8b8:	8b 00                	mov    (%eax),%eax
  80e8ba:	89 45 d0             	mov    %eax,-0x30(%ebp)
  80e8bd:	8b 45 14             	mov    0x14(%ebp),%eax
  80e8c0:	8d 40 04             	lea    0x4(%eax),%eax
  80e8c3:	89 45 14             	mov    %eax,0x14(%ebp)
		switch (ch = *(unsigned char *) fmt++) {
  80e8c6:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			if (width < 0)
  80e8c9:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80e8cd:	79 91                	jns    80e860 <vprintfmt+0x35>
				width = precision, precision = -1;
  80e8cf:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80e8d2:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80e8d5:	c7 45 d0 ff ff ff ff 	movl   $0xffffffff,-0x30(%ebp)
  80e8dc:	eb 82                	jmp    80e860 <vprintfmt+0x35>
  80e8de:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80e8e1:	85 c0                	test   %eax,%eax
  80e8e3:	ba 00 00 00 00       	mov    $0x0,%edx
  80e8e8:	0f 49 d0             	cmovns %eax,%edx
  80e8eb:	89 55 e0             	mov    %edx,-0x20(%ebp)
		switch (ch = *(unsigned char *) fmt++) {
  80e8ee:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80e8f1:	e9 6a ff ff ff       	jmp    80e860 <vprintfmt+0x35>
  80e8f6:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			altflag = 1;
  80e8f9:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
			goto reswitch;
  80e900:	e9 5b ff ff ff       	jmp    80e860 <vprintfmt+0x35>
  80e905:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80e908:	89 45 d0             	mov    %eax,-0x30(%ebp)
  80e90b:	eb bc                	jmp    80e8c9 <vprintfmt+0x9e>
			lflag++;
  80e90d:	83 c1 01             	add    $0x1,%ecx
		switch (ch = *(unsigned char *) fmt++) {
  80e910:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			goto reswitch;
  80e913:	e9 48 ff ff ff       	jmp    80e860 <vprintfmt+0x35>
			putch(va_arg(ap, int), putdat);
  80e918:	8b 45 14             	mov    0x14(%ebp),%eax
  80e91b:	8d 78 04             	lea    0x4(%eax),%edi
  80e91e:	83 ec 08             	sub    $0x8,%esp
  80e921:	53                   	push   %ebx
  80e922:	ff 30                	pushl  (%eax)
  80e924:	ff d6                	call   *%esi
			break;
  80e926:	83 c4 10             	add    $0x10,%esp
			putch(va_arg(ap, int), putdat);
  80e929:	89 7d 14             	mov    %edi,0x14(%ebp)
			break;
  80e92c:	e9 2f 03 00 00       	jmp    80ec60 <vprintfmt+0x435>
			err = va_arg(ap, int);
  80e931:	8b 45 14             	mov    0x14(%ebp),%eax
  80e934:	8d 78 04             	lea    0x4(%eax),%edi
  80e937:	8b 00                	mov    (%eax),%eax
  80e939:	99                   	cltd   
  80e93a:	31 d0                	xor    %edx,%eax
  80e93c:	29 d0                	sub    %edx,%eax
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
  80e93e:	83 f8 0f             	cmp    $0xf,%eax
  80e941:	7f 23                	jg     80e966 <vprintfmt+0x13b>
  80e943:	8b 14 85 80 37 81 00 	mov    0x813780(,%eax,4),%edx
  80e94a:	85 d2                	test   %edx,%edx
  80e94c:	74 18                	je     80e966 <vprintfmt+0x13b>
				printfmt(putch, putdat, "%s", p);
  80e94e:	52                   	push   %edx
  80e94f:	68 b9 26 81 00       	push   $0x8126b9
  80e954:	53                   	push   %ebx
  80e955:	56                   	push   %esi
  80e956:	e8 b3 fe ff ff       	call   80e80e <printfmt>
  80e95b:	83 c4 10             	add    $0x10,%esp
			err = va_arg(ap, int);
  80e95e:	89 7d 14             	mov    %edi,0x14(%ebp)
  80e961:	e9 fa 02 00 00       	jmp    80ec60 <vprintfmt+0x435>
				printfmt(putch, putdat, "error %d", err);
  80e966:	50                   	push   %eax
  80e967:	68 eb 34 81 00       	push   $0x8134eb
  80e96c:	53                   	push   %ebx
  80e96d:	56                   	push   %esi
  80e96e:	e8 9b fe ff ff       	call   80e80e <printfmt>
  80e973:	83 c4 10             	add    $0x10,%esp
			err = va_arg(ap, int);
  80e976:	89 7d 14             	mov    %edi,0x14(%ebp)
				printfmt(putch, putdat, "error %d", err);
  80e979:	e9 e2 02 00 00       	jmp    80ec60 <vprintfmt+0x435>
			if ((p = va_arg(ap, char *)) == NULL)
  80e97e:	8b 45 14             	mov    0x14(%ebp),%eax
  80e981:	83 c0 04             	add    $0x4,%eax
  80e984:	89 45 cc             	mov    %eax,-0x34(%ebp)
  80e987:	8b 45 14             	mov    0x14(%ebp),%eax
  80e98a:	8b 38                	mov    (%eax),%edi
				p = "(null)";
  80e98c:	85 ff                	test   %edi,%edi
  80e98e:	b8 e4 34 81 00       	mov    $0x8134e4,%eax
  80e993:	0f 44 f8             	cmove  %eax,%edi
			if (width > 0 && padc != '-')
  80e996:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80e99a:	0f 8e bd 00 00 00    	jle    80ea5d <vprintfmt+0x232>
  80e9a0:	80 7d d4 2d          	cmpb   $0x2d,-0x2c(%ebp)
  80e9a4:	75 0e                	jne    80e9b4 <vprintfmt+0x189>
  80e9a6:	89 75 08             	mov    %esi,0x8(%ebp)
  80e9a9:	8b 75 d0             	mov    -0x30(%ebp),%esi
  80e9ac:	89 5d 0c             	mov    %ebx,0xc(%ebp)
  80e9af:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80e9b2:	eb 6d                	jmp    80ea21 <vprintfmt+0x1f6>
				for (width -= strnlen(p, precision); width > 0; width--)
  80e9b4:	83 ec 08             	sub    $0x8,%esp
  80e9b7:	ff 75 d0             	pushl  -0x30(%ebp)
  80e9ba:	57                   	push   %edi
  80e9bb:	e8 ec 03 00 00       	call   80edac <strnlen>
  80e9c0:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80e9c3:	29 c1                	sub    %eax,%ecx
  80e9c5:	89 4d c8             	mov    %ecx,-0x38(%ebp)
  80e9c8:	83 c4 10             	add    $0x10,%esp
					putch(padc, putdat);
  80e9cb:	0f be 45 d4          	movsbl -0x2c(%ebp),%eax
  80e9cf:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80e9d2:	89 7d d4             	mov    %edi,-0x2c(%ebp)
  80e9d5:	89 cf                	mov    %ecx,%edi
				for (width -= strnlen(p, precision); width > 0; width--)
  80e9d7:	eb 0f                	jmp    80e9e8 <vprintfmt+0x1bd>
					putch(padc, putdat);
  80e9d9:	83 ec 08             	sub    $0x8,%esp
  80e9dc:	53                   	push   %ebx
  80e9dd:	ff 75 e0             	pushl  -0x20(%ebp)
  80e9e0:	ff d6                	call   *%esi
				for (width -= strnlen(p, precision); width > 0; width--)
  80e9e2:	83 ef 01             	sub    $0x1,%edi
  80e9e5:	83 c4 10             	add    $0x10,%esp
  80e9e8:	85 ff                	test   %edi,%edi
  80e9ea:	7f ed                	jg     80e9d9 <vprintfmt+0x1ae>
  80e9ec:	8b 7d d4             	mov    -0x2c(%ebp),%edi
  80e9ef:	8b 4d c8             	mov    -0x38(%ebp),%ecx
  80e9f2:	85 c9                	test   %ecx,%ecx
  80e9f4:	b8 00 00 00 00       	mov    $0x0,%eax
  80e9f9:	0f 49 c1             	cmovns %ecx,%eax
  80e9fc:	29 c1                	sub    %eax,%ecx
  80e9fe:	89 75 08             	mov    %esi,0x8(%ebp)
  80ea01:	8b 75 d0             	mov    -0x30(%ebp),%esi
  80ea04:	89 5d 0c             	mov    %ebx,0xc(%ebp)
  80ea07:	89 cb                	mov    %ecx,%ebx
  80ea09:	eb 16                	jmp    80ea21 <vprintfmt+0x1f6>
				if (altflag && (ch < ' ' || ch > '~'))
  80ea0b:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
  80ea0f:	75 31                	jne    80ea42 <vprintfmt+0x217>
					putch(ch, putdat);
  80ea11:	83 ec 08             	sub    $0x8,%esp
  80ea14:	ff 75 0c             	pushl  0xc(%ebp)
  80ea17:	50                   	push   %eax
  80ea18:	ff 55 08             	call   *0x8(%ebp)
  80ea1b:	83 c4 10             	add    $0x10,%esp
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  80ea1e:	83 eb 01             	sub    $0x1,%ebx
  80ea21:	83 c7 01             	add    $0x1,%edi
  80ea24:	0f b6 57 ff          	movzbl -0x1(%edi),%edx
  80ea28:	0f be c2             	movsbl %dl,%eax
  80ea2b:	85 c0                	test   %eax,%eax
  80ea2d:	74 59                	je     80ea88 <vprintfmt+0x25d>
  80ea2f:	85 f6                	test   %esi,%esi
  80ea31:	78 d8                	js     80ea0b <vprintfmt+0x1e0>
  80ea33:	83 ee 01             	sub    $0x1,%esi
  80ea36:	79 d3                	jns    80ea0b <vprintfmt+0x1e0>
  80ea38:	89 df                	mov    %ebx,%edi
  80ea3a:	8b 75 08             	mov    0x8(%ebp),%esi
  80ea3d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80ea40:	eb 37                	jmp    80ea79 <vprintfmt+0x24e>
				if (altflag && (ch < ' ' || ch > '~'))
  80ea42:	0f be d2             	movsbl %dl,%edx
  80ea45:	83 ea 20             	sub    $0x20,%edx
  80ea48:	83 fa 5e             	cmp    $0x5e,%edx
  80ea4b:	76 c4                	jbe    80ea11 <vprintfmt+0x1e6>
					putch('?', putdat);
  80ea4d:	83 ec 08             	sub    $0x8,%esp
  80ea50:	ff 75 0c             	pushl  0xc(%ebp)
  80ea53:	6a 3f                	push   $0x3f
  80ea55:	ff 55 08             	call   *0x8(%ebp)
  80ea58:	83 c4 10             	add    $0x10,%esp
  80ea5b:	eb c1                	jmp    80ea1e <vprintfmt+0x1f3>
  80ea5d:	89 75 08             	mov    %esi,0x8(%ebp)
  80ea60:	8b 75 d0             	mov    -0x30(%ebp),%esi
  80ea63:	89 5d 0c             	mov    %ebx,0xc(%ebp)
  80ea66:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80ea69:	eb b6                	jmp    80ea21 <vprintfmt+0x1f6>
				putch(' ', putdat);
  80ea6b:	83 ec 08             	sub    $0x8,%esp
  80ea6e:	53                   	push   %ebx
  80ea6f:	6a 20                	push   $0x20
  80ea71:	ff d6                	call   *%esi
			for (; width > 0; width--)
  80ea73:	83 ef 01             	sub    $0x1,%edi
  80ea76:	83 c4 10             	add    $0x10,%esp
  80ea79:	85 ff                	test   %edi,%edi
  80ea7b:	7f ee                	jg     80ea6b <vprintfmt+0x240>
			if ((p = va_arg(ap, char *)) == NULL)
  80ea7d:	8b 45 cc             	mov    -0x34(%ebp),%eax
  80ea80:	89 45 14             	mov    %eax,0x14(%ebp)
  80ea83:	e9 d8 01 00 00       	jmp    80ec60 <vprintfmt+0x435>
  80ea88:	89 df                	mov    %ebx,%edi
  80ea8a:	8b 75 08             	mov    0x8(%ebp),%esi
  80ea8d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80ea90:	eb e7                	jmp    80ea79 <vprintfmt+0x24e>
	if (lflag >= 2)
  80ea92:	83 f9 01             	cmp    $0x1,%ecx
  80ea95:	7e 45                	jle    80eadc <vprintfmt+0x2b1>
		return va_arg(*ap, long long);
  80ea97:	8b 45 14             	mov    0x14(%ebp),%eax
  80ea9a:	8b 50 04             	mov    0x4(%eax),%edx
  80ea9d:	8b 00                	mov    (%eax),%eax
  80ea9f:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80eaa2:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80eaa5:	8b 45 14             	mov    0x14(%ebp),%eax
  80eaa8:	8d 40 08             	lea    0x8(%eax),%eax
  80eaab:	89 45 14             	mov    %eax,0x14(%ebp)
			if ((long long) num < 0) {
  80eaae:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
  80eab2:	79 62                	jns    80eb16 <vprintfmt+0x2eb>
				putch('-', putdat);
  80eab4:	83 ec 08             	sub    $0x8,%esp
  80eab7:	53                   	push   %ebx
  80eab8:	6a 2d                	push   $0x2d
  80eaba:	ff d6                	call   *%esi
				num = -(long long) num;
  80eabc:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80eabf:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80eac2:	f7 d8                	neg    %eax
  80eac4:	83 d2 00             	adc    $0x0,%edx
  80eac7:	f7 da                	neg    %edx
  80eac9:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80eacc:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80eacf:	83 c4 10             	add    $0x10,%esp
			base = 10;
  80ead2:	ba 0a 00 00 00       	mov    $0xa,%edx
  80ead7:	e9 66 01 00 00       	jmp    80ec42 <vprintfmt+0x417>
	else if (lflag)
  80eadc:	85 c9                	test   %ecx,%ecx
  80eade:	75 1b                	jne    80eafb <vprintfmt+0x2d0>
		return va_arg(*ap, int);
  80eae0:	8b 45 14             	mov    0x14(%ebp),%eax
  80eae3:	8b 00                	mov    (%eax),%eax
  80eae5:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80eae8:	89 c1                	mov    %eax,%ecx
  80eaea:	c1 f9 1f             	sar    $0x1f,%ecx
  80eaed:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  80eaf0:	8b 45 14             	mov    0x14(%ebp),%eax
  80eaf3:	8d 40 04             	lea    0x4(%eax),%eax
  80eaf6:	89 45 14             	mov    %eax,0x14(%ebp)
  80eaf9:	eb b3                	jmp    80eaae <vprintfmt+0x283>
		return va_arg(*ap, long);
  80eafb:	8b 45 14             	mov    0x14(%ebp),%eax
  80eafe:	8b 00                	mov    (%eax),%eax
  80eb00:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80eb03:	89 c1                	mov    %eax,%ecx
  80eb05:	c1 f9 1f             	sar    $0x1f,%ecx
  80eb08:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  80eb0b:	8b 45 14             	mov    0x14(%ebp),%eax
  80eb0e:	8d 40 04             	lea    0x4(%eax),%eax
  80eb11:	89 45 14             	mov    %eax,0x14(%ebp)
  80eb14:	eb 98                	jmp    80eaae <vprintfmt+0x283>
			base = 10;
  80eb16:	ba 0a 00 00 00       	mov    $0xa,%edx
  80eb1b:	e9 22 01 00 00       	jmp    80ec42 <vprintfmt+0x417>
	if (lflag >= 2)
  80eb20:	83 f9 01             	cmp    $0x1,%ecx
  80eb23:	7e 21                	jle    80eb46 <vprintfmt+0x31b>
		return va_arg(*ap, unsigned long long);
  80eb25:	8b 45 14             	mov    0x14(%ebp),%eax
  80eb28:	8b 50 04             	mov    0x4(%eax),%edx
  80eb2b:	8b 00                	mov    (%eax),%eax
  80eb2d:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80eb30:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80eb33:	8b 45 14             	mov    0x14(%ebp),%eax
  80eb36:	8d 40 08             	lea    0x8(%eax),%eax
  80eb39:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 10;
  80eb3c:	ba 0a 00 00 00       	mov    $0xa,%edx
  80eb41:	e9 fc 00 00 00       	jmp    80ec42 <vprintfmt+0x417>
	else if (lflag)
  80eb46:	85 c9                	test   %ecx,%ecx
  80eb48:	75 23                	jne    80eb6d <vprintfmt+0x342>
		return va_arg(*ap, unsigned int);
  80eb4a:	8b 45 14             	mov    0x14(%ebp),%eax
  80eb4d:	8b 00                	mov    (%eax),%eax
  80eb4f:	ba 00 00 00 00       	mov    $0x0,%edx
  80eb54:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80eb57:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80eb5a:	8b 45 14             	mov    0x14(%ebp),%eax
  80eb5d:	8d 40 04             	lea    0x4(%eax),%eax
  80eb60:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 10;
  80eb63:	ba 0a 00 00 00       	mov    $0xa,%edx
  80eb68:	e9 d5 00 00 00       	jmp    80ec42 <vprintfmt+0x417>
		return va_arg(*ap, unsigned long);
  80eb6d:	8b 45 14             	mov    0x14(%ebp),%eax
  80eb70:	8b 00                	mov    (%eax),%eax
  80eb72:	ba 00 00 00 00       	mov    $0x0,%edx
  80eb77:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80eb7a:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80eb7d:	8b 45 14             	mov    0x14(%ebp),%eax
  80eb80:	8d 40 04             	lea    0x4(%eax),%eax
  80eb83:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 10;
  80eb86:	ba 0a 00 00 00       	mov    $0xa,%edx
  80eb8b:	e9 b2 00 00 00       	jmp    80ec42 <vprintfmt+0x417>
	if (lflag >= 2)
  80eb90:	83 f9 01             	cmp    $0x1,%ecx
  80eb93:	7e 42                	jle    80ebd7 <vprintfmt+0x3ac>
		return va_arg(*ap, unsigned long long);
  80eb95:	8b 45 14             	mov    0x14(%ebp),%eax
  80eb98:	8b 50 04             	mov    0x4(%eax),%edx
  80eb9b:	8b 00                	mov    (%eax),%eax
  80eb9d:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80eba0:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80eba3:	8b 45 14             	mov    0x14(%ebp),%eax
  80eba6:	8d 40 08             	lea    0x8(%eax),%eax
  80eba9:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 8;
  80ebac:	ba 08 00 00 00       	mov    $0x8,%edx
			if ((long long) num < 0) {
  80ebb1:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
  80ebb5:	0f 89 87 00 00 00    	jns    80ec42 <vprintfmt+0x417>
				putch('-', putdat);
  80ebbb:	83 ec 08             	sub    $0x8,%esp
  80ebbe:	53                   	push   %ebx
  80ebbf:	6a 2d                	push   $0x2d
  80ebc1:	ff d6                	call   *%esi
				num = -(long long) num;
  80ebc3:	f7 5d d8             	negl   -0x28(%ebp)
  80ebc6:	83 55 dc 00          	adcl   $0x0,-0x24(%ebp)
  80ebca:	f7 5d dc             	negl   -0x24(%ebp)
  80ebcd:	83 c4 10             	add    $0x10,%esp
			base = 8;
  80ebd0:	ba 08 00 00 00       	mov    $0x8,%edx
  80ebd5:	eb 6b                	jmp    80ec42 <vprintfmt+0x417>
	else if (lflag)
  80ebd7:	85 c9                	test   %ecx,%ecx
  80ebd9:	75 1b                	jne    80ebf6 <vprintfmt+0x3cb>
		return va_arg(*ap, unsigned int);
  80ebdb:	8b 45 14             	mov    0x14(%ebp),%eax
  80ebde:	8b 00                	mov    (%eax),%eax
  80ebe0:	ba 00 00 00 00       	mov    $0x0,%edx
  80ebe5:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ebe8:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80ebeb:	8b 45 14             	mov    0x14(%ebp),%eax
  80ebee:	8d 40 04             	lea    0x4(%eax),%eax
  80ebf1:	89 45 14             	mov    %eax,0x14(%ebp)
  80ebf4:	eb b6                	jmp    80ebac <vprintfmt+0x381>
		return va_arg(*ap, unsigned long);
  80ebf6:	8b 45 14             	mov    0x14(%ebp),%eax
  80ebf9:	8b 00                	mov    (%eax),%eax
  80ebfb:	ba 00 00 00 00       	mov    $0x0,%edx
  80ec00:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ec03:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80ec06:	8b 45 14             	mov    0x14(%ebp),%eax
  80ec09:	8d 40 04             	lea    0x4(%eax),%eax
  80ec0c:	89 45 14             	mov    %eax,0x14(%ebp)
  80ec0f:	eb 9b                	jmp    80ebac <vprintfmt+0x381>
			putch('0', putdat);
  80ec11:	83 ec 08             	sub    $0x8,%esp
  80ec14:	53                   	push   %ebx
  80ec15:	6a 30                	push   $0x30
  80ec17:	ff d6                	call   *%esi
			putch('x', putdat);
  80ec19:	83 c4 08             	add    $0x8,%esp
  80ec1c:	53                   	push   %ebx
  80ec1d:	6a 78                	push   $0x78
  80ec1f:	ff d6                	call   *%esi
			num = (unsigned long long)
  80ec21:	8b 45 14             	mov    0x14(%ebp),%eax
  80ec24:	8b 00                	mov    (%eax),%eax
  80ec26:	ba 00 00 00 00       	mov    $0x0,%edx
  80ec2b:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ec2e:	89 55 dc             	mov    %edx,-0x24(%ebp)
			goto number;
  80ec31:	83 c4 10             	add    $0x10,%esp
				(uintptr_t) va_arg(ap, void *);
  80ec34:	8b 45 14             	mov    0x14(%ebp),%eax
  80ec37:	8d 40 04             	lea    0x4(%eax),%eax
  80ec3a:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 16;
  80ec3d:	ba 10 00 00 00       	mov    $0x10,%edx
			printnum(putch, putdat, num, base, width, padc);
  80ec42:	83 ec 0c             	sub    $0xc,%esp
  80ec45:	0f be 45 d4          	movsbl -0x2c(%ebp),%eax
  80ec49:	50                   	push   %eax
  80ec4a:	ff 75 e0             	pushl  -0x20(%ebp)
  80ec4d:	52                   	push   %edx
  80ec4e:	ff 75 dc             	pushl  -0x24(%ebp)
  80ec51:	ff 75 d8             	pushl  -0x28(%ebp)
  80ec54:	89 da                	mov    %ebx,%edx
  80ec56:	89 f0                	mov    %esi,%eax
  80ec58:	e8 e5 fa ff ff       	call   80e742 <printnum>
			break;
  80ec5d:	83 c4 20             	add    $0x20,%esp
			err = va_arg(ap, int);
  80ec60:	8b 7d e4             	mov    -0x1c(%ebp),%edi
		while ((ch = *(unsigned char *) fmt++) != '%') {
  80ec63:	83 c7 01             	add    $0x1,%edi
  80ec66:	0f b6 47 ff          	movzbl -0x1(%edi),%eax
  80ec6a:	83 f8 25             	cmp    $0x25,%eax
  80ec6d:	0f 84 cf fb ff ff    	je     80e842 <vprintfmt+0x17>
			if (ch == '\0')
  80ec73:	85 c0                	test   %eax,%eax
  80ec75:	0f 84 a9 00 00 00    	je     80ed24 <vprintfmt+0x4f9>
			putch(ch, putdat);
  80ec7b:	83 ec 08             	sub    $0x8,%esp
  80ec7e:	53                   	push   %ebx
  80ec7f:	50                   	push   %eax
  80ec80:	ff d6                	call   *%esi
  80ec82:	83 c4 10             	add    $0x10,%esp
  80ec85:	eb dc                	jmp    80ec63 <vprintfmt+0x438>
	if (lflag >= 2)
  80ec87:	83 f9 01             	cmp    $0x1,%ecx
  80ec8a:	7e 1e                	jle    80ecaa <vprintfmt+0x47f>
		return va_arg(*ap, unsigned long long);
  80ec8c:	8b 45 14             	mov    0x14(%ebp),%eax
  80ec8f:	8b 50 04             	mov    0x4(%eax),%edx
  80ec92:	8b 00                	mov    (%eax),%eax
  80ec94:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ec97:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80ec9a:	8b 45 14             	mov    0x14(%ebp),%eax
  80ec9d:	8d 40 08             	lea    0x8(%eax),%eax
  80eca0:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 16;
  80eca3:	ba 10 00 00 00       	mov    $0x10,%edx
  80eca8:	eb 98                	jmp    80ec42 <vprintfmt+0x417>
	else if (lflag)
  80ecaa:	85 c9                	test   %ecx,%ecx
  80ecac:	75 23                	jne    80ecd1 <vprintfmt+0x4a6>
		return va_arg(*ap, unsigned int);
  80ecae:	8b 45 14             	mov    0x14(%ebp),%eax
  80ecb1:	8b 00                	mov    (%eax),%eax
  80ecb3:	ba 00 00 00 00       	mov    $0x0,%edx
  80ecb8:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ecbb:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80ecbe:	8b 45 14             	mov    0x14(%ebp),%eax
  80ecc1:	8d 40 04             	lea    0x4(%eax),%eax
  80ecc4:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 16;
  80ecc7:	ba 10 00 00 00       	mov    $0x10,%edx
  80eccc:	e9 71 ff ff ff       	jmp    80ec42 <vprintfmt+0x417>
		return va_arg(*ap, unsigned long);
  80ecd1:	8b 45 14             	mov    0x14(%ebp),%eax
  80ecd4:	8b 00                	mov    (%eax),%eax
  80ecd6:	ba 00 00 00 00       	mov    $0x0,%edx
  80ecdb:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ecde:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80ece1:	8b 45 14             	mov    0x14(%ebp),%eax
  80ece4:	8d 40 04             	lea    0x4(%eax),%eax
  80ece7:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 16;
  80ecea:	ba 10 00 00 00       	mov    $0x10,%edx
  80ecef:	e9 4e ff ff ff       	jmp    80ec42 <vprintfmt+0x417>
			putch(ch, putdat);
  80ecf4:	83 ec 08             	sub    $0x8,%esp
  80ecf7:	53                   	push   %ebx
  80ecf8:	6a 25                	push   $0x25
  80ecfa:	ff d6                	call   *%esi
			break;
  80ecfc:	83 c4 10             	add    $0x10,%esp
  80ecff:	e9 5c ff ff ff       	jmp    80ec60 <vprintfmt+0x435>
			putch('%', putdat);
  80ed04:	83 ec 08             	sub    $0x8,%esp
  80ed07:	53                   	push   %ebx
  80ed08:	6a 25                	push   $0x25
  80ed0a:	ff d6                	call   *%esi
			for (fmt--; fmt[-1] != '%'; fmt--)
  80ed0c:	83 c4 10             	add    $0x10,%esp
  80ed0f:	89 f8                	mov    %edi,%eax
  80ed11:	eb 03                	jmp    80ed16 <vprintfmt+0x4eb>
  80ed13:	83 e8 01             	sub    $0x1,%eax
  80ed16:	80 78 ff 25          	cmpb   $0x25,-0x1(%eax)
  80ed1a:	75 f7                	jne    80ed13 <vprintfmt+0x4e8>
  80ed1c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80ed1f:	e9 3c ff ff ff       	jmp    80ec60 <vprintfmt+0x435>
}
  80ed24:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80ed27:	5b                   	pop    %ebx
  80ed28:	5e                   	pop    %esi
  80ed29:	5f                   	pop    %edi
  80ed2a:	5d                   	pop    %ebp
  80ed2b:	c3                   	ret    

0080ed2c <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  80ed2c:	55                   	push   %ebp
  80ed2d:	89 e5                	mov    %esp,%ebp
  80ed2f:	83 ec 18             	sub    $0x18,%esp
  80ed32:	8b 45 08             	mov    0x8(%ebp),%eax
  80ed35:	8b 55 0c             	mov    0xc(%ebp),%edx
	struct sprintbuf b = {buf, buf+n-1, 0};
  80ed38:	89 45 ec             	mov    %eax,-0x14(%ebp)
  80ed3b:	8d 4c 10 ff          	lea    -0x1(%eax,%edx,1),%ecx
  80ed3f:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  80ed42:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	if (buf == NULL || n < 1)
  80ed49:	85 c0                	test   %eax,%eax
  80ed4b:	74 26                	je     80ed73 <vsnprintf+0x47>
  80ed4d:	85 d2                	test   %edx,%edx
  80ed4f:	7e 22                	jle    80ed73 <vsnprintf+0x47>
		return -E_INVAL;

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, ap);
  80ed51:	ff 75 14             	pushl  0x14(%ebp)
  80ed54:	ff 75 10             	pushl  0x10(%ebp)
  80ed57:	8d 45 ec             	lea    -0x14(%ebp),%eax
  80ed5a:	50                   	push   %eax
  80ed5b:	68 f1 e7 80 00       	push   $0x80e7f1
  80ed60:	e8 c6 fa ff ff       	call   80e82b <vprintfmt>

	// null terminate the buffer
	*b.buf = '\0';
  80ed65:	8b 45 ec             	mov    -0x14(%ebp),%eax
  80ed68:	c6 00 00             	movb   $0x0,(%eax)

	return b.cnt;
  80ed6b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80ed6e:	83 c4 10             	add    $0x10,%esp
}
  80ed71:	c9                   	leave  
  80ed72:	c3                   	ret    
		return -E_INVAL;
  80ed73:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80ed78:	eb f7                	jmp    80ed71 <vsnprintf+0x45>

0080ed7a <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  80ed7a:	55                   	push   %ebp
  80ed7b:	89 e5                	mov    %esp,%ebp
  80ed7d:	83 ec 08             	sub    $0x8,%esp
	va_list ap;
	int rc;

	va_start(ap, fmt);
  80ed80:	8d 45 14             	lea    0x14(%ebp),%eax
	rc = vsnprintf(buf, n, fmt, ap);
  80ed83:	50                   	push   %eax
  80ed84:	ff 75 10             	pushl  0x10(%ebp)
  80ed87:	ff 75 0c             	pushl  0xc(%ebp)
  80ed8a:	ff 75 08             	pushl  0x8(%ebp)
  80ed8d:	e8 9a ff ff ff       	call   80ed2c <vsnprintf>
	va_end(ap);

	return rc;
}
  80ed92:	c9                   	leave  
  80ed93:	c3                   	ret    

0080ed94 <strlen>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  80ed94:	55                   	push   %ebp
  80ed95:	89 e5                	mov    %esp,%ebp
  80ed97:	8b 55 08             	mov    0x8(%ebp),%edx
	int n;

	for (n = 0; *s != '\0'; s++)
  80ed9a:	b8 00 00 00 00       	mov    $0x0,%eax
  80ed9f:	eb 03                	jmp    80eda4 <strlen+0x10>
		n++;
  80eda1:	83 c0 01             	add    $0x1,%eax
	for (n = 0; *s != '\0'; s++)
  80eda4:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
  80eda8:	75 f7                	jne    80eda1 <strlen+0xd>
	return n;
}
  80edaa:	5d                   	pop    %ebp
  80edab:	c3                   	ret    

0080edac <strnlen>:

int
strnlen(const char *s, size_t size)
{
  80edac:	55                   	push   %ebp
  80edad:	89 e5                	mov    %esp,%ebp
  80edaf:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80edb2:	8b 55 0c             	mov    0xc(%ebp),%edx
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  80edb5:	b8 00 00 00 00       	mov    $0x0,%eax
  80edba:	eb 03                	jmp    80edbf <strnlen+0x13>
		n++;
  80edbc:	83 c0 01             	add    $0x1,%eax
	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  80edbf:	39 d0                	cmp    %edx,%eax
  80edc1:	74 06                	je     80edc9 <strnlen+0x1d>
  80edc3:	80 3c 01 00          	cmpb   $0x0,(%ecx,%eax,1)
  80edc7:	75 f3                	jne    80edbc <strnlen+0x10>
	return n;
}
  80edc9:	5d                   	pop    %ebp
  80edca:	c3                   	ret    

0080edcb <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  80edcb:	55                   	push   %ebp
  80edcc:	89 e5                	mov    %esp,%ebp
  80edce:	53                   	push   %ebx
  80edcf:	8b 45 08             	mov    0x8(%ebp),%eax
  80edd2:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	char *ret;

	ret = dst;
	while ((*dst++ = *src++) != '\0')
  80edd5:	89 c2                	mov    %eax,%edx
  80edd7:	83 c1 01             	add    $0x1,%ecx
  80edda:	83 c2 01             	add    $0x1,%edx
  80eddd:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
  80ede1:	88 5a ff             	mov    %bl,-0x1(%edx)
  80ede4:	84 db                	test   %bl,%bl
  80ede6:	75 ef                	jne    80edd7 <strcpy+0xc>
		/* do nothing */;
	return ret;
}
  80ede8:	5b                   	pop    %ebx
  80ede9:	5d                   	pop    %ebp
  80edea:	c3                   	ret    

0080edeb <strcat>:

char *
strcat(char *dst, const char *src)
{
  80edeb:	55                   	push   %ebp
  80edec:	89 e5                	mov    %esp,%ebp
  80edee:	53                   	push   %ebx
  80edef:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int len = strlen(dst);
  80edf2:	53                   	push   %ebx
  80edf3:	e8 9c ff ff ff       	call   80ed94 <strlen>
  80edf8:	83 c4 04             	add    $0x4,%esp
	strcpy(dst + len, src);
  80edfb:	ff 75 0c             	pushl  0xc(%ebp)
  80edfe:	01 d8                	add    %ebx,%eax
  80ee00:	50                   	push   %eax
  80ee01:	e8 c5 ff ff ff       	call   80edcb <strcpy>
	return dst;
}
  80ee06:	89 d8                	mov    %ebx,%eax
  80ee08:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ee0b:	c9                   	leave  
  80ee0c:	c3                   	ret    

0080ee0d <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  80ee0d:	55                   	push   %ebp
  80ee0e:	89 e5                	mov    %esp,%ebp
  80ee10:	56                   	push   %esi
  80ee11:	53                   	push   %ebx
  80ee12:	8b 75 08             	mov    0x8(%ebp),%esi
  80ee15:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80ee18:	89 f3                	mov    %esi,%ebx
  80ee1a:	03 5d 10             	add    0x10(%ebp),%ebx
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  80ee1d:	89 f2                	mov    %esi,%edx
  80ee1f:	eb 0f                	jmp    80ee30 <strncpy+0x23>
		*dst++ = *src;
  80ee21:	83 c2 01             	add    $0x1,%edx
  80ee24:	0f b6 01             	movzbl (%ecx),%eax
  80ee27:	88 42 ff             	mov    %al,-0x1(%edx)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
  80ee2a:	80 39 01             	cmpb   $0x1,(%ecx)
  80ee2d:	83 d9 ff             	sbb    $0xffffffff,%ecx
	for (i = 0; i < size; i++) {
  80ee30:	39 da                	cmp    %ebx,%edx
  80ee32:	75 ed                	jne    80ee21 <strncpy+0x14>
	}
	return ret;
}
  80ee34:	89 f0                	mov    %esi,%eax
  80ee36:	5b                   	pop    %ebx
  80ee37:	5e                   	pop    %esi
  80ee38:	5d                   	pop    %ebp
  80ee39:	c3                   	ret    

0080ee3a <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  80ee3a:	55                   	push   %ebp
  80ee3b:	89 e5                	mov    %esp,%ebp
  80ee3d:	56                   	push   %esi
  80ee3e:	53                   	push   %ebx
  80ee3f:	8b 75 08             	mov    0x8(%ebp),%esi
  80ee42:	8b 55 0c             	mov    0xc(%ebp),%edx
  80ee45:	8b 4d 10             	mov    0x10(%ebp),%ecx
  80ee48:	89 f0                	mov    %esi,%eax
  80ee4a:	8d 5c 0e ff          	lea    -0x1(%esi,%ecx,1),%ebx
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
  80ee4e:	85 c9                	test   %ecx,%ecx
  80ee50:	75 0b                	jne    80ee5d <strlcpy+0x23>
  80ee52:	eb 17                	jmp    80ee6b <strlcpy+0x31>
		while (--size > 0 && *src != '\0')
			*dst++ = *src++;
  80ee54:	83 c2 01             	add    $0x1,%edx
  80ee57:	83 c0 01             	add    $0x1,%eax
  80ee5a:	88 48 ff             	mov    %cl,-0x1(%eax)
		while (--size > 0 && *src != '\0')
  80ee5d:	39 d8                	cmp    %ebx,%eax
  80ee5f:	74 07                	je     80ee68 <strlcpy+0x2e>
  80ee61:	0f b6 0a             	movzbl (%edx),%ecx
  80ee64:	84 c9                	test   %cl,%cl
  80ee66:	75 ec                	jne    80ee54 <strlcpy+0x1a>
		*dst = '\0';
  80ee68:	c6 00 00             	movb   $0x0,(%eax)
	}
	return dst - dst_in;
  80ee6b:	29 f0                	sub    %esi,%eax
}
  80ee6d:	5b                   	pop    %ebx
  80ee6e:	5e                   	pop    %esi
  80ee6f:	5d                   	pop    %ebp
  80ee70:	c3                   	ret    

0080ee71 <strcmp>:

int
strcmp(const char *p, const char *q)
{
  80ee71:	55                   	push   %ebp
  80ee72:	89 e5                	mov    %esp,%ebp
  80ee74:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80ee77:	8b 55 0c             	mov    0xc(%ebp),%edx
	while (*p && *p == *q)
  80ee7a:	eb 06                	jmp    80ee82 <strcmp+0x11>
		p++, q++;
  80ee7c:	83 c1 01             	add    $0x1,%ecx
  80ee7f:	83 c2 01             	add    $0x1,%edx
	while (*p && *p == *q)
  80ee82:	0f b6 01             	movzbl (%ecx),%eax
  80ee85:	84 c0                	test   %al,%al
  80ee87:	74 04                	je     80ee8d <strcmp+0x1c>
  80ee89:	3a 02                	cmp    (%edx),%al
  80ee8b:	74 ef                	je     80ee7c <strcmp+0xb>
	return (int) ((unsigned char) *p - (unsigned char) *q);
  80ee8d:	0f b6 c0             	movzbl %al,%eax
  80ee90:	0f b6 12             	movzbl (%edx),%edx
  80ee93:	29 d0                	sub    %edx,%eax
}
  80ee95:	5d                   	pop    %ebp
  80ee96:	c3                   	ret    

0080ee97 <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  80ee97:	55                   	push   %ebp
  80ee98:	89 e5                	mov    %esp,%ebp
  80ee9a:	53                   	push   %ebx
  80ee9b:	8b 45 08             	mov    0x8(%ebp),%eax
  80ee9e:	8b 55 0c             	mov    0xc(%ebp),%edx
  80eea1:	89 c3                	mov    %eax,%ebx
  80eea3:	03 5d 10             	add    0x10(%ebp),%ebx
	while (n > 0 && *p && *p == *q)
  80eea6:	eb 06                	jmp    80eeae <strncmp+0x17>
		n--, p++, q++;
  80eea8:	83 c0 01             	add    $0x1,%eax
  80eeab:	83 c2 01             	add    $0x1,%edx
	while (n > 0 && *p && *p == *q)
  80eeae:	39 d8                	cmp    %ebx,%eax
  80eeb0:	74 16                	je     80eec8 <strncmp+0x31>
  80eeb2:	0f b6 08             	movzbl (%eax),%ecx
  80eeb5:	84 c9                	test   %cl,%cl
  80eeb7:	74 04                	je     80eebd <strncmp+0x26>
  80eeb9:	3a 0a                	cmp    (%edx),%cl
  80eebb:	74 eb                	je     80eea8 <strncmp+0x11>
	if (n == 0)
		return 0;
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  80eebd:	0f b6 00             	movzbl (%eax),%eax
  80eec0:	0f b6 12             	movzbl (%edx),%edx
  80eec3:	29 d0                	sub    %edx,%eax
}
  80eec5:	5b                   	pop    %ebx
  80eec6:	5d                   	pop    %ebp
  80eec7:	c3                   	ret    
		return 0;
  80eec8:	b8 00 00 00 00       	mov    $0x0,%eax
  80eecd:	eb f6                	jmp    80eec5 <strncmp+0x2e>

0080eecf <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  80eecf:	55                   	push   %ebp
  80eed0:	89 e5                	mov    %esp,%ebp
  80eed2:	8b 45 08             	mov    0x8(%ebp),%eax
  80eed5:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	for (; *s; s++)
  80eed9:	0f b6 10             	movzbl (%eax),%edx
  80eedc:	84 d2                	test   %dl,%dl
  80eede:	74 09                	je     80eee9 <strchr+0x1a>
		if (*s == c)
  80eee0:	38 ca                	cmp    %cl,%dl
  80eee2:	74 0a                	je     80eeee <strchr+0x1f>
	for (; *s; s++)
  80eee4:	83 c0 01             	add    $0x1,%eax
  80eee7:	eb f0                	jmp    80eed9 <strchr+0xa>
			return (char *) s;
	return 0;
  80eee9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80eeee:	5d                   	pop    %ebp
  80eeef:	c3                   	ret    

0080eef0 <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  80eef0:	55                   	push   %ebp
  80eef1:	89 e5                	mov    %esp,%ebp
  80eef3:	8b 45 08             	mov    0x8(%ebp),%eax
  80eef6:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	for (; *s; s++)
  80eefa:	eb 03                	jmp    80eeff <strfind+0xf>
  80eefc:	83 c0 01             	add    $0x1,%eax
  80eeff:	0f b6 10             	movzbl (%eax),%edx
		if (*s == c)
  80ef02:	38 ca                	cmp    %cl,%dl
  80ef04:	74 04                	je     80ef0a <strfind+0x1a>
  80ef06:	84 d2                	test   %dl,%dl
  80ef08:	75 f2                	jne    80eefc <strfind+0xc>
			break;
	return (char *) s;
}
  80ef0a:	5d                   	pop    %ebp
  80ef0b:	c3                   	ret    

0080ef0c <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  80ef0c:	55                   	push   %ebp
  80ef0d:	89 e5                	mov    %esp,%ebp
  80ef0f:	57                   	push   %edi
  80ef10:	56                   	push   %esi
  80ef11:	53                   	push   %ebx
  80ef12:	8b 7d 08             	mov    0x8(%ebp),%edi
  80ef15:	8b 4d 10             	mov    0x10(%ebp),%ecx
	char *p;

	if (n == 0)
  80ef18:	85 c9                	test   %ecx,%ecx
  80ef1a:	74 13                	je     80ef2f <memset+0x23>
		return v;
	if ((int)v%4 == 0 && n%4 == 0) {
  80ef1c:	f7 c7 03 00 00 00    	test   $0x3,%edi
  80ef22:	75 05                	jne    80ef29 <memset+0x1d>
  80ef24:	f6 c1 03             	test   $0x3,%cl
  80ef27:	74 0d                	je     80ef36 <memset+0x2a>
		c = (c<<24)|(c<<16)|(c<<8)|c;
		asm volatile("cld; rep stosl\n"
			:: "D" (v), "a" (c), "c" (n/4)
			: "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  80ef29:	8b 45 0c             	mov    0xc(%ebp),%eax
  80ef2c:	fc                   	cld    
  80ef2d:	f3 aa                	rep stos %al,%es:(%edi)
			:: "D" (v), "a" (c), "c" (n)
			: "cc", "memory");
	return v;
}
  80ef2f:	89 f8                	mov    %edi,%eax
  80ef31:	5b                   	pop    %ebx
  80ef32:	5e                   	pop    %esi
  80ef33:	5f                   	pop    %edi
  80ef34:	5d                   	pop    %ebp
  80ef35:	c3                   	ret    
		c &= 0xFF;
  80ef36:	0f b6 55 0c          	movzbl 0xc(%ebp),%edx
		c = (c<<24)|(c<<16)|(c<<8)|c;
  80ef3a:	89 d3                	mov    %edx,%ebx
  80ef3c:	c1 e3 08             	shl    $0x8,%ebx
  80ef3f:	89 d0                	mov    %edx,%eax
  80ef41:	c1 e0 18             	shl    $0x18,%eax
  80ef44:	89 d6                	mov    %edx,%esi
  80ef46:	c1 e6 10             	shl    $0x10,%esi
  80ef49:	09 f0                	or     %esi,%eax
  80ef4b:	09 c2                	or     %eax,%edx
  80ef4d:	09 da                	or     %ebx,%edx
			:: "D" (v), "a" (c), "c" (n/4)
  80ef4f:	c1 e9 02             	shr    $0x2,%ecx
		asm volatile("cld; rep stosl\n"
  80ef52:	89 d0                	mov    %edx,%eax
  80ef54:	fc                   	cld    
  80ef55:	f3 ab                	rep stos %eax,%es:(%edi)
  80ef57:	eb d6                	jmp    80ef2f <memset+0x23>

0080ef59 <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  80ef59:	55                   	push   %ebp
  80ef5a:	89 e5                	mov    %esp,%ebp
  80ef5c:	57                   	push   %edi
  80ef5d:	56                   	push   %esi
  80ef5e:	8b 45 08             	mov    0x8(%ebp),%eax
  80ef61:	8b 75 0c             	mov    0xc(%ebp),%esi
  80ef64:	8b 4d 10             	mov    0x10(%ebp),%ecx
	const char *s;
	char *d;

	s = src;
	d = dst;
	if (s < d && s + n > d) {
  80ef67:	39 c6                	cmp    %eax,%esi
  80ef69:	73 35                	jae    80efa0 <memmove+0x47>
  80ef6b:	8d 14 0e             	lea    (%esi,%ecx,1),%edx
  80ef6e:	39 c2                	cmp    %eax,%edx
  80ef70:	76 2e                	jbe    80efa0 <memmove+0x47>
		s += n;
		d += n;
  80ef72:	8d 3c 08             	lea    (%eax,%ecx,1),%edi
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  80ef75:	89 d6                	mov    %edx,%esi
  80ef77:	09 fe                	or     %edi,%esi
  80ef79:	f7 c6 03 00 00 00    	test   $0x3,%esi
  80ef7f:	74 0c                	je     80ef8d <memmove+0x34>
			asm volatile("std; rep movsl\n"
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
  80ef81:	83 ef 01             	sub    $0x1,%edi
  80ef84:	8d 72 ff             	lea    -0x1(%edx),%esi
			asm volatile("std; rep movsb\n"
  80ef87:	fd                   	std    
  80ef88:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  80ef8a:	fc                   	cld    
  80ef8b:	eb 21                	jmp    80efae <memmove+0x55>
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  80ef8d:	f6 c1 03             	test   $0x3,%cl
  80ef90:	75 ef                	jne    80ef81 <memmove+0x28>
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
  80ef92:	83 ef 04             	sub    $0x4,%edi
  80ef95:	8d 72 fc             	lea    -0x4(%edx),%esi
  80ef98:	c1 e9 02             	shr    $0x2,%ecx
			asm volatile("std; rep movsl\n"
  80ef9b:	fd                   	std    
  80ef9c:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  80ef9e:	eb ea                	jmp    80ef8a <memmove+0x31>
	} else {
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  80efa0:	89 f2                	mov    %esi,%edx
  80efa2:	09 c2                	or     %eax,%edx
  80efa4:	f6 c2 03             	test   $0x3,%dl
  80efa7:	74 09                	je     80efb2 <memmove+0x59>
			asm volatile("cld; rep movsl\n"
				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
		else
			asm volatile("cld; rep movsb\n"
  80efa9:	89 c7                	mov    %eax,%edi
  80efab:	fc                   	cld    
  80efac:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
				:: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
}
  80efae:	5e                   	pop    %esi
  80efaf:	5f                   	pop    %edi
  80efb0:	5d                   	pop    %ebp
  80efb1:	c3                   	ret    
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  80efb2:	f6 c1 03             	test   $0x3,%cl
  80efb5:	75 f2                	jne    80efa9 <memmove+0x50>
				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
  80efb7:	c1 e9 02             	shr    $0x2,%ecx
			asm volatile("cld; rep movsl\n"
  80efba:	89 c7                	mov    %eax,%edi
  80efbc:	fc                   	cld    
  80efbd:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  80efbf:	eb ed                	jmp    80efae <memmove+0x55>

0080efc1 <memcpy>:
}
#endif

void *
memcpy(void *dst, const void *src, size_t n)
{
  80efc1:	55                   	push   %ebp
  80efc2:	89 e5                	mov    %esp,%ebp
	return memmove(dst, src, n);
  80efc4:	ff 75 10             	pushl  0x10(%ebp)
  80efc7:	ff 75 0c             	pushl  0xc(%ebp)
  80efca:	ff 75 08             	pushl  0x8(%ebp)
  80efcd:	e8 87 ff ff ff       	call   80ef59 <memmove>
}
  80efd2:	c9                   	leave  
  80efd3:	c3                   	ret    

0080efd4 <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  80efd4:	55                   	push   %ebp
  80efd5:	89 e5                	mov    %esp,%ebp
  80efd7:	56                   	push   %esi
  80efd8:	53                   	push   %ebx
  80efd9:	8b 45 08             	mov    0x8(%ebp),%eax
  80efdc:	8b 55 0c             	mov    0xc(%ebp),%edx
  80efdf:	89 c6                	mov    %eax,%esi
  80efe1:	03 75 10             	add    0x10(%ebp),%esi
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  80efe4:	39 f0                	cmp    %esi,%eax
  80efe6:	74 1c                	je     80f004 <memcmp+0x30>
		if (*s1 != *s2)
  80efe8:	0f b6 08             	movzbl (%eax),%ecx
  80efeb:	0f b6 1a             	movzbl (%edx),%ebx
  80efee:	38 d9                	cmp    %bl,%cl
  80eff0:	75 08                	jne    80effa <memcmp+0x26>
			return (int) *s1 - (int) *s2;
		s1++, s2++;
  80eff2:	83 c0 01             	add    $0x1,%eax
  80eff5:	83 c2 01             	add    $0x1,%edx
  80eff8:	eb ea                	jmp    80efe4 <memcmp+0x10>
			return (int) *s1 - (int) *s2;
  80effa:	0f b6 c1             	movzbl %cl,%eax
  80effd:	0f b6 db             	movzbl %bl,%ebx
  80f000:	29 d8                	sub    %ebx,%eax
  80f002:	eb 05                	jmp    80f009 <memcmp+0x35>
	}

	return 0;
  80f004:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80f009:	5b                   	pop    %ebx
  80f00a:	5e                   	pop    %esi
  80f00b:	5d                   	pop    %ebp
  80f00c:	c3                   	ret    

0080f00d <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  80f00d:	55                   	push   %ebp
  80f00e:	89 e5                	mov    %esp,%ebp
  80f010:	8b 45 08             	mov    0x8(%ebp),%eax
  80f013:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	const void *ends = (const char *) s + n;
  80f016:	89 c2                	mov    %eax,%edx
  80f018:	03 55 10             	add    0x10(%ebp),%edx
	for (; s < ends; s++)
  80f01b:	39 d0                	cmp    %edx,%eax
  80f01d:	73 09                	jae    80f028 <memfind+0x1b>
		if (*(const unsigned char *) s == (unsigned char) c)
  80f01f:	38 08                	cmp    %cl,(%eax)
  80f021:	74 05                	je     80f028 <memfind+0x1b>
	for (; s < ends; s++)
  80f023:	83 c0 01             	add    $0x1,%eax
  80f026:	eb f3                	jmp    80f01b <memfind+0xe>
			break;
	return (void *) s;
}
  80f028:	5d                   	pop    %ebp
  80f029:	c3                   	ret    

0080f02a <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  80f02a:	55                   	push   %ebp
  80f02b:	89 e5                	mov    %esp,%ebp
  80f02d:	57                   	push   %edi
  80f02e:	56                   	push   %esi
  80f02f:	53                   	push   %ebx
  80f030:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80f033:	8b 5d 10             	mov    0x10(%ebp),%ebx
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  80f036:	eb 03                	jmp    80f03b <strtol+0x11>
		s++;
  80f038:	83 c1 01             	add    $0x1,%ecx
	while (*s == ' ' || *s == '\t')
  80f03b:	0f b6 01             	movzbl (%ecx),%eax
  80f03e:	3c 20                	cmp    $0x20,%al
  80f040:	74 f6                	je     80f038 <strtol+0xe>
  80f042:	3c 09                	cmp    $0x9,%al
  80f044:	74 f2                	je     80f038 <strtol+0xe>

	// plus/minus sign
	if (*s == '+')
  80f046:	3c 2b                	cmp    $0x2b,%al
  80f048:	74 2e                	je     80f078 <strtol+0x4e>
	int neg = 0;
  80f04a:	bf 00 00 00 00       	mov    $0x0,%edi
		s++;
	else if (*s == '-')
  80f04f:	3c 2d                	cmp    $0x2d,%al
  80f051:	74 2f                	je     80f082 <strtol+0x58>
		s++, neg = 1;

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  80f053:	f7 c3 ef ff ff ff    	test   $0xffffffef,%ebx
  80f059:	75 05                	jne    80f060 <strtol+0x36>
  80f05b:	80 39 30             	cmpb   $0x30,(%ecx)
  80f05e:	74 2c                	je     80f08c <strtol+0x62>
		s += 2, base = 16;
	else if (base == 0 && s[0] == '0')
  80f060:	85 db                	test   %ebx,%ebx
  80f062:	75 0a                	jne    80f06e <strtol+0x44>
		s++, base = 8;
	else if (base == 0)
		base = 10;
  80f064:	bb 0a 00 00 00       	mov    $0xa,%ebx
	else if (base == 0 && s[0] == '0')
  80f069:	80 39 30             	cmpb   $0x30,(%ecx)
  80f06c:	74 28                	je     80f096 <strtol+0x6c>
		base = 10;
  80f06e:	b8 00 00 00 00       	mov    $0x0,%eax
  80f073:	89 5d 10             	mov    %ebx,0x10(%ebp)
  80f076:	eb 50                	jmp    80f0c8 <strtol+0x9e>
		s++;
  80f078:	83 c1 01             	add    $0x1,%ecx
	int neg = 0;
  80f07b:	bf 00 00 00 00       	mov    $0x0,%edi
  80f080:	eb d1                	jmp    80f053 <strtol+0x29>
		s++, neg = 1;
  80f082:	83 c1 01             	add    $0x1,%ecx
  80f085:	bf 01 00 00 00       	mov    $0x1,%edi
  80f08a:	eb c7                	jmp    80f053 <strtol+0x29>
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  80f08c:	80 79 01 78          	cmpb   $0x78,0x1(%ecx)
  80f090:	74 0e                	je     80f0a0 <strtol+0x76>
	else if (base == 0 && s[0] == '0')
  80f092:	85 db                	test   %ebx,%ebx
  80f094:	75 d8                	jne    80f06e <strtol+0x44>
		s++, base = 8;
  80f096:	83 c1 01             	add    $0x1,%ecx
  80f099:	bb 08 00 00 00       	mov    $0x8,%ebx
  80f09e:	eb ce                	jmp    80f06e <strtol+0x44>
		s += 2, base = 16;
  80f0a0:	83 c1 02             	add    $0x2,%ecx
  80f0a3:	bb 10 00 00 00       	mov    $0x10,%ebx
  80f0a8:	eb c4                	jmp    80f06e <strtol+0x44>
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
			dig = *s - '0';
		else if (*s >= 'a' && *s <= 'z')
  80f0aa:	8d 72 9f             	lea    -0x61(%edx),%esi
  80f0ad:	89 f3                	mov    %esi,%ebx
  80f0af:	80 fb 19             	cmp    $0x19,%bl
  80f0b2:	77 29                	ja     80f0dd <strtol+0xb3>
			dig = *s - 'a' + 10;
  80f0b4:	0f be d2             	movsbl %dl,%edx
  80f0b7:	83 ea 57             	sub    $0x57,%edx
		else if (*s >= 'A' && *s <= 'Z')
			dig = *s - 'A' + 10;
		else
			break;
		if (dig >= base)
  80f0ba:	3b 55 10             	cmp    0x10(%ebp),%edx
  80f0bd:	7d 30                	jge    80f0ef <strtol+0xc5>
			break;
		s++, val = (val * base) + dig;
  80f0bf:	83 c1 01             	add    $0x1,%ecx
  80f0c2:	0f af 45 10          	imul   0x10(%ebp),%eax
  80f0c6:	01 d0                	add    %edx,%eax
		if (*s >= '0' && *s <= '9')
  80f0c8:	0f b6 11             	movzbl (%ecx),%edx
  80f0cb:	8d 72 d0             	lea    -0x30(%edx),%esi
  80f0ce:	89 f3                	mov    %esi,%ebx
  80f0d0:	80 fb 09             	cmp    $0x9,%bl
  80f0d3:	77 d5                	ja     80f0aa <strtol+0x80>
			dig = *s - '0';
  80f0d5:	0f be d2             	movsbl %dl,%edx
  80f0d8:	83 ea 30             	sub    $0x30,%edx
  80f0db:	eb dd                	jmp    80f0ba <strtol+0x90>
		else if (*s >= 'A' && *s <= 'Z')
  80f0dd:	8d 72 bf             	lea    -0x41(%edx),%esi
  80f0e0:	89 f3                	mov    %esi,%ebx
  80f0e2:	80 fb 19             	cmp    $0x19,%bl
  80f0e5:	77 08                	ja     80f0ef <strtol+0xc5>
			dig = *s - 'A' + 10;
  80f0e7:	0f be d2             	movsbl %dl,%edx
  80f0ea:	83 ea 37             	sub    $0x37,%edx
  80f0ed:	eb cb                	jmp    80f0ba <strtol+0x90>
		// we don't properly detect overflow!
	}

	if (endptr)
  80f0ef:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80f0f3:	74 05                	je     80f0fa <strtol+0xd0>
		*endptr = (char *) s;
  80f0f5:	8b 75 0c             	mov    0xc(%ebp),%esi
  80f0f8:	89 0e                	mov    %ecx,(%esi)
	return (neg ? -val : val);
  80f0fa:	89 c2                	mov    %eax,%edx
  80f0fc:	f7 da                	neg    %edx
  80f0fe:	85 ff                	test   %edi,%edi
  80f100:	0f 45 c2             	cmovne %edx,%eax
}
  80f103:	5b                   	pop    %ebx
  80f104:	5e                   	pop    %esi
  80f105:	5f                   	pop    %edi
  80f106:	5d                   	pop    %ebp
  80f107:	c3                   	ret    

0080f108 <sys_cputs>:
	return ret;
}

void
sys_cputs(const char *s, size_t len)
{
  80f108:	55                   	push   %ebp
  80f109:	89 e5                	mov    %esp,%ebp
  80f10b:	57                   	push   %edi
  80f10c:	56                   	push   %esi
  80f10d:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f10e:	b8 00 00 00 00       	mov    $0x0,%eax
  80f113:	8b 55 08             	mov    0x8(%ebp),%edx
  80f116:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f119:	89 c3                	mov    %eax,%ebx
  80f11b:	89 c7                	mov    %eax,%edi
  80f11d:	89 c6                	mov    %eax,%esi
  80f11f:	cd 30                	int    $0x30
	syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);
}
  80f121:	5b                   	pop    %ebx
  80f122:	5e                   	pop    %esi
  80f123:	5f                   	pop    %edi
  80f124:	5d                   	pop    %ebp
  80f125:	c3                   	ret    

0080f126 <sys_cgetc>:

int
sys_cgetc(void)
{
  80f126:	55                   	push   %ebp
  80f127:	89 e5                	mov    %esp,%ebp
  80f129:	57                   	push   %edi
  80f12a:	56                   	push   %esi
  80f12b:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f12c:	ba 00 00 00 00       	mov    $0x0,%edx
  80f131:	b8 01 00 00 00       	mov    $0x1,%eax
  80f136:	89 d1                	mov    %edx,%ecx
  80f138:	89 d3                	mov    %edx,%ebx
  80f13a:	89 d7                	mov    %edx,%edi
  80f13c:	89 d6                	mov    %edx,%esi
  80f13e:	cd 30                	int    $0x30
	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
}
  80f140:	5b                   	pop    %ebx
  80f141:	5e                   	pop    %esi
  80f142:	5f                   	pop    %edi
  80f143:	5d                   	pop    %ebp
  80f144:	c3                   	ret    

0080f145 <sys_env_destroy>:

int
sys_env_destroy(envid_t envid)
{
  80f145:	55                   	push   %ebp
  80f146:	89 e5                	mov    %esp,%ebp
  80f148:	57                   	push   %edi
  80f149:	56                   	push   %esi
  80f14a:	53                   	push   %ebx
  80f14b:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f14e:	b9 00 00 00 00       	mov    $0x0,%ecx
  80f153:	8b 55 08             	mov    0x8(%ebp),%edx
  80f156:	b8 03 00 00 00       	mov    $0x3,%eax
  80f15b:	89 cb                	mov    %ecx,%ebx
  80f15d:	89 cf                	mov    %ecx,%edi
  80f15f:	89 ce                	mov    %ecx,%esi
  80f161:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f163:	85 c0                	test   %eax,%eax
  80f165:	7f 08                	jg     80f16f <sys_env_destroy+0x2a>
	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
}
  80f167:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f16a:	5b                   	pop    %ebx
  80f16b:	5e                   	pop    %esi
  80f16c:	5f                   	pop    %edi
  80f16d:	5d                   	pop    %ebp
  80f16e:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f16f:	83 ec 0c             	sub    $0xc,%esp
  80f172:	50                   	push   %eax
  80f173:	6a 03                	push   $0x3
  80f175:	68 df 37 81 00       	push   $0x8137df
  80f17a:	6a 23                	push   $0x23
  80f17c:	68 fc 37 81 00       	push   $0x8137fc
  80f181:	e8 cd f4 ff ff       	call   80e653 <_panic>

0080f186 <sys_getenvid>:

envid_t
sys_getenvid(void)
{
  80f186:	55                   	push   %ebp
  80f187:	89 e5                	mov    %esp,%ebp
  80f189:	57                   	push   %edi
  80f18a:	56                   	push   %esi
  80f18b:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f18c:	ba 00 00 00 00       	mov    $0x0,%edx
  80f191:	b8 02 00 00 00       	mov    $0x2,%eax
  80f196:	89 d1                	mov    %edx,%ecx
  80f198:	89 d3                	mov    %edx,%ebx
  80f19a:	89 d7                	mov    %edx,%edi
  80f19c:	89 d6                	mov    %edx,%esi
  80f19e:	cd 30                	int    $0x30
	 return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
}
  80f1a0:	5b                   	pop    %ebx
  80f1a1:	5e                   	pop    %esi
  80f1a2:	5f                   	pop    %edi
  80f1a3:	5d                   	pop    %ebp
  80f1a4:	c3                   	ret    

0080f1a5 <sys_yield>:

void
sys_yield(void)
{
  80f1a5:	55                   	push   %ebp
  80f1a6:	89 e5                	mov    %esp,%ebp
  80f1a8:	57                   	push   %edi
  80f1a9:	56                   	push   %esi
  80f1aa:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f1ab:	ba 00 00 00 00       	mov    $0x0,%edx
  80f1b0:	b8 0b 00 00 00       	mov    $0xb,%eax
  80f1b5:	89 d1                	mov    %edx,%ecx
  80f1b7:	89 d3                	mov    %edx,%ebx
  80f1b9:	89 d7                	mov    %edx,%edi
  80f1bb:	89 d6                	mov    %edx,%esi
  80f1bd:	cd 30                	int    $0x30
	syscall(SYS_yield, 0, 0, 0, 0, 0, 0);
}
  80f1bf:	5b                   	pop    %ebx
  80f1c0:	5e                   	pop    %esi
  80f1c1:	5f                   	pop    %edi
  80f1c2:	5d                   	pop    %ebp
  80f1c3:	c3                   	ret    

0080f1c4 <sys_page_alloc>:

int
sys_page_alloc(envid_t envid, void *va, int perm)
{
  80f1c4:	55                   	push   %ebp
  80f1c5:	89 e5                	mov    %esp,%ebp
  80f1c7:	57                   	push   %edi
  80f1c8:	56                   	push   %esi
  80f1c9:	53                   	push   %ebx
  80f1ca:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f1cd:	be 00 00 00 00       	mov    $0x0,%esi
  80f1d2:	8b 55 08             	mov    0x8(%ebp),%edx
  80f1d5:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f1d8:	b8 04 00 00 00       	mov    $0x4,%eax
  80f1dd:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80f1e0:	89 f7                	mov    %esi,%edi
  80f1e2:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f1e4:	85 c0                	test   %eax,%eax
  80f1e6:	7f 08                	jg     80f1f0 <sys_page_alloc+0x2c>
	return syscall(SYS_page_alloc, 1, envid, (uint32_t) va, perm, 0, 0);
}
  80f1e8:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f1eb:	5b                   	pop    %ebx
  80f1ec:	5e                   	pop    %esi
  80f1ed:	5f                   	pop    %edi
  80f1ee:	5d                   	pop    %ebp
  80f1ef:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f1f0:	83 ec 0c             	sub    $0xc,%esp
  80f1f3:	50                   	push   %eax
  80f1f4:	6a 04                	push   $0x4
  80f1f6:	68 df 37 81 00       	push   $0x8137df
  80f1fb:	6a 23                	push   $0x23
  80f1fd:	68 fc 37 81 00       	push   $0x8137fc
  80f202:	e8 4c f4 ff ff       	call   80e653 <_panic>

0080f207 <sys_page_map>:

int
sys_page_map(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, int perm)
{
  80f207:	55                   	push   %ebp
  80f208:	89 e5                	mov    %esp,%ebp
  80f20a:	57                   	push   %edi
  80f20b:	56                   	push   %esi
  80f20c:	53                   	push   %ebx
  80f20d:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f210:	8b 55 08             	mov    0x8(%ebp),%edx
  80f213:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f216:	b8 05 00 00 00       	mov    $0x5,%eax
  80f21b:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80f21e:	8b 7d 14             	mov    0x14(%ebp),%edi
  80f221:	8b 75 18             	mov    0x18(%ebp),%esi
  80f224:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f226:	85 c0                	test   %eax,%eax
  80f228:	7f 08                	jg     80f232 <sys_page_map+0x2b>
	return syscall(SYS_page_map, 1, srcenv, (uint32_t) srcva, dstenv, (uint32_t) dstva, perm);
}
  80f22a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f22d:	5b                   	pop    %ebx
  80f22e:	5e                   	pop    %esi
  80f22f:	5f                   	pop    %edi
  80f230:	5d                   	pop    %ebp
  80f231:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f232:	83 ec 0c             	sub    $0xc,%esp
  80f235:	50                   	push   %eax
  80f236:	6a 05                	push   $0x5
  80f238:	68 df 37 81 00       	push   $0x8137df
  80f23d:	6a 23                	push   $0x23
  80f23f:	68 fc 37 81 00       	push   $0x8137fc
  80f244:	e8 0a f4 ff ff       	call   80e653 <_panic>

0080f249 <sys_page_unmap>:

int
sys_page_unmap(envid_t envid, void *va)
{
  80f249:	55                   	push   %ebp
  80f24a:	89 e5                	mov    %esp,%ebp
  80f24c:	57                   	push   %edi
  80f24d:	56                   	push   %esi
  80f24e:	53                   	push   %ebx
  80f24f:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f252:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f257:	8b 55 08             	mov    0x8(%ebp),%edx
  80f25a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f25d:	b8 06 00 00 00       	mov    $0x6,%eax
  80f262:	89 df                	mov    %ebx,%edi
  80f264:	89 de                	mov    %ebx,%esi
  80f266:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f268:	85 c0                	test   %eax,%eax
  80f26a:	7f 08                	jg     80f274 <sys_page_unmap+0x2b>
	return syscall(SYS_page_unmap, 1, envid, (uint32_t) va, 0, 0, 0);
}
  80f26c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f26f:	5b                   	pop    %ebx
  80f270:	5e                   	pop    %esi
  80f271:	5f                   	pop    %edi
  80f272:	5d                   	pop    %ebp
  80f273:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f274:	83 ec 0c             	sub    $0xc,%esp
  80f277:	50                   	push   %eax
  80f278:	6a 06                	push   $0x6
  80f27a:	68 df 37 81 00       	push   $0x8137df
  80f27f:	6a 23                	push   $0x23
  80f281:	68 fc 37 81 00       	push   $0x8137fc
  80f286:	e8 c8 f3 ff ff       	call   80e653 <_panic>

0080f28b <sys_env_set_status>:

// sys_exofork is inlined in lib.h

int
sys_env_set_status(envid_t envid, int status)
{
  80f28b:	55                   	push   %ebp
  80f28c:	89 e5                	mov    %esp,%ebp
  80f28e:	57                   	push   %edi
  80f28f:	56                   	push   %esi
  80f290:	53                   	push   %ebx
  80f291:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f294:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f299:	8b 55 08             	mov    0x8(%ebp),%edx
  80f29c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f29f:	b8 08 00 00 00       	mov    $0x8,%eax
  80f2a4:	89 df                	mov    %ebx,%edi
  80f2a6:	89 de                	mov    %ebx,%esi
  80f2a8:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f2aa:	85 c0                	test   %eax,%eax
  80f2ac:	7f 08                	jg     80f2b6 <sys_env_set_status+0x2b>
	return syscall(SYS_env_set_status, 1, envid, status, 0, 0, 0);
}
  80f2ae:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f2b1:	5b                   	pop    %ebx
  80f2b2:	5e                   	pop    %esi
  80f2b3:	5f                   	pop    %edi
  80f2b4:	5d                   	pop    %ebp
  80f2b5:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f2b6:	83 ec 0c             	sub    $0xc,%esp
  80f2b9:	50                   	push   %eax
  80f2ba:	6a 08                	push   $0x8
  80f2bc:	68 df 37 81 00       	push   $0x8137df
  80f2c1:	6a 23                	push   $0x23
  80f2c3:	68 fc 37 81 00       	push   $0x8137fc
  80f2c8:	e8 86 f3 ff ff       	call   80e653 <_panic>

0080f2cd <sys_env_set_trapframe>:

int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
  80f2cd:	55                   	push   %ebp
  80f2ce:	89 e5                	mov    %esp,%ebp
  80f2d0:	57                   	push   %edi
  80f2d1:	56                   	push   %esi
  80f2d2:	53                   	push   %ebx
  80f2d3:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f2d6:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f2db:	8b 55 08             	mov    0x8(%ebp),%edx
  80f2de:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f2e1:	b8 09 00 00 00       	mov    $0x9,%eax
  80f2e6:	89 df                	mov    %ebx,%edi
  80f2e8:	89 de                	mov    %ebx,%esi
  80f2ea:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f2ec:	85 c0                	test   %eax,%eax
  80f2ee:	7f 08                	jg     80f2f8 <sys_env_set_trapframe+0x2b>
	return syscall(SYS_env_set_trapframe, 1, envid, (uint32_t) tf, 0, 0, 0);
}
  80f2f0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f2f3:	5b                   	pop    %ebx
  80f2f4:	5e                   	pop    %esi
  80f2f5:	5f                   	pop    %edi
  80f2f6:	5d                   	pop    %ebp
  80f2f7:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f2f8:	83 ec 0c             	sub    $0xc,%esp
  80f2fb:	50                   	push   %eax
  80f2fc:	6a 09                	push   $0x9
  80f2fe:	68 df 37 81 00       	push   $0x8137df
  80f303:	6a 23                	push   $0x23
  80f305:	68 fc 37 81 00       	push   $0x8137fc
  80f30a:	e8 44 f3 ff ff       	call   80e653 <_panic>

0080f30f <sys_env_set_pgfault_upcall>:

int
sys_env_set_pgfault_upcall(envid_t envid, void *upcall)
{
  80f30f:	55                   	push   %ebp
  80f310:	89 e5                	mov    %esp,%ebp
  80f312:	57                   	push   %edi
  80f313:	56                   	push   %esi
  80f314:	53                   	push   %ebx
  80f315:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f318:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f31d:	8b 55 08             	mov    0x8(%ebp),%edx
  80f320:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f323:	b8 0a 00 00 00       	mov    $0xa,%eax
  80f328:	89 df                	mov    %ebx,%edi
  80f32a:	89 de                	mov    %ebx,%esi
  80f32c:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f32e:	85 c0                	test   %eax,%eax
  80f330:	7f 08                	jg     80f33a <sys_env_set_pgfault_upcall+0x2b>
	return syscall(SYS_env_set_pgfault_upcall, 1, envid, (uint32_t) upcall, 0, 0, 0);
}
  80f332:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f335:	5b                   	pop    %ebx
  80f336:	5e                   	pop    %esi
  80f337:	5f                   	pop    %edi
  80f338:	5d                   	pop    %ebp
  80f339:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f33a:	83 ec 0c             	sub    $0xc,%esp
  80f33d:	50                   	push   %eax
  80f33e:	6a 0a                	push   $0xa
  80f340:	68 df 37 81 00       	push   $0x8137df
  80f345:	6a 23                	push   $0x23
  80f347:	68 fc 37 81 00       	push   $0x8137fc
  80f34c:	e8 02 f3 ff ff       	call   80e653 <_panic>

0080f351 <sys_ipc_try_send>:

int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, int perm)
{
  80f351:	55                   	push   %ebp
  80f352:	89 e5                	mov    %esp,%ebp
  80f354:	57                   	push   %edi
  80f355:	56                   	push   %esi
  80f356:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f357:	8b 55 08             	mov    0x8(%ebp),%edx
  80f35a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f35d:	b8 0c 00 00 00       	mov    $0xc,%eax
  80f362:	be 00 00 00 00       	mov    $0x0,%esi
  80f367:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80f36a:	8b 7d 14             	mov    0x14(%ebp),%edi
  80f36d:	cd 30                	int    $0x30
	return syscall(SYS_ipc_try_send, 0, envid, value, (uint32_t) srcva, perm, 0);
}
  80f36f:	5b                   	pop    %ebx
  80f370:	5e                   	pop    %esi
  80f371:	5f                   	pop    %edi
  80f372:	5d                   	pop    %ebp
  80f373:	c3                   	ret    

0080f374 <sys_ipc_recv>:

int
sys_ipc_recv(void *dstva)
{
  80f374:	55                   	push   %ebp
  80f375:	89 e5                	mov    %esp,%ebp
  80f377:	57                   	push   %edi
  80f378:	56                   	push   %esi
  80f379:	53                   	push   %ebx
  80f37a:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f37d:	b9 00 00 00 00       	mov    $0x0,%ecx
  80f382:	8b 55 08             	mov    0x8(%ebp),%edx
  80f385:	b8 0d 00 00 00       	mov    $0xd,%eax
  80f38a:	89 cb                	mov    %ecx,%ebx
  80f38c:	89 cf                	mov    %ecx,%edi
  80f38e:	89 ce                	mov    %ecx,%esi
  80f390:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f392:	85 c0                	test   %eax,%eax
  80f394:	7f 08                	jg     80f39e <sys_ipc_recv+0x2a>
	return syscall(SYS_ipc_recv, 1, (uint32_t)dstva, 0, 0, 0, 0);
}
  80f396:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f399:	5b                   	pop    %ebx
  80f39a:	5e                   	pop    %esi
  80f39b:	5f                   	pop    %edi
  80f39c:	5d                   	pop    %ebp
  80f39d:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f39e:	83 ec 0c             	sub    $0xc,%esp
  80f3a1:	50                   	push   %eax
  80f3a2:	6a 0d                	push   $0xd
  80f3a4:	68 df 37 81 00       	push   $0x8137df
  80f3a9:	6a 23                	push   $0x23
  80f3ab:	68 fc 37 81 00       	push   $0x8137fc
  80f3b0:	e8 9e f2 ff ff       	call   80e653 <_panic>

0080f3b5 <sys_time_msec>:

unsigned int
sys_time_msec(void)
{
  80f3b5:	55                   	push   %ebp
  80f3b6:	89 e5                	mov    %esp,%ebp
  80f3b8:	57                   	push   %edi
  80f3b9:	56                   	push   %esi
  80f3ba:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f3bb:	ba 00 00 00 00       	mov    $0x0,%edx
  80f3c0:	b8 0e 00 00 00       	mov    $0xe,%eax
  80f3c5:	89 d1                	mov    %edx,%ecx
  80f3c7:	89 d3                	mov    %edx,%ebx
  80f3c9:	89 d7                	mov    %edx,%edi
  80f3cb:	89 d6                	mov    %edx,%esi
  80f3cd:	cd 30                	int    $0x30
	return (unsigned int) syscall(SYS_time_msec, 0, 0, 0, 0, 0, 0);
}
  80f3cf:	5b                   	pop    %ebx
  80f3d0:	5e                   	pop    %esi
  80f3d1:	5f                   	pop    %edi
  80f3d2:	5d                   	pop    %ebp
  80f3d3:	c3                   	ret    

0080f3d4 <pgfault>:
// Custom page fault handler - if faulting page is copy-on-write,
// map in our own private writable copy.
//
static void
pgfault(struct UTrapframe *utf)
{
  80f3d4:	55                   	push   %ebp
  80f3d5:	89 e5                	mov    %esp,%ebp
  80f3d7:	57                   	push   %edi
  80f3d8:	56                   	push   %esi
  80f3d9:	53                   	push   %ebx
  80f3da:	83 ec 1c             	sub    $0x1c,%esp
  80f3dd:	8b 45 08             	mov    0x8(%ebp),%eax
    void *addr = (void *) utf->utf_fault_va;
  80f3e0:	8b 18                	mov    (%eax),%ebx
    uint32_t err = utf->utf_err;
  80f3e2:	8b 78 04             	mov    0x4(%eax),%edi
    pte_t pte = uvpt[PGNUM(addr)];
  80f3e5:	89 d8                	mov    %ebx,%eax
  80f3e7:	c1 e8 0c             	shr    $0xc,%eax
  80f3ea:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  80f3f1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    envid_t envid = sys_getenvid();
  80f3f4:	e8 8d fd ff ff       	call   80f186 <sys_getenvid>
	// Hint:
	//   Use the read-only page table mappings at uvpt
	//   (see <inc/memlayout.h>).

	// LAB 4: Your code here.
	if ((err & FEC_WR) == 0 || (pte & PTE_COW) == 0) {
  80f3f9:	f7 c7 02 00 00 00    	test   $0x2,%edi
  80f3ff:	74 73                	je     80f474 <pgfault+0xa0>
  80f401:	89 c6                	mov    %eax,%esi
  80f403:	f7 45 e4 00 08 00 00 	testl  $0x800,-0x1c(%ebp)
  80f40a:	74 68                	je     80f474 <pgfault+0xa0>
	// page to the old page's address.
	// Hint:
	//   You should make three system calls.

	// LAB 4: Your code here.
	if ((r = sys_page_alloc(envid, PFTEMP, PTE_W | PTE_U | PTE_P)) != 0) {
  80f40c:	83 ec 04             	sub    $0x4,%esp
  80f40f:	6a 07                	push   $0x7
  80f411:	68 00 f0 7f 00       	push   $0x7ff000
  80f416:	50                   	push   %eax
  80f417:	e8 a8 fd ff ff       	call   80f1c4 <sys_page_alloc>
  80f41c:	83 c4 10             	add    $0x10,%esp
  80f41f:	85 c0                	test   %eax,%eax
  80f421:	75 65                	jne    80f488 <pgfault+0xb4>
	    panic("pgfault: %e", r);
	}
	memcpy(PFTEMP, ROUNDDOWN(addr, PGSIZE), PGSIZE);
  80f423:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
  80f429:	83 ec 04             	sub    $0x4,%esp
  80f42c:	68 00 10 00 00       	push   $0x1000
  80f431:	53                   	push   %ebx
  80f432:	68 00 f0 7f 00       	push   $0x7ff000
  80f437:	e8 85 fb ff ff       	call   80efc1 <memcpy>
	if ((r = sys_page_map(envid, PFTEMP, envid, ROUNDDOWN(addr, PGSIZE), PTE_W | PTE_U | PTE_P)) != 0) {
  80f43c:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80f443:	53                   	push   %ebx
  80f444:	56                   	push   %esi
  80f445:	68 00 f0 7f 00       	push   $0x7ff000
  80f44a:	56                   	push   %esi
  80f44b:	e8 b7 fd ff ff       	call   80f207 <sys_page_map>
  80f450:	83 c4 20             	add    $0x20,%esp
  80f453:	85 c0                	test   %eax,%eax
  80f455:	75 43                	jne    80f49a <pgfault+0xc6>
	    panic("pgfault: %e", r);
	}
	if ((r = sys_page_unmap(envid, PFTEMP)) != 0) {
  80f457:	83 ec 08             	sub    $0x8,%esp
  80f45a:	68 00 f0 7f 00       	push   $0x7ff000
  80f45f:	56                   	push   %esi
  80f460:	e8 e4 fd ff ff       	call   80f249 <sys_page_unmap>
  80f465:	83 c4 10             	add    $0x10,%esp
  80f468:	85 c0                	test   %eax,%eax
  80f46a:	75 40                	jne    80f4ac <pgfault+0xd8>
	    panic("pgfault: %e", r);
	}
}
  80f46c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f46f:	5b                   	pop    %ebx
  80f470:	5e                   	pop    %esi
  80f471:	5f                   	pop    %edi
  80f472:	5d                   	pop    %ebp
  80f473:	c3                   	ret    
	    panic("pgfault: bad faulting access\n");
  80f474:	83 ec 04             	sub    $0x4,%esp
  80f477:	68 0a 38 81 00       	push   $0x81380a
  80f47c:	6a 1f                	push   $0x1f
  80f47e:	68 28 38 81 00       	push   $0x813828
  80f483:	e8 cb f1 ff ff       	call   80e653 <_panic>
	    panic("pgfault: %e", r);
  80f488:	50                   	push   %eax
  80f489:	68 33 38 81 00       	push   $0x813833
  80f48e:	6a 2a                	push   $0x2a
  80f490:	68 28 38 81 00       	push   $0x813828
  80f495:	e8 b9 f1 ff ff       	call   80e653 <_panic>
	    panic("pgfault: %e", r);
  80f49a:	50                   	push   %eax
  80f49b:	68 33 38 81 00       	push   $0x813833
  80f4a0:	6a 2e                	push   $0x2e
  80f4a2:	68 28 38 81 00       	push   $0x813828
  80f4a7:	e8 a7 f1 ff ff       	call   80e653 <_panic>
	    panic("pgfault: %e", r);
  80f4ac:	50                   	push   %eax
  80f4ad:	68 33 38 81 00       	push   $0x813833
  80f4b2:	6a 31                	push   $0x31
  80f4b4:	68 28 38 81 00       	push   $0x813828
  80f4b9:	e8 95 f1 ff ff       	call   80e653 <_panic>

0080f4be <fork>:
//   Neither user exception stack should ever be marked copy-on-write,
//   so you must allocate a new page for the child's user exception stack.
//
envid_t
fork(void)
{
  80f4be:	55                   	push   %ebp
  80f4bf:	89 e5                	mov    %esp,%ebp
  80f4c1:	57                   	push   %edi
  80f4c2:	56                   	push   %esi
  80f4c3:	53                   	push   %ebx
  80f4c4:	83 ec 28             	sub    $0x28,%esp
	// LAB 4: Your code here.
	envid_t envid;
	uint32_t addr;
	int r;

	set_pgfault_handler(pgfault);
  80f4c7:	68 d4 f3 80 00       	push   $0x80f3d4
  80f4cc:	e8 0f 17 00 00       	call   810be0 <set_pgfault_handler>
// This must be inlined.  Exercise for reader: why?
static inline envid_t __attribute__((always_inline))
sys_exofork(void)
{
	envid_t ret;
	asm volatile("int %2"
  80f4d1:	b8 07 00 00 00       	mov    $0x7,%eax
  80f4d6:	cd 30                	int    $0x30
  80f4d8:	89 45 dc             	mov    %eax,-0x24(%ebp)
  80f4db:	89 45 e0             	mov    %eax,-0x20(%ebp)
	envid = sys_exofork();
	if (envid < 0) {
  80f4de:	83 c4 10             	add    $0x10,%esp
  80f4e1:	85 c0                	test   %eax,%eax
  80f4e3:	78 2b                	js     80f510 <fork+0x52>
	    thisenv = &envs[ENVX(sys_getenvid())];
	    return 0;
	}

	// copy the address space mappings to child
	for (addr = 0; addr < USTACKTOP; addr += PGSIZE) {
  80f4e5:	bb 00 00 00 00       	mov    $0x0,%ebx
	if (envid == 0) {
  80f4ea:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
  80f4ee:	0f 85 b5 00 00 00    	jne    80f5a9 <fork+0xeb>
	    thisenv = &envs[ENVX(sys_getenvid())];
  80f4f4:	e8 8d fc ff ff       	call   80f186 <sys_getenvid>
  80f4f9:	25 ff 03 00 00       	and    $0x3ff,%eax
  80f4fe:	6b c0 7c             	imul   $0x7c,%eax,%eax
  80f501:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  80f506:	a3 5c b2 b3 00       	mov    %eax,0xb3b25c
	    return 0;
  80f50b:	e9 8c 01 00 00       	jmp    80f69c <fork+0x1de>
	    panic("sys_exofork: %e", envid);
  80f510:	50                   	push   %eax
  80f511:	68 3f 38 81 00       	push   $0x81383f
  80f516:	6a 77                	push   $0x77
  80f518:	68 28 38 81 00       	push   $0x813828
  80f51d:	e8 31 f1 ff ff       	call   80e653 <_panic>
        if ((r = sys_page_map(parent_envid, va, envid, va, uvpt[pn] & PTE_SYSCALL)) != 0) {
  80f522:	8b 04 b5 00 00 40 ef 	mov    -0x10c00000(,%esi,4),%eax
  80f529:	83 ec 0c             	sub    $0xc,%esp
  80f52c:	25 07 0e 00 00       	and    $0xe07,%eax
  80f531:	50                   	push   %eax
  80f532:	57                   	push   %edi
  80f533:	ff 75 e0             	pushl  -0x20(%ebp)
  80f536:	57                   	push   %edi
  80f537:	ff 75 e4             	pushl  -0x1c(%ebp)
  80f53a:	e8 c8 fc ff ff       	call   80f207 <sys_page_map>
  80f53f:	83 c4 20             	add    $0x20,%esp
  80f542:	85 c0                	test   %eax,%eax
  80f544:	74 51                	je     80f597 <fork+0xd9>
           panic("duppage: %e", r);
  80f546:	50                   	push   %eax
  80f547:	68 4f 38 81 00       	push   $0x81384f
  80f54c:	6a 4a                	push   $0x4a
  80f54e:	68 28 38 81 00       	push   $0x813828
  80f553:	e8 fb f0 ff ff       	call   80e653 <_panic>
	    if ((r = sys_page_map(parent_envid, va, envid, va, PTE_COW | PTE_U | PTE_P)) != 0) {
  80f558:	83 ec 0c             	sub    $0xc,%esp
  80f55b:	68 05 08 00 00       	push   $0x805
  80f560:	57                   	push   %edi
  80f561:	ff 75 e0             	pushl  -0x20(%ebp)
  80f564:	57                   	push   %edi
  80f565:	ff 75 e4             	pushl  -0x1c(%ebp)
  80f568:	e8 9a fc ff ff       	call   80f207 <sys_page_map>
  80f56d:	83 c4 20             	add    $0x20,%esp
  80f570:	85 c0                	test   %eax,%eax
  80f572:	0f 85 bc 00 00 00    	jne    80f634 <fork+0x176>
	    if ((r = sys_page_map(parent_envid, va, parent_envid, va, PTE_COW | PTE_U | PTE_P)) != 0) {
  80f578:	83 ec 0c             	sub    $0xc,%esp
  80f57b:	68 05 08 00 00       	push   $0x805
  80f580:	57                   	push   %edi
  80f581:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80f584:	50                   	push   %eax
  80f585:	57                   	push   %edi
  80f586:	50                   	push   %eax
  80f587:	e8 7b fc ff ff       	call   80f207 <sys_page_map>
  80f58c:	83 c4 20             	add    $0x20,%esp
  80f58f:	85 c0                	test   %eax,%eax
  80f591:	0f 85 af 00 00 00    	jne    80f646 <fork+0x188>
	for (addr = 0; addr < USTACKTOP; addr += PGSIZE) {
  80f597:	81 c3 00 10 00 00    	add    $0x1000,%ebx
  80f59d:	81 fb 00 e0 bf ee    	cmp    $0xeebfe000,%ebx
  80f5a3:	0f 84 af 00 00 00    	je     80f658 <fork+0x19a>
	    if ((uvpd[PDX(addr)] & PTE_P) == PTE_P && (uvpt[PGNUM(addr)] & PTE_P) == PTE_P) {
  80f5a9:	89 d8                	mov    %ebx,%eax
  80f5ab:	c1 e8 16             	shr    $0x16,%eax
  80f5ae:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  80f5b5:	a8 01                	test   $0x1,%al
  80f5b7:	74 de                	je     80f597 <fork+0xd9>
  80f5b9:	89 de                	mov    %ebx,%esi
  80f5bb:	c1 ee 0c             	shr    $0xc,%esi
  80f5be:	8b 04 b5 00 00 40 ef 	mov    -0x10c00000(,%esi,4),%eax
  80f5c5:	a8 01                	test   $0x1,%al
  80f5c7:	74 ce                	je     80f597 <fork+0xd9>
	envid_t parent_envid = sys_getenvid();
  80f5c9:	e8 b8 fb ff ff       	call   80f186 <sys_getenvid>
  80f5ce:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	void *va = (void *)(pn * PGSIZE);
  80f5d1:	89 f7                	mov    %esi,%edi
  80f5d3:	c1 e7 0c             	shl    $0xc,%edi
	if ((uvpt[pn] & PTE_SHARE) == PTE_SHARE) {
  80f5d6:	8b 04 b5 00 00 40 ef 	mov    -0x10c00000(,%esi,4),%eax
  80f5dd:	f6 c4 04             	test   $0x4,%ah
  80f5e0:	0f 85 3c ff ff ff    	jne    80f522 <fork+0x64>
    } else if ((uvpt[pn] & PTE_W) == PTE_W || (uvpt[pn] & PTE_COW) == PTE_COW) {
  80f5e6:	8b 04 b5 00 00 40 ef 	mov    -0x10c00000(,%esi,4),%eax
  80f5ed:	a8 02                	test   $0x2,%al
  80f5ef:	0f 85 63 ff ff ff    	jne    80f558 <fork+0x9a>
  80f5f5:	8b 04 b5 00 00 40 ef 	mov    -0x10c00000(,%esi,4),%eax
  80f5fc:	f6 c4 08             	test   $0x8,%ah
  80f5ff:	0f 85 53 ff ff ff    	jne    80f558 <fork+0x9a>
	    if ((r = sys_page_map(parent_envid, va, envid, va, PTE_U | PTE_P)) != 0) {
  80f605:	83 ec 0c             	sub    $0xc,%esp
  80f608:	6a 05                	push   $0x5
  80f60a:	57                   	push   %edi
  80f60b:	ff 75 e0             	pushl  -0x20(%ebp)
  80f60e:	57                   	push   %edi
  80f60f:	ff 75 e4             	pushl  -0x1c(%ebp)
  80f612:	e8 f0 fb ff ff       	call   80f207 <sys_page_map>
  80f617:	83 c4 20             	add    $0x20,%esp
  80f61a:	85 c0                	test   %eax,%eax
  80f61c:	0f 84 75 ff ff ff    	je     80f597 <fork+0xd9>
	        panic("duppage: %e", r);
  80f622:	50                   	push   %eax
  80f623:	68 4f 38 81 00       	push   $0x81384f
  80f628:	6a 55                	push   $0x55
  80f62a:	68 28 38 81 00       	push   $0x813828
  80f62f:	e8 1f f0 ff ff       	call   80e653 <_panic>
	        panic("duppage: %e", r);
  80f634:	50                   	push   %eax
  80f635:	68 4f 38 81 00       	push   $0x81384f
  80f63a:	6a 4e                	push   $0x4e
  80f63c:	68 28 38 81 00       	push   $0x813828
  80f641:	e8 0d f0 ff ff       	call   80e653 <_panic>
	        panic("duppage: %e", r);
  80f646:	50                   	push   %eax
  80f647:	68 4f 38 81 00       	push   $0x81384f
  80f64c:	6a 51                	push   $0x51
  80f64e:	68 28 38 81 00       	push   $0x813828
  80f653:	e8 fb ef ff ff       	call   80e653 <_panic>
	}

	// allocate new page for child's user exception stack
	void _pgfault_upcall();

	if ((r = sys_page_alloc(envid, (void *)(UXSTACKTOP - PGSIZE), PTE_W | PTE_U | PTE_P)) != 0) {
  80f658:	83 ec 04             	sub    $0x4,%esp
  80f65b:	6a 07                	push   $0x7
  80f65d:	68 00 f0 bf ee       	push   $0xeebff000
  80f662:	ff 75 dc             	pushl  -0x24(%ebp)
  80f665:	e8 5a fb ff ff       	call   80f1c4 <sys_page_alloc>
  80f66a:	83 c4 10             	add    $0x10,%esp
  80f66d:	85 c0                	test   %eax,%eax
  80f66f:	75 36                	jne    80f6a7 <fork+0x1e9>
	    panic("fork: %e", r);
	}
	if ((r = sys_env_set_pgfault_upcall(envid, _pgfault_upcall)) != 0) {
  80f671:	83 ec 08             	sub    $0x8,%esp
  80f674:	68 59 0c 81 00       	push   $0x810c59
  80f679:	ff 75 dc             	pushl  -0x24(%ebp)
  80f67c:	e8 8e fc ff ff       	call   80f30f <sys_env_set_pgfault_upcall>
  80f681:	83 c4 10             	add    $0x10,%esp
  80f684:	85 c0                	test   %eax,%eax
  80f686:	75 34                	jne    80f6bc <fork+0x1fe>
	    panic("fork: %e", r);
	}

	// mark the child as runnable
	if ((r = sys_env_set_status(envid, ENV_RUNNABLE)) != 0)
  80f688:	83 ec 08             	sub    $0x8,%esp
  80f68b:	6a 02                	push   $0x2
  80f68d:	ff 75 dc             	pushl  -0x24(%ebp)
  80f690:	e8 f6 fb ff ff       	call   80f28b <sys_env_set_status>
  80f695:	83 c4 10             	add    $0x10,%esp
  80f698:	85 c0                	test   %eax,%eax
  80f69a:	75 35                	jne    80f6d1 <fork+0x213>
	    panic("fork: %e", r);

	return envid;
}
  80f69c:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80f69f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f6a2:	5b                   	pop    %ebx
  80f6a3:	5e                   	pop    %esi
  80f6a4:	5f                   	pop    %edi
  80f6a5:	5d                   	pop    %ebp
  80f6a6:	c3                   	ret    
	    panic("fork: %e", r);
  80f6a7:	50                   	push   %eax
  80f6a8:	68 46 38 81 00       	push   $0x813846
  80f6ad:	68 8a 00 00 00       	push   $0x8a
  80f6b2:	68 28 38 81 00       	push   $0x813828
  80f6b7:	e8 97 ef ff ff       	call   80e653 <_panic>
	    panic("fork: %e", r);
  80f6bc:	50                   	push   %eax
  80f6bd:	68 46 38 81 00       	push   $0x813846
  80f6c2:	68 8d 00 00 00       	push   $0x8d
  80f6c7:	68 28 38 81 00       	push   $0x813828
  80f6cc:	e8 82 ef ff ff       	call   80e653 <_panic>
	    panic("fork: %e", r);
  80f6d1:	50                   	push   %eax
  80f6d2:	68 46 38 81 00       	push   $0x813846
  80f6d7:	68 92 00 00 00       	push   $0x92
  80f6dc:	68 28 38 81 00       	push   $0x813828
  80f6e1:	e8 6d ef ff ff       	call   80e653 <_panic>

0080f6e6 <sfork>:

// Challenge!
int
sfork(void)
{
  80f6e6:	55                   	push   %ebp
  80f6e7:	89 e5                	mov    %esp,%ebp
  80f6e9:	83 ec 0c             	sub    $0xc,%esp
	panic("sfork not implemented");
  80f6ec:	68 5b 38 81 00       	push   $0x81385b
  80f6f1:	68 9b 00 00 00       	push   $0x9b
  80f6f6:	68 28 38 81 00       	push   $0x813828
  80f6fb:	e8 53 ef ff ff       	call   80e653 <_panic>

0080f700 <ipc_recv>:
//   If 'pg' is null, pass sys_ipc_recv a value that it will understand
//   as meaning "no page".  (Zero is not the right value, since that's
//   a perfectly valid place to map a page.)
int32_t
ipc_recv(envid_t *from_env_store, void *pg, int *perm_store)
{
  80f700:	55                   	push   %ebp
  80f701:	89 e5                	mov    %esp,%ebp
  80f703:	56                   	push   %esi
  80f704:	53                   	push   %ebx
  80f705:	8b 75 08             	mov    0x8(%ebp),%esi
  80f708:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f70b:	8b 5d 10             	mov    0x10(%ebp),%ebx
	// LAB 4: Your code here.
	int r;

	if (pg == NULL) {
  80f70e:	85 c0                	test   %eax,%eax
	    pg = (void *)UTOP;
  80f710:	ba 00 00 c0 ee       	mov    $0xeec00000,%edx
  80f715:	0f 44 c2             	cmove  %edx,%eax
	}
	if ((r = sys_ipc_recv(pg)) < 0) {
  80f718:	83 ec 0c             	sub    $0xc,%esp
  80f71b:	50                   	push   %eax
  80f71c:	e8 53 fc ff ff       	call   80f374 <sys_ipc_recv>
  80f721:	83 c4 10             	add    $0x10,%esp
  80f724:	85 c0                	test   %eax,%eax
  80f726:	78 2b                	js     80f753 <ipc_recv+0x53>
	    if (perm_store != NULL) {
	        *perm_store = 0;
	    }
	    return r;
	}
	if (from_env_store != NULL) {
  80f728:	85 f6                	test   %esi,%esi
  80f72a:	74 0a                	je     80f736 <ipc_recv+0x36>
	    *from_env_store = thisenv->env_ipc_from;
  80f72c:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80f731:	8b 40 74             	mov    0x74(%eax),%eax
  80f734:	89 06                	mov    %eax,(%esi)
	}
	if (perm_store != NULL) {
  80f736:	85 db                	test   %ebx,%ebx
  80f738:	74 0a                	je     80f744 <ipc_recv+0x44>
	    *perm_store = thisenv->env_ipc_perm;
  80f73a:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80f73f:	8b 40 78             	mov    0x78(%eax),%eax
  80f742:	89 03                	mov    %eax,(%ebx)
	}
	return thisenv->env_ipc_value;
  80f744:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80f749:	8b 40 70             	mov    0x70(%eax),%eax
}
  80f74c:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80f74f:	5b                   	pop    %ebx
  80f750:	5e                   	pop    %esi
  80f751:	5d                   	pop    %ebp
  80f752:	c3                   	ret    
	    if (from_env_store != NULL) {
  80f753:	85 f6                	test   %esi,%esi
  80f755:	74 06                	je     80f75d <ipc_recv+0x5d>
	        *from_env_store = 0;
  80f757:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
	    if (perm_store != NULL) {
  80f75d:	85 db                	test   %ebx,%ebx
  80f75f:	74 eb                	je     80f74c <ipc_recv+0x4c>
	        *perm_store = 0;
  80f761:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  80f767:	eb e3                	jmp    80f74c <ipc_recv+0x4c>

0080f769 <ipc_send>:
//   Use sys_yield() to be CPU-friendly.
//   If 'pg' is null, pass sys_ipc_try_send a value that it will understand
//   as meaning "no page".  (Zero is not the right value.)
void
ipc_send(envid_t to_env, uint32_t val, void *pg, int perm)
{
  80f769:	55                   	push   %ebp
  80f76a:	89 e5                	mov    %esp,%ebp
  80f76c:	57                   	push   %edi
  80f76d:	56                   	push   %esi
  80f76e:	53                   	push   %ebx
  80f76f:	83 ec 0c             	sub    $0xc,%esp
  80f772:	8b 7d 08             	mov    0x8(%ebp),%edi
  80f775:	8b 75 10             	mov    0x10(%ebp),%esi
	// LAB 4: Your code here.
	int r;

	if (pg == NULL) {
	    pg = (void *)UTOP;
  80f778:	85 f6                	test   %esi,%esi
  80f77a:	b8 00 00 c0 ee       	mov    $0xeec00000,%eax
  80f77f:	0f 44 f0             	cmove  %eax,%esi
  80f782:	eb 09                	jmp    80f78d <ipc_send+0x24>
	do {
	    r = sys_ipc_try_send(to_env, val, pg, perm);
	    if (r < 0 && r != -E_IPC_NOT_RECV) {
	        panic("ipc_send: %e", r);
	    }
	    sys_yield();
  80f784:	e8 1c fa ff ff       	call   80f1a5 <sys_yield>
	} while(r != 0);
  80f789:	85 db                	test   %ebx,%ebx
  80f78b:	74 2d                	je     80f7ba <ipc_send+0x51>
	    r = sys_ipc_try_send(to_env, val, pg, perm);
  80f78d:	ff 75 14             	pushl  0x14(%ebp)
  80f790:	56                   	push   %esi
  80f791:	ff 75 0c             	pushl  0xc(%ebp)
  80f794:	57                   	push   %edi
  80f795:	e8 b7 fb ff ff       	call   80f351 <sys_ipc_try_send>
  80f79a:	89 c3                	mov    %eax,%ebx
	    if (r < 0 && r != -E_IPC_NOT_RECV) {
  80f79c:	83 c4 10             	add    $0x10,%esp
  80f79f:	85 c0                	test   %eax,%eax
  80f7a1:	79 e1                	jns    80f784 <ipc_send+0x1b>
  80f7a3:	83 f8 f9             	cmp    $0xfffffff9,%eax
  80f7a6:	74 dc                	je     80f784 <ipc_send+0x1b>
	        panic("ipc_send: %e", r);
  80f7a8:	50                   	push   %eax
  80f7a9:	68 71 38 81 00       	push   $0x813871
  80f7ae:	6a 45                	push   $0x45
  80f7b0:	68 7e 38 81 00       	push   $0x81387e
  80f7b5:	e8 99 ee ff ff       	call   80e653 <_panic>
}
  80f7ba:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f7bd:	5b                   	pop    %ebx
  80f7be:	5e                   	pop    %esi
  80f7bf:	5f                   	pop    %edi
  80f7c0:	5d                   	pop    %ebp
  80f7c1:	c3                   	ret    

0080f7c2 <ipc_find_env>:
// Find the first environment of the given type.  We'll use this to
// find special environments.
// Returns 0 if no such environment exists.
envid_t
ipc_find_env(enum EnvType type)
{
  80f7c2:	55                   	push   %ebp
  80f7c3:	89 e5                	mov    %esp,%ebp
  80f7c5:	8b 4d 08             	mov    0x8(%ebp),%ecx
	int i;
	for (i = 0; i < NENV; i++)
  80f7c8:	b8 00 00 00 00       	mov    $0x0,%eax
		if (envs[i].env_type == type)
  80f7cd:	6b d0 7c             	imul   $0x7c,%eax,%edx
  80f7d0:	81 c2 00 00 c0 ee    	add    $0xeec00000,%edx
  80f7d6:	8b 52 50             	mov    0x50(%edx),%edx
  80f7d9:	39 ca                	cmp    %ecx,%edx
  80f7db:	74 11                	je     80f7ee <ipc_find_env+0x2c>
	for (i = 0; i < NENV; i++)
  80f7dd:	83 c0 01             	add    $0x1,%eax
  80f7e0:	3d 00 04 00 00       	cmp    $0x400,%eax
  80f7e5:	75 e6                	jne    80f7cd <ipc_find_env+0xb>
			return envs[i].env_id;
	return 0;
  80f7e7:	b8 00 00 00 00       	mov    $0x0,%eax
  80f7ec:	eb 0b                	jmp    80f7f9 <ipc_find_env+0x37>
			return envs[i].env_id;
  80f7ee:	6b c0 7c             	imul   $0x7c,%eax,%eax
  80f7f1:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  80f7f6:	8b 40 48             	mov    0x48(%eax),%eax
}
  80f7f9:	5d                   	pop    %ebp
  80f7fa:	c3                   	ret    

0080f7fb <fd2num>:
// File descriptor manipulators
// --------------------------------------------------------------

int
fd2num(struct Fd *fd)
{
  80f7fb:	55                   	push   %ebp
  80f7fc:	89 e5                	mov    %esp,%ebp
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  80f7fe:	8b 45 08             	mov    0x8(%ebp),%eax
  80f801:	05 00 00 00 30       	add    $0x30000000,%eax
  80f806:	c1 e8 0c             	shr    $0xc,%eax
}
  80f809:	5d                   	pop    %ebp
  80f80a:	c3                   	ret    

0080f80b <fd2data>:

char*
fd2data(struct Fd *fd)
{
  80f80b:	55                   	push   %ebp
  80f80c:	89 e5                	mov    %esp,%ebp
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  80f80e:	8b 45 08             	mov    0x8(%ebp),%eax
  80f811:	05 00 00 00 30       	add    $0x30000000,%eax
	return INDEX2DATA(fd2num(fd));
  80f816:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  80f81b:	2d 00 00 fe 2f       	sub    $0x2ffe0000,%eax
}
  80f820:	5d                   	pop    %ebp
  80f821:	c3                   	ret    

0080f822 <fd_alloc>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_MAX_FD: no more file descriptors
// On error, *fd_store is set to 0.
int
fd_alloc(struct Fd **fd_store)
{
  80f822:	55                   	push   %ebp
  80f823:	89 e5                	mov    %esp,%ebp
  80f825:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80f828:	b8 00 00 00 d0       	mov    $0xd0000000,%eax
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
		fd = INDEX2FD(i);
		if ((uvpd[PDX(fd)] & PTE_P) == 0 || (uvpt[PGNUM(fd)] & PTE_P) == 0) {
  80f82d:	89 c2                	mov    %eax,%edx
  80f82f:	c1 ea 16             	shr    $0x16,%edx
  80f832:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  80f839:	f6 c2 01             	test   $0x1,%dl
  80f83c:	74 2a                	je     80f868 <fd_alloc+0x46>
  80f83e:	89 c2                	mov    %eax,%edx
  80f840:	c1 ea 0c             	shr    $0xc,%edx
  80f843:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  80f84a:	f6 c2 01             	test   $0x1,%dl
  80f84d:	74 19                	je     80f868 <fd_alloc+0x46>
  80f84f:	05 00 10 00 00       	add    $0x1000,%eax
	for (i = 0; i < MAXFD; i++) {
  80f854:	3d 00 00 02 d0       	cmp    $0xd0020000,%eax
  80f859:	75 d2                	jne    80f82d <fd_alloc+0xb>
			*fd_store = fd;
			return 0;
		}
	}
	*fd_store = 0;
  80f85b:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
	return -E_MAX_OPEN;
  80f861:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  80f866:	eb 07                	jmp    80f86f <fd_alloc+0x4d>
			*fd_store = fd;
  80f868:	89 01                	mov    %eax,(%ecx)
			return 0;
  80f86a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80f86f:	5d                   	pop    %ebp
  80f870:	c3                   	ret    

0080f871 <fd_lookup>:
// Returns 0 on success (the page is in range and mapped), < 0 on error.
// Errors are:
//	-E_INVAL: fdnum was either not in range or not mapped.
int
fd_lookup(int fdnum, struct Fd **fd_store)
{
  80f871:	55                   	push   %ebp
  80f872:	89 e5                	mov    %esp,%ebp
  80f874:	8b 45 08             	mov    0x8(%ebp),%eax
	struct Fd *fd;

	if (fdnum < 0 || fdnum >= MAXFD) {
  80f877:	83 f8 1f             	cmp    $0x1f,%eax
  80f87a:	77 36                	ja     80f8b2 <fd_lookup+0x41>
		if (debug)
			cprintf("[%08x] bad fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	fd = INDEX2FD(fdnum);
  80f87c:	c1 e0 0c             	shl    $0xc,%eax
  80f87f:	2d 00 00 00 30       	sub    $0x30000000,%eax
	if (!(uvpd[PDX(fd)] & PTE_P) || !(uvpt[PGNUM(fd)] & PTE_P)) {
  80f884:	89 c2                	mov    %eax,%edx
  80f886:	c1 ea 16             	shr    $0x16,%edx
  80f889:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  80f890:	f6 c2 01             	test   $0x1,%dl
  80f893:	74 24                	je     80f8b9 <fd_lookup+0x48>
  80f895:	89 c2                	mov    %eax,%edx
  80f897:	c1 ea 0c             	shr    $0xc,%edx
  80f89a:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  80f8a1:	f6 c2 01             	test   $0x1,%dl
  80f8a4:	74 1a                	je     80f8c0 <fd_lookup+0x4f>
		if (debug)
			cprintf("[%08x] closed fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	*fd_store = fd;
  80f8a6:	8b 55 0c             	mov    0xc(%ebp),%edx
  80f8a9:	89 02                	mov    %eax,(%edx)
	return 0;
  80f8ab:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80f8b0:	5d                   	pop    %ebp
  80f8b1:	c3                   	ret    
		return -E_INVAL;
  80f8b2:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80f8b7:	eb f7                	jmp    80f8b0 <fd_lookup+0x3f>
		return -E_INVAL;
  80f8b9:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80f8be:	eb f0                	jmp    80f8b0 <fd_lookup+0x3f>
  80f8c0:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80f8c5:	eb e9                	jmp    80f8b0 <fd_lookup+0x3f>

0080f8c7 <dev_lookup>:
	0
};

int
dev_lookup(int dev_id, struct Dev **dev)
{
  80f8c7:	55                   	push   %ebp
  80f8c8:	89 e5                	mov    %esp,%ebp
  80f8ca:	83 ec 08             	sub    $0x8,%esp
  80f8cd:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80f8d0:	ba 04 39 81 00       	mov    $0x813904,%edx
	int i;
	for (i = 0; devtab[i]; i++)
  80f8d5:	b8 ec 42 81 00       	mov    $0x8142ec,%eax
		if (devtab[i]->dev_id == dev_id) {
  80f8da:	39 08                	cmp    %ecx,(%eax)
  80f8dc:	74 33                	je     80f911 <dev_lookup+0x4a>
  80f8de:	83 c2 04             	add    $0x4,%edx
	for (i = 0; devtab[i]; i++)
  80f8e1:	8b 02                	mov    (%edx),%eax
  80f8e3:	85 c0                	test   %eax,%eax
  80f8e5:	75 f3                	jne    80f8da <dev_lookup+0x13>
			*dev = devtab[i];
			return 0;
		}
	cprintf("[%08x] unknown device type %d\n", thisenv->env_id, dev_id);
  80f8e7:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80f8ec:	8b 40 48             	mov    0x48(%eax),%eax
  80f8ef:	83 ec 04             	sub    $0x4,%esp
  80f8f2:	51                   	push   %ecx
  80f8f3:	50                   	push   %eax
  80f8f4:	68 88 38 81 00       	push   $0x813888
  80f8f9:	e8 30 ee ff ff       	call   80e72e <cprintf>
	*dev = 0;
  80f8fe:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f901:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return -E_INVAL;
  80f907:	83 c4 10             	add    $0x10,%esp
  80f90a:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
  80f90f:	c9                   	leave  
  80f910:	c3                   	ret    
			*dev = devtab[i];
  80f911:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f914:	89 01                	mov    %eax,(%ecx)
			return 0;
  80f916:	b8 00 00 00 00       	mov    $0x0,%eax
  80f91b:	eb f2                	jmp    80f90f <dev_lookup+0x48>

0080f91d <fd_close>:
{
  80f91d:	55                   	push   %ebp
  80f91e:	89 e5                	mov    %esp,%ebp
  80f920:	57                   	push   %edi
  80f921:	56                   	push   %esi
  80f922:	53                   	push   %ebx
  80f923:	83 ec 1c             	sub    $0x1c,%esp
  80f926:	8b 75 08             	mov    0x8(%ebp),%esi
  80f929:	8b 7d 0c             	mov    0xc(%ebp),%edi
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
  80f92c:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80f92f:	50                   	push   %eax
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  80f930:	8d 86 00 00 00 30    	lea    0x30000000(%esi),%eax
  80f936:	c1 e8 0c             	shr    $0xc,%eax
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
  80f939:	50                   	push   %eax
  80f93a:	e8 32 ff ff ff       	call   80f871 <fd_lookup>
  80f93f:	89 c3                	mov    %eax,%ebx
  80f941:	83 c4 08             	add    $0x8,%esp
  80f944:	85 c0                	test   %eax,%eax
  80f946:	78 05                	js     80f94d <fd_close+0x30>
	    || fd != fd2)
  80f948:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
  80f94b:	74 16                	je     80f963 <fd_close+0x46>
		return (must_exist ? r : 0);
  80f94d:	89 f8                	mov    %edi,%eax
  80f94f:	84 c0                	test   %al,%al
  80f951:	b8 00 00 00 00       	mov    $0x0,%eax
  80f956:	0f 44 d8             	cmove  %eax,%ebx
}
  80f959:	89 d8                	mov    %ebx,%eax
  80f95b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f95e:	5b                   	pop    %ebx
  80f95f:	5e                   	pop    %esi
  80f960:	5f                   	pop    %edi
  80f961:	5d                   	pop    %ebp
  80f962:	c3                   	ret    
	if ((r = dev_lookup(fd->fd_dev_id, &dev)) >= 0) {
  80f963:	83 ec 08             	sub    $0x8,%esp
  80f966:	8d 45 e0             	lea    -0x20(%ebp),%eax
  80f969:	50                   	push   %eax
  80f96a:	ff 36                	pushl  (%esi)
  80f96c:	e8 56 ff ff ff       	call   80f8c7 <dev_lookup>
  80f971:	89 c3                	mov    %eax,%ebx
  80f973:	83 c4 10             	add    $0x10,%esp
  80f976:	85 c0                	test   %eax,%eax
  80f978:	78 15                	js     80f98f <fd_close+0x72>
		if (dev->dev_close)
  80f97a:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80f97d:	8b 40 10             	mov    0x10(%eax),%eax
  80f980:	85 c0                	test   %eax,%eax
  80f982:	74 1b                	je     80f99f <fd_close+0x82>
			r = (*dev->dev_close)(fd);
  80f984:	83 ec 0c             	sub    $0xc,%esp
  80f987:	56                   	push   %esi
  80f988:	ff d0                	call   *%eax
  80f98a:	89 c3                	mov    %eax,%ebx
  80f98c:	83 c4 10             	add    $0x10,%esp
	(void) sys_page_unmap(0, fd);
  80f98f:	83 ec 08             	sub    $0x8,%esp
  80f992:	56                   	push   %esi
  80f993:	6a 00                	push   $0x0
  80f995:	e8 af f8 ff ff       	call   80f249 <sys_page_unmap>
	return r;
  80f99a:	83 c4 10             	add    $0x10,%esp
  80f99d:	eb ba                	jmp    80f959 <fd_close+0x3c>
			r = 0;
  80f99f:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f9a4:	eb e9                	jmp    80f98f <fd_close+0x72>

0080f9a6 <close>:

int
close(int fdnum)
{
  80f9a6:	55                   	push   %ebp
  80f9a7:	89 e5                	mov    %esp,%ebp
  80f9a9:	83 ec 18             	sub    $0x18,%esp
	struct Fd *fd;
	int r;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  80f9ac:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80f9af:	50                   	push   %eax
  80f9b0:	ff 75 08             	pushl  0x8(%ebp)
  80f9b3:	e8 b9 fe ff ff       	call   80f871 <fd_lookup>
  80f9b8:	83 c4 08             	add    $0x8,%esp
  80f9bb:	85 c0                	test   %eax,%eax
  80f9bd:	78 10                	js     80f9cf <close+0x29>
		return r;
	else
		return fd_close(fd, 1);
  80f9bf:	83 ec 08             	sub    $0x8,%esp
  80f9c2:	6a 01                	push   $0x1
  80f9c4:	ff 75 f4             	pushl  -0xc(%ebp)
  80f9c7:	e8 51 ff ff ff       	call   80f91d <fd_close>
  80f9cc:	83 c4 10             	add    $0x10,%esp
}
  80f9cf:	c9                   	leave  
  80f9d0:	c3                   	ret    

0080f9d1 <close_all>:

void
close_all(void)
{
  80f9d1:	55                   	push   %ebp
  80f9d2:	89 e5                	mov    %esp,%ebp
  80f9d4:	53                   	push   %ebx
  80f9d5:	83 ec 04             	sub    $0x4,%esp
	int i;
	for (i = 0; i < MAXFD; i++)
  80f9d8:	bb 00 00 00 00       	mov    $0x0,%ebx
		close(i);
  80f9dd:	83 ec 0c             	sub    $0xc,%esp
  80f9e0:	53                   	push   %ebx
  80f9e1:	e8 c0 ff ff ff       	call   80f9a6 <close>
	for (i = 0; i < MAXFD; i++)
  80f9e6:	83 c3 01             	add    $0x1,%ebx
  80f9e9:	83 c4 10             	add    $0x10,%esp
  80f9ec:	83 fb 20             	cmp    $0x20,%ebx
  80f9ef:	75 ec                	jne    80f9dd <close_all+0xc>
}
  80f9f1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80f9f4:	c9                   	leave  
  80f9f5:	c3                   	ret    

0080f9f6 <dup>:
// file and the file offset of the other.
// Closes any previously open file descriptor at 'newfdnum'.
// This is implemented using virtual memory tricks (of course!).
int
dup(int oldfdnum, int newfdnum)
{
  80f9f6:	55                   	push   %ebp
  80f9f7:	89 e5                	mov    %esp,%ebp
  80f9f9:	57                   	push   %edi
  80f9fa:	56                   	push   %esi
  80f9fb:	53                   	push   %ebx
  80f9fc:	83 ec 1c             	sub    $0x1c,%esp
	int r;
	char *ova, *nva;
	pte_t pte;
	struct Fd *oldfd, *newfd;

	if ((r = fd_lookup(oldfdnum, &oldfd)) < 0)
  80f9ff:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80fa02:	50                   	push   %eax
  80fa03:	ff 75 08             	pushl  0x8(%ebp)
  80fa06:	e8 66 fe ff ff       	call   80f871 <fd_lookup>
  80fa0b:	89 c3                	mov    %eax,%ebx
  80fa0d:	83 c4 08             	add    $0x8,%esp
  80fa10:	85 c0                	test   %eax,%eax
  80fa12:	0f 88 81 00 00 00    	js     80fa99 <dup+0xa3>
		return r;
	close(newfdnum);
  80fa18:	83 ec 0c             	sub    $0xc,%esp
  80fa1b:	ff 75 0c             	pushl  0xc(%ebp)
  80fa1e:	e8 83 ff ff ff       	call   80f9a6 <close>

	newfd = INDEX2FD(newfdnum);
  80fa23:	8b 75 0c             	mov    0xc(%ebp),%esi
  80fa26:	c1 e6 0c             	shl    $0xc,%esi
  80fa29:	81 ee 00 00 00 30    	sub    $0x30000000,%esi
	ova = fd2data(oldfd);
  80fa2f:	83 c4 04             	add    $0x4,%esp
  80fa32:	ff 75 e4             	pushl  -0x1c(%ebp)
  80fa35:	e8 d1 fd ff ff       	call   80f80b <fd2data>
  80fa3a:	89 c3                	mov    %eax,%ebx
	nva = fd2data(newfd);
  80fa3c:	89 34 24             	mov    %esi,(%esp)
  80fa3f:	e8 c7 fd ff ff       	call   80f80b <fd2data>
  80fa44:	83 c4 10             	add    $0x10,%esp
  80fa47:	89 c7                	mov    %eax,%edi

	if ((uvpd[PDX(ova)] & PTE_P) && (uvpt[PGNUM(ova)] & PTE_P))
  80fa49:	89 d8                	mov    %ebx,%eax
  80fa4b:	c1 e8 16             	shr    $0x16,%eax
  80fa4e:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  80fa55:	a8 01                	test   $0x1,%al
  80fa57:	74 11                	je     80fa6a <dup+0x74>
  80fa59:	89 d8                	mov    %ebx,%eax
  80fa5b:	c1 e8 0c             	shr    $0xc,%eax
  80fa5e:	8b 14 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%edx
  80fa65:	f6 c2 01             	test   $0x1,%dl
  80fa68:	75 39                	jne    80faa3 <dup+0xad>
		if ((r = sys_page_map(0, ova, 0, nva, uvpt[PGNUM(ova)] & PTE_SYSCALL)) < 0)
			goto err;
	if ((r = sys_page_map(0, oldfd, 0, newfd, uvpt[PGNUM(oldfd)] & PTE_SYSCALL)) < 0)
  80fa6a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80fa6d:	89 d0                	mov    %edx,%eax
  80fa6f:	c1 e8 0c             	shr    $0xc,%eax
  80fa72:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  80fa79:	83 ec 0c             	sub    $0xc,%esp
  80fa7c:	25 07 0e 00 00       	and    $0xe07,%eax
  80fa81:	50                   	push   %eax
  80fa82:	56                   	push   %esi
  80fa83:	6a 00                	push   $0x0
  80fa85:	52                   	push   %edx
  80fa86:	6a 00                	push   $0x0
  80fa88:	e8 7a f7 ff ff       	call   80f207 <sys_page_map>
  80fa8d:	89 c3                	mov    %eax,%ebx
  80fa8f:	83 c4 20             	add    $0x20,%esp
  80fa92:	85 c0                	test   %eax,%eax
  80fa94:	78 31                	js     80fac7 <dup+0xd1>
		goto err;

	return newfdnum;
  80fa96:	8b 5d 0c             	mov    0xc(%ebp),%ebx

err:
	sys_page_unmap(0, newfd);
	sys_page_unmap(0, nva);
	return r;
}
  80fa99:	89 d8                	mov    %ebx,%eax
  80fa9b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80fa9e:	5b                   	pop    %ebx
  80fa9f:	5e                   	pop    %esi
  80faa0:	5f                   	pop    %edi
  80faa1:	5d                   	pop    %ebp
  80faa2:	c3                   	ret    
		if ((r = sys_page_map(0, ova, 0, nva, uvpt[PGNUM(ova)] & PTE_SYSCALL)) < 0)
  80faa3:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  80faaa:	83 ec 0c             	sub    $0xc,%esp
  80faad:	25 07 0e 00 00       	and    $0xe07,%eax
  80fab2:	50                   	push   %eax
  80fab3:	57                   	push   %edi
  80fab4:	6a 00                	push   $0x0
  80fab6:	53                   	push   %ebx
  80fab7:	6a 00                	push   $0x0
  80fab9:	e8 49 f7 ff ff       	call   80f207 <sys_page_map>
  80fabe:	89 c3                	mov    %eax,%ebx
  80fac0:	83 c4 20             	add    $0x20,%esp
  80fac3:	85 c0                	test   %eax,%eax
  80fac5:	79 a3                	jns    80fa6a <dup+0x74>
	sys_page_unmap(0, newfd);
  80fac7:	83 ec 08             	sub    $0x8,%esp
  80faca:	56                   	push   %esi
  80facb:	6a 00                	push   $0x0
  80facd:	e8 77 f7 ff ff       	call   80f249 <sys_page_unmap>
	sys_page_unmap(0, nva);
  80fad2:	83 c4 08             	add    $0x8,%esp
  80fad5:	57                   	push   %edi
  80fad6:	6a 00                	push   $0x0
  80fad8:	e8 6c f7 ff ff       	call   80f249 <sys_page_unmap>
	return r;
  80fadd:	83 c4 10             	add    $0x10,%esp
  80fae0:	eb b7                	jmp    80fa99 <dup+0xa3>

0080fae2 <read>:

ssize_t
read(int fdnum, void *buf, size_t n)
{
  80fae2:	55                   	push   %ebp
  80fae3:	89 e5                	mov    %esp,%ebp
  80fae5:	53                   	push   %ebx
  80fae6:	83 ec 14             	sub    $0x14,%esp
  80fae9:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  80faec:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80faef:	50                   	push   %eax
  80faf0:	53                   	push   %ebx
  80faf1:	e8 7b fd ff ff       	call   80f871 <fd_lookup>
  80faf6:	83 c4 08             	add    $0x8,%esp
  80faf9:	85 c0                	test   %eax,%eax
  80fafb:	78 3f                	js     80fb3c <read+0x5a>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80fafd:	83 ec 08             	sub    $0x8,%esp
  80fb00:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80fb03:	50                   	push   %eax
  80fb04:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80fb07:	ff 30                	pushl  (%eax)
  80fb09:	e8 b9 fd ff ff       	call   80f8c7 <dev_lookup>
  80fb0e:	83 c4 10             	add    $0x10,%esp
  80fb11:	85 c0                	test   %eax,%eax
  80fb13:	78 27                	js     80fb3c <read+0x5a>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_WRONLY) {
  80fb15:	8b 55 f0             	mov    -0x10(%ebp),%edx
  80fb18:	8b 42 08             	mov    0x8(%edx),%eax
  80fb1b:	83 e0 03             	and    $0x3,%eax
  80fb1e:	83 f8 01             	cmp    $0x1,%eax
  80fb21:	74 1e                	je     80fb41 <read+0x5f>
		cprintf("[%08x] read %d -- bad mode\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	if (!dev->dev_read)
  80fb23:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80fb26:	8b 40 08             	mov    0x8(%eax),%eax
  80fb29:	85 c0                	test   %eax,%eax
  80fb2b:	74 35                	je     80fb62 <read+0x80>
		return -E_NOT_SUPP;
	return (*dev->dev_read)(fd, buf, n);
  80fb2d:	83 ec 04             	sub    $0x4,%esp
  80fb30:	ff 75 10             	pushl  0x10(%ebp)
  80fb33:	ff 75 0c             	pushl  0xc(%ebp)
  80fb36:	52                   	push   %edx
  80fb37:	ff d0                	call   *%eax
  80fb39:	83 c4 10             	add    $0x10,%esp
}
  80fb3c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80fb3f:	c9                   	leave  
  80fb40:	c3                   	ret    
		cprintf("[%08x] read %d -- bad mode\n", thisenv->env_id, fdnum);
  80fb41:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80fb46:	8b 40 48             	mov    0x48(%eax),%eax
  80fb49:	83 ec 04             	sub    $0x4,%esp
  80fb4c:	53                   	push   %ebx
  80fb4d:	50                   	push   %eax
  80fb4e:	68 c9 38 81 00       	push   $0x8138c9
  80fb53:	e8 d6 eb ff ff       	call   80e72e <cprintf>
		return -E_INVAL;
  80fb58:	83 c4 10             	add    $0x10,%esp
  80fb5b:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80fb60:	eb da                	jmp    80fb3c <read+0x5a>
		return -E_NOT_SUPP;
  80fb62:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  80fb67:	eb d3                	jmp    80fb3c <read+0x5a>

0080fb69 <readn>:

ssize_t
readn(int fdnum, void *buf, size_t n)
{
  80fb69:	55                   	push   %ebp
  80fb6a:	89 e5                	mov    %esp,%ebp
  80fb6c:	57                   	push   %edi
  80fb6d:	56                   	push   %esi
  80fb6e:	53                   	push   %ebx
  80fb6f:	83 ec 0c             	sub    $0xc,%esp
  80fb72:	8b 7d 08             	mov    0x8(%ebp),%edi
  80fb75:	8b 75 10             	mov    0x10(%ebp),%esi
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  80fb78:	bb 00 00 00 00       	mov    $0x0,%ebx
  80fb7d:	39 f3                	cmp    %esi,%ebx
  80fb7f:	73 25                	jae    80fba6 <readn+0x3d>
		m = read(fdnum, (char*)buf + tot, n - tot);
  80fb81:	83 ec 04             	sub    $0x4,%esp
  80fb84:	89 f0                	mov    %esi,%eax
  80fb86:	29 d8                	sub    %ebx,%eax
  80fb88:	50                   	push   %eax
  80fb89:	89 d8                	mov    %ebx,%eax
  80fb8b:	03 45 0c             	add    0xc(%ebp),%eax
  80fb8e:	50                   	push   %eax
  80fb8f:	57                   	push   %edi
  80fb90:	e8 4d ff ff ff       	call   80fae2 <read>
		if (m < 0)
  80fb95:	83 c4 10             	add    $0x10,%esp
  80fb98:	85 c0                	test   %eax,%eax
  80fb9a:	78 08                	js     80fba4 <readn+0x3b>
			return m;
		if (m == 0)
  80fb9c:	85 c0                	test   %eax,%eax
  80fb9e:	74 06                	je     80fba6 <readn+0x3d>
	for (tot = 0; tot < n; tot += m) {
  80fba0:	01 c3                	add    %eax,%ebx
  80fba2:	eb d9                	jmp    80fb7d <readn+0x14>
		m = read(fdnum, (char*)buf + tot, n - tot);
  80fba4:	89 c3                	mov    %eax,%ebx
			break;
	}
	return tot;
}
  80fba6:	89 d8                	mov    %ebx,%eax
  80fba8:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80fbab:	5b                   	pop    %ebx
  80fbac:	5e                   	pop    %esi
  80fbad:	5f                   	pop    %edi
  80fbae:	5d                   	pop    %ebp
  80fbaf:	c3                   	ret    

0080fbb0 <write>:

ssize_t
write(int fdnum, const void *buf, size_t n)
{
  80fbb0:	55                   	push   %ebp
  80fbb1:	89 e5                	mov    %esp,%ebp
  80fbb3:	53                   	push   %ebx
  80fbb4:	83 ec 14             	sub    $0x14,%esp
  80fbb7:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  80fbba:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80fbbd:	50                   	push   %eax
  80fbbe:	53                   	push   %ebx
  80fbbf:	e8 ad fc ff ff       	call   80f871 <fd_lookup>
  80fbc4:	83 c4 08             	add    $0x8,%esp
  80fbc7:	85 c0                	test   %eax,%eax
  80fbc9:	78 3a                	js     80fc05 <write+0x55>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80fbcb:	83 ec 08             	sub    $0x8,%esp
  80fbce:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80fbd1:	50                   	push   %eax
  80fbd2:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80fbd5:	ff 30                	pushl  (%eax)
  80fbd7:	e8 eb fc ff ff       	call   80f8c7 <dev_lookup>
  80fbdc:	83 c4 10             	add    $0x10,%esp
  80fbdf:	85 c0                	test   %eax,%eax
  80fbe1:	78 22                	js     80fc05 <write+0x55>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  80fbe3:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80fbe6:	f6 40 08 03          	testb  $0x3,0x8(%eax)
  80fbea:	74 1e                	je     80fc0a <write+0x5a>
		return -E_INVAL;
	}
	if (debug)
		cprintf("write %d %p %d via dev %s\n",
			fdnum, buf, n, dev->dev_name);
	if (!dev->dev_write)
  80fbec:	8b 55 f4             	mov    -0xc(%ebp),%edx
  80fbef:	8b 52 0c             	mov    0xc(%edx),%edx
  80fbf2:	85 d2                	test   %edx,%edx
  80fbf4:	74 35                	je     80fc2b <write+0x7b>
		return -E_NOT_SUPP;
	return (*dev->dev_write)(fd, buf, n);
  80fbf6:	83 ec 04             	sub    $0x4,%esp
  80fbf9:	ff 75 10             	pushl  0x10(%ebp)
  80fbfc:	ff 75 0c             	pushl  0xc(%ebp)
  80fbff:	50                   	push   %eax
  80fc00:	ff d2                	call   *%edx
  80fc02:	83 c4 10             	add    $0x10,%esp
}
  80fc05:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80fc08:	c9                   	leave  
  80fc09:	c3                   	ret    
		cprintf("[%08x] write %d -- bad mode\n", thisenv->env_id, fdnum);
  80fc0a:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80fc0f:	8b 40 48             	mov    0x48(%eax),%eax
  80fc12:	83 ec 04             	sub    $0x4,%esp
  80fc15:	53                   	push   %ebx
  80fc16:	50                   	push   %eax
  80fc17:	68 e5 38 81 00       	push   $0x8138e5
  80fc1c:	e8 0d eb ff ff       	call   80e72e <cprintf>
		return -E_INVAL;
  80fc21:	83 c4 10             	add    $0x10,%esp
  80fc24:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80fc29:	eb da                	jmp    80fc05 <write+0x55>
		return -E_NOT_SUPP;
  80fc2b:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  80fc30:	eb d3                	jmp    80fc05 <write+0x55>

0080fc32 <seek>:

int
seek(int fdnum, off_t offset)
{
  80fc32:	55                   	push   %ebp
  80fc33:	89 e5                	mov    %esp,%ebp
  80fc35:	83 ec 10             	sub    $0x10,%esp
	int r;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  80fc38:	8d 45 fc             	lea    -0x4(%ebp),%eax
  80fc3b:	50                   	push   %eax
  80fc3c:	ff 75 08             	pushl  0x8(%ebp)
  80fc3f:	e8 2d fc ff ff       	call   80f871 <fd_lookup>
  80fc44:	83 c4 08             	add    $0x8,%esp
  80fc47:	85 c0                	test   %eax,%eax
  80fc49:	78 0e                	js     80fc59 <seek+0x27>
		return r;
	fd->fd_offset = offset;
  80fc4b:	8b 55 0c             	mov    0xc(%ebp),%edx
  80fc4e:	8b 45 fc             	mov    -0x4(%ebp),%eax
  80fc51:	89 50 04             	mov    %edx,0x4(%eax)
	return 0;
  80fc54:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80fc59:	c9                   	leave  
  80fc5a:	c3                   	ret    

0080fc5b <ftruncate>:

int
ftruncate(int fdnum, off_t newsize)
{
  80fc5b:	55                   	push   %ebp
  80fc5c:	89 e5                	mov    %esp,%ebp
  80fc5e:	53                   	push   %ebx
  80fc5f:	83 ec 14             	sub    $0x14,%esp
  80fc62:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
  80fc65:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80fc68:	50                   	push   %eax
  80fc69:	53                   	push   %ebx
  80fc6a:	e8 02 fc ff ff       	call   80f871 <fd_lookup>
  80fc6f:	83 c4 08             	add    $0x8,%esp
  80fc72:	85 c0                	test   %eax,%eax
  80fc74:	78 37                	js     80fcad <ftruncate+0x52>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80fc76:	83 ec 08             	sub    $0x8,%esp
  80fc79:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80fc7c:	50                   	push   %eax
  80fc7d:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80fc80:	ff 30                	pushl  (%eax)
  80fc82:	e8 40 fc ff ff       	call   80f8c7 <dev_lookup>
  80fc87:	83 c4 10             	add    $0x10,%esp
  80fc8a:	85 c0                	test   %eax,%eax
  80fc8c:	78 1f                	js     80fcad <ftruncate+0x52>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  80fc8e:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80fc91:	f6 40 08 03          	testb  $0x3,0x8(%eax)
  80fc95:	74 1b                	je     80fcb2 <ftruncate+0x57>
		cprintf("[%08x] ftruncate %d -- bad mode\n",
			thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	if (!dev->dev_trunc)
  80fc97:	8b 55 f4             	mov    -0xc(%ebp),%edx
  80fc9a:	8b 52 18             	mov    0x18(%edx),%edx
  80fc9d:	85 d2                	test   %edx,%edx
  80fc9f:	74 32                	je     80fcd3 <ftruncate+0x78>
		return -E_NOT_SUPP;
	return (*dev->dev_trunc)(fd, newsize);
  80fca1:	83 ec 08             	sub    $0x8,%esp
  80fca4:	ff 75 0c             	pushl  0xc(%ebp)
  80fca7:	50                   	push   %eax
  80fca8:	ff d2                	call   *%edx
  80fcaa:	83 c4 10             	add    $0x10,%esp
}
  80fcad:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80fcb0:	c9                   	leave  
  80fcb1:	c3                   	ret    
			thisenv->env_id, fdnum);
  80fcb2:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
		cprintf("[%08x] ftruncate %d -- bad mode\n",
  80fcb7:	8b 40 48             	mov    0x48(%eax),%eax
  80fcba:	83 ec 04             	sub    $0x4,%esp
  80fcbd:	53                   	push   %ebx
  80fcbe:	50                   	push   %eax
  80fcbf:	68 a8 38 81 00       	push   $0x8138a8
  80fcc4:	e8 65 ea ff ff       	call   80e72e <cprintf>
		return -E_INVAL;
  80fcc9:	83 c4 10             	add    $0x10,%esp
  80fccc:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80fcd1:	eb da                	jmp    80fcad <ftruncate+0x52>
		return -E_NOT_SUPP;
  80fcd3:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  80fcd8:	eb d3                	jmp    80fcad <ftruncate+0x52>

0080fcda <fstat>:

int
fstat(int fdnum, struct Stat *stat)
{
  80fcda:	55                   	push   %ebp
  80fcdb:	89 e5                	mov    %esp,%ebp
  80fcdd:	53                   	push   %ebx
  80fcde:	83 ec 14             	sub    $0x14,%esp
  80fce1:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  80fce4:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80fce7:	50                   	push   %eax
  80fce8:	ff 75 08             	pushl  0x8(%ebp)
  80fceb:	e8 81 fb ff ff       	call   80f871 <fd_lookup>
  80fcf0:	83 c4 08             	add    $0x8,%esp
  80fcf3:	85 c0                	test   %eax,%eax
  80fcf5:	78 4b                	js     80fd42 <fstat+0x68>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80fcf7:	83 ec 08             	sub    $0x8,%esp
  80fcfa:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80fcfd:	50                   	push   %eax
  80fcfe:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80fd01:	ff 30                	pushl  (%eax)
  80fd03:	e8 bf fb ff ff       	call   80f8c7 <dev_lookup>
  80fd08:	83 c4 10             	add    $0x10,%esp
  80fd0b:	85 c0                	test   %eax,%eax
  80fd0d:	78 33                	js     80fd42 <fstat+0x68>
		return r;
	if (!dev->dev_stat)
  80fd0f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80fd12:	83 78 14 00          	cmpl   $0x0,0x14(%eax)
  80fd16:	74 2f                	je     80fd47 <fstat+0x6d>
		return -E_NOT_SUPP;
	stat->st_name[0] = 0;
  80fd18:	c6 03 00             	movb   $0x0,(%ebx)
	stat->st_size = 0;
  80fd1b:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  80fd22:	00 00 00 
	stat->st_isdir = 0;
  80fd25:	c7 83 84 00 00 00 00 	movl   $0x0,0x84(%ebx)
  80fd2c:	00 00 00 
	stat->st_dev = dev;
  80fd2f:	89 83 88 00 00 00    	mov    %eax,0x88(%ebx)
	return (*dev->dev_stat)(fd, stat);
  80fd35:	83 ec 08             	sub    $0x8,%esp
  80fd38:	53                   	push   %ebx
  80fd39:	ff 75 f0             	pushl  -0x10(%ebp)
  80fd3c:	ff 50 14             	call   *0x14(%eax)
  80fd3f:	83 c4 10             	add    $0x10,%esp
}
  80fd42:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80fd45:	c9                   	leave  
  80fd46:	c3                   	ret    
		return -E_NOT_SUPP;
  80fd47:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  80fd4c:	eb f4                	jmp    80fd42 <fstat+0x68>

0080fd4e <stat>:

int
stat(const char *path, struct Stat *stat)
{
  80fd4e:	55                   	push   %ebp
  80fd4f:	89 e5                	mov    %esp,%ebp
  80fd51:	56                   	push   %esi
  80fd52:	53                   	push   %ebx
	int fd, r;

	if ((fd = open(path, O_RDONLY)) < 0)
  80fd53:	83 ec 08             	sub    $0x8,%esp
  80fd56:	6a 00                	push   $0x0
  80fd58:	ff 75 08             	pushl  0x8(%ebp)
  80fd5b:	e8 26 02 00 00       	call   80ff86 <open>
  80fd60:	89 c3                	mov    %eax,%ebx
  80fd62:	83 c4 10             	add    $0x10,%esp
  80fd65:	85 c0                	test   %eax,%eax
  80fd67:	78 1b                	js     80fd84 <stat+0x36>
		return fd;
	r = fstat(fd, stat);
  80fd69:	83 ec 08             	sub    $0x8,%esp
  80fd6c:	ff 75 0c             	pushl  0xc(%ebp)
  80fd6f:	50                   	push   %eax
  80fd70:	e8 65 ff ff ff       	call   80fcda <fstat>
  80fd75:	89 c6                	mov    %eax,%esi
	close(fd);
  80fd77:	89 1c 24             	mov    %ebx,(%esp)
  80fd7a:	e8 27 fc ff ff       	call   80f9a6 <close>
	return r;
  80fd7f:	83 c4 10             	add    $0x10,%esp
  80fd82:	89 f3                	mov    %esi,%ebx
}
  80fd84:	89 d8                	mov    %ebx,%eax
  80fd86:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80fd89:	5b                   	pop    %ebx
  80fd8a:	5e                   	pop    %esi
  80fd8b:	5d                   	pop    %ebp
  80fd8c:	c3                   	ret    

0080fd8d <fsipc>:
// type: request code, passed as the simple integer IPC value.
// dstva: virtual address at which to receive reply page, 0 if none.
// Returns result from the file server.
static int
fsipc(unsigned type, void *dstva)
{
  80fd8d:	55                   	push   %ebp
  80fd8e:	89 e5                	mov    %esp,%ebp
  80fd90:	56                   	push   %esi
  80fd91:	53                   	push   %ebx
  80fd92:	89 c6                	mov    %eax,%esi
  80fd94:	89 d3                	mov    %edx,%ebx
	static envid_t fsenv;
	if (fsenv == 0)
  80fd96:	83 3d cc b1 b3 00 00 	cmpl   $0x0,0xb3b1cc
  80fd9d:	74 27                	je     80fdc6 <fsipc+0x39>
	static_assert(sizeof(fsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] fsipc %d %08x\n", thisenv->env_id, type, *(uint32_t *)&fsipcbuf);

	ipc_send(fsenv, type, &fsipcbuf, PTE_P | PTE_W | PTE_U);
  80fd9f:	6a 07                	push   $0x7
  80fda1:	68 00 c0 b3 00       	push   $0xb3c000
  80fda6:	56                   	push   %esi
  80fda7:	ff 35 cc b1 b3 00    	pushl  0xb3b1cc
  80fdad:	e8 b7 f9 ff ff       	call   80f769 <ipc_send>
	return ipc_recv(NULL, dstva, NULL);
  80fdb2:	83 c4 0c             	add    $0xc,%esp
  80fdb5:	6a 00                	push   $0x0
  80fdb7:	53                   	push   %ebx
  80fdb8:	6a 00                	push   $0x0
  80fdba:	e8 41 f9 ff ff       	call   80f700 <ipc_recv>
}
  80fdbf:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80fdc2:	5b                   	pop    %ebx
  80fdc3:	5e                   	pop    %esi
  80fdc4:	5d                   	pop    %ebp
  80fdc5:	c3                   	ret    
		fsenv = ipc_find_env(ENV_TYPE_FS);
  80fdc6:	83 ec 0c             	sub    $0xc,%esp
  80fdc9:	6a 01                	push   $0x1
  80fdcb:	e8 f2 f9 ff ff       	call   80f7c2 <ipc_find_env>
  80fdd0:	a3 cc b1 b3 00       	mov    %eax,0xb3b1cc
  80fdd5:	83 c4 10             	add    $0x10,%esp
  80fdd8:	eb c5                	jmp    80fd9f <fsipc+0x12>

0080fdda <devfile_trunc>:
}

// Truncate or extend an open file to 'size' bytes
static int
devfile_trunc(struct Fd *fd, off_t newsize)
{
  80fdda:	55                   	push   %ebp
  80fddb:	89 e5                	mov    %esp,%ebp
  80fddd:	83 ec 08             	sub    $0x8,%esp
	fsipcbuf.set_size.req_fileid = fd->fd_file.id;
  80fde0:	8b 45 08             	mov    0x8(%ebp),%eax
  80fde3:	8b 40 0c             	mov    0xc(%eax),%eax
  80fde6:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	fsipcbuf.set_size.req_size = newsize;
  80fdeb:	8b 45 0c             	mov    0xc(%ebp),%eax
  80fdee:	a3 04 c0 b3 00       	mov    %eax,0xb3c004
	return fsipc(FSREQ_SET_SIZE, NULL);
  80fdf3:	ba 00 00 00 00       	mov    $0x0,%edx
  80fdf8:	b8 02 00 00 00       	mov    $0x2,%eax
  80fdfd:	e8 8b ff ff ff       	call   80fd8d <fsipc>
}
  80fe02:	c9                   	leave  
  80fe03:	c3                   	ret    

0080fe04 <devfile_flush>:
{
  80fe04:	55                   	push   %ebp
  80fe05:	89 e5                	mov    %esp,%ebp
  80fe07:	83 ec 08             	sub    $0x8,%esp
	fsipcbuf.flush.req_fileid = fd->fd_file.id;
  80fe0a:	8b 45 08             	mov    0x8(%ebp),%eax
  80fe0d:	8b 40 0c             	mov    0xc(%eax),%eax
  80fe10:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	return fsipc(FSREQ_FLUSH, NULL);
  80fe15:	ba 00 00 00 00       	mov    $0x0,%edx
  80fe1a:	b8 06 00 00 00       	mov    $0x6,%eax
  80fe1f:	e8 69 ff ff ff       	call   80fd8d <fsipc>
}
  80fe24:	c9                   	leave  
  80fe25:	c3                   	ret    

0080fe26 <devfile_stat>:
{
  80fe26:	55                   	push   %ebp
  80fe27:	89 e5                	mov    %esp,%ebp
  80fe29:	53                   	push   %ebx
  80fe2a:	83 ec 04             	sub    $0x4,%esp
  80fe2d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	fsipcbuf.stat.req_fileid = fd->fd_file.id;
  80fe30:	8b 45 08             	mov    0x8(%ebp),%eax
  80fe33:	8b 40 0c             	mov    0xc(%eax),%eax
  80fe36:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	if ((r = fsipc(FSREQ_STAT, NULL)) < 0)
  80fe3b:	ba 00 00 00 00       	mov    $0x0,%edx
  80fe40:	b8 05 00 00 00       	mov    $0x5,%eax
  80fe45:	e8 43 ff ff ff       	call   80fd8d <fsipc>
  80fe4a:	85 c0                	test   %eax,%eax
  80fe4c:	78 2c                	js     80fe7a <devfile_stat+0x54>
	strcpy(st->st_name, fsipcbuf.statRet.ret_name);
  80fe4e:	83 ec 08             	sub    $0x8,%esp
  80fe51:	68 00 c0 b3 00       	push   $0xb3c000
  80fe56:	53                   	push   %ebx
  80fe57:	e8 6f ef ff ff       	call   80edcb <strcpy>
	st->st_size = fsipcbuf.statRet.ret_size;
  80fe5c:	a1 80 c0 b3 00       	mov    0xb3c080,%eax
  80fe61:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
	st->st_isdir = fsipcbuf.statRet.ret_isdir;
  80fe67:	a1 84 c0 b3 00       	mov    0xb3c084,%eax
  80fe6c:	89 83 84 00 00 00    	mov    %eax,0x84(%ebx)
	return 0;
  80fe72:	83 c4 10             	add    $0x10,%esp
  80fe75:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80fe7a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80fe7d:	c9                   	leave  
  80fe7e:	c3                   	ret    

0080fe7f <devfile_write>:
{
  80fe7f:	55                   	push   %ebp
  80fe80:	89 e5                	mov    %esp,%ebp
  80fe82:	53                   	push   %ebx
  80fe83:	83 ec 04             	sub    $0x4,%esp
  80fe86:	8b 5d 10             	mov    0x10(%ebp),%ebx
	fsipcbuf.write.req_fileid = fd->fd_file.id;
  80fe89:	8b 45 08             	mov    0x8(%ebp),%eax
  80fe8c:	8b 40 0c             	mov    0xc(%eax),%eax
  80fe8f:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	fsipcbuf.write.req_n = n;
  80fe94:	89 1d 04 c0 b3 00    	mov    %ebx,0xb3c004
	assert(n <= PGSIZE - (sizeof(int) + sizeof(size_t)));
  80fe9a:	81 fb f8 0f 00 00    	cmp    $0xff8,%ebx
  80fea0:	77 30                	ja     80fed2 <devfile_write+0x53>
	memmove(fsipcbuf.write.req_buf, buf, n);
  80fea2:	83 ec 04             	sub    $0x4,%esp
  80fea5:	53                   	push   %ebx
  80fea6:	ff 75 0c             	pushl  0xc(%ebp)
  80fea9:	68 08 c0 b3 00       	push   $0xb3c008
  80feae:	e8 a6 f0 ff ff       	call   80ef59 <memmove>
	if ((r = fsipc(FSREQ_WRITE, NULL)) < 0)
  80feb3:	ba 00 00 00 00       	mov    $0x0,%edx
  80feb8:	b8 04 00 00 00       	mov    $0x4,%eax
  80febd:	e8 cb fe ff ff       	call   80fd8d <fsipc>
  80fec2:	83 c4 10             	add    $0x10,%esp
  80fec5:	85 c0                	test   %eax,%eax
  80fec7:	78 04                	js     80fecd <devfile_write+0x4e>
	assert(r <= n);
  80fec9:	39 d8                	cmp    %ebx,%eax
  80fecb:	77 1e                	ja     80feeb <devfile_write+0x6c>
}
  80fecd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80fed0:	c9                   	leave  
  80fed1:	c3                   	ret    
	assert(n <= PGSIZE - (sizeof(int) + sizeof(size_t)));
  80fed2:	68 18 39 81 00       	push   $0x813918
  80fed7:	68 a7 26 81 00       	push   $0x8126a7
  80fedc:	68 94 00 00 00       	push   $0x94
  80fee1:	68 45 39 81 00       	push   $0x813945
  80fee6:	e8 68 e7 ff ff       	call   80e653 <_panic>
	assert(r <= n);
  80feeb:	68 50 39 81 00       	push   $0x813950
  80fef0:	68 a7 26 81 00       	push   $0x8126a7
  80fef5:	68 98 00 00 00       	push   $0x98
  80fefa:	68 45 39 81 00       	push   $0x813945
  80feff:	e8 4f e7 ff ff       	call   80e653 <_panic>

0080ff04 <devfile_read>:
{
  80ff04:	55                   	push   %ebp
  80ff05:	89 e5                	mov    %esp,%ebp
  80ff07:	56                   	push   %esi
  80ff08:	53                   	push   %ebx
  80ff09:	8b 75 10             	mov    0x10(%ebp),%esi
	fsipcbuf.read.req_fileid = fd->fd_file.id;
  80ff0c:	8b 45 08             	mov    0x8(%ebp),%eax
  80ff0f:	8b 40 0c             	mov    0xc(%eax),%eax
  80ff12:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	fsipcbuf.read.req_n = n;
  80ff17:	89 35 04 c0 b3 00    	mov    %esi,0xb3c004
	if ((r = fsipc(FSREQ_READ, NULL)) < 0)
  80ff1d:	ba 00 00 00 00       	mov    $0x0,%edx
  80ff22:	b8 03 00 00 00       	mov    $0x3,%eax
  80ff27:	e8 61 fe ff ff       	call   80fd8d <fsipc>
  80ff2c:	89 c3                	mov    %eax,%ebx
  80ff2e:	85 c0                	test   %eax,%eax
  80ff30:	78 1f                	js     80ff51 <devfile_read+0x4d>
	assert(r <= n);
  80ff32:	39 f0                	cmp    %esi,%eax
  80ff34:	77 24                	ja     80ff5a <devfile_read+0x56>
	assert(r <= PGSIZE);
  80ff36:	3d 00 10 00 00       	cmp    $0x1000,%eax
  80ff3b:	7f 33                	jg     80ff70 <devfile_read+0x6c>
	memmove(buf, fsipcbuf.readRet.ret_buf, r);
  80ff3d:	83 ec 04             	sub    $0x4,%esp
  80ff40:	50                   	push   %eax
  80ff41:	68 00 c0 b3 00       	push   $0xb3c000
  80ff46:	ff 75 0c             	pushl  0xc(%ebp)
  80ff49:	e8 0b f0 ff ff       	call   80ef59 <memmove>
	return r;
  80ff4e:	83 c4 10             	add    $0x10,%esp
}
  80ff51:	89 d8                	mov    %ebx,%eax
  80ff53:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80ff56:	5b                   	pop    %ebx
  80ff57:	5e                   	pop    %esi
  80ff58:	5d                   	pop    %ebp
  80ff59:	c3                   	ret    
	assert(r <= n);
  80ff5a:	68 50 39 81 00       	push   $0x813950
  80ff5f:	68 a7 26 81 00       	push   $0x8126a7
  80ff64:	6a 7c                	push   $0x7c
  80ff66:	68 45 39 81 00       	push   $0x813945
  80ff6b:	e8 e3 e6 ff ff       	call   80e653 <_panic>
	assert(r <= PGSIZE);
  80ff70:	68 57 39 81 00       	push   $0x813957
  80ff75:	68 a7 26 81 00       	push   $0x8126a7
  80ff7a:	6a 7d                	push   $0x7d
  80ff7c:	68 45 39 81 00       	push   $0x813945
  80ff81:	e8 cd e6 ff ff       	call   80e653 <_panic>

0080ff86 <open>:
{
  80ff86:	55                   	push   %ebp
  80ff87:	89 e5                	mov    %esp,%ebp
  80ff89:	56                   	push   %esi
  80ff8a:	53                   	push   %ebx
  80ff8b:	83 ec 1c             	sub    $0x1c,%esp
  80ff8e:	8b 75 08             	mov    0x8(%ebp),%esi
	if (strlen(path) >= MAXPATHLEN)
  80ff91:	56                   	push   %esi
  80ff92:	e8 fd ed ff ff       	call   80ed94 <strlen>
  80ff97:	83 c4 10             	add    $0x10,%esp
  80ff9a:	3d ff 03 00 00       	cmp    $0x3ff,%eax
  80ff9f:	7f 6c                	jg     81000d <open+0x87>
	if ((r = fd_alloc(&fd)) < 0)
  80ffa1:	83 ec 0c             	sub    $0xc,%esp
  80ffa4:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80ffa7:	50                   	push   %eax
  80ffa8:	e8 75 f8 ff ff       	call   80f822 <fd_alloc>
  80ffad:	89 c3                	mov    %eax,%ebx
  80ffaf:	83 c4 10             	add    $0x10,%esp
  80ffb2:	85 c0                	test   %eax,%eax
  80ffb4:	78 3c                	js     80fff2 <open+0x6c>
	strcpy(fsipcbuf.open.req_path, path);
  80ffb6:	83 ec 08             	sub    $0x8,%esp
  80ffb9:	56                   	push   %esi
  80ffba:	68 00 c0 b3 00       	push   $0xb3c000
  80ffbf:	e8 07 ee ff ff       	call   80edcb <strcpy>
	fsipcbuf.open.req_omode = mode;
  80ffc4:	8b 45 0c             	mov    0xc(%ebp),%eax
  80ffc7:	a3 00 c4 b3 00       	mov    %eax,0xb3c400
	if ((r = fsipc(FSREQ_OPEN, fd)) < 0) {
  80ffcc:	8b 55 f4             	mov    -0xc(%ebp),%edx
  80ffcf:	b8 01 00 00 00       	mov    $0x1,%eax
  80ffd4:	e8 b4 fd ff ff       	call   80fd8d <fsipc>
  80ffd9:	89 c3                	mov    %eax,%ebx
  80ffdb:	83 c4 10             	add    $0x10,%esp
  80ffde:	85 c0                	test   %eax,%eax
  80ffe0:	78 19                	js     80fffb <open+0x75>
	return fd2num(fd);
  80ffe2:	83 ec 0c             	sub    $0xc,%esp
  80ffe5:	ff 75 f4             	pushl  -0xc(%ebp)
  80ffe8:	e8 0e f8 ff ff       	call   80f7fb <fd2num>
  80ffed:	89 c3                	mov    %eax,%ebx
  80ffef:	83 c4 10             	add    $0x10,%esp
}
  80fff2:	89 d8                	mov    %ebx,%eax
  80fff4:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80fff7:	5b                   	pop    %ebx
  80fff8:	5e                   	pop    %esi
  80fff9:	5d                   	pop    %ebp
  80fffa:	c3                   	ret    
		fd_close(fd, 0);
  80fffb:	83 ec 08             	sub    $0x8,%esp
  80fffe:	6a 00                	push   $0x0
  810000:	ff 75 f4             	pushl  -0xc(%ebp)
  810003:	e8 15 f9 ff ff       	call   80f91d <fd_close>
		return r;
  810008:	83 c4 10             	add    $0x10,%esp
  81000b:	eb e5                	jmp    80fff2 <open+0x6c>
		return -E_BAD_PATH;
  81000d:	bb f4 ff ff ff       	mov    $0xfffffff4,%ebx
  810012:	eb de                	jmp    80fff2 <open+0x6c>

00810014 <sync>:


// Synchronize disk with buffer cache
int
sync(void)
{
  810014:	55                   	push   %ebp
  810015:	89 e5                	mov    %esp,%ebp
  810017:	83 ec 08             	sub    $0x8,%esp
	// Ask the file server to update the disk
	// by writing any dirty blocks in the buffer cache.

	return fsipc(FSREQ_SYNC, NULL);
  81001a:	ba 00 00 00 00       	mov    $0x0,%edx
  81001f:	b8 08 00 00 00       	mov    $0x8,%eax
  810024:	e8 64 fd ff ff       	call   80fd8d <fsipc>
}
  810029:	c9                   	leave  
  81002a:	c3                   	ret    

0081002b <devpipe_stat>:
	return i;
}

static int
devpipe_stat(struct Fd *fd, struct Stat *stat)
{
  81002b:	55                   	push   %ebp
  81002c:	89 e5                	mov    %esp,%ebp
  81002e:	56                   	push   %esi
  81002f:	53                   	push   %ebx
  810030:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct Pipe *p = (struct Pipe*) fd2data(fd);
  810033:	83 ec 0c             	sub    $0xc,%esp
  810036:	ff 75 08             	pushl  0x8(%ebp)
  810039:	e8 cd f7 ff ff       	call   80f80b <fd2data>
  81003e:	89 c6                	mov    %eax,%esi
	strcpy(stat->st_name, "<pipe>");
  810040:	83 c4 08             	add    $0x8,%esp
  810043:	68 63 39 81 00       	push   $0x813963
  810048:	53                   	push   %ebx
  810049:	e8 7d ed ff ff       	call   80edcb <strcpy>
	stat->st_size = p->p_wpos - p->p_rpos;
  81004e:	8b 46 04             	mov    0x4(%esi),%eax
  810051:	2b 06                	sub    (%esi),%eax
  810053:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
	stat->st_isdir = 0;
  810059:	c7 83 84 00 00 00 00 	movl   $0x0,0x84(%ebx)
  810060:	00 00 00 
	stat->st_dev = &devpipe;
  810063:	c7 83 88 00 00 00 08 	movl   $0x814308,0x88(%ebx)
  81006a:	43 81 00 
	return 0;
}
  81006d:	b8 00 00 00 00       	mov    $0x0,%eax
  810072:	8d 65 f8             	lea    -0x8(%ebp),%esp
  810075:	5b                   	pop    %ebx
  810076:	5e                   	pop    %esi
  810077:	5d                   	pop    %ebp
  810078:	c3                   	ret    

00810079 <devpipe_close>:

static int
devpipe_close(struct Fd *fd)
{
  810079:	55                   	push   %ebp
  81007a:	89 e5                	mov    %esp,%ebp
  81007c:	53                   	push   %ebx
  81007d:	83 ec 0c             	sub    $0xc,%esp
  810080:	8b 5d 08             	mov    0x8(%ebp),%ebx
	(void) sys_page_unmap(0, fd);
  810083:	53                   	push   %ebx
  810084:	6a 00                	push   $0x0
  810086:	e8 be f1 ff ff       	call   80f249 <sys_page_unmap>
	return sys_page_unmap(0, fd2data(fd));
  81008b:	89 1c 24             	mov    %ebx,(%esp)
  81008e:	e8 78 f7 ff ff       	call   80f80b <fd2data>
  810093:	83 c4 08             	add    $0x8,%esp
  810096:	50                   	push   %eax
  810097:	6a 00                	push   $0x0
  810099:	e8 ab f1 ff ff       	call   80f249 <sys_page_unmap>
}
  81009e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8100a1:	c9                   	leave  
  8100a2:	c3                   	ret    

008100a3 <_pipeisclosed>:
{
  8100a3:	55                   	push   %ebp
  8100a4:	89 e5                	mov    %esp,%ebp
  8100a6:	57                   	push   %edi
  8100a7:	56                   	push   %esi
  8100a8:	53                   	push   %ebx
  8100a9:	83 ec 1c             	sub    $0x1c,%esp
  8100ac:	89 c7                	mov    %eax,%edi
  8100ae:	89 d6                	mov    %edx,%esi
		n = thisenv->env_runs;
  8100b0:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  8100b5:	8b 58 58             	mov    0x58(%eax),%ebx
		ret = pageref(fd) == pageref(p);
  8100b8:	83 ec 0c             	sub    $0xc,%esp
  8100bb:	57                   	push   %edi
  8100bc:	e8 be 0b 00 00       	call   810c7f <pageref>
  8100c1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8100c4:	89 34 24             	mov    %esi,(%esp)
  8100c7:	e8 b3 0b 00 00       	call   810c7f <pageref>
		nn = thisenv->env_runs;
  8100cc:	8b 15 5c b2 b3 00    	mov    0xb3b25c,%edx
  8100d2:	8b 4a 58             	mov    0x58(%edx),%ecx
		if (n == nn)
  8100d5:	83 c4 10             	add    $0x10,%esp
  8100d8:	39 cb                	cmp    %ecx,%ebx
  8100da:	74 1b                	je     8100f7 <_pipeisclosed+0x54>
		if (n != nn && ret == 1)
  8100dc:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
  8100df:	75 cf                	jne    8100b0 <_pipeisclosed+0xd>
			cprintf("pipe race avoided\n", n, thisenv->env_runs, ret);
  8100e1:	8b 42 58             	mov    0x58(%edx),%eax
  8100e4:	6a 01                	push   $0x1
  8100e6:	50                   	push   %eax
  8100e7:	53                   	push   %ebx
  8100e8:	68 6a 39 81 00       	push   $0x81396a
  8100ed:	e8 3c e6 ff ff       	call   80e72e <cprintf>
  8100f2:	83 c4 10             	add    $0x10,%esp
  8100f5:	eb b9                	jmp    8100b0 <_pipeisclosed+0xd>
		ret = pageref(fd) == pageref(p);
  8100f7:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
  8100fa:	0f 94 c0             	sete   %al
  8100fd:	0f b6 c0             	movzbl %al,%eax
}
  810100:	8d 65 f4             	lea    -0xc(%ebp),%esp
  810103:	5b                   	pop    %ebx
  810104:	5e                   	pop    %esi
  810105:	5f                   	pop    %edi
  810106:	5d                   	pop    %ebp
  810107:	c3                   	ret    

00810108 <devpipe_write>:
{
  810108:	55                   	push   %ebp
  810109:	89 e5                	mov    %esp,%ebp
  81010b:	57                   	push   %edi
  81010c:	56                   	push   %esi
  81010d:	53                   	push   %ebx
  81010e:	83 ec 28             	sub    $0x28,%esp
  810111:	8b 75 08             	mov    0x8(%ebp),%esi
	p = (struct Pipe*) fd2data(fd);
  810114:	56                   	push   %esi
  810115:	e8 f1 f6 ff ff       	call   80f80b <fd2data>
  81011a:	89 c3                	mov    %eax,%ebx
	for (i = 0; i < n; i++) {
  81011c:	83 c4 10             	add    $0x10,%esp
  81011f:	bf 00 00 00 00       	mov    $0x0,%edi
  810124:	3b 7d 10             	cmp    0x10(%ebp),%edi
  810127:	74 4f                	je     810178 <devpipe_write+0x70>
		while (p->p_wpos >= p->p_rpos + sizeof(p->p_buf)) {
  810129:	8b 43 04             	mov    0x4(%ebx),%eax
  81012c:	8b 0b                	mov    (%ebx),%ecx
  81012e:	8d 51 20             	lea    0x20(%ecx),%edx
  810131:	39 d0                	cmp    %edx,%eax
  810133:	72 14                	jb     810149 <devpipe_write+0x41>
			if (_pipeisclosed(fd, p))
  810135:	89 da                	mov    %ebx,%edx
  810137:	89 f0                	mov    %esi,%eax
  810139:	e8 65 ff ff ff       	call   8100a3 <_pipeisclosed>
  81013e:	85 c0                	test   %eax,%eax
  810140:	75 3a                	jne    81017c <devpipe_write+0x74>
			sys_yield();
  810142:	e8 5e f0 ff ff       	call   80f1a5 <sys_yield>
  810147:	eb e0                	jmp    810129 <devpipe_write+0x21>
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
  810149:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  81014c:	0f b6 0c 39          	movzbl (%ecx,%edi,1),%ecx
  810150:	88 4d e7             	mov    %cl,-0x19(%ebp)
  810153:	89 c2                	mov    %eax,%edx
  810155:	c1 fa 1f             	sar    $0x1f,%edx
  810158:	89 d1                	mov    %edx,%ecx
  81015a:	c1 e9 1b             	shr    $0x1b,%ecx
  81015d:	8d 14 08             	lea    (%eax,%ecx,1),%edx
  810160:	83 e2 1f             	and    $0x1f,%edx
  810163:	29 ca                	sub    %ecx,%edx
  810165:	0f b6 4d e7          	movzbl -0x19(%ebp),%ecx
  810169:	88 4c 13 08          	mov    %cl,0x8(%ebx,%edx,1)
		p->p_wpos++;
  81016d:	83 c0 01             	add    $0x1,%eax
  810170:	89 43 04             	mov    %eax,0x4(%ebx)
	for (i = 0; i < n; i++) {
  810173:	83 c7 01             	add    $0x1,%edi
  810176:	eb ac                	jmp    810124 <devpipe_write+0x1c>
	return i;
  810178:	89 f8                	mov    %edi,%eax
  81017a:	eb 05                	jmp    810181 <devpipe_write+0x79>
				return 0;
  81017c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  810181:	8d 65 f4             	lea    -0xc(%ebp),%esp
  810184:	5b                   	pop    %ebx
  810185:	5e                   	pop    %esi
  810186:	5f                   	pop    %edi
  810187:	5d                   	pop    %ebp
  810188:	c3                   	ret    

00810189 <devpipe_read>:
{
  810189:	55                   	push   %ebp
  81018a:	89 e5                	mov    %esp,%ebp
  81018c:	57                   	push   %edi
  81018d:	56                   	push   %esi
  81018e:	53                   	push   %ebx
  81018f:	83 ec 18             	sub    $0x18,%esp
  810192:	8b 7d 08             	mov    0x8(%ebp),%edi
	p = (struct Pipe*)fd2data(fd);
  810195:	57                   	push   %edi
  810196:	e8 70 f6 ff ff       	call   80f80b <fd2data>
  81019b:	89 c3                	mov    %eax,%ebx
	for (i = 0; i < n; i++) {
  81019d:	83 c4 10             	add    $0x10,%esp
  8101a0:	be 00 00 00 00       	mov    $0x0,%esi
  8101a5:	3b 75 10             	cmp    0x10(%ebp),%esi
  8101a8:	74 47                	je     8101f1 <devpipe_read+0x68>
		while (p->p_rpos == p->p_wpos) {
  8101aa:	8b 03                	mov    (%ebx),%eax
  8101ac:	3b 43 04             	cmp    0x4(%ebx),%eax
  8101af:	75 22                	jne    8101d3 <devpipe_read+0x4a>
			if (i > 0)
  8101b1:	85 f6                	test   %esi,%esi
  8101b3:	75 14                	jne    8101c9 <devpipe_read+0x40>
			if (_pipeisclosed(fd, p))
  8101b5:	89 da                	mov    %ebx,%edx
  8101b7:	89 f8                	mov    %edi,%eax
  8101b9:	e8 e5 fe ff ff       	call   8100a3 <_pipeisclosed>
  8101be:	85 c0                	test   %eax,%eax
  8101c0:	75 33                	jne    8101f5 <devpipe_read+0x6c>
			sys_yield();
  8101c2:	e8 de ef ff ff       	call   80f1a5 <sys_yield>
  8101c7:	eb e1                	jmp    8101aa <devpipe_read+0x21>
				return i;
  8101c9:	89 f0                	mov    %esi,%eax
}
  8101cb:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8101ce:	5b                   	pop    %ebx
  8101cf:	5e                   	pop    %esi
  8101d0:	5f                   	pop    %edi
  8101d1:	5d                   	pop    %ebp
  8101d2:	c3                   	ret    
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
  8101d3:	99                   	cltd   
  8101d4:	c1 ea 1b             	shr    $0x1b,%edx
  8101d7:	01 d0                	add    %edx,%eax
  8101d9:	83 e0 1f             	and    $0x1f,%eax
  8101dc:	29 d0                	sub    %edx,%eax
  8101de:	0f b6 44 03 08       	movzbl 0x8(%ebx,%eax,1),%eax
  8101e3:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  8101e6:	88 04 31             	mov    %al,(%ecx,%esi,1)
		p->p_rpos++;
  8101e9:	83 03 01             	addl   $0x1,(%ebx)
	for (i = 0; i < n; i++) {
  8101ec:	83 c6 01             	add    $0x1,%esi
  8101ef:	eb b4                	jmp    8101a5 <devpipe_read+0x1c>
	return i;
  8101f1:	89 f0                	mov    %esi,%eax
  8101f3:	eb d6                	jmp    8101cb <devpipe_read+0x42>
				return 0;
  8101f5:	b8 00 00 00 00       	mov    $0x0,%eax
  8101fa:	eb cf                	jmp    8101cb <devpipe_read+0x42>

008101fc <pipe>:
{
  8101fc:	55                   	push   %ebp
  8101fd:	89 e5                	mov    %esp,%ebp
  8101ff:	56                   	push   %esi
  810200:	53                   	push   %ebx
  810201:	83 ec 1c             	sub    $0x1c,%esp
	if ((r = fd_alloc(&fd0)) < 0
  810204:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810207:	50                   	push   %eax
  810208:	e8 15 f6 ff ff       	call   80f822 <fd_alloc>
  81020d:	89 c3                	mov    %eax,%ebx
  81020f:	83 c4 10             	add    $0x10,%esp
  810212:	85 c0                	test   %eax,%eax
  810214:	78 5b                	js     810271 <pipe+0x75>
	    || (r = sys_page_alloc(0, fd0, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  810216:	83 ec 04             	sub    $0x4,%esp
  810219:	68 07 04 00 00       	push   $0x407
  81021e:	ff 75 f4             	pushl  -0xc(%ebp)
  810221:	6a 00                	push   $0x0
  810223:	e8 9c ef ff ff       	call   80f1c4 <sys_page_alloc>
  810228:	89 c3                	mov    %eax,%ebx
  81022a:	83 c4 10             	add    $0x10,%esp
  81022d:	85 c0                	test   %eax,%eax
  81022f:	78 40                	js     810271 <pipe+0x75>
	if ((r = fd_alloc(&fd1)) < 0
  810231:	83 ec 0c             	sub    $0xc,%esp
  810234:	8d 45 f0             	lea    -0x10(%ebp),%eax
  810237:	50                   	push   %eax
  810238:	e8 e5 f5 ff ff       	call   80f822 <fd_alloc>
  81023d:	89 c3                	mov    %eax,%ebx
  81023f:	83 c4 10             	add    $0x10,%esp
  810242:	85 c0                	test   %eax,%eax
  810244:	78 1b                	js     810261 <pipe+0x65>
	    || (r = sys_page_alloc(0, fd1, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  810246:	83 ec 04             	sub    $0x4,%esp
  810249:	68 07 04 00 00       	push   $0x407
  81024e:	ff 75 f0             	pushl  -0x10(%ebp)
  810251:	6a 00                	push   $0x0
  810253:	e8 6c ef ff ff       	call   80f1c4 <sys_page_alloc>
  810258:	89 c3                	mov    %eax,%ebx
  81025a:	83 c4 10             	add    $0x10,%esp
  81025d:	85 c0                	test   %eax,%eax
  81025f:	79 19                	jns    81027a <pipe+0x7e>
	sys_page_unmap(0, fd0);
  810261:	83 ec 08             	sub    $0x8,%esp
  810264:	ff 75 f4             	pushl  -0xc(%ebp)
  810267:	6a 00                	push   $0x0
  810269:	e8 db ef ff ff       	call   80f249 <sys_page_unmap>
  81026e:	83 c4 10             	add    $0x10,%esp
}
  810271:	89 d8                	mov    %ebx,%eax
  810273:	8d 65 f8             	lea    -0x8(%ebp),%esp
  810276:	5b                   	pop    %ebx
  810277:	5e                   	pop    %esi
  810278:	5d                   	pop    %ebp
  810279:	c3                   	ret    
	va = fd2data(fd0);
  81027a:	83 ec 0c             	sub    $0xc,%esp
  81027d:	ff 75 f4             	pushl  -0xc(%ebp)
  810280:	e8 86 f5 ff ff       	call   80f80b <fd2data>
  810285:	89 c6                	mov    %eax,%esi
	if ((r = sys_page_alloc(0, va, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  810287:	83 c4 0c             	add    $0xc,%esp
  81028a:	68 07 04 00 00       	push   $0x407
  81028f:	50                   	push   %eax
  810290:	6a 00                	push   $0x0
  810292:	e8 2d ef ff ff       	call   80f1c4 <sys_page_alloc>
  810297:	89 c3                	mov    %eax,%ebx
  810299:	83 c4 10             	add    $0x10,%esp
  81029c:	85 c0                	test   %eax,%eax
  81029e:	0f 88 8c 00 00 00    	js     810330 <pipe+0x134>
	if ((r = sys_page_map(0, va, 0, fd2data(fd1), PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  8102a4:	83 ec 0c             	sub    $0xc,%esp
  8102a7:	ff 75 f0             	pushl  -0x10(%ebp)
  8102aa:	e8 5c f5 ff ff       	call   80f80b <fd2data>
  8102af:	c7 04 24 07 04 00 00 	movl   $0x407,(%esp)
  8102b6:	50                   	push   %eax
  8102b7:	6a 00                	push   $0x0
  8102b9:	56                   	push   %esi
  8102ba:	6a 00                	push   $0x0
  8102bc:	e8 46 ef ff ff       	call   80f207 <sys_page_map>
  8102c1:	89 c3                	mov    %eax,%ebx
  8102c3:	83 c4 20             	add    $0x20,%esp
  8102c6:	85 c0                	test   %eax,%eax
  8102c8:	78 58                	js     810322 <pipe+0x126>
	fd0->fd_dev_id = devpipe.dev_id;
  8102ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8102cd:	8b 15 08 43 81 00    	mov    0x814308,%edx
  8102d3:	89 10                	mov    %edx,(%eax)
	fd0->fd_omode = O_RDONLY;
  8102d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8102d8:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	fd1->fd_dev_id = devpipe.dev_id;
  8102df:	8b 45 f0             	mov    -0x10(%ebp),%eax
  8102e2:	8b 15 08 43 81 00    	mov    0x814308,%edx
  8102e8:	89 10                	mov    %edx,(%eax)
	fd1->fd_omode = O_WRONLY;
  8102ea:	8b 45 f0             	mov    -0x10(%ebp),%eax
  8102ed:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
	pfd[0] = fd2num(fd0);
  8102f4:	83 ec 0c             	sub    $0xc,%esp
  8102f7:	ff 75 f4             	pushl  -0xc(%ebp)
  8102fa:	e8 fc f4 ff ff       	call   80f7fb <fd2num>
  8102ff:	8b 4d 08             	mov    0x8(%ebp),%ecx
  810302:	89 01                	mov    %eax,(%ecx)
	pfd[1] = fd2num(fd1);
  810304:	83 c4 04             	add    $0x4,%esp
  810307:	ff 75 f0             	pushl  -0x10(%ebp)
  81030a:	e8 ec f4 ff ff       	call   80f7fb <fd2num>
  81030f:	8b 4d 08             	mov    0x8(%ebp),%ecx
  810312:	89 41 04             	mov    %eax,0x4(%ecx)
	return 0;
  810315:	83 c4 10             	add    $0x10,%esp
  810318:	bb 00 00 00 00       	mov    $0x0,%ebx
  81031d:	e9 4f ff ff ff       	jmp    810271 <pipe+0x75>
	sys_page_unmap(0, va);
  810322:	83 ec 08             	sub    $0x8,%esp
  810325:	56                   	push   %esi
  810326:	6a 00                	push   $0x0
  810328:	e8 1c ef ff ff       	call   80f249 <sys_page_unmap>
  81032d:	83 c4 10             	add    $0x10,%esp
	sys_page_unmap(0, fd1);
  810330:	83 ec 08             	sub    $0x8,%esp
  810333:	ff 75 f0             	pushl  -0x10(%ebp)
  810336:	6a 00                	push   $0x0
  810338:	e8 0c ef ff ff       	call   80f249 <sys_page_unmap>
  81033d:	83 c4 10             	add    $0x10,%esp
  810340:	e9 1c ff ff ff       	jmp    810261 <pipe+0x65>

00810345 <pipeisclosed>:
{
  810345:	55                   	push   %ebp
  810346:	89 e5                	mov    %esp,%ebp
  810348:	83 ec 20             	sub    $0x20,%esp
	if ((r = fd_lookup(fdnum, &fd)) < 0)
  81034b:	8d 45 f4             	lea    -0xc(%ebp),%eax
  81034e:	50                   	push   %eax
  81034f:	ff 75 08             	pushl  0x8(%ebp)
  810352:	e8 1a f5 ff ff       	call   80f871 <fd_lookup>
  810357:	83 c4 10             	add    $0x10,%esp
  81035a:	85 c0                	test   %eax,%eax
  81035c:	78 18                	js     810376 <pipeisclosed+0x31>
	p = (struct Pipe*) fd2data(fd);
  81035e:	83 ec 0c             	sub    $0xc,%esp
  810361:	ff 75 f4             	pushl  -0xc(%ebp)
  810364:	e8 a2 f4 ff ff       	call   80f80b <fd2data>
	return _pipeisclosed(fd, p);
  810369:	89 c2                	mov    %eax,%edx
  81036b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  81036e:	e8 30 fd ff ff       	call   8100a3 <_pipeisclosed>
  810373:	83 c4 10             	add    $0x10,%esp
}
  810376:	c9                   	leave  
  810377:	c3                   	ret    

00810378 <devsock_stat>:
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
}

static int
devsock_stat(struct Fd *fd, struct Stat *stat)
{
  810378:	55                   	push   %ebp
  810379:	89 e5                	mov    %esp,%ebp
  81037b:	83 ec 10             	sub    $0x10,%esp
	strcpy(stat->st_name, "<sock>");
  81037e:	68 82 39 81 00       	push   $0x813982
  810383:	ff 75 0c             	pushl  0xc(%ebp)
  810386:	e8 40 ea ff ff       	call   80edcb <strcpy>
	return 0;
}
  81038b:	b8 00 00 00 00       	mov    $0x0,%eax
  810390:	c9                   	leave  
  810391:	c3                   	ret    

00810392 <devsock_close>:
{
  810392:	55                   	push   %ebp
  810393:	89 e5                	mov    %esp,%ebp
  810395:	53                   	push   %ebx
  810396:	83 ec 10             	sub    $0x10,%esp
  810399:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (pageref(fd) == 1)
  81039c:	53                   	push   %ebx
  81039d:	e8 dd 08 00 00       	call   810c7f <pageref>
  8103a2:	83 c4 10             	add    $0x10,%esp
		return 0;
  8103a5:	ba 00 00 00 00       	mov    $0x0,%edx
	if (pageref(fd) == 1)
  8103aa:	83 f8 01             	cmp    $0x1,%eax
  8103ad:	74 07                	je     8103b6 <devsock_close+0x24>
}
  8103af:	89 d0                	mov    %edx,%eax
  8103b1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8103b4:	c9                   	leave  
  8103b5:	c3                   	ret    
		return nsipc_close(fd->fd_sock.sockid);
  8103b6:	83 ec 0c             	sub    $0xc,%esp
  8103b9:	ff 73 0c             	pushl  0xc(%ebx)
  8103bc:	e8 b7 02 00 00       	call   810678 <nsipc_close>
  8103c1:	89 c2                	mov    %eax,%edx
  8103c3:	83 c4 10             	add    $0x10,%esp
  8103c6:	eb e7                	jmp    8103af <devsock_close+0x1d>

008103c8 <devsock_write>:
{
  8103c8:	55                   	push   %ebp
  8103c9:	89 e5                	mov    %esp,%ebp
  8103cb:	83 ec 08             	sub    $0x8,%esp
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
  8103ce:	6a 00                	push   $0x0
  8103d0:	ff 75 10             	pushl  0x10(%ebp)
  8103d3:	ff 75 0c             	pushl  0xc(%ebp)
  8103d6:	8b 45 08             	mov    0x8(%ebp),%eax
  8103d9:	ff 70 0c             	pushl  0xc(%eax)
  8103dc:	e8 74 03 00 00       	call   810755 <nsipc_send>
}
  8103e1:	c9                   	leave  
  8103e2:	c3                   	ret    

008103e3 <devsock_read>:
{
  8103e3:	55                   	push   %ebp
  8103e4:	89 e5                	mov    %esp,%ebp
  8103e6:	83 ec 08             	sub    $0x8,%esp
	return nsipc_recv(fd->fd_sock.sockid, buf, n, 0);
  8103e9:	6a 00                	push   $0x0
  8103eb:	ff 75 10             	pushl  0x10(%ebp)
  8103ee:	ff 75 0c             	pushl  0xc(%ebp)
  8103f1:	8b 45 08             	mov    0x8(%ebp),%eax
  8103f4:	ff 70 0c             	pushl  0xc(%eax)
  8103f7:	e8 ed 02 00 00       	call   8106e9 <nsipc_recv>
}
  8103fc:	c9                   	leave  
  8103fd:	c3                   	ret    

008103fe <fd2sockid>:
{
  8103fe:	55                   	push   %ebp
  8103ff:	89 e5                	mov    %esp,%ebp
  810401:	83 ec 20             	sub    $0x20,%esp
	if ((r = fd_lookup(fd, &sfd)) < 0)
  810404:	8d 55 f4             	lea    -0xc(%ebp),%edx
  810407:	52                   	push   %edx
  810408:	50                   	push   %eax
  810409:	e8 63 f4 ff ff       	call   80f871 <fd_lookup>
  81040e:	83 c4 10             	add    $0x10,%esp
  810411:	85 c0                	test   %eax,%eax
  810413:	78 10                	js     810425 <fd2sockid+0x27>
	if (sfd->fd_dev_id != devsock.dev_id)
  810415:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810418:	8b 0d 24 43 81 00    	mov    0x814324,%ecx
  81041e:	39 08                	cmp    %ecx,(%eax)
  810420:	75 05                	jne    810427 <fd2sockid+0x29>
	return sfd->fd_sock.sockid;
  810422:	8b 40 0c             	mov    0xc(%eax),%eax
}
  810425:	c9                   	leave  
  810426:	c3                   	ret    
		return -E_NOT_SUPP;
  810427:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  81042c:	eb f7                	jmp    810425 <fd2sockid+0x27>

0081042e <alloc_sockfd>:
{
  81042e:	55                   	push   %ebp
  81042f:	89 e5                	mov    %esp,%ebp
  810431:	56                   	push   %esi
  810432:	53                   	push   %ebx
  810433:	83 ec 1c             	sub    $0x1c,%esp
  810436:	89 c6                	mov    %eax,%esi
	if ((r = fd_alloc(&sfd)) < 0
  810438:	8d 45 f4             	lea    -0xc(%ebp),%eax
  81043b:	50                   	push   %eax
  81043c:	e8 e1 f3 ff ff       	call   80f822 <fd_alloc>
  810441:	89 c3                	mov    %eax,%ebx
  810443:	83 c4 10             	add    $0x10,%esp
  810446:	85 c0                	test   %eax,%eax
  810448:	78 43                	js     81048d <alloc_sockfd+0x5f>
	    || (r = sys_page_alloc(0, sfd, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0) {
  81044a:	83 ec 04             	sub    $0x4,%esp
  81044d:	68 07 04 00 00       	push   $0x407
  810452:	ff 75 f4             	pushl  -0xc(%ebp)
  810455:	6a 00                	push   $0x0
  810457:	e8 68 ed ff ff       	call   80f1c4 <sys_page_alloc>
  81045c:	89 c3                	mov    %eax,%ebx
  81045e:	83 c4 10             	add    $0x10,%esp
  810461:	85 c0                	test   %eax,%eax
  810463:	78 28                	js     81048d <alloc_sockfd+0x5f>
	sfd->fd_dev_id = devsock.dev_id;
  810465:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810468:	8b 15 24 43 81 00    	mov    0x814324,%edx
  81046e:	89 10                	mov    %edx,(%eax)
	sfd->fd_omode = O_RDWR;
  810470:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810473:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
	sfd->fd_sock.sockid = sockid;
  81047a:	89 70 0c             	mov    %esi,0xc(%eax)
	return fd2num(sfd);
  81047d:	83 ec 0c             	sub    $0xc,%esp
  810480:	50                   	push   %eax
  810481:	e8 75 f3 ff ff       	call   80f7fb <fd2num>
  810486:	89 c3                	mov    %eax,%ebx
  810488:	83 c4 10             	add    $0x10,%esp
  81048b:	eb 0c                	jmp    810499 <alloc_sockfd+0x6b>
		nsipc_close(sockid);
  81048d:	83 ec 0c             	sub    $0xc,%esp
  810490:	56                   	push   %esi
  810491:	e8 e2 01 00 00       	call   810678 <nsipc_close>
		return r;
  810496:	83 c4 10             	add    $0x10,%esp
}
  810499:	89 d8                	mov    %ebx,%eax
  81049b:	8d 65 f8             	lea    -0x8(%ebp),%esp
  81049e:	5b                   	pop    %ebx
  81049f:	5e                   	pop    %esi
  8104a0:	5d                   	pop    %ebp
  8104a1:	c3                   	ret    

008104a2 <accept>:
{
  8104a2:	55                   	push   %ebp
  8104a3:	89 e5                	mov    %esp,%ebp
  8104a5:	83 ec 08             	sub    $0x8,%esp
	if ((r = fd2sockid(s)) < 0)
  8104a8:	8b 45 08             	mov    0x8(%ebp),%eax
  8104ab:	e8 4e ff ff ff       	call   8103fe <fd2sockid>
  8104b0:	85 c0                	test   %eax,%eax
  8104b2:	78 1b                	js     8104cf <accept+0x2d>
	if ((r = nsipc_accept(r, addr, addrlen)) < 0)
  8104b4:	83 ec 04             	sub    $0x4,%esp
  8104b7:	ff 75 10             	pushl  0x10(%ebp)
  8104ba:	ff 75 0c             	pushl  0xc(%ebp)
  8104bd:	50                   	push   %eax
  8104be:	e8 0e 01 00 00       	call   8105d1 <nsipc_accept>
  8104c3:	83 c4 10             	add    $0x10,%esp
  8104c6:	85 c0                	test   %eax,%eax
  8104c8:	78 05                	js     8104cf <accept+0x2d>
	return alloc_sockfd(r);
  8104ca:	e8 5f ff ff ff       	call   81042e <alloc_sockfd>
}
  8104cf:	c9                   	leave  
  8104d0:	c3                   	ret    

008104d1 <bind>:
{
  8104d1:	55                   	push   %ebp
  8104d2:	89 e5                	mov    %esp,%ebp
  8104d4:	83 ec 08             	sub    $0x8,%esp
	if ((r = fd2sockid(s)) < 0)
  8104d7:	8b 45 08             	mov    0x8(%ebp),%eax
  8104da:	e8 1f ff ff ff       	call   8103fe <fd2sockid>
  8104df:	85 c0                	test   %eax,%eax
  8104e1:	78 12                	js     8104f5 <bind+0x24>
	return nsipc_bind(r, name, namelen);
  8104e3:	83 ec 04             	sub    $0x4,%esp
  8104e6:	ff 75 10             	pushl  0x10(%ebp)
  8104e9:	ff 75 0c             	pushl  0xc(%ebp)
  8104ec:	50                   	push   %eax
  8104ed:	e8 2f 01 00 00       	call   810621 <nsipc_bind>
  8104f2:	83 c4 10             	add    $0x10,%esp
}
  8104f5:	c9                   	leave  
  8104f6:	c3                   	ret    

008104f7 <shutdown>:
{
  8104f7:	55                   	push   %ebp
  8104f8:	89 e5                	mov    %esp,%ebp
  8104fa:	83 ec 08             	sub    $0x8,%esp
	if ((r = fd2sockid(s)) < 0)
  8104fd:	8b 45 08             	mov    0x8(%ebp),%eax
  810500:	e8 f9 fe ff ff       	call   8103fe <fd2sockid>
  810505:	85 c0                	test   %eax,%eax
  810507:	78 0f                	js     810518 <shutdown+0x21>
	return nsipc_shutdown(r, how);
  810509:	83 ec 08             	sub    $0x8,%esp
  81050c:	ff 75 0c             	pushl  0xc(%ebp)
  81050f:	50                   	push   %eax
  810510:	e8 41 01 00 00       	call   810656 <nsipc_shutdown>
  810515:	83 c4 10             	add    $0x10,%esp
}
  810518:	c9                   	leave  
  810519:	c3                   	ret    

0081051a <connect>:
{
  81051a:	55                   	push   %ebp
  81051b:	89 e5                	mov    %esp,%ebp
  81051d:	83 ec 08             	sub    $0x8,%esp
	if ((r = fd2sockid(s)) < 0)
  810520:	8b 45 08             	mov    0x8(%ebp),%eax
  810523:	e8 d6 fe ff ff       	call   8103fe <fd2sockid>
  810528:	85 c0                	test   %eax,%eax
  81052a:	78 12                	js     81053e <connect+0x24>
	return nsipc_connect(r, name, namelen);
  81052c:	83 ec 04             	sub    $0x4,%esp
  81052f:	ff 75 10             	pushl  0x10(%ebp)
  810532:	ff 75 0c             	pushl  0xc(%ebp)
  810535:	50                   	push   %eax
  810536:	e8 57 01 00 00       	call   810692 <nsipc_connect>
  81053b:	83 c4 10             	add    $0x10,%esp
}
  81053e:	c9                   	leave  
  81053f:	c3                   	ret    

00810540 <listen>:
{
  810540:	55                   	push   %ebp
  810541:	89 e5                	mov    %esp,%ebp
  810543:	83 ec 08             	sub    $0x8,%esp
	if ((r = fd2sockid(s)) < 0)
  810546:	8b 45 08             	mov    0x8(%ebp),%eax
  810549:	e8 b0 fe ff ff       	call   8103fe <fd2sockid>
  81054e:	85 c0                	test   %eax,%eax
  810550:	78 0f                	js     810561 <listen+0x21>
	return nsipc_listen(r, backlog);
  810552:	83 ec 08             	sub    $0x8,%esp
  810555:	ff 75 0c             	pushl  0xc(%ebp)
  810558:	50                   	push   %eax
  810559:	e8 69 01 00 00       	call   8106c7 <nsipc_listen>
  81055e:	83 c4 10             	add    $0x10,%esp
}
  810561:	c9                   	leave  
  810562:	c3                   	ret    

00810563 <socket>:

int
socket(int domain, int type, int protocol)
{
  810563:	55                   	push   %ebp
  810564:	89 e5                	mov    %esp,%ebp
  810566:	83 ec 0c             	sub    $0xc,%esp
	int r;
	if ((r = nsipc_socket(domain, type, protocol)) < 0)
  810569:	ff 75 10             	pushl  0x10(%ebp)
  81056c:	ff 75 0c             	pushl  0xc(%ebp)
  81056f:	ff 75 08             	pushl  0x8(%ebp)
  810572:	e8 3c 02 00 00       	call   8107b3 <nsipc_socket>
  810577:	83 c4 10             	add    $0x10,%esp
  81057a:	85 c0                	test   %eax,%eax
  81057c:	78 05                	js     810583 <socket+0x20>
		return r;
	return alloc_sockfd(r);
  81057e:	e8 ab fe ff ff       	call   81042e <alloc_sockfd>
}
  810583:	c9                   	leave  
  810584:	c3                   	ret    

00810585 <nsipc>:
// may be written back to nsipcbuf.
// type: request code, passed as the simple integer IPC value.
// Returns 0 if successful, < 0 on failure.
static int
nsipc(unsigned type)
{
  810585:	55                   	push   %ebp
  810586:	89 e5                	mov    %esp,%ebp
  810588:	53                   	push   %ebx
  810589:	83 ec 04             	sub    $0x4,%esp
  81058c:	89 c3                	mov    %eax,%ebx
	static envid_t nsenv;
	if (nsenv == 0)
  81058e:	83 3d d0 b1 b3 00 00 	cmpl   $0x0,0xb3b1d0
  810595:	74 26                	je     8105bd <nsipc+0x38>
	static_assert(sizeof(nsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] nsipc %d\n", thisenv->env_id, type);

	ipc_send(nsenv, type, &nsipcbuf, PTE_P|PTE_W|PTE_U);
  810597:	6a 07                	push   $0x7
  810599:	68 00 d0 b3 00       	push   $0xb3d000
  81059e:	53                   	push   %ebx
  81059f:	ff 35 d0 b1 b3 00    	pushl  0xb3b1d0
  8105a5:	e8 bf f1 ff ff       	call   80f769 <ipc_send>
	return ipc_recv(NULL, NULL, NULL);
  8105aa:	83 c4 0c             	add    $0xc,%esp
  8105ad:	6a 00                	push   $0x0
  8105af:	6a 00                	push   $0x0
  8105b1:	6a 00                	push   $0x0
  8105b3:	e8 48 f1 ff ff       	call   80f700 <ipc_recv>
}
  8105b8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8105bb:	c9                   	leave  
  8105bc:	c3                   	ret    
		nsenv = ipc_find_env(ENV_TYPE_NS);
  8105bd:	83 ec 0c             	sub    $0xc,%esp
  8105c0:	6a 02                	push   $0x2
  8105c2:	e8 fb f1 ff ff       	call   80f7c2 <ipc_find_env>
  8105c7:	a3 d0 b1 b3 00       	mov    %eax,0xb3b1d0
  8105cc:	83 c4 10             	add    $0x10,%esp
  8105cf:	eb c6                	jmp    810597 <nsipc+0x12>

008105d1 <nsipc_accept>:

int
nsipc_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  8105d1:	55                   	push   %ebp
  8105d2:	89 e5                	mov    %esp,%ebp
  8105d4:	56                   	push   %esi
  8105d5:	53                   	push   %ebx
  8105d6:	8b 75 10             	mov    0x10(%ebp),%esi
	int r;

	nsipcbuf.accept.req_s = s;
  8105d9:	8b 45 08             	mov    0x8(%ebp),%eax
  8105dc:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.accept.req_addrlen = *addrlen;
  8105e1:	8b 06                	mov    (%esi),%eax
  8105e3:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	if ((r = nsipc(NSREQ_ACCEPT)) >= 0) {
  8105e8:	b8 01 00 00 00       	mov    $0x1,%eax
  8105ed:	e8 93 ff ff ff       	call   810585 <nsipc>
  8105f2:	89 c3                	mov    %eax,%ebx
  8105f4:	85 c0                	test   %eax,%eax
  8105f6:	78 20                	js     810618 <nsipc_accept+0x47>
		struct Nsret_accept *ret = &nsipcbuf.acceptRet;
		memmove(addr, &ret->ret_addr, ret->ret_addrlen);
  8105f8:	83 ec 04             	sub    $0x4,%esp
  8105fb:	ff 35 10 d0 b3 00    	pushl  0xb3d010
  810601:	68 00 d0 b3 00       	push   $0xb3d000
  810606:	ff 75 0c             	pushl  0xc(%ebp)
  810609:	e8 4b e9 ff ff       	call   80ef59 <memmove>
		*addrlen = ret->ret_addrlen;
  81060e:	a1 10 d0 b3 00       	mov    0xb3d010,%eax
  810613:	89 06                	mov    %eax,(%esi)
  810615:	83 c4 10             	add    $0x10,%esp
	}
	return r;
}
  810618:	89 d8                	mov    %ebx,%eax
  81061a:	8d 65 f8             	lea    -0x8(%ebp),%esp
  81061d:	5b                   	pop    %ebx
  81061e:	5e                   	pop    %esi
  81061f:	5d                   	pop    %ebp
  810620:	c3                   	ret    

00810621 <nsipc_bind>:

int
nsipc_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  810621:	55                   	push   %ebp
  810622:	89 e5                	mov    %esp,%ebp
  810624:	53                   	push   %ebx
  810625:	83 ec 08             	sub    $0x8,%esp
  810628:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.bind.req_s = s;
  81062b:	8b 45 08             	mov    0x8(%ebp),%eax
  81062e:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	memmove(&nsipcbuf.bind.req_name, name, namelen);
  810633:	53                   	push   %ebx
  810634:	ff 75 0c             	pushl  0xc(%ebp)
  810637:	68 04 d0 b3 00       	push   $0xb3d004
  81063c:	e8 18 e9 ff ff       	call   80ef59 <memmove>
	nsipcbuf.bind.req_namelen = namelen;
  810641:	89 1d 14 d0 b3 00    	mov    %ebx,0xb3d014
	return nsipc(NSREQ_BIND);
  810647:	b8 02 00 00 00       	mov    $0x2,%eax
  81064c:	e8 34 ff ff ff       	call   810585 <nsipc>
}
  810651:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  810654:	c9                   	leave  
  810655:	c3                   	ret    

00810656 <nsipc_shutdown>:

int
nsipc_shutdown(int s, int how)
{
  810656:	55                   	push   %ebp
  810657:	89 e5                	mov    %esp,%ebp
  810659:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.shutdown.req_s = s;
  81065c:	8b 45 08             	mov    0x8(%ebp),%eax
  81065f:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.shutdown.req_how = how;
  810664:	8b 45 0c             	mov    0xc(%ebp),%eax
  810667:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	return nsipc(NSREQ_SHUTDOWN);
  81066c:	b8 03 00 00 00       	mov    $0x3,%eax
  810671:	e8 0f ff ff ff       	call   810585 <nsipc>
}
  810676:	c9                   	leave  
  810677:	c3                   	ret    

00810678 <nsipc_close>:

int
nsipc_close(int s)
{
  810678:	55                   	push   %ebp
  810679:	89 e5                	mov    %esp,%ebp
  81067b:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.close.req_s = s;
  81067e:	8b 45 08             	mov    0x8(%ebp),%eax
  810681:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	return nsipc(NSREQ_CLOSE);
  810686:	b8 04 00 00 00       	mov    $0x4,%eax
  81068b:	e8 f5 fe ff ff       	call   810585 <nsipc>
}
  810690:	c9                   	leave  
  810691:	c3                   	ret    

00810692 <nsipc_connect>:

int
nsipc_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  810692:	55                   	push   %ebp
  810693:	89 e5                	mov    %esp,%ebp
  810695:	53                   	push   %ebx
  810696:	83 ec 08             	sub    $0x8,%esp
  810699:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.connect.req_s = s;
  81069c:	8b 45 08             	mov    0x8(%ebp),%eax
  81069f:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	memmove(&nsipcbuf.connect.req_name, name, namelen);
  8106a4:	53                   	push   %ebx
  8106a5:	ff 75 0c             	pushl  0xc(%ebp)
  8106a8:	68 04 d0 b3 00       	push   $0xb3d004
  8106ad:	e8 a7 e8 ff ff       	call   80ef59 <memmove>
	nsipcbuf.connect.req_namelen = namelen;
  8106b2:	89 1d 14 d0 b3 00    	mov    %ebx,0xb3d014
	return nsipc(NSREQ_CONNECT);
  8106b8:	b8 05 00 00 00       	mov    $0x5,%eax
  8106bd:	e8 c3 fe ff ff       	call   810585 <nsipc>
}
  8106c2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8106c5:	c9                   	leave  
  8106c6:	c3                   	ret    

008106c7 <nsipc_listen>:

int
nsipc_listen(int s, int backlog)
{
  8106c7:	55                   	push   %ebp
  8106c8:	89 e5                	mov    %esp,%ebp
  8106ca:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.listen.req_s = s;
  8106cd:	8b 45 08             	mov    0x8(%ebp),%eax
  8106d0:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.listen.req_backlog = backlog;
  8106d5:	8b 45 0c             	mov    0xc(%ebp),%eax
  8106d8:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	return nsipc(NSREQ_LISTEN);
  8106dd:	b8 06 00 00 00       	mov    $0x6,%eax
  8106e2:	e8 9e fe ff ff       	call   810585 <nsipc>
}
  8106e7:	c9                   	leave  
  8106e8:	c3                   	ret    

008106e9 <nsipc_recv>:

int
nsipc_recv(int s, void *mem, int len, unsigned int flags)
{
  8106e9:	55                   	push   %ebp
  8106ea:	89 e5                	mov    %esp,%ebp
  8106ec:	56                   	push   %esi
  8106ed:	53                   	push   %ebx
  8106ee:	8b 75 10             	mov    0x10(%ebp),%esi
	int r;

	nsipcbuf.recv.req_s = s;
  8106f1:	8b 45 08             	mov    0x8(%ebp),%eax
  8106f4:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.recv.req_len = len;
  8106f9:	89 35 04 d0 b3 00    	mov    %esi,0xb3d004
	nsipcbuf.recv.req_flags = flags;
  8106ff:	8b 45 14             	mov    0x14(%ebp),%eax
  810702:	a3 08 d0 b3 00       	mov    %eax,0xb3d008

	if ((r = nsipc(NSREQ_RECV)) >= 0) {
  810707:	b8 07 00 00 00       	mov    $0x7,%eax
  81070c:	e8 74 fe ff ff       	call   810585 <nsipc>
  810711:	89 c3                	mov    %eax,%ebx
  810713:	85 c0                	test   %eax,%eax
  810715:	78 1f                	js     810736 <nsipc_recv+0x4d>
		assert(r < 1600 && r <= len);
  810717:	3d 3f 06 00 00       	cmp    $0x63f,%eax
  81071c:	7f 21                	jg     81073f <nsipc_recv+0x56>
  81071e:	39 c6                	cmp    %eax,%esi
  810720:	7c 1d                	jl     81073f <nsipc_recv+0x56>
		memmove(mem, nsipcbuf.recvRet.ret_buf, r);
  810722:	83 ec 04             	sub    $0x4,%esp
  810725:	50                   	push   %eax
  810726:	68 00 d0 b3 00       	push   $0xb3d000
  81072b:	ff 75 0c             	pushl  0xc(%ebp)
  81072e:	e8 26 e8 ff ff       	call   80ef59 <memmove>
  810733:	83 c4 10             	add    $0x10,%esp
	}

	return r;
}
  810736:	89 d8                	mov    %ebx,%eax
  810738:	8d 65 f8             	lea    -0x8(%ebp),%esp
  81073b:	5b                   	pop    %ebx
  81073c:	5e                   	pop    %esi
  81073d:	5d                   	pop    %ebp
  81073e:	c3                   	ret    
		assert(r < 1600 && r <= len);
  81073f:	68 8e 39 81 00       	push   $0x81398e
  810744:	68 a7 26 81 00       	push   $0x8126a7
  810749:	6a 62                	push   $0x62
  81074b:	68 a3 39 81 00       	push   $0x8139a3
  810750:	e8 fe de ff ff       	call   80e653 <_panic>

00810755 <nsipc_send>:

int
nsipc_send(int s, const void *buf, int size, unsigned int flags)
{
  810755:	55                   	push   %ebp
  810756:	89 e5                	mov    %esp,%ebp
  810758:	53                   	push   %ebx
  810759:	83 ec 04             	sub    $0x4,%esp
  81075c:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.send.req_s = s;
  81075f:	8b 45 08             	mov    0x8(%ebp),%eax
  810762:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	assert(size < 1600);
  810767:	81 fb 3f 06 00 00    	cmp    $0x63f,%ebx
  81076d:	7f 2e                	jg     81079d <nsipc_send+0x48>
	memmove(&nsipcbuf.send.req_buf, buf, size);
  81076f:	83 ec 04             	sub    $0x4,%esp
  810772:	53                   	push   %ebx
  810773:	ff 75 0c             	pushl  0xc(%ebp)
  810776:	68 0c d0 b3 00       	push   $0xb3d00c
  81077b:	e8 d9 e7 ff ff       	call   80ef59 <memmove>
	nsipcbuf.send.req_size = size;
  810780:	89 1d 04 d0 b3 00    	mov    %ebx,0xb3d004
	nsipcbuf.send.req_flags = flags;
  810786:	8b 45 14             	mov    0x14(%ebp),%eax
  810789:	a3 08 d0 b3 00       	mov    %eax,0xb3d008
	return nsipc(NSREQ_SEND);
  81078e:	b8 08 00 00 00       	mov    $0x8,%eax
  810793:	e8 ed fd ff ff       	call   810585 <nsipc>
}
  810798:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  81079b:	c9                   	leave  
  81079c:	c3                   	ret    
	assert(size < 1600);
  81079d:	68 af 39 81 00       	push   $0x8139af
  8107a2:	68 a7 26 81 00       	push   $0x8126a7
  8107a7:	6a 6d                	push   $0x6d
  8107a9:	68 a3 39 81 00       	push   $0x8139a3
  8107ae:	e8 a0 de ff ff       	call   80e653 <_panic>

008107b3 <nsipc_socket>:

int
nsipc_socket(int domain, int type, int protocol)
{
  8107b3:	55                   	push   %ebp
  8107b4:	89 e5                	mov    %esp,%ebp
  8107b6:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.socket.req_domain = domain;
  8107b9:	8b 45 08             	mov    0x8(%ebp),%eax
  8107bc:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.socket.req_type = type;
  8107c1:	8b 45 0c             	mov    0xc(%ebp),%eax
  8107c4:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	nsipcbuf.socket.req_protocol = protocol;
  8107c9:	8b 45 10             	mov    0x10(%ebp),%eax
  8107cc:	a3 08 d0 b3 00       	mov    %eax,0xb3d008
	return nsipc(NSREQ_SOCKET);
  8107d1:	b8 09 00 00 00       	mov    $0x9,%eax
  8107d6:	e8 aa fd ff ff       	call   810585 <nsipc>
}
  8107db:	c9                   	leave  
  8107dc:	c3                   	ret    

008107dd <free>:
	return v;
}

void
free(void *v)
{
  8107dd:	55                   	push   %ebp
  8107de:	89 e5                	mov    %esp,%ebp
  8107e0:	53                   	push   %ebx
  8107e1:	83 ec 04             	sub    $0x4,%esp
  8107e4:	8b 5d 08             	mov    0x8(%ebp),%ebx
	uint8_t *c;
	uint32_t *ref;

	if (v == 0)
  8107e7:	85 db                	test   %ebx,%ebx
  8107e9:	0f 84 87 00 00 00    	je     810876 <free+0x99>
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);
  8107ef:	8d 83 00 00 00 f8    	lea    -0x8000000(%ebx),%eax
  8107f5:	3d ff ff ff 07       	cmp    $0x7ffffff,%eax
  8107fa:	77 51                	ja     81084d <free+0x70>

	c = ROUNDDOWN(v, PGSIZE);
  8107fc:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx

	while (uvpt[PGNUM(c)] & PTE_CONTINUED) {
  810802:	89 d8                	mov    %ebx,%eax
  810804:	c1 e8 0c             	shr    $0xc,%eax
  810807:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  81080e:	f6 c4 02             	test   $0x2,%ah
  810811:	74 50                	je     810863 <free+0x86>
		sys_page_unmap(0, c);
  810813:	83 ec 08             	sub    $0x8,%esp
  810816:	53                   	push   %ebx
  810817:	6a 00                	push   $0x0
  810819:	e8 2b ea ff ff       	call   80f249 <sys_page_unmap>
		c += PGSIZE;
  81081e:	81 c3 00 10 00 00    	add    $0x1000,%ebx
		assert(mbegin <= c && c < mend);
  810824:	8d 83 00 00 00 f8    	lea    -0x8000000(%ebx),%eax
  81082a:	83 c4 10             	add    $0x10,%esp
  81082d:	3d ff ff ff 07       	cmp    $0x7ffffff,%eax
  810832:	76 ce                	jbe    810802 <free+0x25>
  810834:	68 f9 39 81 00       	push   $0x8139f9
  810839:	68 a7 26 81 00       	push   $0x8126a7
  81083e:	68 81 00 00 00       	push   $0x81
  810843:	68 ec 39 81 00       	push   $0x8139ec
  810848:	e8 06 de ff ff       	call   80e653 <_panic>
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);
  81084d:	68 bc 39 81 00       	push   $0x8139bc
  810852:	68 a7 26 81 00       	push   $0x8126a7
  810857:	6a 7a                	push   $0x7a
  810859:	68 ec 39 81 00       	push   $0x8139ec
  81085e:	e8 f0 dd ff ff       	call   80e653 <_panic>
	/*
	 * c is just a piece of this page, so dec the ref count
	 * and maybe free the page.
	 */
	ref = (uint32_t*) (c + PGSIZE - 4);
	if (--(*ref) == 0)
  810863:	8b 83 fc 0f 00 00    	mov    0xffc(%ebx),%eax
  810869:	83 e8 01             	sub    $0x1,%eax
  81086c:	89 83 fc 0f 00 00    	mov    %eax,0xffc(%ebx)
  810872:	85 c0                	test   %eax,%eax
  810874:	74 05                	je     81087b <free+0x9e>
		sys_page_unmap(0, c);
}
  810876:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  810879:	c9                   	leave  
  81087a:	c3                   	ret    
		sys_page_unmap(0, c);
  81087b:	83 ec 08             	sub    $0x8,%esp
  81087e:	53                   	push   %ebx
  81087f:	6a 00                	push   $0x0
  810881:	e8 c3 e9 ff ff       	call   80f249 <sys_page_unmap>
  810886:	83 c4 10             	add    $0x10,%esp
  810889:	eb eb                	jmp    810876 <free+0x99>

0081088b <malloc>:
{
  81088b:	55                   	push   %ebp
  81088c:	89 e5                	mov    %esp,%ebp
  81088e:	57                   	push   %edi
  81088f:	56                   	push   %esi
  810890:	53                   	push   %ebx
  810891:	83 ec 1c             	sub    $0x1c,%esp
	if (mptr == 0)
  810894:	a1 d4 b1 b3 00       	mov    0xb3b1d4,%eax
  810899:	85 c0                	test   %eax,%eax
  81089b:	74 55                	je     8108f2 <malloc+0x67>
	n = ROUNDUP(n, 4);
  81089d:	8b 7d 08             	mov    0x8(%ebp),%edi
  8108a0:	8d 57 03             	lea    0x3(%edi),%edx
  8108a3:	83 e2 fc             	and    $0xfffffffc,%edx
  8108a6:	89 d7                	mov    %edx,%edi
  8108a8:	89 55 dc             	mov    %edx,-0x24(%ebp)
	if (n >= MAXMALLOC)
  8108ab:	81 fa ff ff 0f 00    	cmp    $0xfffff,%edx
  8108b1:	0f 87 a5 01 00 00    	ja     810a5c <malloc+0x1d1>
	if ((uintptr_t) mptr % PGSIZE){
  8108b7:	89 c2                	mov    %eax,%edx
  8108b9:	a9 ff 0f 00 00       	test   $0xfff,%eax
  8108be:	74 53                	je     810913 <malloc+0x88>
		if ((uintptr_t) mptr / PGSIZE == (uintptr_t) (mptr + n - 1 + 4) / PGSIZE) {
  8108c0:	89 c3                	mov    %eax,%ebx
  8108c2:	c1 eb 0c             	shr    $0xc,%ebx
  8108c5:	8d 4c 38 03          	lea    0x3(%eax,%edi,1),%ecx
  8108c9:	c1 e9 0c             	shr    $0xc,%ecx
  8108cc:	39 cb                	cmp    %ecx,%ebx
  8108ce:	74 61                	je     810931 <malloc+0xa6>
		free(mptr);	/* drop reference to this page */
  8108d0:	83 ec 0c             	sub    $0xc,%esp
  8108d3:	50                   	push   %eax
  8108d4:	e8 04 ff ff ff       	call   8107dd <free>
		mptr = ROUNDDOWN(mptr + PGSIZE, PGSIZE);
  8108d9:	a1 d4 b1 b3 00       	mov    0xb3b1d4,%eax
  8108de:	05 00 10 00 00       	add    $0x1000,%eax
  8108e3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  8108e8:	a3 d4 b1 b3 00       	mov    %eax,0xb3b1d4
  8108ed:	83 c4 10             	add    $0x10,%esp
  8108f0:	eb 21                	jmp    810913 <malloc+0x88>
		mptr = mbegin;
  8108f2:	c7 05 d4 b1 b3 00 00 	movl   $0x8000000,0xb3b1d4
  8108f9:	00 00 08 
	n = ROUNDUP(n, 4);
  8108fc:	8b 45 08             	mov    0x8(%ebp),%eax
  8108ff:	83 c0 03             	add    $0x3,%eax
  810902:	83 e0 fc             	and    $0xfffffffc,%eax
  810905:	89 45 dc             	mov    %eax,-0x24(%ebp)
	if (n >= MAXMALLOC)
  810908:	3d ff ff 0f 00       	cmp    $0xfffff,%eax
  81090d:	0f 87 42 01 00 00    	ja     810a55 <malloc+0x1ca>
  810913:	8b 35 d4 b1 b3 00    	mov    0xb3b1d4,%esi
{
  810919:	c7 45 d8 02 00 00 00 	movl   $0x2,-0x28(%ebp)
  810920:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
		if (isfree(mptr, n + 4))
  810924:	8b 45 dc             	mov    -0x24(%ebp),%eax
  810927:	8d 58 04             	lea    0x4(%eax),%ebx
  81092a:	bf 01 00 00 00       	mov    $0x1,%edi
  81092f:	eb 66                	jmp    810997 <malloc+0x10c>
		ref = (uint32_t*) (ROUNDUP(mptr, PGSIZE) - 4);
  810931:	81 c2 ff 0f 00 00    	add    $0xfff,%edx
  810937:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
			(*ref)++;
  81093d:	83 42 fc 01          	addl   $0x1,-0x4(%edx)
			mptr += n;
  810941:	01 c7                	add    %eax,%edi
  810943:	89 3d d4 b1 b3 00    	mov    %edi,0xb3b1d4
			return v;
  810949:	e9 ff 00 00 00       	jmp    810a4d <malloc+0x1c2>
	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  81094e:	05 00 10 00 00       	add    $0x1000,%eax
  810953:	39 c8                	cmp    %ecx,%eax
  810955:	0f 83 90 00 00 00    	jae    8109eb <malloc+0x160>
		if (va >= (uintptr_t) mend
  81095b:	3d ff ff ff 0f       	cmp    $0xfffffff,%eax
  810960:	77 22                	ja     810984 <malloc+0xf9>
		    || ((uvpd[PDX(va)] & PTE_P) && (uvpt[PGNUM(va)] & PTE_P)))
  810962:	89 c2                	mov    %eax,%edx
  810964:	c1 ea 16             	shr    $0x16,%edx
  810967:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  81096e:	f6 c2 01             	test   $0x1,%dl
  810971:	74 db                	je     81094e <malloc+0xc3>
  810973:	89 c2                	mov    %eax,%edx
  810975:	c1 ea 0c             	shr    $0xc,%edx
  810978:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  81097f:	f6 c2 01             	test   $0x1,%dl
  810982:	74 ca                	je     81094e <malloc+0xc3>
  810984:	81 c6 00 10 00 00    	add    $0x1000,%esi
  81098a:	89 f8                	mov    %edi,%eax
  81098c:	88 45 e7             	mov    %al,-0x19(%ebp)
		if (mptr == mend) {
  81098f:	81 fe 00 00 00 10    	cmp    $0x10000000,%esi
  810995:	74 0a                	je     8109a1 <malloc+0x116>
  810997:	89 75 e0             	mov    %esi,-0x20(%ebp)
  81099a:	8d 0c 33             	lea    (%ebx,%esi,1),%ecx
	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  81099d:	89 f0                	mov    %esi,%eax
  81099f:	eb b2                	jmp    810953 <malloc+0xc8>
			mptr = mbegin;
  8109a1:	be 00 00 00 08       	mov    $0x8000000,%esi
  8109a6:	c6 45 e7 01          	movb   $0x1,-0x19(%ebp)
			if (++nwrap == 2)
  8109aa:	83 6d d8 01          	subl   $0x1,-0x28(%ebp)
  8109ae:	75 e7                	jne    810997 <malloc+0x10c>
  8109b0:	c7 05 d4 b1 b3 00 00 	movl   $0x8000000,0xb3b1d4
  8109b7:	00 00 08 
				return 0;	/* out of address space */
  8109ba:	b8 00 00 00 00       	mov    $0x0,%eax
  8109bf:	e9 89 00 00 00       	jmp    810a4d <malloc+0x1c2>
				sys_page_unmap(0, mptr + i);
  8109c4:	83 ec 08             	sub    $0x8,%esp
  8109c7:	89 f0                	mov    %esi,%eax
  8109c9:	03 05 d4 b1 b3 00    	add    0xb3b1d4,%eax
  8109cf:	50                   	push   %eax
  8109d0:	6a 00                	push   $0x0
  8109d2:	e8 72 e8 ff ff       	call   80f249 <sys_page_unmap>
			for (; i >= 0; i -= PGSIZE)
  8109d7:	81 ee 00 10 00 00    	sub    $0x1000,%esi
  8109dd:	83 c4 10             	add    $0x10,%esp
  8109e0:	85 f6                	test   %esi,%esi
  8109e2:	79 e0                	jns    8109c4 <malloc+0x139>
			return 0;	/* out of physical memory */
  8109e4:	b8 00 00 00 00       	mov    $0x0,%eax
  8109e9:	eb 62                	jmp    810a4d <malloc+0x1c2>
  8109eb:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
  8109ef:	75 3a                	jne    810a2b <malloc+0x1a0>
	for (i = 0; i < n + 4; i += PGSIZE){
  8109f1:	be 00 00 00 00       	mov    $0x0,%esi
  8109f6:	89 f2                	mov    %esi,%edx
  8109f8:	39 f3                	cmp    %esi,%ebx
  8109fa:	76 39                	jbe    810a35 <malloc+0x1aa>
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
  8109fc:	8d be 00 10 00 00    	lea    0x1000(%esi),%edi
  810a02:	39 df                	cmp    %ebx,%edi
  810a04:	19 c0                	sbb    %eax,%eax
  810a06:	25 00 02 00 00       	and    $0x200,%eax
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
  810a0b:	83 ec 04             	sub    $0x4,%esp
  810a0e:	83 c8 07             	or     $0x7,%eax
  810a11:	50                   	push   %eax
  810a12:	03 15 d4 b1 b3 00    	add    0xb3b1d4,%edx
  810a18:	52                   	push   %edx
  810a19:	6a 00                	push   $0x0
  810a1b:	e8 a4 e7 ff ff       	call   80f1c4 <sys_page_alloc>
  810a20:	83 c4 10             	add    $0x10,%esp
  810a23:	85 c0                	test   %eax,%eax
  810a25:	78 b9                	js     8109e0 <malloc+0x155>
	for (i = 0; i < n + 4; i += PGSIZE){
  810a27:	89 fe                	mov    %edi,%esi
  810a29:	eb cb                	jmp    8109f6 <malloc+0x16b>
  810a2b:	8b 45 e0             	mov    -0x20(%ebp),%eax
  810a2e:	a3 d4 b1 b3 00       	mov    %eax,0xb3b1d4
  810a33:	eb bc                	jmp    8109f1 <malloc+0x166>
	ref = (uint32_t*) (mptr + i - 4);
  810a35:	a1 d4 b1 b3 00       	mov    0xb3b1d4,%eax
	*ref = 2;	/* reference for mptr, reference for returned block */
  810a3a:	c7 44 30 fc 02 00 00 	movl   $0x2,-0x4(%eax,%esi,1)
  810a41:	00 
	mptr += n;
  810a42:	8b 55 dc             	mov    -0x24(%ebp),%edx
  810a45:	01 c2                	add    %eax,%edx
  810a47:	89 15 d4 b1 b3 00    	mov    %edx,0xb3b1d4
}
  810a4d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  810a50:	5b                   	pop    %ebx
  810a51:	5e                   	pop    %esi
  810a52:	5f                   	pop    %edi
  810a53:	5d                   	pop    %ebp
  810a54:	c3                   	ret    
		return 0;
  810a55:	b8 00 00 00 00       	mov    $0x0,%eax
  810a5a:	eb f1                	jmp    810a4d <malloc+0x1c2>
  810a5c:	b8 00 00 00 00       	mov    $0x0,%eax
  810a61:	eb ea                	jmp    810a4d <malloc+0x1c2>

00810a63 <devcons_close>:
	return tot;
}

static int
devcons_close(struct Fd *fd)
{
  810a63:	55                   	push   %ebp
  810a64:	89 e5                	mov    %esp,%ebp
	USED(fd);

	return 0;
}
  810a66:	b8 00 00 00 00       	mov    $0x0,%eax
  810a6b:	5d                   	pop    %ebp
  810a6c:	c3                   	ret    

00810a6d <devcons_stat>:

static int
devcons_stat(struct Fd *fd, struct Stat *stat)
{
  810a6d:	55                   	push   %ebp
  810a6e:	89 e5                	mov    %esp,%ebp
  810a70:	83 ec 10             	sub    $0x10,%esp
	strcpy(stat->st_name, "<cons>");
  810a73:	68 11 3a 81 00       	push   $0x813a11
  810a78:	ff 75 0c             	pushl  0xc(%ebp)
  810a7b:	e8 4b e3 ff ff       	call   80edcb <strcpy>
	return 0;
}
  810a80:	b8 00 00 00 00       	mov    $0x0,%eax
  810a85:	c9                   	leave  
  810a86:	c3                   	ret    

00810a87 <devcons_write>:
{
  810a87:	55                   	push   %ebp
  810a88:	89 e5                	mov    %esp,%ebp
  810a8a:	57                   	push   %edi
  810a8b:	56                   	push   %esi
  810a8c:	53                   	push   %ebx
  810a8d:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
	for (tot = 0; tot < n; tot += m) {
  810a93:	be 00 00 00 00       	mov    $0x0,%esi
		memmove(buf, (char*)vbuf + tot, m);
  810a98:	8d bd 68 ff ff ff    	lea    -0x98(%ebp),%edi
	for (tot = 0; tot < n; tot += m) {
  810a9e:	eb 2f                	jmp    810acf <devcons_write+0x48>
		m = n - tot;
  810aa0:	8b 5d 10             	mov    0x10(%ebp),%ebx
  810aa3:	29 f3                	sub    %esi,%ebx
  810aa5:	83 fb 7f             	cmp    $0x7f,%ebx
  810aa8:	b8 7f 00 00 00       	mov    $0x7f,%eax
  810aad:	0f 47 d8             	cmova  %eax,%ebx
		memmove(buf, (char*)vbuf + tot, m);
  810ab0:	83 ec 04             	sub    $0x4,%esp
  810ab3:	53                   	push   %ebx
  810ab4:	89 f0                	mov    %esi,%eax
  810ab6:	03 45 0c             	add    0xc(%ebp),%eax
  810ab9:	50                   	push   %eax
  810aba:	57                   	push   %edi
  810abb:	e8 99 e4 ff ff       	call   80ef59 <memmove>
		sys_cputs(buf, m);
  810ac0:	83 c4 08             	add    $0x8,%esp
  810ac3:	53                   	push   %ebx
  810ac4:	57                   	push   %edi
  810ac5:	e8 3e e6 ff ff       	call   80f108 <sys_cputs>
	for (tot = 0; tot < n; tot += m) {
  810aca:	01 de                	add    %ebx,%esi
  810acc:	83 c4 10             	add    $0x10,%esp
  810acf:	3b 75 10             	cmp    0x10(%ebp),%esi
  810ad2:	72 cc                	jb     810aa0 <devcons_write+0x19>
}
  810ad4:	89 f0                	mov    %esi,%eax
  810ad6:	8d 65 f4             	lea    -0xc(%ebp),%esp
  810ad9:	5b                   	pop    %ebx
  810ada:	5e                   	pop    %esi
  810adb:	5f                   	pop    %edi
  810adc:	5d                   	pop    %ebp
  810add:	c3                   	ret    

00810ade <devcons_read>:
{
  810ade:	55                   	push   %ebp
  810adf:	89 e5                	mov    %esp,%ebp
  810ae1:	83 ec 08             	sub    $0x8,%esp
  810ae4:	b8 00 00 00 00       	mov    $0x0,%eax
	if (n == 0)
  810ae9:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  810aed:	75 07                	jne    810af6 <devcons_read+0x18>
}
  810aef:	c9                   	leave  
  810af0:	c3                   	ret    
		sys_yield();
  810af1:	e8 af e6 ff ff       	call   80f1a5 <sys_yield>
	while ((c = sys_cgetc()) == 0)
  810af6:	e8 2b e6 ff ff       	call   80f126 <sys_cgetc>
  810afb:	85 c0                	test   %eax,%eax
  810afd:	74 f2                	je     810af1 <devcons_read+0x13>
	if (c < 0)
  810aff:	85 c0                	test   %eax,%eax
  810b01:	78 ec                	js     810aef <devcons_read+0x11>
	if (c == 0x04)	// ctl-d is eof
  810b03:	83 f8 04             	cmp    $0x4,%eax
  810b06:	74 0c                	je     810b14 <devcons_read+0x36>
	*(char*)vbuf = c;
  810b08:	8b 55 0c             	mov    0xc(%ebp),%edx
  810b0b:	88 02                	mov    %al,(%edx)
	return 1;
  810b0d:	b8 01 00 00 00       	mov    $0x1,%eax
  810b12:	eb db                	jmp    810aef <devcons_read+0x11>
		return 0;
  810b14:	b8 00 00 00 00       	mov    $0x0,%eax
  810b19:	eb d4                	jmp    810aef <devcons_read+0x11>

00810b1b <cputchar>:
{
  810b1b:	55                   	push   %ebp
  810b1c:	89 e5                	mov    %esp,%ebp
  810b1e:	83 ec 20             	sub    $0x20,%esp
	char c = ch;
  810b21:	8b 45 08             	mov    0x8(%ebp),%eax
  810b24:	88 45 f7             	mov    %al,-0x9(%ebp)
	sys_cputs(&c, 1);
  810b27:	6a 01                	push   $0x1
  810b29:	8d 45 f7             	lea    -0x9(%ebp),%eax
  810b2c:	50                   	push   %eax
  810b2d:	e8 d6 e5 ff ff       	call   80f108 <sys_cputs>
}
  810b32:	83 c4 10             	add    $0x10,%esp
  810b35:	c9                   	leave  
  810b36:	c3                   	ret    

00810b37 <getchar>:
{
  810b37:	55                   	push   %ebp
  810b38:	89 e5                	mov    %esp,%ebp
  810b3a:	83 ec 1c             	sub    $0x1c,%esp
	r = read(0, &c, 1);
  810b3d:	6a 01                	push   $0x1
  810b3f:	8d 45 f7             	lea    -0x9(%ebp),%eax
  810b42:	50                   	push   %eax
  810b43:	6a 00                	push   $0x0
  810b45:	e8 98 ef ff ff       	call   80fae2 <read>
	if (r < 0)
  810b4a:	83 c4 10             	add    $0x10,%esp
  810b4d:	85 c0                	test   %eax,%eax
  810b4f:	78 08                	js     810b59 <getchar+0x22>
	if (r < 1)
  810b51:	85 c0                	test   %eax,%eax
  810b53:	7e 06                	jle    810b5b <getchar+0x24>
	return c;
  810b55:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
}
  810b59:	c9                   	leave  
  810b5a:	c3                   	ret    
		return -E_EOF;
  810b5b:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  810b60:	eb f7                	jmp    810b59 <getchar+0x22>

00810b62 <iscons>:
{
  810b62:	55                   	push   %ebp
  810b63:	89 e5                	mov    %esp,%ebp
  810b65:	83 ec 20             	sub    $0x20,%esp
	if ((r = fd_lookup(fdnum, &fd)) < 0)
  810b68:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810b6b:	50                   	push   %eax
  810b6c:	ff 75 08             	pushl  0x8(%ebp)
  810b6f:	e8 fd ec ff ff       	call   80f871 <fd_lookup>
  810b74:	83 c4 10             	add    $0x10,%esp
  810b77:	85 c0                	test   %eax,%eax
  810b79:	78 11                	js     810b8c <iscons+0x2a>
	return fd->fd_dev_id == devcons.dev_id;
  810b7b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810b7e:	8b 15 40 43 81 00    	mov    0x814340,%edx
  810b84:	39 10                	cmp    %edx,(%eax)
  810b86:	0f 94 c0             	sete   %al
  810b89:	0f b6 c0             	movzbl %al,%eax
}
  810b8c:	c9                   	leave  
  810b8d:	c3                   	ret    

00810b8e <opencons>:
{
  810b8e:	55                   	push   %ebp
  810b8f:	89 e5                	mov    %esp,%ebp
  810b91:	83 ec 24             	sub    $0x24,%esp
	if ((r = fd_alloc(&fd)) < 0)
  810b94:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810b97:	50                   	push   %eax
  810b98:	e8 85 ec ff ff       	call   80f822 <fd_alloc>
  810b9d:	83 c4 10             	add    $0x10,%esp
  810ba0:	85 c0                	test   %eax,%eax
  810ba2:	78 3a                	js     810bde <opencons+0x50>
	if ((r = sys_page_alloc(0, fd, PTE_P|PTE_U|PTE_W|PTE_SHARE)) < 0)
  810ba4:	83 ec 04             	sub    $0x4,%esp
  810ba7:	68 07 04 00 00       	push   $0x407
  810bac:	ff 75 f4             	pushl  -0xc(%ebp)
  810baf:	6a 00                	push   $0x0
  810bb1:	e8 0e e6 ff ff       	call   80f1c4 <sys_page_alloc>
  810bb6:	83 c4 10             	add    $0x10,%esp
  810bb9:	85 c0                	test   %eax,%eax
  810bbb:	78 21                	js     810bde <opencons+0x50>
	fd->fd_dev_id = devcons.dev_id;
  810bbd:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810bc0:	8b 15 40 43 81 00    	mov    0x814340,%edx
  810bc6:	89 10                	mov    %edx,(%eax)
	fd->fd_omode = O_RDWR;
  810bc8:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810bcb:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
	return fd2num(fd);
  810bd2:	83 ec 0c             	sub    $0xc,%esp
  810bd5:	50                   	push   %eax
  810bd6:	e8 20 ec ff ff       	call   80f7fb <fd2num>
  810bdb:	83 c4 10             	add    $0x10,%esp
}
  810bde:	c9                   	leave  
  810bdf:	c3                   	ret    

00810be0 <set_pgfault_handler>:
// at UXSTACKTOP), and tell the kernel to call the assembly-language
// _pgfault_upcall routine when a page fault occurs.
//
void
set_pgfault_handler(void (*handler)(struct UTrapframe *utf))
{
  810be0:	55                   	push   %ebp
  810be1:	89 e5                	mov    %esp,%ebp
  810be3:	83 ec 08             	sub    $0x8,%esp
	int r;

	if (_pgfault_handler == 0) {
  810be6:	83 3d 00 e0 b3 00 00 	cmpl   $0x0,0xb3e000
  810bed:	74 0a                	je     810bf9 <set_pgfault_handler+0x19>
		    panic("set_pgfault_handler: %e", r);
		}
	}

	// Save handler pointer for assembly to call.
	_pgfault_handler = handler;
  810bef:	8b 45 08             	mov    0x8(%ebp),%eax
  810bf2:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
}
  810bf7:	c9                   	leave  
  810bf8:	c3                   	ret    
		if ((r = sys_page_alloc(thisenv->env_id, (void *)(UXSTACKTOP - PGSIZE), PTE_W | PTE_U | PTE_P)) != 0) {
  810bf9:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  810bfe:	8b 40 48             	mov    0x48(%eax),%eax
  810c01:	83 ec 04             	sub    $0x4,%esp
  810c04:	6a 07                	push   $0x7
  810c06:	68 00 f0 bf ee       	push   $0xeebff000
  810c0b:	50                   	push   %eax
  810c0c:	e8 b3 e5 ff ff       	call   80f1c4 <sys_page_alloc>
  810c11:	83 c4 10             	add    $0x10,%esp
  810c14:	85 c0                	test   %eax,%eax
  810c16:	75 2f                	jne    810c47 <set_pgfault_handler+0x67>
		if ((r = sys_env_set_pgfault_upcall(thisenv->env_id, _pgfault_upcall)) != 0) {
  810c18:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  810c1d:	8b 40 48             	mov    0x48(%eax),%eax
  810c20:	83 ec 08             	sub    $0x8,%esp
  810c23:	68 59 0c 81 00       	push   $0x810c59
  810c28:	50                   	push   %eax
  810c29:	e8 e1 e6 ff ff       	call   80f30f <sys_env_set_pgfault_upcall>
  810c2e:	83 c4 10             	add    $0x10,%esp
  810c31:	85 c0                	test   %eax,%eax
  810c33:	74 ba                	je     810bef <set_pgfault_handler+0xf>
		    panic("set_pgfault_handler: %e", r);
  810c35:	50                   	push   %eax
  810c36:	68 1d 3a 81 00       	push   $0x813a1d
  810c3b:	6a 24                	push   $0x24
  810c3d:	68 35 3a 81 00       	push   $0x813a35
  810c42:	e8 0c da ff ff       	call   80e653 <_panic>
		    panic("set_pgfault_handler: %e", r);
  810c47:	50                   	push   %eax
  810c48:	68 1d 3a 81 00       	push   $0x813a1d
  810c4d:	6a 21                	push   $0x21
  810c4f:	68 35 3a 81 00       	push   $0x813a35
  810c54:	e8 fa d9 ff ff       	call   80e653 <_panic>

00810c59 <_pgfault_upcall>:

.text
.globl _pgfault_upcall
_pgfault_upcall:
	// Call the C page fault handler.
	pushl %esp			// function argument: pointer to UTF
  810c59:	54                   	push   %esp
	movl _pgfault_handler, %eax
  810c5a:	a1 00 e0 b3 00       	mov    0xb3e000,%eax
	call *%eax
  810c5f:	ff d0                	call   *%eax
	addl $4, %esp			// pop function argument
  810c61:	83 c4 04             	add    $0x4,%esp
	// registers are available for intermediate calculations.  You
	// may find that you have to rearrange your code in non-obvious
	// ways as registers become unavailable as scratch space.
	//
	// LAB 4: Your code here.
	movl 0x30(%esp), %ecx    // save trap-time esp in ecx
  810c64:	8b 4c 24 30          	mov    0x30(%esp),%ecx
	subl $4, %ecx            // enlarge the previous stack for 4 bytes
  810c68:	83 e9 04             	sub    $0x4,%ecx
	movl %ecx, 0x30(%esp)    // write the modified esp back
  810c6b:	89 4c 24 30          	mov    %ecx,0x30(%esp)
	movl 0x28(%esp), %edx    // save trap-time eip in edx
  810c6f:	8b 54 24 28          	mov    0x28(%esp),%edx
	movl %edx, (%ecx)        // save eip at new esp for return
  810c73:	89 11                	mov    %edx,(%ecx)

	// Restore the trap-time registers.  After you do this, you
	// can no longer modify any general-purpose registers.
	// LAB 4: Your code here.
	addl $8, %esp            // skip fault_va and tf_err
  810c75:	83 c4 08             	add    $0x8,%esp
	popal                    // pop PushRegs
  810c78:	61                   	popa   

	// Restore eflags from the stack.  After you do this, you can
	// no longer use arithmetic operations or anything else that
	// modifies eflags.
	// LAB 4: Your code here.
	addl $4, %esp            // skip eip
  810c79:	83 c4 04             	add    $0x4,%esp
	popfl                    // pop eflags
  810c7c:	9d                   	popf   

	// Switch back to the adjusted trap-time stack.
	// LAB 4: Your code here.
	pop %esp
  810c7d:	5c                   	pop    %esp

	// Return to re-execute the instruction that faulted.
	// LAB 4: Your code here.
  810c7e:	c3                   	ret    

00810c7f <pageref>:
#include <inc/lib.h>

int
pageref(void *v)
{
  810c7f:	55                   	push   %ebp
  810c80:	89 e5                	mov    %esp,%ebp
  810c82:	8b 55 08             	mov    0x8(%ebp),%edx
	pte_t pte;

	if (!(uvpd[PDX(v)] & PTE_P))
  810c85:	89 d0                	mov    %edx,%eax
  810c87:	c1 e8 16             	shr    $0x16,%eax
  810c8a:	8b 0c 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%ecx
		return 0;
  810c91:	b8 00 00 00 00       	mov    $0x0,%eax
	if (!(uvpd[PDX(v)] & PTE_P))
  810c96:	f6 c1 01             	test   $0x1,%cl
  810c99:	74 1d                	je     810cb8 <pageref+0x39>
	pte = uvpt[PGNUM(v)];
  810c9b:	c1 ea 0c             	shr    $0xc,%edx
  810c9e:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
	if (!(pte & PTE_P))
  810ca5:	f6 c2 01             	test   $0x1,%dl
  810ca8:	74 0e                	je     810cb8 <pageref+0x39>
		return 0;
	return pages[PGNUM(pte)].pp_ref;
  810caa:	c1 ea 0c             	shr    $0xc,%edx
  810cad:	0f b7 04 d5 04 00 00 	movzwl -0x10fffffc(,%edx,8),%eax
  810cb4:	ef 
  810cb5:	0f b7 c0             	movzwl %ax,%eax
}
  810cb8:	5d                   	pop    %ebp
  810cb9:	c3                   	ret    
  810cba:	66 90                	xchg   %ax,%ax
  810cbc:	66 90                	xchg   %ax,%ax
  810cbe:	66 90                	xchg   %ax,%ax

00810cc0 <__udivdi3>:
  810cc0:	55                   	push   %ebp
  810cc1:	57                   	push   %edi
  810cc2:	56                   	push   %esi
  810cc3:	53                   	push   %ebx
  810cc4:	83 ec 1c             	sub    $0x1c,%esp
  810cc7:	8b 54 24 3c          	mov    0x3c(%esp),%edx
  810ccb:	8b 6c 24 30          	mov    0x30(%esp),%ebp
  810ccf:	8b 74 24 34          	mov    0x34(%esp),%esi
  810cd3:	8b 5c 24 38          	mov    0x38(%esp),%ebx
  810cd7:	85 d2                	test   %edx,%edx
  810cd9:	75 35                	jne    810d10 <__udivdi3+0x50>
  810cdb:	39 f3                	cmp    %esi,%ebx
  810cdd:	0f 87 bd 00 00 00    	ja     810da0 <__udivdi3+0xe0>
  810ce3:	85 db                	test   %ebx,%ebx
  810ce5:	89 d9                	mov    %ebx,%ecx
  810ce7:	75 0b                	jne    810cf4 <__udivdi3+0x34>
  810ce9:	b8 01 00 00 00       	mov    $0x1,%eax
  810cee:	31 d2                	xor    %edx,%edx
  810cf0:	f7 f3                	div    %ebx
  810cf2:	89 c1                	mov    %eax,%ecx
  810cf4:	31 d2                	xor    %edx,%edx
  810cf6:	89 f0                	mov    %esi,%eax
  810cf8:	f7 f1                	div    %ecx
  810cfa:	89 c6                	mov    %eax,%esi
  810cfc:	89 e8                	mov    %ebp,%eax
  810cfe:	89 f7                	mov    %esi,%edi
  810d00:	f7 f1                	div    %ecx
  810d02:	89 fa                	mov    %edi,%edx
  810d04:	83 c4 1c             	add    $0x1c,%esp
  810d07:	5b                   	pop    %ebx
  810d08:	5e                   	pop    %esi
  810d09:	5f                   	pop    %edi
  810d0a:	5d                   	pop    %ebp
  810d0b:	c3                   	ret    
  810d0c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  810d10:	39 f2                	cmp    %esi,%edx
  810d12:	77 7c                	ja     810d90 <__udivdi3+0xd0>
  810d14:	0f bd fa             	bsr    %edx,%edi
  810d17:	83 f7 1f             	xor    $0x1f,%edi
  810d1a:	0f 84 98 00 00 00    	je     810db8 <__udivdi3+0xf8>
  810d20:	89 f9                	mov    %edi,%ecx
  810d22:	b8 20 00 00 00       	mov    $0x20,%eax
  810d27:	29 f8                	sub    %edi,%eax
  810d29:	d3 e2                	shl    %cl,%edx
  810d2b:	89 54 24 08          	mov    %edx,0x8(%esp)
  810d2f:	89 c1                	mov    %eax,%ecx
  810d31:	89 da                	mov    %ebx,%edx
  810d33:	d3 ea                	shr    %cl,%edx
  810d35:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  810d39:	09 d1                	or     %edx,%ecx
  810d3b:	89 f2                	mov    %esi,%edx
  810d3d:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  810d41:	89 f9                	mov    %edi,%ecx
  810d43:	d3 e3                	shl    %cl,%ebx
  810d45:	89 c1                	mov    %eax,%ecx
  810d47:	d3 ea                	shr    %cl,%edx
  810d49:	89 f9                	mov    %edi,%ecx
  810d4b:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  810d4f:	d3 e6                	shl    %cl,%esi
  810d51:	89 eb                	mov    %ebp,%ebx
  810d53:	89 c1                	mov    %eax,%ecx
  810d55:	d3 eb                	shr    %cl,%ebx
  810d57:	09 de                	or     %ebx,%esi
  810d59:	89 f0                	mov    %esi,%eax
  810d5b:	f7 74 24 08          	divl   0x8(%esp)
  810d5f:	89 d6                	mov    %edx,%esi
  810d61:	89 c3                	mov    %eax,%ebx
  810d63:	f7 64 24 0c          	mull   0xc(%esp)
  810d67:	39 d6                	cmp    %edx,%esi
  810d69:	72 0c                	jb     810d77 <__udivdi3+0xb7>
  810d6b:	89 f9                	mov    %edi,%ecx
  810d6d:	d3 e5                	shl    %cl,%ebp
  810d6f:	39 c5                	cmp    %eax,%ebp
  810d71:	73 5d                	jae    810dd0 <__udivdi3+0x110>
  810d73:	39 d6                	cmp    %edx,%esi
  810d75:	75 59                	jne    810dd0 <__udivdi3+0x110>
  810d77:	8d 43 ff             	lea    -0x1(%ebx),%eax
  810d7a:	31 ff                	xor    %edi,%edi
  810d7c:	89 fa                	mov    %edi,%edx
  810d7e:	83 c4 1c             	add    $0x1c,%esp
  810d81:	5b                   	pop    %ebx
  810d82:	5e                   	pop    %esi
  810d83:	5f                   	pop    %edi
  810d84:	5d                   	pop    %ebp
  810d85:	c3                   	ret    
  810d86:	8d 76 00             	lea    0x0(%esi),%esi
  810d89:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
  810d90:	31 ff                	xor    %edi,%edi
  810d92:	31 c0                	xor    %eax,%eax
  810d94:	89 fa                	mov    %edi,%edx
  810d96:	83 c4 1c             	add    $0x1c,%esp
  810d99:	5b                   	pop    %ebx
  810d9a:	5e                   	pop    %esi
  810d9b:	5f                   	pop    %edi
  810d9c:	5d                   	pop    %ebp
  810d9d:	c3                   	ret    
  810d9e:	66 90                	xchg   %ax,%ax
  810da0:	31 ff                	xor    %edi,%edi
  810da2:	89 e8                	mov    %ebp,%eax
  810da4:	89 f2                	mov    %esi,%edx
  810da6:	f7 f3                	div    %ebx
  810da8:	89 fa                	mov    %edi,%edx
  810daa:	83 c4 1c             	add    $0x1c,%esp
  810dad:	5b                   	pop    %ebx
  810dae:	5e                   	pop    %esi
  810daf:	5f                   	pop    %edi
  810db0:	5d                   	pop    %ebp
  810db1:	c3                   	ret    
  810db2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  810db8:	39 f2                	cmp    %esi,%edx
  810dba:	72 06                	jb     810dc2 <__udivdi3+0x102>
  810dbc:	31 c0                	xor    %eax,%eax
  810dbe:	39 eb                	cmp    %ebp,%ebx
  810dc0:	77 d2                	ja     810d94 <__udivdi3+0xd4>
  810dc2:	b8 01 00 00 00       	mov    $0x1,%eax
  810dc7:	eb cb                	jmp    810d94 <__udivdi3+0xd4>
  810dc9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  810dd0:	89 d8                	mov    %ebx,%eax
  810dd2:	31 ff                	xor    %edi,%edi
  810dd4:	eb be                	jmp    810d94 <__udivdi3+0xd4>
  810dd6:	66 90                	xchg   %ax,%ax
  810dd8:	66 90                	xchg   %ax,%ax
  810dda:	66 90                	xchg   %ax,%ax
  810ddc:	66 90                	xchg   %ax,%ax
  810dde:	66 90                	xchg   %ax,%ax

00810de0 <__umoddi3>:
  810de0:	55                   	push   %ebp
  810de1:	57                   	push   %edi
  810de2:	56                   	push   %esi
  810de3:	53                   	push   %ebx
  810de4:	83 ec 1c             	sub    $0x1c,%esp
  810de7:	8b 6c 24 3c          	mov    0x3c(%esp),%ebp
  810deb:	8b 74 24 30          	mov    0x30(%esp),%esi
  810def:	8b 5c 24 34          	mov    0x34(%esp),%ebx
  810df3:	8b 7c 24 38          	mov    0x38(%esp),%edi
  810df7:	85 ed                	test   %ebp,%ebp
  810df9:	89 f0                	mov    %esi,%eax
  810dfb:	89 da                	mov    %ebx,%edx
  810dfd:	75 19                	jne    810e18 <__umoddi3+0x38>
  810dff:	39 df                	cmp    %ebx,%edi
  810e01:	0f 86 b1 00 00 00    	jbe    810eb8 <__umoddi3+0xd8>
  810e07:	f7 f7                	div    %edi
  810e09:	89 d0                	mov    %edx,%eax
  810e0b:	31 d2                	xor    %edx,%edx
  810e0d:	83 c4 1c             	add    $0x1c,%esp
  810e10:	5b                   	pop    %ebx
  810e11:	5e                   	pop    %esi
  810e12:	5f                   	pop    %edi
  810e13:	5d                   	pop    %ebp
  810e14:	c3                   	ret    
  810e15:	8d 76 00             	lea    0x0(%esi),%esi
  810e18:	39 dd                	cmp    %ebx,%ebp
  810e1a:	77 f1                	ja     810e0d <__umoddi3+0x2d>
  810e1c:	0f bd cd             	bsr    %ebp,%ecx
  810e1f:	83 f1 1f             	xor    $0x1f,%ecx
  810e22:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  810e26:	0f 84 b4 00 00 00    	je     810ee0 <__umoddi3+0x100>
  810e2c:	b8 20 00 00 00       	mov    $0x20,%eax
  810e31:	89 c2                	mov    %eax,%edx
  810e33:	8b 44 24 04          	mov    0x4(%esp),%eax
  810e37:	29 c2                	sub    %eax,%edx
  810e39:	89 c1                	mov    %eax,%ecx
  810e3b:	89 f8                	mov    %edi,%eax
  810e3d:	d3 e5                	shl    %cl,%ebp
  810e3f:	89 d1                	mov    %edx,%ecx
  810e41:	89 54 24 0c          	mov    %edx,0xc(%esp)
  810e45:	d3 e8                	shr    %cl,%eax
  810e47:	09 c5                	or     %eax,%ebp
  810e49:	8b 44 24 04          	mov    0x4(%esp),%eax
  810e4d:	89 c1                	mov    %eax,%ecx
  810e4f:	d3 e7                	shl    %cl,%edi
  810e51:	89 d1                	mov    %edx,%ecx
  810e53:	89 7c 24 08          	mov    %edi,0x8(%esp)
  810e57:	89 df                	mov    %ebx,%edi
  810e59:	d3 ef                	shr    %cl,%edi
  810e5b:	89 c1                	mov    %eax,%ecx
  810e5d:	89 f0                	mov    %esi,%eax
  810e5f:	d3 e3                	shl    %cl,%ebx
  810e61:	89 d1                	mov    %edx,%ecx
  810e63:	89 fa                	mov    %edi,%edx
  810e65:	d3 e8                	shr    %cl,%eax
  810e67:	0f b6 4c 24 04       	movzbl 0x4(%esp),%ecx
  810e6c:	09 d8                	or     %ebx,%eax
  810e6e:	f7 f5                	div    %ebp
  810e70:	d3 e6                	shl    %cl,%esi
  810e72:	89 d1                	mov    %edx,%ecx
  810e74:	f7 64 24 08          	mull   0x8(%esp)
  810e78:	39 d1                	cmp    %edx,%ecx
  810e7a:	89 c3                	mov    %eax,%ebx
  810e7c:	89 d7                	mov    %edx,%edi
  810e7e:	72 06                	jb     810e86 <__umoddi3+0xa6>
  810e80:	75 0e                	jne    810e90 <__umoddi3+0xb0>
  810e82:	39 c6                	cmp    %eax,%esi
  810e84:	73 0a                	jae    810e90 <__umoddi3+0xb0>
  810e86:	2b 44 24 08          	sub    0x8(%esp),%eax
  810e8a:	19 ea                	sbb    %ebp,%edx
  810e8c:	89 d7                	mov    %edx,%edi
  810e8e:	89 c3                	mov    %eax,%ebx
  810e90:	89 ca                	mov    %ecx,%edx
  810e92:	0f b6 4c 24 0c       	movzbl 0xc(%esp),%ecx
  810e97:	29 de                	sub    %ebx,%esi
  810e99:	19 fa                	sbb    %edi,%edx
  810e9b:	8b 5c 24 04          	mov    0x4(%esp),%ebx
  810e9f:	89 d0                	mov    %edx,%eax
  810ea1:	d3 e0                	shl    %cl,%eax
  810ea3:	89 d9                	mov    %ebx,%ecx
  810ea5:	d3 ee                	shr    %cl,%esi
  810ea7:	d3 ea                	shr    %cl,%edx
  810ea9:	09 f0                	or     %esi,%eax
  810eab:	83 c4 1c             	add    $0x1c,%esp
  810eae:	5b                   	pop    %ebx
  810eaf:	5e                   	pop    %esi
  810eb0:	5f                   	pop    %edi
  810eb1:	5d                   	pop    %ebp
  810eb2:	c3                   	ret    
  810eb3:	90                   	nop
  810eb4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  810eb8:	85 ff                	test   %edi,%edi
  810eba:	89 f9                	mov    %edi,%ecx
  810ebc:	75 0b                	jne    810ec9 <__umoddi3+0xe9>
  810ebe:	b8 01 00 00 00       	mov    $0x1,%eax
  810ec3:	31 d2                	xor    %edx,%edx
  810ec5:	f7 f7                	div    %edi
  810ec7:	89 c1                	mov    %eax,%ecx
  810ec9:	89 d8                	mov    %ebx,%eax
  810ecb:	31 d2                	xor    %edx,%edx
  810ecd:	f7 f1                	div    %ecx
  810ecf:	89 f0                	mov    %esi,%eax
  810ed1:	f7 f1                	div    %ecx
  810ed3:	e9 31 ff ff ff       	jmp    810e09 <__umoddi3+0x29>
  810ed8:	90                   	nop
  810ed9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  810ee0:	39 dd                	cmp    %ebx,%ebp
  810ee2:	72 08                	jb     810eec <__umoddi3+0x10c>
  810ee4:	39 f7                	cmp    %esi,%edi
  810ee6:	0f 87 21 ff ff ff    	ja     810e0d <__umoddi3+0x2d>
  810eec:	89 da                	mov    %ebx,%edx
  810eee:	89 f0                	mov    %esi,%eax
  810ef0:	29 f8                	sub    %edi,%eax
  810ef2:	19 ea                	sbb    %ebp,%edx
  810ef4:	e9 14 ff ff ff       	jmp    810e0d <__umoddi3+0x2d>
